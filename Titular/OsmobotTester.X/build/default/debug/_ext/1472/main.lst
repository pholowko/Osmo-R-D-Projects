CCS PCH C Compiler, Version 5.045, 35992               05-Apr-17 17:58

               Filename:   C:\Aquarium Software\Debug Monitor\OsmobotTester.X\build\default\debug\_ext\1472\main.lst

               ROM used:   37110 bytes (57%)
                           Largest free fragment is 28422
               RAM used:   1905 (49%) at main() level
                           2038 (52%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 30

*
00000:  GOTO   8C9A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  F9D.5
00056:  GOTO   0060
0005A:  BTFSC  F9E.5
0005C:  GOTO   0FB2
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVFF  15,FF5
0009A:  MOVFF  16,FF6
0009E:  MOVFF  17,FF7
000A2:  MOVF   04,W
000A4:  MOVFF  06,FE0
000A8:  MOVFF  05,FD8
000AC:  RETFIE 0
.................... // Debug Display Sensor Main.c file 
.................... #include <18F46k22.h> 
.................... //////////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F46K22 
000AE:  DATA 44,4F
000B0:  DATA 20,25
000B2:  DATA 4C,75
000B4:  DATA 20,25
000B6:  DATA 66,20
000B8:  DATA 20,00
000BA:  DATA 57,54
000BC:  DATA 20,25
000BE:  DATA 4C,75
000C0:  DATA 20,20
000C2:  DATA 25,66
000C4:  DATA 20,20
000C6:  DATA 20,00
000C8:  DATA 4E,48
000CA:  DATA 34,20
000CC:  DATA 25,4C
000CE:  DATA 75,20
000D0:  DATA 20,25
000D2:  DATA 66,00
000D4:  DATA 43,4F
000D6:  DATA 32,20
000D8:  DATA 25,4C
000DA:  DATA 75,20
000DC:  DATA 70,70
000DE:  DATA 6D,00
000E0:  DATA 41,54
000E2:  DATA 2B,52
000E4:  DATA 48,20
000E6:  DATA 25,66
000E8:  DATA 43,20
000EA:  DATA 25,66
000EC:  DATA 25,25
000EE:  DATA 00,00
000F0:  DATA 4F,73
000F2:  DATA 6D,6F
000F4:  DATA 62,6F
000F6:  DATA 74,20
000F8:  DATA 54,65
000FA:  DATA 73,74
000FC:  DATA 69,6E
000FE:  DATA 67,20
00100:  DATA 61,6E
00102:  DATA 64,20
00104:  DATA 43,6F
00106:  DATA 6E,66
00108:  DATA 69,67
0010A:  DATA 75,72
0010C:  DATA 61,74
0010E:  DATA 69,6F
00110:  DATA 6E,20
00112:  DATA 48,65
00114:  DATA 6C,70
00116:  DATA 0A,0D
00118:  DATA 00,00
0011A:  DATA 42,65
0011C:  DATA 6C,6F
0011E:  DATA 77,20
00120:  DATA 69,73
00122:  DATA 20,61
00124:  DATA 20,6C
00126:  DATA 69,73
00128:  DATA 74,20
0012A:  DATA 6F,66
0012C:  DATA 20,61
0012E:  DATA 6C,6C
00130:  DATA 20,74
00132:  DATA 68,65
00134:  DATA 20,63
00136:  DATA 6F,6D
00138:  DATA 6D,61
0013A:  DATA 6E,64
0013C:  DATA 73,20
0013E:  DATA 74,68
00140:  DATA 69,73
00142:  DATA 20,75
00144:  DATA 6E,69
00146:  DATA 74,20
00148:  DATA 63,61
0014A:  DATA 6E,20
0014C:  DATA 64,6F
0014E:  DATA 2E,20
00150:  DATA 20,46
00152:  DATA 61,62
00154:  DATA 75,61
00156:  DATA 72,79
00158:  DATA 20,31
0015A:  DATA 31,2C
0015C:  DATA 20,32
0015E:  DATA 30,31
00160:  DATA 37,0A
00162:  DATA 0D,00
00164:  DATA 73,68
00166:  DATA 6F,77
00168:  DATA 63,6F
0016A:  DATA 6E,66
0016C:  DATA 69,67
0016E:  DATA 20,20
00170:  DATA 20,20
00172:  DATA 20,20
00174:  DATA 20,20
00176:  DATA 20,20
00178:  DATA 44,75
0017A:  DATA 6D,70
0017C:  DATA 73,20
0017E:  DATA 61,6C
00180:  DATA 6C,20
00182:  DATA 6F,66
00184:  DATA 20,74
00186:  DATA 68,65
00188:  DATA 20,63
0018A:  DATA 75,72
0018C:  DATA 72,65
0018E:  DATA 6E,74
00190:  DATA 20,63
00192:  DATA 61,6C
00194:  DATA 69,62
00196:  DATA 72,61
00198:  DATA 74,69
0019A:  DATA 6F,6E
0019C:  DATA 73,20
0019E:  DATA 66,6F
001A0:  DATA 72,20
001A2:  DATA 61,6C
001A4:  DATA 6C,20
001A6:  DATA 73,65
001A8:  DATA 6E,73
001AA:  DATA 6F,72
001AC:  DATA 73,20
001AE:  DATA 74,6F
001B0:  DATA 20,64
001B2:  DATA 61,74
001B4:  DATA 65,20
001B6:  DATA 74,6F
001B8:  DATA 20,74
001BA:  DATA 68,65
001BC:  DATA 20,64
001BE:  DATA 69,73
001C0:  DATA 70,6C
001C2:  DATA 61,79
001C4:  DATA 2E,0A
001C6:  DATA 0D,00
001C8:  DATA 73,61
001CA:  DATA 76,65
001CC:  DATA 63,6F
001CE:  DATA 6E,66
001D0:  DATA 69,67
001D2:  DATA 20,20
001D4:  DATA 20,20
001D6:  DATA 20,20
001D8:  DATA 20,20
001DA:  DATA 20,20
001DC:  DATA 53,61
001DE:  DATA 76,65
001E0:  DATA 73,20
001E2:  DATA 61,6C
001E4:  DATA 6C,20
001E6:  DATA 6F,66
001E8:  DATA 20,74
001EA:  DATA 68,65
001EC:  DATA 20,63
001EE:  DATA 75,72
001F0:  DATA 72,65
001F2:  DATA 6E,74
001F4:  DATA 20,63
001F6:  DATA 61,6C
001F8:  DATA 69,62
001FA:  DATA 72,61
001FC:  DATA 74,69
001FE:  DATA 6F,6E
00200:  DATA 20,69
00202:  DATA 6E,20
00204:  DATA 45,45
00206:  DATA 50,52
00208:  DATA 4F,4D
0020A:  DATA 20,6F
0020C:  DATA 6E,20
0020E:  DATA 74,68
00210:  DATA 69,73
00212:  DATA 20,64
00214:  DATA 65,76
00216:  DATA 69,63
00218:  DATA 65,2E
0021A:  DATA 20,20
0021C:  DATA 49,74
0021E:  DATA 27,73
00220:  DATA 20,75
00222:  DATA 73,65
00224:  DATA 64,20
00226:  DATA 61,73
00228:  DATA 20,64
0022A:  DATA 65,66
0022C:  DATA 61,75
0022E:  DATA 6C,74
00230:  DATA 20,66
00232:  DATA 6F,72
00234:  DATA 20,69
00236:  DATA 6E,69
00238:  DATA 74,61
0023A:  DATA 6C,69
0023C:  DATA 7A,69
0023E:  DATA 6E,67
00240:  DATA 20,6E
00242:  DATA 65,77
00244:  DATA 20,75
00246:  DATA 6E,69
00248:  DATA 74,73
0024A:  DATA 2E,0A
0024C:  DATA 0D,00
0024E:  DATA 64,69
00250:  DATA 73,70
00252:  DATA 6C,61
00254:  DATA 79,20
00256:  DATA 20,20
00258:  DATA 20,20
0025A:  DATA 20,20
0025C:  DATA 20,20
0025E:  DATA 20,20
00260:  DATA 20,20
00262:  DATA 43,6F
00264:  DATA 6D,6D
00266:  DATA 61,6E
00268:  DATA 64,20
0026A:  DATA 74,6F
0026C:  DATA 20,73
0026E:  DATA 65,74
00270:  DATA 20,6F
00272:  DATA 72,20
00274:  DATA 72,65
00276:  DATA 73,65
00278:  DATA 74,20
0027A:  DATA 69,74
0027C:  DATA 65,6D
0027E:  DATA 73,20
00280:  DATA 74,6F
00282:  DATA 20,74
00284:  DATA 68,65
00286:  DATA 20,56
00288:  DATA 46,44
0028A:  DATA 20,20
0028C:  DATA 64,69
0028E:  DATA 73,70
00290:  DATA 6C,61
00292:  DATA 79,2E
00294:  DATA 20,4F
00296:  DATA 6E,6C
00298:  DATA 79,20
0029A:  DATA 34,20
0029C:  DATA 69,74
0029E:  DATA 65,6D
002A0:  DATA 73,20
002A2:  DATA 63,61
002A4:  DATA 6E,20
002A6:  DATA 62,65
002A8:  DATA 20,73
002AA:  DATA 68,6F
002AC:  DATA 77,6E
002AE:  DATA 20,61
002B0:  DATA 74,20
002B2:  DATA 74,68
002B4:  DATA 65,20
002B6:  DATA 73,61
002B8:  DATA 6D,65
002BA:  DATA 20,74
002BC:  DATA 69,6D
002BE:  DATA 65,2E
002C0:  DATA 20,20
002C2:  DATA 41,6C
002C4:  DATA 6C,20
002C6:  DATA 65,6C
002C8:  DATA 73,65
002CA:  DATA 20,77
002CC:  DATA 69,6C
002CE:  DATA 6C,20
002D0:  DATA 62,65
002D2:  DATA 20,74
002D4:  DATA 72,75
002D6:  DATA 6E,63
002D8:  DATA 61,74
002DA:  DATA 65,64
002DC:  DATA 2E,0A
002DE:  DATA 0D,00
002E0:  DATA 20,20
002E2:  DATA 20,20
002E4:  DATA 20,20
002E6:  DATA 20,20
002E8:  DATA 20,20
002EA:  DATA 20,20
002EC:  DATA 20,20
002EE:  DATA 20,20
002F0:  DATA 20,20
002F2:  DATA 20,20
002F4:  DATA 48,65
002F6:  DATA 72,65
002F8:  DATA 20,61
002FA:  DATA 72,65
002FC:  DATA 20,74
002FE:  DATA 68,65
00300:  DATA 20,6F
00302:  DATA 70,74
00304:  DATA 69,6F
00306:  DATA 6E,73
00308:  DATA 2E,0A
0030A:  DATA 0D,00
0030C:  DATA 20,20
0030E:  DATA 20,20
00310:  DATA 20,20
00312:  DATA 20,20
00314:  DATA 20,20
00316:  DATA 20,20
00318:  DATA 20,20
0031A:  DATA 20,20
0031C:  DATA 20,20
0031E:  DATA 20,20
00320:  DATA 70,70
00322:  DATA 68,20
00324:  DATA 64,6F
00326:  DATA 20,20
00328:  DATA 70,68
0032A:  DATA 20,20
0032C:  DATA 77,64
0032E:  DATA 20,20
00330:  DATA 70,68
00332:  DATA 62,75
00334:  DATA 6C,62
00336:  DATA 20,20
00338:  DATA 63,6C
0033A:  DATA 65,61
0033C:  DATA 72,20
0033E:  DATA 6C,75
00340:  DATA 78,20
00342:  DATA 20,65
00344:  DATA 63,20
00346:  DATA 20,20
00348:  DATA 77,74
0034A:  DATA 20,20
0034C:  DATA 70,61
0034E:  DATA 72,20
00350:  DATA 20,6E
00352:  DATA 68,34
00354:  DATA 20,0A
00356:  DATA 0D,00
00358:  DATA 64,65
0035A:  DATA 66,61
0035C:  DATA 75,6C
0035E:  DATA 74,20
00360:  DATA 20,20
00362:  DATA 20,20
00364:  DATA 20,20
00366:  DATA 20,20
00368:  DATA 20,20
0036A:  DATA 20,20
0036C:  DATA 54,68
0036E:  DATA 69,73
00370:  DATA 20,73
00372:  DATA 65,74
00374:  DATA 73,20
00376:  DATA 61,6C
00378:  DATA 6C,20
0037A:  DATA 6F,66
0037C:  DATA 20,74
0037E:  DATA 68,65
00380:  DATA 20,63
00382:  DATA 61,6C
00384:  DATA 69,62
00386:  DATA 72,61
00388:  DATA 74,69
0038A:  DATA 6F,6E
0038C:  DATA 20,74
0038E:  DATA 6F,20
00390:  DATA 64,65
00392:  DATA 66,61
00394:  DATA 75,6C
00396:  DATA 74,20
00398:  DATA 76,61
0039A:  DATA 6C,75
0039C:  DATA 65,73
0039E:  DATA 2E,0A
003A0:  DATA 0D,00
003A2:  DATA 75,70
003A4:  DATA 64,61
003A6:  DATA 74,65
003A8:  DATA 20,20
003AA:  DATA 20,20
003AC:  DATA 20,20
003AE:  DATA 20,20
003B0:  DATA 20,20
003B2:  DATA 20,20
003B4:  DATA 20,20
003B6:  DATA 49,74
003B8:  DATA 20,73
003BA:  DATA 68,6F
003BC:  DATA 6F,74
003BE:  DATA 73,20
003C0:  DATA 74,68
003C2:  DATA 65,20
003C4:  DATA 63,75
003C6:  DATA 72,72
003C8:  DATA 65,6E
003CA:  DATA 74,20
003CC:  DATA 63,61
003CE:  DATA 6C,69
003D0:  DATA 62,72
003D2:  DATA 61,74
003D4:  DATA 69,6F
003D6:  DATA 6E,20
003D8:  DATA 76,61
003DA:  DATA 6C,75
003DC:  DATA 65,73
003DE:  DATA 20,74
003E0:  DATA 6F,20
003E2:  DATA 74,68
003E4:  DATA 65,20
003E6:  DATA 72,65
003E8:  DATA 6D,6F
003EA:  DATA 74,65
003EC:  DATA 20,64
003EE:  DATA 65,76
003F0:  DATA 69,63
003F2:  DATA 65,2E
003F4:  DATA 0A,0D
003F6:  DATA 00,00
003F8:  DATA 73,65
003FA:  DATA 74,20
003FC:  DATA 20,20
003FE:  DATA 20,20
00400:  DATA 20,20
00402:  DATA 20,20
00404:  DATA 20,20
00406:  DATA 20,20
00408:  DATA 20,20
0040A:  DATA 20,20
0040C:  DATA 53,65
0040E:  DATA 74,73
00410:  DATA 20,74
00412:  DATA 68,65
00414:  DATA 20,63
00416:  DATA 61,6C
00418:  DATA 69,62
0041A:  DATA 72,61
0041C:  DATA 74,69
0041E:  DATA 6F,6E
00420:  DATA 20,76
00422:  DATA 61,72
00424:  DATA 2E,20
00426:  DATA 20,54
00428:  DATA 68,65
0042A:  DATA 20,66
0042C:  DATA 6F,72
0042E:  DATA 6D,61
00430:  DATA 74,20
00432:  DATA 69,73
00434:  DATA 20,3E
00436:  DATA 73,65
00438:  DATA 74,20
0043A:  DATA 76,61
0043C:  DATA 72,6E
0043E:  DATA 61,6D
00440:  DATA 65,20
00442:  DATA 76,61
00444:  DATA 6C,75
00446:  DATA 65,2E
00448:  DATA 20,20
0044A:  DATA 4F,6E
0044C:  DATA 65,20
0044E:  DATA 73,70
00450:  DATA 61,63
00452:  DATA 65,20
00454:  DATA 69,6E
00456:  DATA 20,62
00458:  DATA 65,74
0045A:  DATA 77,65
0045C:  DATA 65,6E
0045E:  DATA 2E,0A
00460:  DATA 0D,00
00462:  DATA 20,20
00464:  DATA 20,20
00466:  DATA 20,20
00468:  DATA 20,20
0046A:  DATA 20,20
0046C:  DATA 20,20
0046E:  DATA 20,20
00470:  DATA 20,20
00472:  DATA 20,20
00474:  DATA 20,20
00476:  DATA 20,20
00478:  DATA 20,20
0047A:  DATA 20,20
0047C:  DATA 20,20
0047E:  DATA 55,73
00480:  DATA 65,20
00482:  DATA 74,68
00484:  DATA 65,20
00486:  DATA 73,68
00488:  DATA 6F,77
0048A:  DATA 63,6F
0048C:  DATA 6E,66
0048E:  DATA 69,67
00490:  DATA 20,63
00492:  DATA 6F,6D
00494:  DATA 6D,61
00496:  DATA 6E,64
00498:  DATA 20,74
0049A:  DATA 6F,20
0049C:  DATA 64,69
0049E:  DATA 73,70
004A0:  DATA 6C,61
004A2:  DATA 79,20
004A4:  DATA 74,68
004A6:  DATA 65,20
004A8:  DATA 76,61
004AA:  DATA 72,20
004AC:  DATA 6E,61
004AE:  DATA 6D,65
004B0:  DATA 73,20
004B2:  DATA 69,6E
004B4:  DATA 20,28
004B6:  DATA 29,2E
004B8:  DATA 0A,0D
004BA:  DATA 00,00
004BC:  DATA 72,73
004BE:  DATA 74,20
004C0:  DATA 20,20
004C2:  DATA 20,20
004C4:  DATA 20,20
004C6:  DATA 20,20
004C8:  DATA 20,20
004CA:  DATA 20,20
004CC:  DATA 20,20
004CE:  DATA 20,20
004D0:  DATA 72,65
004D2:  DATA 62,6F
004D4:  DATA 6F,74
004D6:  DATA 20,74
004D8:  DATA 68,69
004DA:  DATA 73,20
004DC:  DATA 75,6E
004DE:  DATA 69,74
004E0:  DATA 2E,0A
004E2:  DATA 0D,00
004E4:  DATA 65,6E
004E6:  DATA 64,20
004E8:  DATA 6F,66
004EA:  DATA 20,6C
004EC:  DATA 69,6E
004EE:  DATA 65,0A
004F0:  DATA 0D,00
004F2:  DATA 45,72
004F4:  DATA 72,6F
004F6:  DATA 72,20
004F8:  DATA 53,61
004FA:  DATA 76,69
004FC:  DATA 6E,67
004FE:  DATA 20,4C
00500:  DATA 6F,63
00502:  DATA 61,6C
00504:  DATA 20,43
00506:  DATA 6F,6E
00508:  DATA 66,69
0050A:  DATA 67,75
0050C:  DATA 72,61
0050E:  DATA 74,69
00510:  DATA 6F,6E
00512:  DATA 0A,0D
00514:  DATA 00,00
00516:  DATA 4C,6F
00518:  DATA 63,61
0051A:  DATA 6C,20
0051C:  DATA 43,6F
0051E:  DATA 6E,66
00520:  DATA 69,67
00522:  DATA 75,72
00524:  DATA 61,74
00526:  DATA 69,6F
00528:  DATA 6E,73
0052A:  DATA 20,43
0052C:  DATA 6C,65
0052E:  DATA 61,72
00530:  DATA 65,64
00532:  DATA 0A,0D
00534:  DATA 00,00
00536:  DATA 45,72
00538:  DATA 72,6F
0053A:  DATA 72,20
0053C:  DATA 53,61
0053E:  DATA 76,69
00540:  DATA 6E,67
00542:  DATA 20,4C
00544:  DATA 6F,63
00546:  DATA 61,6C
00548:  DATA 20,43
0054A:  DATA 6F,6E
0054C:  DATA 66,69
0054E:  DATA 67,75
00550:  DATA 72,61
00552:  DATA 74,69
00554:  DATA 6F,6E
00556:  DATA 0A,0D
00558:  DATA 00,00
0055A:  DATA 4C,6F
0055C:  DATA 63,61
0055E:  DATA 6C,20
00560:  DATA 43,6F
00562:  DATA 6E,66
00564:  DATA 69,67
00566:  DATA 75,72
00568:  DATA 61,74
0056A:  DATA 69,6F
0056C:  DATA 6E,73
0056E:  DATA 20,53
00570:  DATA 61,76
00572:  DATA 65,64
00574:  DATA 0A,0D
00576:  DATA 00,00
00578:  DATA 28,72
0057A:  DATA 65,74
0057C:  DATA 6E,68
0057E:  DATA 34,31
00580:  DATA 29,20
00582:  DATA 20,6E
00584:  DATA 68,34
00586:  DATA 70,74
00588:  DATA 31,72
0058A:  DATA 65,74
0058C:  DATA 75,72
0058E:  DATA 6E,65
00590:  DATA 64,6E
00592:  DATA 75,6D
00594:  DATA 62,65
00596:  DATA 72,20
00598:  DATA 73,65
0059A:  DATA 74,20
0059C:  DATA 74,6F
0059E:  DATA 20,25
005A0:  DATA 66,0A
005A2:  DATA 0D,00
005A4:  DATA 41,6C
005A6:  DATA 73,6F
005A8:  DATA 20,75
005AA:  DATA 73,65
005AC:  DATA 64,20
005AE:  DATA 61,73
005B0:  DATA 20,41
005B2:  DATA 6E,61
005B4:  DATA 6C,6F
005B6:  DATA 67,20
005B8:  DATA 4E,48
005BA:  DATA 34,20
005BC:  DATA 70,72
005BE:  DATA 6F,62
005C0:  DATA 65,20
005C2:  DATA 6F,75
005C4:  DATA 74,70
005C6:  DATA 75,74
005C8:  DATA 20,6C
005CA:  DATA 6F,77
005CC:  DATA 20,6E
005CE:  DATA 75,6D
005D0:  DATA 62,65
005D2:  DATA 72,2E
005D4:  DATA 0A,0D
005D6:  DATA 00,00
005D8:  DATA 28,72
005DA:  DATA 65,74
005DC:  DATA 6E,68
005DE:  DATA 34,32
005E0:  DATA 29,20
005E2:  DATA 20,6E
005E4:  DATA 68,34
005E6:  DATA 70,74
005E8:  DATA 32,72
005EA:  DATA 65,74
005EC:  DATA 75,72
005EE:  DATA 6E,65
005F0:  DATA 64,6E
005F2:  DATA 75,6D
005F4:  DATA 62,65
005F6:  DATA 72,20
005F8:  DATA 73,65
005FA:  DATA 74,20
005FC:  DATA 74,6F
005FE:  DATA 20,25
00600:  DATA 66,0A
00602:  DATA 0D,00
00604:  DATA 28,72
00606:  DATA 65,74
00608:  DATA 6E,68
0060A:  DATA 34,33
0060C:  DATA 29,20
0060E:  DATA 20,6E
00610:  DATA 68,34
00612:  DATA 70,74
00614:  DATA 33,72
00616:  DATA 65,74
00618:  DATA 75,72
0061A:  DATA 6E,65
0061C:  DATA 64,6E
0061E:  DATA 75,6D
00620:  DATA 62,65
00622:  DATA 72,20
00624:  DATA 73,65
00626:  DATA 74,20
00628:  DATA 74,6F
0062A:  DATA 20,25
0062C:  DATA 66,0A
0062E:  DATA 0D,00
00630:  DATA 41,6C
00632:  DATA 73,6F
00634:  DATA 20,75
00636:  DATA 73,65
00638:  DATA 64,20
0063A:  DATA 61,73
0063C:  DATA 20,41
0063E:  DATA 6E,61
00640:  DATA 6C,6F
00642:  DATA 67,20
00644:  DATA 4E,48
00646:  DATA 34,20
00648:  DATA 70,72
0064A:  DATA 6F,62
0064C:  DATA 65,20
0064E:  DATA 6F,75
00650:  DATA 74,70
00652:  DATA 75,74
00654:  DATA 20,68
00656:  DATA 69,67
00658:  DATA 68,20
0065A:  DATA 6E,75
0065C:  DATA 6D,62
0065E:  DATA 65,72
00660:  DATA 2E,0A
00662:  DATA 0D,00
00664:  DATA 28,6E
00666:  DATA 68,34
00668:  DATA 70,74
0066A:  DATA 31,29
0066C:  DATA 20,20
0066E:  DATA 6E,68
00670:  DATA 34,70
00672:  DATA 74,31
00674:  DATA 63,61
00676:  DATA 6C,31
00678:  DATA 6F,66
0067A:  DATA 33,20
0067C:  DATA 73,65
0067E:  DATA 74,20
00680:  DATA 74,6F
00682:  DATA 20,25
00684:  DATA 4C,75
00686:  DATA 0A,0D
00688:  DATA 00,00
0068A:  DATA 41,6C
0068C:  DATA 73,6F
0068E:  DATA 20,75
00690:  DATA 73,65
00692:  DATA 64,20
00694:  DATA 61,73
00696:  DATA 20,41
00698:  DATA 6E,61
0069A:  DATA 6C,6F
0069C:  DATA 67,20
0069E:  DATA 4E,48
006A0:  DATA 34,20
006A2:  DATA 70,72
006A4:  DATA 6F,62
006A6:  DATA 65,20
006A8:  DATA 69,6E
006AA:  DATA 70,75
006AC:  DATA 74,20
006AE:  DATA 6C,6F
006B0:  DATA 77,20
006B2:  DATA 6E,75
006B4:  DATA 6D,62
006B6:  DATA 65,72
006B8:  DATA 2E,0A
006BA:  DATA 0D,00
006BC:  DATA 28,6E
006BE:  DATA 68,34
006C0:  DATA 70,74
006C2:  DATA 32,29
006C4:  DATA 20,20
006C6:  DATA 6E,68
006C8:  DATA 34,70
006CA:  DATA 74,31
006CC:  DATA 63,61
006CE:  DATA 6C,32
006D0:  DATA 6F,66
006D2:  DATA 33,20
006D4:  DATA 73,65
006D6:  DATA 74,20
006D8:  DATA 74,6F
006DA:  DATA 20,25
006DC:  DATA 4C,75
006DE:  DATA 0A,0D
006E0:  DATA 00,00
006E2:  DATA 28,6E
006E4:  DATA 68,34
006E6:  DATA 70,74
006E8:  DATA 33,29
006EA:  DATA 20,20
006EC:  DATA 6E,68
006EE:  DATA 34,70
006F0:  DATA 74,31
006F2:  DATA 63,61
006F4:  DATA 6C,33
006F6:  DATA 6F,66
006F8:  DATA 33,20
006FA:  DATA 73,65
006FC:  DATA 74,20
006FE:  DATA 74,6F
00700:  DATA 20,25
00702:  DATA 4C,75
00704:  DATA 0A,0D
00706:  DATA 00,00
00708:  DATA 41,6C
0070A:  DATA 73,6F
0070C:  DATA 20,75
0070E:  DATA 73,65
00710:  DATA 64,20
00712:  DATA 61,73
00714:  DATA 20,41
00716:  DATA 6E,61
00718:  DATA 6C,6F
0071A:  DATA 67,20
0071C:  DATA 4E,48
0071E:  DATA 34,20
00720:  DATA 70,72
00722:  DATA 6F,62
00724:  DATA 65,20
00726:  DATA 69,6E
00728:  DATA 70,75
0072A:  DATA 74,20
0072C:  DATA 6C,6F
0072E:  DATA 77,20
00730:  DATA 6E,75
00732:  DATA 6D,62
00734:  DATA 65,72
00736:  DATA 2E,0A
00738:  DATA 0D,00
0073A:  DATA 28,6E
0073C:  DATA 68,34
0073E:  DATA 70,74
00740:  DATA 34,29
00742:  DATA 20,20
00744:  DATA 6E,68
00746:  DATA 34,70
00748:  DATA 74,32
0074A:  DATA 63,61
0074C:  DATA 6C,31
0074E:  DATA 6F,66
00750:  DATA 33,20
00752:  DATA 73,65
00754:  DATA 74,20
00756:  DATA 74,6F
00758:  DATA 20,25
0075A:  DATA 4C,75
0075C:  DATA 0A,0D
0075E:  DATA 00,00
00760:  DATA 41,6C
00762:  DATA 73,6F
00764:  DATA 20,75
00766:  DATA 73,65
00768:  DATA 64,20
0076A:  DATA 61,73
0076C:  DATA 20,41
0076E:  DATA 6E,61
00770:  DATA 6C,6F
00772:  DATA 67,20
00774:  DATA 4E,48
00776:  DATA 34,20
00778:  DATA 70,72
0077A:  DATA 6F,62
0077C:  DATA 65,20
0077E:  DATA 69,6E
00780:  DATA 70,75
00782:  DATA 74,20
00784:  DATA 6C,6F
00786:  DATA 77,20
00788:  DATA 6E,75
0078A:  DATA 6D,62
0078C:  DATA 65,72
0078E:  DATA 2E,0A
00790:  DATA 0D,00
00792:  DATA 28,6E
00794:  DATA 68,34
00796:  DATA 70,74
00798:  DATA 35,29
0079A:  DATA 20,20
0079C:  DATA 6E,68
0079E:  DATA 34,70
007A0:  DATA 74,32
007A2:  DATA 63,61
007A4:  DATA 6C,32
007A6:  DATA 6F,66
007A8:  DATA 33,20
007AA:  DATA 73,65
007AC:  DATA 74,20
007AE:  DATA 74,6F
007B0:  DATA 20,25
007B2:  DATA 4C,75
007B4:  DATA 0A,0D
007B6:  DATA 00,00
007B8:  DATA 41,6C
007BA:  DATA 73,6F
007BC:  DATA 20,75
007BE:  DATA 73,65
007C0:  DATA 64,20
007C2:  DATA 61,73
007C4:  DATA 20,41
007C6:  DATA 6E,61
007C8:  DATA 6C,6F
007CA:  DATA 67,20
007CC:  DATA 4E,48
007CE:  DATA 34,20
007D0:  DATA 70,72
007D2:  DATA 6F,62
007D4:  DATA 65,20
007D6:  DATA 69,6E
007D8:  DATA 70,75
007DA:  DATA 74,20
007DC:  DATA 6C,6F
007DE:  DATA 77,20
007E0:  DATA 6E,75
007E2:  DATA 6D,62
007E4:  DATA 65,72
007E6:  DATA 2E,0A
007E8:  DATA 0D,00
007EA:  DATA 28,6E
007EC:  DATA 68,34
007EE:  DATA 70,74
007F0:  DATA 36,29
007F2:  DATA 20,20
007F4:  DATA 6E,68
007F6:  DATA 34,70
007F8:  DATA 74,32
007FA:  DATA 63,61
007FC:  DATA 6C,33
007FE:  DATA 6F,66
00800:  DATA 33,20
00802:  DATA 73,65
00804:  DATA 74,20
00806:  DATA 74,6F
00808:  DATA 20,25
0080A:  DATA 4C,75
0080C:  DATA 0A,0D
0080E:  DATA 00,00
00810:  DATA 41,6C
00812:  DATA 73,6F
00814:  DATA 20,75
00816:  DATA 73,65
00818:  DATA 64,20
0081A:  DATA 61,73
0081C:  DATA 20,41
0081E:  DATA 6E,61
00820:  DATA 6C,6F
00822:  DATA 67,20
00824:  DATA 4E,48
00826:  DATA 34,20
00828:  DATA 70,72
0082A:  DATA 6F,62
0082C:  DATA 65,20
0082E:  DATA 69,6E
00830:  DATA 70,75
00832:  DATA 74,20
00834:  DATA 6C,6F
00836:  DATA 77,20
00838:  DATA 6E,75
0083A:  DATA 6D,62
0083C:  DATA 65,72
0083E:  DATA 2E,0A
00840:  DATA 0D,00
00842:  DATA 28,6E
00844:  DATA 68,34
00846:  DATA 70,74
00848:  DATA 37,29
0084A:  DATA 20,20
0084C:  DATA 6E,68
0084E:  DATA 34,70
00850:  DATA 74,33
00852:  DATA 63,61
00854:  DATA 6C,31
00856:  DATA 6F,66
00858:  DATA 33,20
0085A:  DATA 73,65
0085C:  DATA 74,20
0085E:  DATA 74,6F
00860:  DATA 20,25
00862:  DATA 4C,75
00864:  DATA 0A,0D
00866:  DATA 00,00
00868:  DATA 41,6C
0086A:  DATA 73,6F
0086C:  DATA 20,75
0086E:  DATA 73,65
00870:  DATA 64,20
00872:  DATA 61,73
00874:  DATA 20,41
00876:  DATA 6E,61
00878:  DATA 6C,6F
0087A:  DATA 67,20
0087C:  DATA 4E,48
0087E:  DATA 34,20
00880:  DATA 70,72
00882:  DATA 6F,62
00884:  DATA 65,20
00886:  DATA 69,6E
00888:  DATA 70,75
0088A:  DATA 74,20
0088C:  DATA 6C,6F
0088E:  DATA 77,20
00890:  DATA 6E,75
00892:  DATA 6D,62
00894:  DATA 65,72
00896:  DATA 2E,0A
00898:  DATA 0D,00
0089A:  DATA 28,6E
0089C:  DATA 68,34
0089E:  DATA 70,74
008A0:  DATA 38,29
008A2:  DATA 20,20
008A4:  DATA 6E,68
008A6:  DATA 34,70
008A8:  DATA 74,33
008AA:  DATA 63,61
008AC:  DATA 6C,32
008AE:  DATA 6F,66
008B0:  DATA 33,20
008B2:  DATA 73,65
008B4:  DATA 74,20
008B6:  DATA 74,6F
008B8:  DATA 20,25
008BA:  DATA 4C,75
008BC:  DATA 0A,0D
008BE:  DATA 00,00
008C0:  DATA 41,6C
008C2:  DATA 73,6F
008C4:  DATA 20,75
008C6:  DATA 73,65
008C8:  DATA 64,20
008CA:  DATA 61,73
008CC:  DATA 20,41
008CE:  DATA 6E,61
008D0:  DATA 6C,6F
008D2:  DATA 67,20
008D4:  DATA 4E,48
008D6:  DATA 34,20
008D8:  DATA 70,72
008DA:  DATA 6F,62
008DC:  DATA 65,20
008DE:  DATA 69,6E
008E0:  DATA 70,75
008E2:  DATA 74,20
008E4:  DATA 6C,6F
008E6:  DATA 77,20
008E8:  DATA 6E,75
008EA:  DATA 6D,62
008EC:  DATA 65,72
008EE:  DATA 2E,0A
008F0:  DATA 0D,00
008F2:  DATA 28,6E
008F4:  DATA 68,34
008F6:  DATA 70,74
008F8:  DATA 39,29
008FA:  DATA 20,20
008FC:  DATA 6E,68
008FE:  DATA 34,70
00900:  DATA 74,33
00902:  DATA 63,61
00904:  DATA 6C,33
00906:  DATA 6F,66
00908:  DATA 33,20
0090A:  DATA 73,65
0090C:  DATA 74,20
0090E:  DATA 74,6F
00910:  DATA 20,25
00912:  DATA 4C,75
00914:  DATA 0A,0D
00916:  DATA 00,00
00918:  DATA 28,44
0091A:  DATA 4F,70
0091C:  DATA 74,31
0091E:  DATA 29,20
00920:  DATA 20,44
00922:  DATA 4F,70
00924:  DATA 74,31
00926:  DATA 63,61
00928:  DATA 6C,31
0092A:  DATA 6F,66
0092C:  DATA 33,20
0092E:  DATA 73,65
00930:  DATA 74,20
00932:  DATA 74,6F
00934:  DATA 20,25
00936:  DATA 4C,75
00938:  DATA 0A,0D
0093A:  DATA 00,00
0093C:  DATA 28,44
0093E:  DATA 4F,70
00940:  DATA 74,32
00942:  DATA 29,20
00944:  DATA 20,44
00946:  DATA 4F,70
00948:  DATA 74,31
0094A:  DATA 63,61
0094C:  DATA 6C,32
0094E:  DATA 6F,66
00950:  DATA 33,20
00952:  DATA 73,65
00954:  DATA 74,20
00956:  DATA 74,6F
00958:  DATA 20,25
0095A:  DATA 4C,75
0095C:  DATA 0A,0D
0095E:  DATA 00,00
00960:  DATA 28,44
00962:  DATA 4F,70
00964:  DATA 74,33
00966:  DATA 29,20
00968:  DATA 20,44
0096A:  DATA 4F,70
0096C:  DATA 74,31
0096E:  DATA 63,61
00970:  DATA 6C,33
00972:  DATA 6F,66
00974:  DATA 33,20
00976:  DATA 73,65
00978:  DATA 74,20
0097A:  DATA 74,6F
0097C:  DATA 20,25
0097E:  DATA 4C,75
00980:  DATA 0A,0D
00982:  DATA 00,00
00984:  DATA 28,44
00986:  DATA 4F,70
00988:  DATA 74,34
0098A:  DATA 29,20
0098C:  DATA 20,44
0098E:  DATA 4F,70
00990:  DATA 74,32
00992:  DATA 63,61
00994:  DATA 6C,31
00996:  DATA 6F,66
00998:  DATA 33,20
0099A:  DATA 73,65
0099C:  DATA 74,20
0099E:  DATA 74,6F
009A0:  DATA 20,25
009A2:  DATA 4C,75
009A4:  DATA 0A,0D
009A6:  DATA 00,00
009A8:  DATA 28,44
009AA:  DATA 4F,70
009AC:  DATA 74,35
009AE:  DATA 29,20
009B0:  DATA 20,44
009B2:  DATA 4F,70
009B4:  DATA 74,32
009B6:  DATA 63,61
009B8:  DATA 6C,32
009BA:  DATA 6F,66
009BC:  DATA 33,20
009BE:  DATA 73,65
009C0:  DATA 74,20
009C2:  DATA 74,6F
009C4:  DATA 20,25
009C6:  DATA 4C,75
009C8:  DATA 0A,0D
009CA:  DATA 00,00
009CC:  DATA 28,44
009CE:  DATA 4F,70
009D0:  DATA 74,36
009D2:  DATA 29,20
009D4:  DATA 20,44
009D6:  DATA 4F,70
009D8:  DATA 74,32
009DA:  DATA 63,61
009DC:  DATA 6C,33
009DE:  DATA 6F,66
009E0:  DATA 33,20
009E2:  DATA 73,65
009E4:  DATA 74,20
009E6:  DATA 74,6F
009E8:  DATA 20,25
009EA:  DATA 4C,75
009EC:  DATA 0A,0D
009EE:  DATA 00,00
009F0:  DATA 28,44
009F2:  DATA 4F,70
009F4:  DATA 74,31
009F6:  DATA 37,20
009F8:  DATA 20,44
009FA:  DATA 4F,70
009FC:  DATA 74,33
009FE:  DATA 63,61
00A00:  DATA 6C,31
00A02:  DATA 6F,66
00A04:  DATA 33,20
00A06:  DATA 73,65
00A08:  DATA 74,20
00A0A:  DATA 74,6F
00A0C:  DATA 20,25
00A0E:  DATA 4C,75
00A10:  DATA 0A,0D
00A12:  DATA 00,00
00A14:  DATA 28,44
00A16:  DATA 4F,70
00A18:  DATA 74,38
00A1A:  DATA 29,20
00A1C:  DATA 20,44
00A1E:  DATA 4F,70
00A20:  DATA 74,33
00A22:  DATA 63,61
00A24:  DATA 6C,32
00A26:  DATA 6F,66
00A28:  DATA 33,20
00A2A:  DATA 73,65
00A2C:  DATA 74,20
00A2E:  DATA 74,6F
00A30:  DATA 20,25
00A32:  DATA 4C,75
00A34:  DATA 0A,0D
00A36:  DATA 00,00
00A38:  DATA 28,44
00A3A:  DATA 4F,70
00A3C:  DATA 74,39
00A3E:  DATA 29,20
00A40:  DATA 20,44
00A42:  DATA 4F,70
00A44:  DATA 74,33
00A46:  DATA 63,61
00A48:  DATA 6C,33
00A4A:  DATA 6F,66
00A4C:  DATA 33,20
00A4E:  DATA 73,65
00A50:  DATA 74,20
00A52:  DATA 74,6F
00A54:  DATA 20,25
00A56:  DATA 4C,75
00A58:  DATA 0A,0D
00A5A:  DATA 00,00
00A5C:  DATA 53,65
00A5E:  DATA 74,74
00A60:  DATA 69,6E
00A62:  DATA 67,20
00A64:  DATA 61,6C
00A66:  DATA 6C,20
00A68:  DATA 63,61
00A6A:  DATA 6C,69
00A6C:  DATA 62,72
00A6E:  DATA 61,74
00A70:  DATA 69,6F
00A72:  DATA 6E,20
00A74:  DATA 76,61
00A76:  DATA 6C,75
00A78:  DATA 65,73
00A7A:  DATA 20,74
00A7C:  DATA 6F,20
00A7E:  DATA 64,65
00A80:  DATA 66,61
00A82:  DATA 75,6C
00A84:  DATA 74,2E
00A86:  DATA 20,20
00A88:  DATA 44,6F
00A8A:  DATA 20,61
00A8C:  DATA 20,73
00A8E:  DATA 61,76
00A90:  DATA 65,63
00A92:  DATA 6F,6E
00A94:  DATA 66,69
00A96:  DATA 67,20
00A98:  DATA 74,6F
00A9A:  DATA 20,73
00A9C:  DATA 61,76
00A9E:  DATA 65,20
00AA0:  DATA 69,74
00AA2:  DATA 20,69
00AA4:  DATA 6E,20
00AA6:  DATA 45,45
00AA8:  DATA 50,52
00AAA:  DATA 4F,4D
00AAC:  DATA 2E,0A
00AAE:  DATA 0D,00
00AB0:  DATA 43,75
00AB2:  DATA 72,72
00AB4:  DATA 65,6E
00AB6:  DATA 74,20
00AB8:  DATA 43,61
00ABA:  DATA 6C,69
00ABC:  DATA 62,72
00ABE:  DATA 61,74
00AC0:  DATA 69,6F
00AC2:  DATA 6E,73
00AC4:  DATA 0A,0D
00AC6:  DATA 00,00
00AC8:  DATA 70,68
00ACA:  DATA 63,61
00ACC:  DATA 6C,6C
00ACE:  DATA 6F,77
00AD0:  DATA 20,3D
00AD2:  DATA 20,25
00AD4:  DATA 66,0A
00AD6:  DATA 0D,00
00AD8:  DATA 70,68
00ADA:  DATA 63,61
00ADC:  DATA 6C,68
00ADE:  DATA 69,67
00AE0:  DATA 68,20
00AE2:  DATA 3D,20
00AE4:  DATA 25,66
00AE6:  DATA 0A,0D
00AE8:  DATA 00,00
00AEA:  DATA 70,68
00AEC:  DATA 6E,75
00AEE:  DATA 6D,62
00AF0:  DATA 65,72
00AF2:  DATA 75,70
00AF4:  DATA 70,65
00AF6:  DATA 72,20
00AF8:  DATA 3D,20
00AFA:  DATA 25,66
00AFC:  DATA 0A,0D
00AFE:  DATA 00,00
00B00:  DATA 28,6E
00B02:  DATA 68,34
00B04:  DATA 70,74
00B06:  DATA 31,29
00B08:  DATA 20,6E
00B0A:  DATA 68,34
00B0C:  DATA 70,74
00B0E:  DATA 31,63
00B10:  DATA 61,6C
00B12:  DATA 31,6F
00B14:  DATA 66,33
00B16:  DATA 20,3D
00B18:  DATA 20,25
00B1A:  DATA 4C,75
00B1C:  DATA 0A,0D
00B1E:  DATA 00,00
00B20:  DATA 28,6E
00B22:  DATA 68,34
00B24:  DATA 70,74
00B26:  DATA 32,29
00B28:  DATA 20,6E
00B2A:  DATA 68,34
00B2C:  DATA 70,74
00B2E:  DATA 31,63
00B30:  DATA 61,6C
00B32:  DATA 32,6F
00B34:  DATA 66,33
00B36:  DATA 20,3D
00B38:  DATA 20,25
00B3A:  DATA 4C,75
00B3C:  DATA 0A,0D
00B3E:  DATA 00,00
00B40:  DATA 28,6E
00B42:  DATA 68,34
00B44:  DATA 70,74
00B46:  DATA 33,29
00B48:  DATA 20,6E
00B4A:  DATA 68,34
00B4C:  DATA 70,74
00B4E:  DATA 31,63
00B50:  DATA 61,6C
00B52:  DATA 33,6F
00B54:  DATA 66,33
00B56:  DATA 20,3D
00B58:  DATA 20,25
00B5A:  DATA 4C,75
00B5C:  DATA 0A,0D
00B5E:  DATA 00,00
00B60:  DATA 28,6E
00B62:  DATA 68,34
00B64:  DATA 70,74
00B66:  DATA 34,29
00B68:  DATA 20,6E
00B6A:  DATA 68,34
00B6C:  DATA 70,74
00B6E:  DATA 32,63
00B70:  DATA 61,6C
00B72:  DATA 31,6F
00B74:  DATA 66,33
00B76:  DATA 20,3D
00B78:  DATA 20,25
00B7A:  DATA 4C,75
00B7C:  DATA 0A,0D
00B7E:  DATA 00,00
00B80:  DATA 28,6E
00B82:  DATA 68,34
00B84:  DATA 70,74
00B86:  DATA 35,29
00B88:  DATA 20,6E
00B8A:  DATA 68,34
00B8C:  DATA 70,74
00B8E:  DATA 32,63
00B90:  DATA 61,6C
00B92:  DATA 32,6F
00B94:  DATA 66,33
00B96:  DATA 20,3D
00B98:  DATA 20,25
00B9A:  DATA 4C,75
00B9C:  DATA 0A,0D
00B9E:  DATA 00,00
00BA0:  DATA 28,6E
00BA2:  DATA 68,34
00BA4:  DATA 70,74
00BA6:  DATA 36,29
00BA8:  DATA 20,6E
00BAA:  DATA 68,34
00BAC:  DATA 70,74
00BAE:  DATA 32,63
00BB0:  DATA 61,6C
00BB2:  DATA 33,6F
00BB4:  DATA 66,33
00BB6:  DATA 20,3D
00BB8:  DATA 20,25
00BBA:  DATA 4C,75
00BBC:  DATA 0A,0D
00BBE:  DATA 00,00
00BC0:  DATA 28,6E
00BC2:  DATA 68,34
00BC4:  DATA 70,74
00BC6:  DATA 37,29
00BC8:  DATA 20,6E
00BCA:  DATA 68,34
00BCC:  DATA 70,74
00BCE:  DATA 33,63
00BD0:  DATA 61,6C
00BD2:  DATA 31,6F
00BD4:  DATA 66,33
00BD6:  DATA 20,3D
00BD8:  DATA 20,25
00BDA:  DATA 4C,75
00BDC:  DATA 0A,0D
00BDE:  DATA 00,00
00BE0:  DATA 28,6E
00BE2:  DATA 68,34
00BE4:  DATA 70,74
00BE6:  DATA 38,29
00BE8:  DATA 20,6E
00BEA:  DATA 68,34
00BEC:  DATA 70,74
00BEE:  DATA 33,63
00BF0:  DATA 61,6C
00BF2:  DATA 32,6F
00BF4:  DATA 66,33
00BF6:  DATA 20,3D
00BF8:  DATA 20,25
00BFA:  DATA 4C,75
00BFC:  DATA 0A,0D
00BFE:  DATA 00,00
00C00:  DATA 28,6E
00C02:  DATA 68,34
00C04:  DATA 70,74
00C06:  DATA 39,29
00C08:  DATA 20,6E
00C0A:  DATA 68,34
00C0C:  DATA 70,74
00C0E:  DATA 33,63
00C10:  DATA 61,6C
00C12:  DATA 33,6F
00C14:  DATA 66,33
00C16:  DATA 20,3D
00C18:  DATA 20,25
00C1A:  DATA 4C,75
00C1C:  DATA 0A,0D
00C1E:  DATA 00,00
00C20:  DATA 28,72
00C22:  DATA 65,74
00C24:  DATA 6E,68
00C26:  DATA 34,31
00C28:  DATA 29,20
00C2A:  DATA 6E,68
00C2C:  DATA 34,70
00C2E:  DATA 74,31
00C30:  DATA 72,65
00C32:  DATA 74,75
00C34:  DATA 72,6E
00C36:  DATA 65,64
00C38:  DATA 6E,75
00C3A:  DATA 6D,62
00C3C:  DATA 65,72
00C3E:  DATA 20,3D
00C40:  DATA 20,25
00C42:  DATA 66,0A
00C44:  DATA 0D,00
00C46:  DATA 28,72
00C48:  DATA 65,74
00C4A:  DATA 6E,68
00C4C:  DATA 34,32
00C4E:  DATA 29,20
00C50:  DATA 6E,68
00C52:  DATA 34,70
00C54:  DATA 74,32
00C56:  DATA 72,65
00C58:  DATA 74,75
00C5A:  DATA 72,6E
00C5C:  DATA 65,64
00C5E:  DATA 6E,75
00C60:  DATA 6D,62
00C62:  DATA 65,72
00C64:  DATA 20,3D
00C66:  DATA 20,25
00C68:  DATA 66,0A
00C6A:  DATA 0D,00
00C6C:  DATA 28,72
00C6E:  DATA 65,74
00C70:  DATA 6E,68
00C72:  DATA 34,33
00C74:  DATA 29,20
00C76:  DATA 6E,68
00C78:  DATA 34,70
00C7A:  DATA 74,33
00C7C:  DATA 72,65
00C7E:  DATA 74,75
00C80:  DATA 72,6E
00C82:  DATA 65,64
00C84:  DATA 6E,75
00C86:  DATA 6D,62
00C88:  DATA 65,72
00C8A:  DATA 20,3D
00C8C:  DATA 20,25
00C8E:  DATA 66,0A
00C90:  DATA 0D,00
00C92:  DATA 28,44
00C94:  DATA 4F,70
00C96:  DATA 74,31
00C98:  DATA 29,20
00C9A:  DATA 44,4F
00C9C:  DATA 70,74
00C9E:  DATA 31,63
00CA0:  DATA 61,6C
00CA2:  DATA 31,6F
00CA4:  DATA 66,33
00CA6:  DATA 20,3D
00CA8:  DATA 20,25
00CAA:  DATA 4C,75
00CAC:  DATA 0A,0D
00CAE:  DATA 00,00
00CB0:  DATA 28,44
00CB2:  DATA 4F,70
00CB4:  DATA 74,32
00CB6:  DATA 29,20
00CB8:  DATA 44,4F
00CBA:  DATA 70,74
00CBC:  DATA 31,63
00CBE:  DATA 61,6C
00CC0:  DATA 32,6F
00CC2:  DATA 66,33
00CC4:  DATA 20,3D
00CC6:  DATA 20,25
00CC8:  DATA 4C,75
00CCA:  DATA 0A,0D
00CCC:  DATA 00,00
00CCE:  DATA 28,44
00CD0:  DATA 4F,70
00CD2:  DATA 74,33
00CD4:  DATA 29,20
00CD6:  DATA 44,4F
00CD8:  DATA 70,74
00CDA:  DATA 31,63
00CDC:  DATA 61,6C
00CDE:  DATA 33,6F
00CE0:  DATA 66,33
00CE2:  DATA 20,3D
00CE4:  DATA 20,25
00CE6:  DATA 4C,75
00CE8:  DATA 0A,0D
00CEA:  DATA 00,00
00CEC:  DATA 28,44
00CEE:  DATA 4F,70
00CF0:  DATA 74,34
00CF2:  DATA 29,20
00CF4:  DATA 44,4F
00CF6:  DATA 70,74
00CF8:  DATA 32,63
00CFA:  DATA 61,6C
00CFC:  DATA 31,6F
00CFE:  DATA 66,33
00D00:  DATA 20,3D
00D02:  DATA 20,25
00D04:  DATA 4C,75
00D06:  DATA 0A,0D
00D08:  DATA 00,00
00D0A:  DATA 28,44
00D0C:  DATA 4F,70
00D0E:  DATA 74,35
00D10:  DATA 29,20
00D12:  DATA 44,4F
00D14:  DATA 70,74
00D16:  DATA 32,63
00D18:  DATA 61,6C
00D1A:  DATA 32,6F
00D1C:  DATA 66,33
00D1E:  DATA 20,3D
00D20:  DATA 20,25
00D22:  DATA 4C,75
00D24:  DATA 0A,0D
00D26:  DATA 00,00
00D28:  DATA 28,44
00D2A:  DATA 4F,70
00D2C:  DATA 74,36
00D2E:  DATA 29,20
00D30:  DATA 44,4F
00D32:  DATA 70,74
00D34:  DATA 32,63
00D36:  DATA 61,6C
00D38:  DATA 33,6F
00D3A:  DATA 66,33
00D3C:  DATA 20,3D
00D3E:  DATA 20,25
00D40:  DATA 4C,75
00D42:  DATA 0A,0D
00D44:  DATA 00,00
00D46:  DATA 28,44
00D48:  DATA 4F,70
00D4A:  DATA 74,37
00D4C:  DATA 29,20
00D4E:  DATA 44,4F
00D50:  DATA 70,74
00D52:  DATA 33,63
00D54:  DATA 61,6C
00D56:  DATA 31,6F
00D58:  DATA 66,33
00D5A:  DATA 20,3D
00D5C:  DATA 20,25
00D5E:  DATA 4C,75
00D60:  DATA 0A,0D
00D62:  DATA 00,00
00D64:  DATA 28,44
00D66:  DATA 4F,70
00D68:  DATA 74,38
00D6A:  DATA 29,20
00D6C:  DATA 44,4F
00D6E:  DATA 70,74
00D70:  DATA 33,63
00D72:  DATA 61,6C
00D74:  DATA 32,6F
00D76:  DATA 66,33
00D78:  DATA 20,3D
00D7A:  DATA 20,25
00D7C:  DATA 4C,75
00D7E:  DATA 0A,0D
00D80:  DATA 00,00
00D82:  DATA 28,44
00D84:  DATA 4F,70
00D86:  DATA 74,39
00D88:  DATA 29,20
00D8A:  DATA 44,4F
00D8C:  DATA 70,74
00D8E:  DATA 33,63
00D90:  DATA 61,6C
00D92:  DATA 33,6F
00D94:  DATA 66,33
00D96:  DATA 20,3D
00D98:  DATA 20,25
00D9A:  DATA 4C,75
00D9C:  DATA 0A,0D
00D9E:  DATA 00,00
00DA0:  DATA 28,44
00DA2:  DATA 4F,72
00DA4:  DATA 65,74
00DA6:  DATA 31,29
00DA8:  DATA 20,44
00DAA:  DATA 4F,70
00DAC:  DATA 74,31
00DAE:  DATA 72,65
00DB0:  DATA 74,75
00DB2:  DATA 72,6E
00DB4:  DATA 65,64
00DB6:  DATA 6E,75
00DB8:  DATA 6D,62
00DBA:  DATA 65,72
00DBC:  DATA 20,3D
00DBE:  DATA 20,25
00DC0:  DATA 66,0A
00DC2:  DATA 0D,00
00DC4:  DATA 28,44
00DC6:  DATA 4F,72
00DC8:  DATA 65,74
00DCA:  DATA 29,20
00DCC:  DATA 44,4F
00DCE:  DATA 70,74
00DD0:  DATA 32,72
00DD2:  DATA 65,74
00DD4:  DATA 75,72
00DD6:  DATA 6E,65
00DD8:  DATA 64,6E
00DDA:  DATA 75,6D
00DDC:  DATA 62,65
00DDE:  DATA 72,20
00DE0:  DATA 3D,20
00DE2:  DATA 25,66
00DE4:  DATA 0A,0D
00DE6:  DATA 00,00
00DE8:  DATA 28,44
00DEA:  DATA 4F,72
00DEC:  DATA 65,74
00DEE:  DATA 33,29
00DF0:  DATA 20,44
00DF2:  DATA 4F,70
00DF4:  DATA 74,33
00DF6:  DATA 72,65
00DF8:  DATA 74,75
00DFA:  DATA 72,6E
00DFC:  DATA 65,64
00DFE:  DATA 6E,75
00E00:  DATA 6D,62
00E02:  DATA 65,72
00E04:  DATA 20,3D
00E06:  DATA 20,25
00E08:  DATA 66,0A
00E0A:  DATA 0D,00
00E0C:  DATA 28,54
00E0E:  DATA 48,70
00E10:  DATA 74,31
00E12:  DATA 29,20
00E14:  DATA 54,68
00E16:  DATA 65,72
00E18:  DATA 6D,69
00E1A:  DATA 73,74
00E1C:  DATA 65,72
00E1E:  DATA 70,74
00E20:  DATA 31,63
00E22:  DATA 61,6C
00E24:  DATA 31,6F
00E26:  DATA 66,33
00E28:  DATA 20,3D
00E2A:  DATA 20,25
00E2C:  DATA 4C,75
00E2E:  DATA 0A,0D
00E30:  DATA 00,00
00E32:  DATA 28,54
00E34:  DATA 48,70
00E36:  DATA 74,32
00E38:  DATA 29,20
00E3A:  DATA 54,68
00E3C:  DATA 65,72
00E3E:  DATA 6D,69
00E40:  DATA 73,74
00E42:  DATA 65,72
00E44:  DATA 70,74
00E46:  DATA 32,63
00E48:  DATA 61,6C
00E4A:  DATA 31,6F
00E4C:  DATA 66,33
00E4E:  DATA 20,3D
00E50:  DATA 20,25
00E52:  DATA 4C,75
00E54:  DATA 0A,0D
00E56:  DATA 00,00
00E58:  DATA 28,54
00E5A:  DATA 48,70
00E5C:  DATA 74,33
00E5E:  DATA 29,20
00E60:  DATA 54,68
00E62:  DATA 65,72
00E64:  DATA 6D,69
00E66:  DATA 73,74
00E68:  DATA 65,72
00E6A:  DATA 70,74
00E6C:  DATA 33,63
00E6E:  DATA 61,6C
00E70:  DATA 31,6F
00E72:  DATA 66,33
00E74:  DATA 20,3D
00E76:  DATA 20,25
00E78:  DATA 4C,75
00E7A:  DATA 0A,0D
00E7C:  DATA 00,00
00E7E:  DATA 28,54
00E80:  DATA 48,72
00E82:  DATA 65,74
00E84:  DATA 31,29
00E86:  DATA 20,54
00E88:  DATA 68,65
00E8A:  DATA 72,6D
00E8C:  DATA 69,73
00E8E:  DATA 74,65
00E90:  DATA 72,70
00E92:  DATA 74,31
00E94:  DATA 72,65
00E96:  DATA 74,75
00E98:  DATA 72,6E
00E9A:  DATA 65,64
00E9C:  DATA 6E,75
00E9E:  DATA 6D,62
00EA0:  DATA 65,72
00EA2:  DATA 20,3D
00EA4:  DATA 20,25
00EA6:  DATA 66,0A
00EA8:  DATA 0D,00
00EAA:  DATA 28,54
00EAC:  DATA 48,72
00EAE:  DATA 65,74
00EB0:  DATA 32,29
00EB2:  DATA 20,54
00EB4:  DATA 68,65
00EB6:  DATA 72,6D
00EB8:  DATA 69,73
00EBA:  DATA 74,65
00EBC:  DATA 72,70
00EBE:  DATA 74,32
00EC0:  DATA 72,65
00EC2:  DATA 74,75
00EC4:  DATA 72,6E
00EC6:  DATA 65,64
00EC8:  DATA 6E,75
00ECA:  DATA 6D,62
00ECC:  DATA 65,72
00ECE:  DATA 20,3D
00ED0:  DATA 20,25
00ED2:  DATA 66,0A
00ED4:  DATA 0D,00
00ED6:  DATA 28,54
00ED8:  DATA 48,72
00EDA:  DATA 65,74
00EDC:  DATA 33,29
00EDE:  DATA 20,54
00EE0:  DATA 68,65
00EE2:  DATA 72,6D
00EE4:  DATA 69,73
00EE6:  DATA 74,65
00EE8:  DATA 72,70
00EEA:  DATA 74,33
00EEC:  DATA 72,65
00EEE:  DATA 74,75
00EF0:  DATA 72,6E
00EF2:  DATA 65,64
00EF4:  DATA 6E,75
00EF6:  DATA 6D,62
00EF8:  DATA 65,72
00EFA:  DATA 20,3D
00EFC:  DATA 20,25
00EFE:  DATA 66,0A
00F00:  DATA 0D,00
00F02:  DATA 65,63
00F04:  DATA 63,61
00F06:  DATA 6C,31
00F08:  DATA 78,20
00F0A:  DATA 3D,20
00F0C:  DATA 25,66
00F0E:  DATA 0A,0D
00F10:  DATA 00,00
00F12:  DATA 65,63
00F14:  DATA 63,61
00F16:  DATA 6C,32
00F18:  DATA 78,20
00F1A:  DATA 3D,20
00F1C:  DATA 25,66
00F1E:  DATA 0A,0D
00F20:  DATA 00,00
00F22:  DATA 65,63
00F24:  DATA 63,61
00F26:  DATA 6C,33
00F28:  DATA 78,20
00F2A:  DATA 3D,20
00F2C:  DATA 25,66
00F2E:  DATA 0A,0D
00F30:  DATA 00,00
00F32:  DATA 65,63
00F34:  DATA 63,61
00F36:  DATA 6C,31
00F38:  DATA 79,20
00F3A:  DATA 3D,20
00F3C:  DATA 25,66
00F3E:  DATA 0A,0D
00F40:  DATA 00,00
00F42:  DATA 65,63
00F44:  DATA 63,61
00F46:  DATA 6C,32
00F48:  DATA 79,20
00F4A:  DATA 3D,20
00F4C:  DATA 25,66
00F4E:  DATA 0A,0D
00F50:  DATA 00,00
00F52:  DATA 65,63
00F54:  DATA 63,61
00F56:  DATA 6C,33
00F58:  DATA 79,20
00F5A:  DATA 3D,20
00F5C:  DATA 25,66
00F5E:  DATA 0A,0D
00F60:  DATA 00,00
00F62:  DATA 53,61
00F64:  DATA 76,69
00F66:  DATA 6E,67
00F68:  DATA 20,43
00F6A:  DATA 61,6C
00F6C:  DATA 69,62
00F6E:  DATA 72,61
00F70:  DATA 74,69
00F72:  DATA 6F,6E
00F74:  DATA 73,20
00F76:  DATA 69,6E
00F78:  DATA 74,6F
00F7A:  DATA 20,45
00F7C:  DATA 45,50
00F7E:  DATA 52,4F
00F80:  DATA 4D,0A
00F82:  DATA 0D,00
00F84:  DATA 43,6F
00F86:  DATA 6D,70
00F88:  DATA 6C,65
00F8A:  DATA 74,69
00F8C:  DATA 6E,67
00F8E:  DATA 20,6C
00F90:  DATA 61,73
00F92:  DATA 74,20
00F94:  DATA 70,6F
00F96:  DATA 6C,6C
00F98:  DATA 69,6E
00F9A:  DATA 67,20
00F9C:  DATA 62,65
00F9E:  DATA 66,6F
00FA0:  DATA 72,65
00FA2:  DATA 20,75
00FA4:  DATA 70,64
00FA6:  DATA 61,74
00FA8:  DATA 69,6E
00FAA:  DATA 67,0A
00FAC:  DATA 0D,00
00FAE:  DATA 0D,0A
00FB0:  DATA 3E,00
*
0101C:  DATA 49,64
0101E:  DATA 65,6E
01020:  DATA 74,69
01022:  DATA 66,79
01024:  DATA 69,6E
01026:  DATA 67,00
01028:  DATA 56,65
0102A:  DATA 72,6E
0102C:  DATA 69,65
0102E:  DATA 72,20
01030:  DATA 25,4C
01032:  DATA 75,20
01034:  DATA 4E,48
01036:  DATA 33,20
01038:  DATA 25,66
0103A:  DATA 20,20
0103C:  DATA 00,00
0103E:  DATA 54,49
01040:  DATA 20,31
01042:  DATA 30,31
01044:  DATA 35,20
01046:  DATA 52,48
01048:  DATA 2F,54
0104A:  DATA 65,6D
0104C:  DATA 70,00
0104E:  DATA 54,65
01050:  DATA 6D,70
01052:  DATA 20,25
01054:  DATA 66,00
01056:  DATA 52,48
01058:  DATA 20,25
0105A:  DATA 66,00
0105C:  DATA 20,20
0105E:  DATA 20,20
01060:  DATA 20,20
01062:  DATA 20,54
01064:  DATA 41,4F
01066:  DATA 53,20
01068:  DATA 33,34
0106A:  DATA 31,34
0106C:  DATA 00,00
0106E:  DATA 72,65
01070:  DATA 64,20
01072:  DATA 25,4C
01074:  DATA 75,00
01076:  DATA 67,72
01078:  DATA 65,65
0107A:  DATA 6E,20
0107C:  DATA 25,4C
0107E:  DATA 75,00
01080:  DATA 62,6C
01082:  DATA 75,65
01084:  DATA 20,25
01086:  DATA 4C,75
01088:  DATA 00,00
0108A:  DATA 20,41
0108C:  DATA 6E,61
0108E:  DATA 6C,6F
01090:  DATA 67,20
01092:  DATA 44,4F
01094:  DATA 20,61
01096:  DATA 6E,64
01098:  DATA 20,4E
0109A:  DATA 48,34
0109C:  DATA 20,20
0109E:  DATA 00,00
010A0:  DATA 57,54
010A2:  DATA 20,25
010A4:  DATA 66,20
010A6:  DATA 20,52
010A8:  DATA 61,77
010AA:  DATA 20,25
010AC:  DATA 4C,75
010AE:  DATA 20,20
010B0:  DATA 00,00
010B2:  DATA 4E,48
010B4:  DATA 34,20
010B6:  DATA 25,4C
010B8:  DATA 75,20
010BA:  DATA 20,20
010BC:  DATA 00,00
010BE:  DATA 44,4F
010C0:  DATA 20,25
010C2:  DATA 4C,75
010C4:  DATA 20,20
010C6:  DATA 20,00
010C8:  DATA 57,54
010CA:  DATA 20,25
010CC:  DATA 66,20
010CE:  DATA 20,52
010D0:  DATA 61,77
010D2:  DATA 20,25
010D4:  DATA 4C,75
010D6:  DATA 20,20
010D8:  DATA 00,00
010DA:  DATA 44,4F
010DC:  DATA 20,52
010DE:  DATA 61,77
010E0:  DATA 20,25
010E2:  DATA 4C,75
010E4:  DATA 20,20
010E6:  DATA 20,20
010E8:  DATA 00,00
010EA:  DATA 4E,48
010EC:  DATA 34,2D
010EE:  DATA 44,4F
010F0:  DATA 20,52
010F2:  DATA 47,42
010F4:  DATA 57,20
010F6:  DATA 25,4C
010F8:  DATA 75,20
010FA:  DATA 20,25
010FC:  DATA 4C,75
010FE:  DATA 20,20
01100:  DATA 25,4C
01102:  DATA 75,20
01104:  DATA 20,25
01106:  DATA 4C,75
01108:  DATA 20,20
0110A:  DATA 44,4F
0110C:  DATA 20,52
0110E:  DATA 65,64
01110:  DATA 20,20
01112:  DATA 25,4C
01114:  DATA 75,20
01116:  DATA 20,57
01118:  DATA 54,20
0111A:  DATA 25,66
0111C:  DATA 20,20
0111E:  DATA 52,61
01120:  DATA 77,20
01122:  DATA 25,4C
01124:  DATA 75,0A
01126:  DATA 0D,00
01128:  DATA 20,20
0112A:  DATA 43,4F
0112C:  DATA 32,2F
0112E:  DATA 52,48
01130:  DATA 2F,54
01132:  DATA 65,6D
01134:  DATA 70,20
01136:  DATA 20,20
01138:  DATA 00,00
0113A:  DATA 41,54
0113C:  DATA 20,25
0113E:  DATA 66,20
01140:  DATA 20,52
01142:  DATA 48,20
01144:  DATA 20,25
01146:  DATA 66,20
01148:  DATA 20,00
0114A:  DATA 43,4F
0114C:  DATA 32,20
0114E:  DATA 25,4C
01150:  DATA 75,20
01152:  DATA 20,20
01154:  DATA 20,00
01156:  DATA 43,6F
01158:  DATA 6D,6D
0115A:  DATA 61,6E
0115C:  DATA 64,20
0115E:  DATA 4C,69
01160:  DATA 6E,65
01162:  DATA 20,50
01164:  DATA 72,6F
01166:  DATA 63,65
01168:  DATA 73,73
0116A:  DATA 6F,72
0116C:  DATA 0D,0A
0116E:  DATA 3E,00
01170:  DATA 50,72
01172:  DATA 65,73
01174:  DATA 73,20
01176:  DATA 3F,20
01178:  DATA 61,6E
0117A:  DATA 64,20
0117C:  DATA 43,52
0117E:  DATA 20,66
01180:  DATA 6F,72
01182:  DATA 20,61
01184:  DATA 20,6C
01186:  DATA 69,73
01188:  DATA 74,20
0118A:  DATA 6F,66
0118C:  DATA 20,63
0118E:  DATA 6F,6D
01190:  DATA 6D,61
01192:  DATA 6E,64
01194:  DATA 73,0D
01196:  DATA 0A,3E
01198:  DATA 00,00
0119A:  DATA 53,65
0119C:  DATA 6E,64
0119E:  DATA 69,6E
011A0:  DATA 67,20
011A2:  DATA 55,70
011A4:  DATA 64,61
011A6:  DATA 74,65
011A8:  DATA 64,20
011AA:  DATA 43,6F
011AC:  DATA 6E,66
011AE:  DATA 69,67
011B0:  DATA 75,72
011B2:  DATA 61,74
011B4:  DATA 69,6F
011B6:  DATA 6E,73
011B8:  DATA 0A,0D
011BA:  DATA 00,00
011BC:  DATA 55,70
011BE:  DATA 64,61
011C0:  DATA 74,65
011C2:  DATA 20,43
011C4:  DATA 6F,6D
011C6:  DATA 70,6C
011C8:  DATA 65,74
011CA:  DATA 65,64
011CC:  DATA 0D,0A
011CE:  DATA 00,00
*
01C20:  TBLRD*+
01C22:  MOVF   FF5,F
01C24:  BZ    1C40
01C26:  MOVFF  FF6,7A8
01C2A:  MOVFF  FF7,7A9
01C2E:  MOVF   FF5,W
01C30:  BTFSS  F9E.4
01C32:  BRA    1C30
01C34:  MOVWF  FAD
01C36:  MOVFF  7A8,FF6
01C3A:  MOVFF  7A9,FF7
01C3E:  BRA    1C20
01C40:  RETURN 0
01C42:  MOVFF  232,FEA
01C46:  MOVFF  231,FE9
01C4A:  MOVLB  7
01C4C:  MOVFF  7BC,FEF
01C50:  INCF   FE9,F
01C52:  BTFSC  FD8.2
01C54:  INCF   FEA,F
01C56:  CLRF   FEF
01C58:  MOVLB  2
01C5A:  INCF   x31,F
01C5C:  BTFSC  FD8.2
01C5E:  INCF   x32,F
01C60:  MOVLB  0
01C62:  RETURN 0
01C64:  TBLRD*+
01C66:  MOVF   FF5,F
01C68:  BZ    1C82
01C6A:  MOVFF  FF6,7AF
01C6E:  MOVFF  FF7,7B0
01C72:  MOVFF  FF5,7BC
01C76:  RCALL  1C42
01C78:  MOVFF  7AF,FF6
01C7C:  MOVFF  7B0,FF7
01C80:  BRA    1C64
01C82:  RETURN 0
*
01CE0:  MOVLW  80
01CE2:  BTFSS  FD8.1
01CE4:  BRA    1CEA
01CE6:  MOVLB  7
01CE8:  XORWF  xE8,F
01CEA:  MOVLB  7
01CEC:  CLRF   xED
01CEE:  CLRF   xEE
01CF0:  MOVFF  7E4,7EC
01CF4:  MOVF   xE8,W
01CF6:  XORWF  xEC,F
01CF8:  MOVF   xE3,W
01CFA:  BTFSC  FD8.2
01CFC:  BRA    1EBC
01CFE:  MOVWF  xEB
01D00:  MOVWF  00
01D02:  MOVF   xE7,W
01D04:  BTFSC  FD8.2
01D06:  BRA    1ECE
01D08:  SUBWF  xEB,F
01D0A:  BTFSC  FD8.2
01D0C:  BRA    1E14
01D0E:  BNC   1D8C
01D10:  MOVFF  7E8,7F1
01D14:  BSF    xF1.7
01D16:  MOVFF  7E9,7F0
01D1A:  MOVFF  7EA,7EF
01D1E:  CLRF   xEE
01D20:  BCF    FD8.0
01D22:  RRCF   xF1,F
01D24:  RRCF   xF0,F
01D26:  RRCF   xEF,F
01D28:  RRCF   xEE,F
01D2A:  DECFSZ xEB,F
01D2C:  BRA    1D1E
01D2E:  BTFSS  xEC.7
01D30:  BRA    1D38
01D32:  BSF    xED.0
01D34:  BRA    1EF6
01D36:  BCF    xED.0
01D38:  BCF    xEB.0
01D3A:  BSF    xED.4
01D3C:  MOVLW  07
01D3E:  MOVWF  FEA
01D40:  MOVLW  E6
01D42:  MOVWF  FE9
01D44:  BRA    1F1C
01D46:  BCF    xED.4
01D48:  BTFSC  xEC.7
01D4A:  BRA    1D60
01D4C:  BTFSS  xEB.0
01D4E:  BRA    1D76
01D50:  RRCF   xF1,F
01D52:  RRCF   xF0,F
01D54:  RRCF   xEF,F
01D56:  RRCF   xEE,F
01D58:  INCF   00,F
01D5A:  BTFSC  FD8.2
01D5C:  BRA    1EEC
01D5E:  BRA    1D76
01D60:  BTFSC  xF1.7
01D62:  BRA    1D7C
01D64:  BCF    FD8.0
01D66:  RLCF   xEE,F
01D68:  RLCF   xEF,F
01D6A:  RLCF   xF0,F
01D6C:  RLCF   xF1,F
01D6E:  DECF   00,F
01D70:  BTFSC  FD8.2
01D72:  BRA    1EEC
01D74:  BRA    1D60
01D76:  BSF    xED.6
01D78:  BRA    1E54
01D7A:  BCF    xED.6
01D7C:  MOVFF  7E4,7EC
01D80:  BTFSS  xE4.7
01D82:  BRA    1D88
01D84:  BSF    xF1.7
01D86:  BRA    1EDE
01D88:  BCF    xF1.7
01D8A:  BRA    1EDE
01D8C:  MOVFF  7E7,7EB
01D90:  MOVFF  7E7,00
01D94:  MOVF   xE3,W
01D96:  SUBWF  xEB,F
01D98:  MOVFF  7E4,7F1
01D9C:  BSF    xF1.7
01D9E:  MOVFF  7E5,7F0
01DA2:  MOVFF  7E6,7EF
01DA6:  CLRF   xEE
01DA8:  BCF    FD8.0
01DAA:  RRCF   xF1,F
01DAC:  RRCF   xF0,F
01DAE:  RRCF   xEF,F
01DB0:  RRCF   xEE,F
01DB2:  DECFSZ xEB,F
01DB4:  BRA    1DA6
01DB6:  BTFSS  xEC.7
01DB8:  BRA    1DC0
01DBA:  BSF    xED.1
01DBC:  BRA    1EF6
01DBE:  BCF    xED.1
01DC0:  BCF    xEB.0
01DC2:  BSF    xED.5
01DC4:  MOVLW  07
01DC6:  MOVWF  FEA
01DC8:  MOVLW  EA
01DCA:  MOVWF  FE9
01DCC:  BRA    1F1C
01DCE:  BCF    xED.5
01DD0:  BTFSC  xEC.7
01DD2:  BRA    1DE8
01DD4:  BTFSS  xEB.0
01DD6:  BRA    1DFE
01DD8:  RRCF   xF1,F
01DDA:  RRCF   xF0,F
01DDC:  RRCF   xEF,F
01DDE:  RRCF   xEE,F
01DE0:  INCF   00,F
01DE2:  BTFSC  FD8.2
01DE4:  BRA    1EEC
01DE6:  BRA    1DFE
01DE8:  BTFSC  xF1.7
01DEA:  BRA    1E04
01DEC:  BCF    FD8.0
01DEE:  RLCF   xEE,F
01DF0:  RLCF   xEF,F
01DF2:  RLCF   xF0,F
01DF4:  RLCF   xF1,F
01DF6:  DECF   00,F
01DF8:  BTFSC  FD8.2
01DFA:  BRA    1EEC
01DFC:  BRA    1DE8
01DFE:  BSF    xED.7
01E00:  BRA    1E54
01E02:  BCF    xED.7
01E04:  MOVFF  7E8,7EC
01E08:  BTFSS  xE8.7
01E0A:  BRA    1E10
01E0C:  BSF    xF1.7
01E0E:  BRA    1EDE
01E10:  BCF    xF1.7
01E12:  BRA    1EDE
01E14:  MOVFF  7E8,7F1
01E18:  BSF    xF1.7
01E1A:  MOVFF  7E9,7F0
01E1E:  MOVFF  7EA,7EF
01E22:  BTFSS  xEC.7
01E24:  BRA    1E2E
01E26:  BCF    xF1.7
01E28:  BSF    xED.2
01E2A:  BRA    1EF6
01E2C:  BCF    xED.2
01E2E:  CLRF   xEE
01E30:  BCF    xEB.0
01E32:  MOVLW  07
01E34:  MOVWF  FEA
01E36:  MOVLW  E6
01E38:  MOVWF  FE9
01E3A:  BRA    1F1C
01E3C:  BTFSC  xEC.7
01E3E:  BRA    1E78
01E40:  MOVFF  7E4,7EC
01E44:  BTFSS  xEB.0
01E46:  BRA    1E54
01E48:  RRCF   xF1,F
01E4A:  RRCF   xF0,F
01E4C:  RRCF   xEF,F
01E4E:  RRCF   xEE,F
01E50:  INCF   00,F
01E52:  BZ    1EEC
01E54:  BTFSS  xEE.7
01E56:  BRA    1E6E
01E58:  INCF   xEF,F
01E5A:  BNZ   1E6E
01E5C:  INCF   xF0,F
01E5E:  BNZ   1E6E
01E60:  INCF   xF1,F
01E62:  BNZ   1E6E
01E64:  RRCF   xF1,F
01E66:  RRCF   xF0,F
01E68:  RRCF   xEF,F
01E6A:  INCF   00,F
01E6C:  BZ    1EEC
01E6E:  BTFSC  xED.6
01E70:  BRA    1D7A
01E72:  BTFSC  xED.7
01E74:  BRA    1E02
01E76:  BRA    1EB0
01E78:  MOVLW  80
01E7A:  XORWF  xF1,F
01E7C:  BTFSS  xF1.7
01E7E:  BRA    1E88
01E80:  BRA    1EF6
01E82:  MOVFF  7E8,7EC
01E86:  BRA    1E9C
01E88:  MOVFF  7E4,7EC
01E8C:  MOVF   xF1,F
01E8E:  BNZ   1E9C
01E90:  MOVF   xF0,F
01E92:  BNZ   1E9C
01E94:  MOVF   xEF,F
01E96:  BNZ   1E9C
01E98:  CLRF   00
01E9A:  BRA    1EDE
01E9C:  BTFSC  xF1.7
01E9E:  BRA    1EB0
01EA0:  BCF    FD8.0
01EA2:  RLCF   xEE,F
01EA4:  RLCF   xEF,F
01EA6:  RLCF   xF0,F
01EA8:  RLCF   xF1,F
01EAA:  DECFSZ 00,F
01EAC:  BRA    1E9C
01EAE:  BRA    1EEC
01EB0:  BTFSS  xEC.7
01EB2:  BRA    1EB8
01EB4:  BSF    xF1.7
01EB6:  BRA    1EDE
01EB8:  BCF    xF1.7
01EBA:  BRA    1EDE
01EBC:  MOVFF  7E7,00
01EC0:  MOVFF  7E8,7F1
01EC4:  MOVFF  7E9,7F0
01EC8:  MOVFF  7EA,7EF
01ECC:  BRA    1EDE
01ECE:  MOVFF  7E3,00
01ED2:  MOVFF  7E4,7F1
01ED6:  MOVFF  7E5,7F0
01EDA:  MOVFF  7E6,7EF
01EDE:  MOVFF  7F1,01
01EE2:  MOVFF  7F0,02
01EE6:  MOVFF  7EF,03
01EEA:  BRA    1F54
01EEC:  CLRF   00
01EEE:  CLRF   01
01EF0:  CLRF   02
01EF2:  CLRF   03
01EF4:  BRA    1F54
01EF6:  CLRF   xEE
01EF8:  COMF   xEF,F
01EFA:  COMF   xF0,F
01EFC:  COMF   xF1,F
01EFE:  COMF   xEE,F
01F00:  INCF   xEE,F
01F02:  BNZ   1F0E
01F04:  INCF   xEF,F
01F06:  BNZ   1F0E
01F08:  INCF   xF0,F
01F0A:  BNZ   1F0E
01F0C:  INCF   xF1,F
01F0E:  BTFSC  xED.0
01F10:  BRA    1D36
01F12:  BTFSC  xED.1
01F14:  BRA    1DBE
01F16:  BTFSC  xED.2
01F18:  BRA    1E2C
01F1A:  BRA    1E82
01F1C:  MOVF   FEF,W
01F1E:  ADDWF  xEF,F
01F20:  BNC   1F2C
01F22:  INCF   xF0,F
01F24:  BNZ   1F2C
01F26:  INCF   xF1,F
01F28:  BTFSC  FD8.2
01F2A:  BSF    xEB.0
01F2C:  MOVF   FED,F
01F2E:  MOVF   FEF,W
01F30:  ADDWF  xF0,F
01F32:  BNC   1F3A
01F34:  INCF   xF1,F
01F36:  BTFSC  FD8.2
01F38:  BSF    xEB.0
01F3A:  MOVF   FED,F
01F3C:  MOVF   FEF,W
01F3E:  BTFSC  FEF.7
01F40:  BRA    1F44
01F42:  XORLW  80
01F44:  ADDWF  xF1,F
01F46:  BTFSC  FD8.0
01F48:  BSF    xEB.0
01F4A:  BTFSC  xED.4
01F4C:  BRA    1D46
01F4E:  BTFSC  xED.5
01F50:  BRA    1DCE
01F52:  BRA    1E3C
01F54:  MOVLB  0
01F56:  RETURN 0
01F58:  MOVLB  7
01F5A:  MOVF   xD8,W
01F5C:  BTFSC  FD8.2
01F5E:  BRA    20AA
01F60:  MOVWF  xE4
01F62:  MOVF   xDC,W
01F64:  BTFSC  FD8.2
01F66:  BRA    20AA
01F68:  SUBWF  xE4,F
01F6A:  BNC   1F76
01F6C:  MOVLW  7F
01F6E:  ADDWF  xE4,F
01F70:  BTFSC  FD8.0
01F72:  BRA    20AA
01F74:  BRA    1F82
01F76:  MOVLW  81
01F78:  SUBWF  xE4,F
01F7A:  BTFSS  FD8.0
01F7C:  BRA    20AA
01F7E:  BTFSC  FD8.2
01F80:  BRA    20AA
01F82:  MOVFF  7E4,00
01F86:  CLRF   01
01F88:  CLRF   02
01F8A:  CLRF   03
01F8C:  CLRF   xE3
01F8E:  MOVFF  7D9,7E2
01F92:  BSF    xE2.7
01F94:  MOVFF  7DA,7E1
01F98:  MOVFF  7DB,7E0
01F9C:  MOVLW  19
01F9E:  MOVWF  xE4
01FA0:  MOVF   xDF,W
01FA2:  SUBWF  xE0,F
01FA4:  BC    1FC0
01FA6:  MOVLW  01
01FA8:  SUBWF  xE1,F
01FAA:  BC    1FC0
01FAC:  SUBWF  xE2,F
01FAE:  BC    1FC0
01FB0:  SUBWF  xE3,F
01FB2:  BC    1FC0
01FB4:  INCF   xE3,F
01FB6:  INCF   xE2,F
01FB8:  INCF   xE1,F
01FBA:  MOVF   xDF,W
01FBC:  ADDWF  xE0,F
01FBE:  BRA    2010
01FC0:  MOVF   xDE,W
01FC2:  SUBWF  xE1,F
01FC4:  BC    1FEA
01FC6:  MOVLW  01
01FC8:  SUBWF  xE2,F
01FCA:  BC    1FEA
01FCC:  SUBWF  xE3,F
01FCE:  BC    1FEA
01FD0:  INCF   xE3,F
01FD2:  INCF   xE2,F
01FD4:  MOVF   xDE,W
01FD6:  ADDWF  xE1,F
01FD8:  MOVF   xDF,W
01FDA:  ADDWF  xE0,F
01FDC:  BNC   2010
01FDE:  INCF   xE1,F
01FE0:  BNZ   2010
01FE2:  INCF   xE2,F
01FE4:  BNZ   2010
01FE6:  INCF   xE3,F
01FE8:  BRA    2010
01FEA:  MOVF   xDD,W
01FEC:  IORLW  80
01FEE:  SUBWF  xE2,F
01FF0:  BC    200E
01FF2:  MOVLW  01
01FF4:  SUBWF  xE3,F
01FF6:  BC    200E
01FF8:  INCF   xE3,F
01FFA:  MOVF   xDD,W
01FFC:  IORLW  80
01FFE:  ADDWF  xE2,F
02000:  MOVF   xDE,W
02002:  ADDWF  xE1,F
02004:  BNC   1FD8
02006:  INCF   xE2,F
02008:  BNZ   1FD8
0200A:  INCF   xE3,F
0200C:  BRA    1FD8
0200E:  BSF    03.0
02010:  DECFSZ xE4,F
02012:  BRA    2016
02014:  BRA    202C
02016:  BCF    FD8.0
02018:  RLCF   xE0,F
0201A:  RLCF   xE1,F
0201C:  RLCF   xE2,F
0201E:  RLCF   xE3,F
02020:  BCF    FD8.0
02022:  RLCF   03,F
02024:  RLCF   02,F
02026:  RLCF   01,F
02028:  RLCF   xE5,F
0202A:  BRA    1FA0
0202C:  BTFSS  xE5.0
0202E:  BRA    203C
02030:  BCF    FD8.0
02032:  RRCF   01,F
02034:  RRCF   02,F
02036:  RRCF   03,F
02038:  RRCF   xE5,F
0203A:  BRA    2040
0203C:  DECF   00,F
0203E:  BZ    20AA
02040:  BTFSC  xE5.7
02042:  BRA    2080
02044:  BCF    FD8.0
02046:  RLCF   xE0,F
02048:  RLCF   xE1,F
0204A:  RLCF   xE2,F
0204C:  RLCF   xE3,F
0204E:  MOVF   xDF,W
02050:  SUBWF  xE0,F
02052:  BC    2062
02054:  MOVLW  01
02056:  SUBWF  xE1,F
02058:  BC    2062
0205A:  SUBWF  xE2,F
0205C:  BC    2062
0205E:  SUBWF  xE3,F
02060:  BNC   2096
02062:  MOVF   xDE,W
02064:  SUBWF  xE1,F
02066:  BC    2072
02068:  MOVLW  01
0206A:  SUBWF  xE2,F
0206C:  BC    2072
0206E:  SUBWF  xE3,F
02070:  BNC   2096
02072:  MOVF   xDD,W
02074:  IORLW  80
02076:  SUBWF  xE2,F
02078:  BC    2080
0207A:  MOVLW  01
0207C:  SUBWF  xE3,F
0207E:  BNC   2096
02080:  INCF   03,F
02082:  BNZ   2096
02084:  INCF   02,F
02086:  BNZ   2096
02088:  INCF   01,F
0208A:  BNZ   2096
0208C:  INCF   00,F
0208E:  BZ    20AA
02090:  RRCF   01,F
02092:  RRCF   02,F
02094:  RRCF   03,F
02096:  MOVFF  7D9,7E4
0209A:  MOVF   xDD,W
0209C:  XORWF  xE4,F
0209E:  BTFSS  xE4.7
020A0:  BRA    20A6
020A2:  BSF    01.7
020A4:  BRA    20B2
020A6:  BCF    01.7
020A8:  BRA    20B2
020AA:  CLRF   00
020AC:  CLRF   01
020AE:  CLRF   02
020B0:  CLRF   03
020B2:  MOVLB  0
020B4:  RETURN 0
020B6:  MOVLB  7
020B8:  MOVF   xDF,W
020BA:  BTFSC  FD8.2
020BC:  BRA    21A0
020BE:  MOVWF  00
020C0:  MOVF   xE3,W
020C2:  BTFSC  FD8.2
020C4:  BRA    21A0
020C6:  ADDWF  00,F
020C8:  BNC   20D2
020CA:  MOVLW  81
020CC:  ADDWF  00,F
020CE:  BC    21A0
020D0:  BRA    20DA
020D2:  MOVLW  7F
020D4:  SUBWF  00,F
020D6:  BNC   21A0
020D8:  BZ    21A0
020DA:  MOVFF  7E0,7E7
020DE:  MOVF   xE4,W
020E0:  XORWF  xE7,F
020E2:  BSF    xE0.7
020E4:  BSF    xE4.7
020E6:  MOVF   xE2,W
020E8:  MULWF  xE6
020EA:  MOVFF  FF4,7E9
020EE:  MOVF   xE1,W
020F0:  MULWF  xE5
020F2:  MOVFF  FF4,03
020F6:  MOVFF  FF3,7E8
020FA:  MULWF  xE6
020FC:  MOVF   FF3,W
020FE:  ADDWF  xE9,F
02100:  MOVF   FF4,W
02102:  ADDWFC xE8,F
02104:  MOVLW  00
02106:  ADDWFC 03,F
02108:  MOVF   xE2,W
0210A:  MULWF  xE5
0210C:  MOVF   FF3,W
0210E:  ADDWF  xE9,F
02110:  MOVF   FF4,W
02112:  ADDWFC xE8,F
02114:  MOVLW  00
02116:  CLRF   02
02118:  ADDWFC 03,F
0211A:  ADDWFC 02,F
0211C:  MOVF   xE0,W
0211E:  MULWF  xE6
02120:  MOVF   FF3,W
02122:  ADDWF  xE8,F
02124:  MOVF   FF4,W
02126:  ADDWFC 03,F
02128:  MOVLW  00
0212A:  ADDWFC 02,F
0212C:  MOVF   xE0,W
0212E:  MULWF  xE5
02130:  MOVF   FF3,W
02132:  ADDWF  03,F
02134:  MOVF   FF4,W
02136:  ADDWFC 02,F
02138:  MOVLW  00
0213A:  CLRF   01
0213C:  ADDWFC 01,F
0213E:  MOVF   xE2,W
02140:  MULWF  xE4
02142:  MOVF   FF3,W
02144:  ADDWF  xE8,F
02146:  MOVF   FF4,W
02148:  ADDWFC 03,F
0214A:  MOVLW  00
0214C:  ADDWFC 02,F
0214E:  ADDWFC 01,F
02150:  MOVF   xE1,W
02152:  MULWF  xE4
02154:  MOVF   FF3,W
02156:  ADDWF  03,F
02158:  MOVF   FF4,W
0215A:  ADDWFC 02,F
0215C:  MOVLW  00
0215E:  ADDWFC 01,F
02160:  MOVF   xE0,W
02162:  MULWF  xE4
02164:  MOVF   FF3,W
02166:  ADDWF  02,F
02168:  MOVF   FF4,W
0216A:  ADDWFC 01,F
0216C:  INCF   00,F
0216E:  BTFSC  01.7
02170:  BRA    217C
02172:  RLCF   xE8,F
02174:  RLCF   03,F
02176:  RLCF   02,F
02178:  RLCF   01,F
0217A:  DECF   00,F
0217C:  MOVLW  00
0217E:  BTFSS  xE8.7
02180:  BRA    2196
02182:  INCF   03,F
02184:  ADDWFC 02,F
02186:  ADDWFC 01,F
02188:  MOVF   01,W
0218A:  BNZ   2196
0218C:  MOVF   02,W
0218E:  BNZ   2196
02190:  MOVF   03,W
02192:  BNZ   2196
02194:  INCF   00,F
02196:  BTFSC  xE7.7
02198:  BSF    01.7
0219A:  BTFSS  xE7.7
0219C:  BCF    01.7
0219E:  BRA    21A8
021A0:  CLRF   00
021A2:  CLRF   01
021A4:  CLRF   02
021A6:  CLRF   03
021A8:  MOVLB  0
021AA:  RETURN 0
021AC:  MOVLW  8E
021AE:  MOVWF  00
021B0:  MOVFF  7E4,01
021B4:  MOVFF  7E3,02
021B8:  CLRF   03
021BA:  MOVF   01,F
021BC:  BNZ   21D0
021BE:  MOVFF  02,01
021C2:  CLRF   02
021C4:  MOVLW  08
021C6:  SUBWF  00,F
021C8:  MOVF   01,F
021CA:  BNZ   21D0
021CC:  CLRF   00
021CE:  BRA    21E0
021D0:  BCF    FD8.0
021D2:  BTFSC  01.7
021D4:  BRA    21DE
021D6:  RLCF   02,F
021D8:  RLCF   01,F
021DA:  DECF   00,F
021DC:  BRA    21D0
021DE:  BCF    01.7
021E0:  RETURN 0
021E2:  MOVFF  7E0,7E7
021E6:  MOVLB  7
021E8:  MOVF   xE4,W
021EA:  XORWF  xE7,F
021EC:  BTFSS  xE7.7
021EE:  BRA    21FA
021F0:  BCF    FD8.2
021F2:  BCF    FD8.0
021F4:  BTFSC  xE0.7
021F6:  BSF    FD8.0
021F8:  BRA    2258
021FA:  MOVFF  7E0,7E7
021FE:  MOVFF  7E3,7E8
02202:  MOVF   xDF,W
02204:  SUBWF  xE8,F
02206:  BZ    2214
02208:  BTFSS  xE7.7
0220A:  BRA    2258
0220C:  MOVF   FD8,W
0220E:  XORLW  01
02210:  MOVWF  FD8
02212:  BRA    2258
02214:  MOVFF  7E4,7E8
02218:  MOVF   xE0,W
0221A:  SUBWF  xE8,F
0221C:  BZ    222A
0221E:  BTFSS  xE7.7
02220:  BRA    2258
02222:  MOVF   FD8,W
02224:  XORLW  01
02226:  MOVWF  FD8
02228:  BRA    2258
0222A:  MOVFF  7E5,7E8
0222E:  MOVF   xE1,W
02230:  SUBWF  xE8,F
02232:  BZ    2240
02234:  BTFSS  xE7.7
02236:  BRA    2258
02238:  MOVF   FD8,W
0223A:  XORLW  01
0223C:  MOVWF  FD8
0223E:  BRA    2258
02240:  MOVFF  7E6,7E8
02244:  MOVF   xE2,W
02246:  SUBWF  xE8,F
02248:  BZ    2256
0224A:  BTFSS  xE7.7
0224C:  BRA    2258
0224E:  MOVF   FD8,W
02250:  XORLW  01
02252:  MOVWF  FD8
02254:  BRA    2258
02256:  BCF    FD8.0
02258:  MOVLB  0
0225A:  RETURN 0
0225C:  MOVLW  8E
0225E:  MOVWF  00
02260:  MOVLB  7
02262:  MOVF   xDF,W
02264:  SUBWF  00,F
02266:  MOVFF  7E0,02
0226A:  MOVFF  7E1,01
0226E:  BSF    02.7
02270:  MOVF   00,F
02272:  BZ    2286
02274:  BCF    FD8.0
02276:  MOVF   02,F
02278:  BNZ   227E
0227A:  MOVF   01,F
0227C:  BZ    2286
0227E:  RRCF   02,F
02280:  RRCF   01,F
02282:  DECFSZ 00,F
02284:  BRA    2274
02286:  BTFSS  xE0.7
02288:  BRA    2294
0228A:  COMF   01,F
0228C:  COMF   02,F
0228E:  INCF   01,F
02290:  BTFSC  FD8.2
02292:  INCF   02,F
02294:  MOVLB  0
02296:  RETURN 0
*
0277C:  MOVLW  8E
0277E:  MOVWF  00
02780:  MOVFF  7D6,01
02784:  MOVFF  7D5,02
02788:  CLRF   03
0278A:  BTFSS  01.7
0278C:  BRA    2798
0278E:  COMF   01,F
02790:  COMF   02,F
02792:  INCF   02,F
02794:  BNZ   2798
02796:  INCF   01,F
02798:  MOVF   01,F
0279A:  BNZ   27AE
0279C:  MOVFF  02,01
027A0:  CLRF   02
027A2:  MOVLW  08
027A4:  SUBWF  00,F
027A6:  MOVF   01,F
027A8:  BNZ   27AE
027AA:  CLRF   00
027AC:  BRA    27CA
027AE:  BCF    FD8.0
027B0:  BTFSC  01.7
027B2:  BRA    27BC
027B4:  RLCF   02,F
027B6:  RLCF   01,F
027B8:  DECF   00,F
027BA:  BRA    27AE
027BC:  MOVLB  7
027BE:  BTFSS  xD6.7
027C0:  BRA    27C6
027C2:  MOVLB  0
027C4:  BRA    27CA
027C6:  BCF    01.7
027C8:  MOVLB  0
027CA:  RETURN 0
*
0327E:  TBLRD*+
03280:  MOVFF  FF6,7B0
03284:  MOVFF  FF7,7B1
03288:  MOVFF  FF5,7BC
0328C:  CALL   1C42
03290:  MOVFF  7B0,FF6
03294:  MOVFF  7B1,FF7
03298:  MOVLB  7
0329A:  DECFSZ xAF,F
0329C:  BRA    32A0
0329E:  BRA    32A4
032A0:  MOVLB  0
032A2:  BRA    327E
032A4:  MOVLB  0
032A6:  RETURN 0
032A8:  MOVFF  FEA,7B7
032AC:  MOVFF  FE9,7B6
032B0:  MOVLB  7
032B2:  SWAPF  xB0,W
032B4:  IORLW  F0
032B6:  MOVWF  xB2
032B8:  ADDWF  xB2,F
032BA:  ADDLW  E2
032BC:  MOVWF  xB3
032BE:  ADDLW  32
032C0:  MOVWF  xB5
032C2:  MOVF   xB0,W
032C4:  ANDLW  0F
032C6:  ADDWF  xB3,F
032C8:  ADDWF  xB3,F
032CA:  ADDWF  xB5,F
032CC:  ADDLW  E9
032CE:  MOVWF  xB4
032D0:  ADDWF  xB4,F
032D2:  ADDWF  xB4,F
032D4:  SWAPF  xAF,W
032D6:  ANDLW  0F
032D8:  ADDWF  xB4,F
032DA:  ADDWF  xB5,F
032DC:  RLCF   xB4,F
032DE:  RLCF   xB5,F
032E0:  COMF   xB5,F
032E2:  RLCF   xB5,F
032E4:  MOVF   xAF,W
032E6:  ANDLW  0F
032E8:  ADDWF  xB5,F
032EA:  RLCF   xB2,F
032EC:  MOVLW  07
032EE:  MOVWF  xB1
032F0:  MOVLW  0A
032F2:  DECF   xB4,F
032F4:  ADDWF  xB5,F
032F6:  BNC   32F2
032F8:  DECF   xB3,F
032FA:  ADDWF  xB4,F
032FC:  BNC   32F8
032FE:  DECF   xB2,F
03300:  ADDWF  xB3,F
03302:  BNC   32FE
03304:  DECF   xB1,F
03306:  ADDWF  xB2,F
03308:  BNC   3304
0330A:  MOVLW  07
0330C:  MOVWF  FEA
0330E:  MOVLW  B1
03310:  MOVWF  FE9
03312:  MOVLW  07
03314:  ANDWF  xB6,W
03316:  BCF    xB6.6
03318:  ADDWF  FE9,F
0331A:  MOVLW  00
0331C:  ADDWFC FEA,F
0331E:  MOVF   FE9,W
03320:  SUBLW  B5
03322:  BNZ   332C
03324:  MOVF   FEA,W
03326:  SUBLW  07
03328:  BNZ   332C
0332A:  BSF    xB6.6
0332C:  MOVF   FEF,W
0332E:  MOVWF  00
03330:  BNZ   3342
03332:  BTFSC  xB6.6
03334:  BRA    3342
03336:  BTFSC  xB6.4
03338:  BRA    3366
0333A:  BTFSC  xB6.3
0333C:  BRA    3342
0333E:  MOVLW  20
03340:  BRA    3348
03342:  BSF    xB6.3
03344:  BCF    xB6.4
03346:  MOVLW  30
03348:  ADDWF  00,F
0334A:  MOVFF  FEA,7B0
0334E:  MOVFF  FE9,7AF
03352:  MOVFF  00,7BC
03356:  MOVLB  0
03358:  CALL   1C42
0335C:  MOVFF  7B0,FEA
03360:  MOVFF  7AF,FE9
03364:  MOVLB  7
03366:  MOVF   FEE,W
03368:  BTFSS  xB6.6
0336A:  BRA    331E
0336C:  MOVLB  0
0336E:  RETURN 0
03370:  MOVLB  7
03372:  MOVF   xBC,W
03374:  SUBLW  B6
03376:  MOVWF  xBC
03378:  CLRF   03
0337A:  MOVFF  7BD,7C0
0337E:  BSF    xBD.7
03380:  BCF    FD8.0
03382:  RRCF   xBD,F
03384:  RRCF   xBE,F
03386:  RRCF   xBF,F
03388:  RRCF   03,F
0338A:  RRCF   02,F
0338C:  RRCF   01,F
0338E:  RRCF   00,F
03390:  DECFSZ xBC,F
03392:  BRA    3380
03394:  BTFSS  xC0.7
03396:  BRA    33AE
03398:  COMF   00,F
0339A:  COMF   01,F
0339C:  COMF   02,F
0339E:  COMF   03,F
033A0:  INCF   00,F
033A2:  BTFSC  FD8.2
033A4:  INCF   01,F
033A6:  BTFSC  FD8.2
033A8:  INCF   02,F
033AA:  BTFSC  FD8.2
033AC:  INCF   03,F
033AE:  MOVLB  0
033B0:  RETURN 0
033B2:  BTFSC  FD8.1
033B4:  BRA    33BE
033B6:  MOVLW  07
033B8:  MOVWF  FEA
033BA:  MOVLW  C4
033BC:  MOVWF  FE9
033BE:  CLRF   00
033C0:  CLRF   01
033C2:  CLRF   02
033C4:  CLRF   03
033C6:  MOVLB  7
033C8:  CLRF   xC4
033CA:  CLRF   xC5
033CC:  CLRF   xC6
033CE:  CLRF   xC7
033D0:  MOVF   xC3,W
033D2:  IORWF  xC2,W
033D4:  IORWF  xC1,W
033D6:  IORWF  xC0,W
033D8:  BZ    3432
033DA:  MOVLW  20
033DC:  MOVWF  xC8
033DE:  BCF    FD8.0
033E0:  RLCF   xBC,F
033E2:  RLCF   xBD,F
033E4:  RLCF   xBE,F
033E6:  RLCF   xBF,F
033E8:  RLCF   xC4,F
033EA:  RLCF   xC5,F
033EC:  RLCF   xC6,F
033EE:  RLCF   xC7,F
033F0:  MOVF   xC3,W
033F2:  SUBWF  xC7,W
033F4:  BNZ   3406
033F6:  MOVF   xC2,W
033F8:  SUBWF  xC6,W
033FA:  BNZ   3406
033FC:  MOVF   xC1,W
033FE:  SUBWF  xC5,W
03400:  BNZ   3406
03402:  MOVF   xC0,W
03404:  SUBWF  xC4,W
03406:  BNC   3426
03408:  MOVF   xC0,W
0340A:  SUBWF  xC4,F
0340C:  MOVF   xC1,W
0340E:  BTFSS  FD8.0
03410:  INCFSZ xC1,W
03412:  SUBWF  xC5,F
03414:  MOVF   xC2,W
03416:  BTFSS  FD8.0
03418:  INCFSZ xC2,W
0341A:  SUBWF  xC6,F
0341C:  MOVF   xC3,W
0341E:  BTFSS  FD8.0
03420:  INCFSZ xC3,W
03422:  SUBWF  xC7,F
03424:  BSF    FD8.0
03426:  RLCF   00,F
03428:  RLCF   01,F
0342A:  RLCF   02,F
0342C:  RLCF   03,F
0342E:  DECFSZ xC8,F
03430:  BRA    33DE
03432:  MOVFF  7C4,FEF
03436:  MOVFF  7C5,FEC
0343A:  MOVFF  7C6,FEC
0343E:  MOVFF  7C7,FEC
03442:  MOVLB  0
03444:  RETURN 0
03446:  MOVF   FE9,W
03448:  MOVLB  7
0344A:  MOVWF  xB4
0344C:  MOVF   xB3,W
0344E:  MOVWF  xB6
03450:  BZ    348A
03452:  MOVFF  7B2,7E2
03456:  MOVFF  7B1,7E1
0345A:  MOVFF  7B0,7E0
0345E:  MOVFF  7AF,7DF
03462:  CLRF   xE6
03464:  CLRF   xE5
03466:  MOVLW  20
03468:  MOVWF  xE4
0346A:  MOVLW  82
0346C:  MOVWF  xE3
0346E:  MOVLB  0
03470:  CALL   20B6
03474:  MOVFF  03,7B2
03478:  MOVFF  02,7B1
0347C:  MOVFF  01,7B0
03480:  MOVFF  00,7AF
03484:  MOVLB  7
03486:  DECFSZ xB6,F
03488:  BRA    3452
0348A:  MOVFF  7B2,7BF
0348E:  MOVFF  7B1,7BE
03492:  MOVFF  7B0,7BD
03496:  MOVFF  7AF,7BC
0349A:  MOVLB  0
0349C:  RCALL  3370
0349E:  MOVFF  03,7B2
034A2:  MOVFF  02,7B1
034A6:  MOVFF  01,7B0
034AA:  MOVFF  00,7AF
034AE:  MOVLB  7
034B0:  BTFSS  xB2.7
034B2:  BRA    34CE
034B4:  DECF   xB4,F
034B6:  BSF    xB4.5
034B8:  COMF   xAF,F
034BA:  COMF   xB0,F
034BC:  COMF   xB1,F
034BE:  COMF   xB2,F
034C0:  INCF   xAF,F
034C2:  BTFSC  FD8.2
034C4:  INCF   xB0,F
034C6:  BTFSC  FD8.2
034C8:  INCF   xB1,F
034CA:  BTFSC  FD8.2
034CC:  INCF   xB2,F
034CE:  MOVLW  3B
034D0:  MOVWF  xBB
034D2:  MOVLW  9A
034D4:  MOVWF  xBA
034D6:  MOVLW  CA
034D8:  MOVWF  xB9
034DA:  CLRF   xB8
034DC:  MOVLW  0A
034DE:  MOVWF  xB6
034E0:  MOVF   xB3,W
034E2:  BTFSC  FD8.2
034E4:  INCF   xB4,F
034E6:  BSF    FD8.1
034E8:  MOVLW  07
034EA:  MOVWF  FEA
034EC:  MOVLW  AF
034EE:  MOVWF  FE9
034F0:  MOVFF  7B2,7BF
034F4:  MOVFF  7B1,7BE
034F8:  MOVFF  7B0,7BD
034FC:  MOVFF  7AF,7BC
03500:  MOVFF  7BB,7C3
03504:  MOVFF  7BA,7C2
03508:  MOVFF  7B9,7C1
0350C:  MOVFF  7B8,7C0
03510:  MOVLB  0
03512:  RCALL  33B2
03514:  MOVF   01,W
03516:  MOVF   00,F
03518:  BNZ   3540
0351A:  MOVLB  7
0351C:  INCF   xB3,W
0351E:  SUBWF  xB6,W
03520:  BTFSS  FD8.2
03522:  BRA    3528
03524:  MOVLB  0
03526:  BRA    3540
03528:  MOVF   xB4,W
0352A:  BZ    3546
0352C:  ANDLW  0F
0352E:  SUBWF  xB6,W
03530:  BZ    3534
03532:  BC    35BC
03534:  BTFSC  xB4.7
03536:  BRA    35BC
03538:  BTFSC  xB4.6
0353A:  BRA    3546
0353C:  MOVLW  20
0353E:  BRA    35AE
03540:  MOVLW  20
03542:  MOVLB  7
03544:  ANDWF  xB4,F
03546:  BTFSS  xB4.5
03548:  BRA    3568
0354A:  BCF    xB4.5
0354C:  MOVF   xB3,W
0354E:  BTFSS  FD8.2
03550:  DECF   xB4,F
03552:  MOVF   00,W
03554:  MOVWF  xB4
03556:  MOVLW  2D
03558:  MOVWF  xBC
0355A:  MOVLB  0
0355C:  CALL   1C42
03560:  MOVLB  7
03562:  MOVF   xB4,W
03564:  MOVWF  00
03566:  CLRF   xB4
03568:  MOVF   xB3,W
0356A:  SUBWF  xB6,W
0356C:  BNZ   3588
0356E:  MOVF   00,W
03570:  MOVWF  xB4
03572:  MOVLW  2E
03574:  MOVWF  xBC
03576:  MOVLB  0
03578:  CALL   1C42
0357C:  MOVLB  7
0357E:  MOVF   xB4,W
03580:  MOVWF  00
03582:  MOVLW  20
03584:  ANDWF  xB4,F
03586:  MOVLW  00
03588:  MOVLW  30
0358A:  BTFSS  xB4.5
0358C:  BRA    35AE
0358E:  BCF    xB4.5
03590:  MOVF   xB3,W
03592:  BTFSS  FD8.2
03594:  DECF   xB4,F
03596:  MOVF   00,W
03598:  MOVWF  xB4
0359A:  MOVLW  2D
0359C:  MOVWF  xBC
0359E:  MOVLB  0
035A0:  CALL   1C42
035A4:  MOVLB  7
035A6:  MOVF   xB4,W
035A8:  MOVWF  00
035AA:  CLRF   xB4
035AC:  MOVLW  30
035AE:  ADDWF  00,F
035B0:  MOVFF  00,7BC
035B4:  MOVLB  0
035B6:  CALL   1C42
035BA:  MOVLB  7
035BC:  BCF    FD8.1
035BE:  MOVFF  7BB,7BF
035C2:  MOVFF  7BA,7BE
035C6:  MOVFF  7B9,7BD
035CA:  MOVFF  7B8,7BC
035CE:  CLRF   xC3
035D0:  CLRF   xC2
035D2:  CLRF   xC1
035D4:  MOVLW  0A
035D6:  MOVWF  xC0
035D8:  MOVLB  0
035DA:  RCALL  33B2
035DC:  MOVFF  03,7BB
035E0:  MOVFF  02,7BA
035E4:  MOVFF  01,7B9
035E8:  MOVFF  00,7B8
035EC:  MOVLB  7
035EE:  DECFSZ xB6,F
035F0:  BRA    34E6
035F2:  MOVLB  0
035F4:  RETURN 0
*
04150:  ADDWF  FE8,W
04152:  CLRF   FF7
04154:  RLCF   FF7,F
04156:  ADDLW  6B
04158:  MOVWF  FF6
0415A:  MOVLW  41
0415C:  ADDWFC FF7,F
0415E:  TBLRD*-
04160:  MOVF   FF5,W
04162:  MOVWF  FFA
04164:  TBLRD*
04166:  MOVF   FF5,W
04168:  MOVWF  FF9
0416A:  DATA 10,41
0416C:  DATA 18,41
0416E:  DATA 20,41
04170:  DATA 28,41
*
04CE8:  MOVLB  7
04CEA:  MOVF   xB4,W
04CEC:  MULWF  xB6
04CEE:  MOVFF  FF3,01
04CF2:  MOVFF  FF4,00
04CF6:  MULWF  xB7
04CF8:  MOVF   FF3,W
04CFA:  ADDWF  00,F
04CFC:  MOVF   xB5,W
04CFE:  MULWF  xB6
04D00:  MOVF   FF3,W
04D02:  ADDWFC 00,W
04D04:  MOVWF  02
04D06:  MOVLB  0
04D08:  RETURN 0
*
0508C:  MOVF   FEF,F
0508E:  BZ    50B0
05090:  MOVFF  FEA,7A9
05094:  MOVFF  FE9,7A8
05098:  MOVF   FEF,W
0509A:  BTFSS  F9E.4
0509C:  BRA    509A
0509E:  MOVWF  FAD
050A0:  MOVFF  7A9,FEA
050A4:  MOVFF  7A8,FE9
050A8:  INCF   FE9,F
050AA:  BTFSC  FD8.2
050AC:  INCF   FEA,F
050AE:  BRA    508C
050B0:  GOTO   640C (RETURN)
*
05642:  TBLRD*+
05644:  MOVFF  FF6,7A9
05648:  MOVFF  FF7,7AA
0564C:  MOVF   FF5,W
0564E:  BTFSS  F9E.4
05650:  BRA    564E
05652:  MOVWF  FAD
05654:  MOVFF  7A9,FF6
05658:  MOVFF  7AA,FF7
0565C:  MOVLB  7
0565E:  DECFSZ xA8,F
05660:  BRA    5664
05662:  BRA    5668
05664:  MOVLB  0
05666:  BRA    5642
05668:  MOVLB  0
0566A:  RETURN 0
0566C:  MOVF   FE9,W
0566E:  MOVLB  7
05670:  MOVWF  xAD
05672:  MOVF   xAC,W
05674:  MOVWF  xAF
05676:  BZ    56B0
05678:  MOVFF  7AB,7E2
0567C:  MOVFF  7AA,7E1
05680:  MOVFF  7A9,7E0
05684:  MOVFF  7A8,7DF
05688:  CLRF   xE6
0568A:  CLRF   xE5
0568C:  MOVLW  20
0568E:  MOVWF  xE4
05690:  MOVLW  82
05692:  MOVWF  xE3
05694:  MOVLB  0
05696:  CALL   20B6
0569A:  MOVFF  03,7AB
0569E:  MOVFF  02,7AA
056A2:  MOVFF  01,7A9
056A6:  MOVFF  00,7A8
056AA:  MOVLB  7
056AC:  DECFSZ xAF,F
056AE:  BRA    5678
056B0:  MOVFF  7AB,7BF
056B4:  MOVFF  7AA,7BE
056B8:  MOVFF  7A9,7BD
056BC:  MOVFF  7A8,7BC
056C0:  MOVLB  0
056C2:  CALL   3370
056C6:  MOVFF  03,7AB
056CA:  MOVFF  02,7AA
056CE:  MOVFF  01,7A9
056D2:  MOVFF  00,7A8
056D6:  MOVLB  7
056D8:  BTFSS  xAB.7
056DA:  BRA    56F6
056DC:  DECF   xAD,F
056DE:  BSF    xAD.5
056E0:  COMF   xA8,F
056E2:  COMF   xA9,F
056E4:  COMF   xAA,F
056E6:  COMF   xAB,F
056E8:  INCF   xA8,F
056EA:  BTFSC  FD8.2
056EC:  INCF   xA9,F
056EE:  BTFSC  FD8.2
056F0:  INCF   xAA,F
056F2:  BTFSC  FD8.2
056F4:  INCF   xAB,F
056F6:  MOVLW  3B
056F8:  MOVWF  xB4
056FA:  MOVLW  9A
056FC:  MOVWF  xB3
056FE:  MOVLW  CA
05700:  MOVWF  xB2
05702:  CLRF   xB1
05704:  MOVLW  0A
05706:  MOVWF  xAF
05708:  MOVF   xAC,W
0570A:  BTFSC  FD8.2
0570C:  INCF   xAD,F
0570E:  BSF    FD8.1
05710:  MOVLW  07
05712:  MOVWF  FEA
05714:  MOVLW  A8
05716:  MOVWF  FE9
05718:  MOVFF  7AB,7BF
0571C:  MOVFF  7AA,7BE
05720:  MOVFF  7A9,7BD
05724:  MOVFF  7A8,7BC
05728:  MOVFF  7B4,7C3
0572C:  MOVFF  7B3,7C2
05730:  MOVFF  7B2,7C1
05734:  MOVFF  7B1,7C0
05738:  MOVLB  0
0573A:  CALL   33B2
0573E:  MOVF   01,W
05740:  MOVF   00,F
05742:  BNZ   576A
05744:  MOVLB  7
05746:  INCF   xAC,W
05748:  SUBWF  xAF,W
0574A:  BTFSS  FD8.2
0574C:  BRA    5752
0574E:  MOVLB  0
05750:  BRA    576A
05752:  MOVF   xAD,W
05754:  BZ    5770
05756:  ANDLW  0F
05758:  SUBWF  xAF,W
0575A:  BZ    575E
0575C:  BC    57D6
0575E:  BTFSC  xAD.7
05760:  BRA    57D6
05762:  BTFSC  xAD.6
05764:  BRA    5770
05766:  MOVLW  20
05768:  BRA    57CC
0576A:  MOVLW  20
0576C:  MOVLB  7
0576E:  ANDWF  xAD,F
05770:  BTFSS  xAD.5
05772:  BRA    578E
05774:  BCF    xAD.5
05776:  MOVF   xAC,W
05778:  BTFSS  FD8.2
0577A:  DECF   xAD,F
0577C:  MOVF   00,W
0577E:  MOVWF  xAD
05780:  MOVLW  2D
05782:  BTFSS  F9E.4
05784:  BRA    5782
05786:  MOVWF  FAD
05788:  MOVF   xAD,W
0578A:  MOVWF  00
0578C:  CLRF   xAD
0578E:  MOVF   xAC,W
05790:  SUBWF  xAF,W
05792:  BNZ   57AA
05794:  MOVF   00,W
05796:  MOVWF  xAD
05798:  MOVLW  2E
0579A:  BTFSS  F9E.4
0579C:  BRA    579A
0579E:  MOVWF  FAD
057A0:  MOVF   xAD,W
057A2:  MOVWF  00
057A4:  MOVLW  20
057A6:  ANDWF  xAD,F
057A8:  MOVLW  00
057AA:  MOVLW  30
057AC:  BTFSS  xAD.5
057AE:  BRA    57CC
057B0:  BCF    xAD.5
057B2:  MOVF   xAC,W
057B4:  BTFSS  FD8.2
057B6:  DECF   xAD,F
057B8:  MOVF   00,W
057BA:  MOVWF  xAD
057BC:  MOVLW  2D
057BE:  BTFSS  F9E.4
057C0:  BRA    57BE
057C2:  MOVWF  FAD
057C4:  MOVF   xAD,W
057C6:  MOVWF  00
057C8:  CLRF   xAD
057CA:  MOVLW  30
057CC:  ADDWF  00,F
057CE:  MOVF   00,W
057D0:  BTFSS  F9E.4
057D2:  BRA    57D0
057D4:  MOVWF  FAD
057D6:  BCF    FD8.1
057D8:  MOVFF  7B4,7BF
057DC:  MOVFF  7B3,7BE
057E0:  MOVFF  7B2,7BD
057E4:  MOVFF  7B1,7BC
057E8:  CLRF   xC3
057EA:  CLRF   xC2
057EC:  CLRF   xC1
057EE:  MOVLW  0A
057F0:  MOVWF  xC0
057F2:  MOVLB  0
057F4:  CALL   33B2
057F8:  MOVFF  03,7B4
057FC:  MOVFF  02,7B3
05800:  MOVFF  01,7B2
05804:  MOVFF  00,7B1
05808:  MOVLB  7
0580A:  DECFSZ xAF,F
0580C:  BRA    570E
0580E:  MOVLB  0
05810:  RETURN 0
05812:  MOVLB  7
05814:  MOVF   xB1,W
05816:  XORWF  xB3,W
05818:  ANDLW  80
0581A:  MOVWF  xB5
0581C:  BTFSS  xB1.7
0581E:  BRA    582A
05820:  COMF   xB0,F
05822:  COMF   xB1,F
05824:  INCF   xB0,F
05826:  BTFSC  FD8.2
05828:  INCF   xB1,F
0582A:  BTFSS  xB3.7
0582C:  BRA    5838
0582E:  COMF   xB2,F
05830:  COMF   xB3,F
05832:  INCF   xB2,F
05834:  BTFSC  FD8.2
05836:  INCF   xB3,F
05838:  MOVF   xB0,W
0583A:  MULWF  xB2
0583C:  MOVFF  FF3,01
05840:  MOVFF  FF4,00
05844:  MULWF  xB3
05846:  MOVF   FF3,W
05848:  ADDWF  00,F
0584A:  MOVF   xB1,W
0584C:  MULWF  xB2
0584E:  MOVF   FF3,W
05850:  ADDWFC 00,W
05852:  MOVWF  02
05854:  BTFSS  xB5.7
05856:  BRA    5862
05858:  COMF   01,F
0585A:  COMF   02,F
0585C:  INCF   01,F
0585E:  BTFSC  FD8.2
05860:  INCF   02,F
05862:  MOVLB  0
05864:  GOTO   5942 (RETURN)
*
05A4C:  MOVFF  FEA,7B0
05A50:  MOVFF  FE9,7AF
05A54:  MOVLB  7
05A56:  SWAPF  xA9,W
05A58:  IORLW  F0
05A5A:  MOVWF  xAB
05A5C:  ADDWF  xAB,F
05A5E:  ADDLW  E2
05A60:  MOVWF  xAC
05A62:  ADDLW  32
05A64:  MOVWF  xAE
05A66:  MOVF   xA9,W
05A68:  ANDLW  0F
05A6A:  ADDWF  xAC,F
05A6C:  ADDWF  xAC,F
05A6E:  ADDWF  xAE,F
05A70:  ADDLW  E9
05A72:  MOVWF  xAD
05A74:  ADDWF  xAD,F
05A76:  ADDWF  xAD,F
05A78:  SWAPF  xA8,W
05A7A:  ANDLW  0F
05A7C:  ADDWF  xAD,F
05A7E:  ADDWF  xAE,F
05A80:  RLCF   xAD,F
05A82:  RLCF   xAE,F
05A84:  COMF   xAE,F
05A86:  RLCF   xAE,F
05A88:  MOVF   xA8,W
05A8A:  ANDLW  0F
05A8C:  ADDWF  xAE,F
05A8E:  RLCF   xAB,F
05A90:  MOVLW  07
05A92:  MOVWF  xAA
05A94:  MOVLW  0A
05A96:  DECF   xAD,F
05A98:  ADDWF  xAE,F
05A9A:  BNC   5A96
05A9C:  DECF   xAC,F
05A9E:  ADDWF  xAD,F
05AA0:  BNC   5A9C
05AA2:  DECF   xAB,F
05AA4:  ADDWF  xAC,F
05AA6:  BNC   5AA2
05AA8:  DECF   xAA,F
05AAA:  ADDWF  xAB,F
05AAC:  BNC   5AA8
05AAE:  MOVLW  07
05AB0:  MOVWF  FEA
05AB2:  MOVLW  AA
05AB4:  MOVWF  FE9
05AB6:  MOVLW  07
05AB8:  ANDWF  xAF,W
05ABA:  BCF    xAF.6
05ABC:  ADDWF  FE9,F
05ABE:  MOVLW  00
05AC0:  ADDWFC FEA,F
05AC2:  MOVF   FE9,W
05AC4:  SUBLW  AE
05AC6:  BNZ   5AD0
05AC8:  MOVF   FEA,W
05ACA:  SUBLW  07
05ACC:  BNZ   5AD0
05ACE:  BSF    xAF.6
05AD0:  MOVF   FEF,W
05AD2:  MOVWF  00
05AD4:  BNZ   5AE6
05AD6:  BTFSC  xAF.6
05AD8:  BRA    5AE6
05ADA:  BTFSC  xAF.4
05ADC:  BRA    5AF6
05ADE:  BTFSC  xAF.3
05AE0:  BRA    5AE6
05AE2:  MOVLW  20
05AE4:  BRA    5AEC
05AE6:  BSF    xAF.3
05AE8:  BCF    xAF.4
05AEA:  MOVLW  30
05AEC:  ADDWF  00,F
05AEE:  MOVF   00,W
05AF0:  BTFSS  F9E.4
05AF2:  BRA    5AF0
05AF4:  MOVWF  FAD
05AF6:  MOVF   FEE,W
05AF8:  BTFSS  xAF.6
05AFA:  BRA    5AC2
05AFC:  MOVLB  0
05AFE:  RETURN 0
....................  
.................... #list 
....................  
.................... #DEVICE ICD=TRUE 
.................... #device ADC=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
050B4:  MOVLB  7
050B6:  MOVFF  7B5,FE9
050BA:  MOVFF  7B6,FEA
050BE:  MOVFF  FEF,7B9
050C2:  MOVFF  7B8,03
050C6:  MOVFF  7B7,FE9
050CA:  MOVFF  7B8,FEA
050CE:  MOVF   FEF,W
050D0:  SUBWF  xB9,W
050D2:  BZ    5164
050D4:  MOVFF  7B6,03
050D8:  MOVFF  7B5,FE9
050DC:  MOVFF  7B6,FEA
050E0:  MOVFF  FEF,7B9
050E4:  MOVF   xB9,W
050E6:  SUBLW  40
050E8:  BC    50F0
050EA:  MOVF   xB9,W
050EC:  SUBLW  5A
050EE:  BC    50FC
050F0:  MOVF   xB9,W
050F2:  SUBLW  60
050F4:  BC    518E
050F6:  MOVF   xB9,W
050F8:  SUBLW  7A
050FA:  BNC   518E
050FC:  MOVFF  7B8,03
05100:  MOVFF  7B7,FE9
05104:  MOVFF  7B8,FEA
05108:  MOVFF  FEF,7B9
0510C:  MOVF   xB9,W
0510E:  SUBLW  40
05110:  BC    5118
05112:  MOVF   xB9,W
05114:  SUBLW  5A
05116:  BC    5124
05118:  MOVF   xB9,W
0511A:  SUBLW  60
0511C:  BC    518E
0511E:  MOVF   xB9,W
05120:  SUBLW  7A
05122:  BNC   518E
05124:  MOVFF  7B5,FE9
05128:  MOVFF  7B6,FEA
0512C:  MOVFF  FEF,7B9
05130:  MOVFF  7B8,03
05134:  MOVFF  7B7,FE9
05138:  MOVFF  7B8,FEA
0513C:  MOVLW  20
0513E:  ADDWF  FEF,W
05140:  SUBWF  xB9,W
05142:  BZ    5164
05144:  MOVFF  7B7,FE9
05148:  MOVFF  7B8,FEA
0514C:  MOVFF  FEF,7B9
05150:  MOVFF  7B6,03
05154:  MOVFF  7B5,FE9
05158:  MOVFF  7B6,FEA
0515C:  MOVLW  20
0515E:  ADDWF  FEF,W
05160:  SUBWF  xB9,W
05162:  BNZ   518E
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
05164:  MOVFF  7B6,03
05168:  MOVFF  7B5,FE9
0516C:  MOVFF  7B6,FEA
05170:  MOVF   FEF,F
05172:  BNZ   517A
....................        return(0); 
05174:  MOVLW  00
05176:  MOVWF  01
05178:  BRA    51B8
0517A:  MOVFF  7B6,03
0517E:  MOVF   xB5,W
05180:  INCF   xB5,F
05182:  BTFSC  FD8.2
05184:  INCF   xB6,F
05186:  INCF   xB7,F
05188:  BTFSC  FD8.2
0518A:  INCF   xB8,F
0518C:  BRA    50B6
....................  return((*s1 < *s2) ? -1: 1); 
0518E:  MOVFF  7B6,03
05192:  MOVFF  7B5,FE9
05196:  MOVFF  7B6,FEA
0519A:  MOVFF  FEF,7B9
0519E:  MOVFF  7B8,03
051A2:  MOVFF  7B7,FE9
051A6:  MOVFF  7B8,FEA
051AA:  MOVF   FEF,W
051AC:  SUBWF  xB9,W
051AE:  BC    51B4
051B0:  MOVLW  FF
051B2:  BRA    51B6
051B4:  MOVLW  01
051B6:  MOVWF  01
051B8:  MOVLB  0
051BA:  RETURN 0
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
05868:  MOVLB  7
0586A:  CLRF   xAE
....................    sign = 0; 
0586C:  CLRF   xAC
....................    base = 10; 
0586E:  MOVLW  0A
05870:  MOVWF  xAD
....................    result = 0; 
05872:  CLRF   xAB
05874:  CLRF   xAA
....................  
....................    if (!s) 
05876:  MOVF   xA8,W
05878:  IORWF  xA9,W
0587A:  BNZ   5884
....................       return 0; 
0587C:  MOVLW  00
0587E:  MOVWF  01
05880:  MOVWF  02
05882:  BRA    5A48
....................    c = s[index++]; 
05884:  MOVF   xAE,W
05886:  INCF   xAE,F
05888:  ADDWF  xA8,W
0588A:  MOVWF  FE9
0588C:  MOVLW  00
0588E:  ADDWFC xA9,W
05890:  MOVWF  FEA
05892:  MOVFF  FEF,7AF
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
05896:  MOVF   xAF,W
05898:  SUBLW  2D
0589A:  BNZ   58B4
....................    { 
....................       sign = 1;         // Set the sign to negative 
0589C:  MOVLW  01
0589E:  MOVWF  xAC
....................       c = s[index++]; 
058A0:  MOVF   xAE,W
058A2:  INCF   xAE,F
058A4:  ADDWF  xA8,W
058A6:  MOVWF  FE9
058A8:  MOVLW  00
058AA:  ADDWFC xA9,W
058AC:  MOVWF  FEA
058AE:  MOVFF  FEF,7AF
....................    } 
058B2:  BRA    58CC
....................    else if (c == '+') 
058B4:  MOVF   xAF,W
058B6:  SUBLW  2B
058B8:  BNZ   58CC
....................    { 
....................       c = s[index++]; 
058BA:  MOVF   xAE,W
058BC:  INCF   xAE,F
058BE:  ADDWF  xA8,W
058C0:  MOVWF  FE9
058C2:  MOVLW  00
058C4:  ADDWFC xA9,W
058C6:  MOVWF  FEA
058C8:  MOVFF  FEF,7AF
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
058CC:  MOVF   xAF,W
058CE:  SUBLW  2F
058D0:  BTFSC  FD8.0
058D2:  BRA    5A2C
058D4:  MOVF   xAF,W
058D6:  SUBLW  39
058D8:  BTFSS  FD8.0
058DA:  BRA    5A2C
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
058DC:  MOVF   xAF,W
058DE:  SUBLW  30
058E0:  BNZ   591E
058E2:  MOVF   xAE,W
058E4:  ADDWF  xA8,W
058E6:  MOVWF  FE9
058E8:  MOVLW  00
058EA:  ADDWFC xA9,W
058EC:  MOVWF  FEA
058EE:  MOVF   FEF,W
058F0:  SUBLW  78
058F2:  BZ    5906
058F4:  MOVF   xAE,W
058F6:  ADDWF  xA8,W
058F8:  MOVWF  FE9
058FA:  MOVLW  00
058FC:  ADDWFC xA9,W
058FE:  MOVWF  FEA
05900:  MOVF   FEF,W
05902:  SUBLW  58
05904:  BNZ   591E
....................       { 
....................          base = 16; 
05906:  MOVLW  10
05908:  MOVWF  xAD
....................          index++; 
0590A:  INCF   xAE,F
....................          c = s[index++]; 
0590C:  MOVF   xAE,W
0590E:  INCF   xAE,F
05910:  ADDWF  xA8,W
05912:  MOVWF  FE9
05914:  MOVLW  00
05916:  ADDWFC xA9,W
05918:  MOVWF  FEA
0591A:  MOVFF  FEF,7AF
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0591E:  MOVF   xAD,W
05920:  SUBLW  0A
05922:  BNZ   5968
....................       { 
....................          while (c >= '0' && c <= '9') 
05924:  MOVF   xAF,W
05926:  SUBLW  2F
05928:  BC    5966
0592A:  MOVF   xAF,W
0592C:  SUBLW  39
0592E:  BNC   5966
....................          { 
....................             result = 10*result + (c - '0'); 
05930:  CLRF   xB1
05932:  MOVLW  0A
05934:  MOVWF  xB0
05936:  MOVFF  7AB,7B3
0593A:  MOVFF  7AA,7B2
0593E:  MOVLB  0
05940:  BRA    5812
05942:  MOVLW  30
05944:  MOVLB  7
05946:  SUBWF  xAF,W
05948:  ADDWF  01,W
0594A:  MOVWF  xAA
0594C:  MOVLW  00
0594E:  ADDWFC 02,W
05950:  MOVWF  xAB
....................             c = s[index++]; 
05952:  MOVF   xAE,W
05954:  INCF   xAE,F
05956:  ADDWF  xA8,W
05958:  MOVWF  FE9
0595A:  MOVLW  00
0595C:  ADDWFC xA9,W
0595E:  MOVWF  FEA
05960:  MOVFF  FEF,7AF
05964:  BRA    5924
....................          } 
....................       } 
05966:  BRA    5A2C
....................       else if (base == 16)    // The number is a hexa number 
05968:  MOVF   xAD,W
0596A:  SUBLW  10
0596C:  BNZ   5A2C
....................       { 
....................          c = toupper(c); 
0596E:  MOVF   xAF,W
05970:  SUBLW  60
05972:  BC    5980
05974:  MOVF   xAF,W
05976:  SUBLW  7A
05978:  BNC   5980
0597A:  MOVF   xAF,W
0597C:  ANDLW  DF
0597E:  BRA    5982
05980:  MOVF   xAF,W
05982:  MOVWF  xAF
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
05984:  MOVF   xAF,W
05986:  SUBLW  2F
05988:  BC    5990
0598A:  MOVF   xAF,W
0598C:  SUBLW  39
0598E:  BC    599C
05990:  MOVF   xAF,W
05992:  SUBLW  40
05994:  BC    5A2C
05996:  MOVF   xAF,W
05998:  SUBLW  46
0599A:  BNC   5A2C
....................          { 
....................             if (c >= '0' && c <= '9') 
0599C:  MOVF   xAF,W
0599E:  SUBLW  2F
059A0:  BC    59D6
059A2:  MOVF   xAF,W
059A4:  SUBLW  39
059A6:  BNC   59D6
....................                result = (result << 4) + (c - '0'); 
059A8:  RLCF   xAA,W
059AA:  MOVWF  xB0
059AC:  RLCF   xAB,W
059AE:  MOVWF  xB1
059B0:  RLCF   xB0,F
059B2:  RLCF   xB1,F
059B4:  RLCF   xB0,F
059B6:  RLCF   xB1,F
059B8:  RLCF   xB0,F
059BA:  RLCF   xB1,F
059BC:  MOVLW  F0
059BE:  ANDWF  xB0,F
059C0:  MOVLW  30
059C2:  SUBWF  xAF,W
059C4:  ADDWF  xB0,W
059C6:  MOVWF  01
059C8:  MOVLW  00
059CA:  ADDWFC xB1,W
059CC:  MOVWF  03
059CE:  MOVFF  01,7AA
059D2:  MOVWF  xAB
059D4:  BRA    5A02
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
059D6:  RLCF   xAA,W
059D8:  MOVWF  xB0
059DA:  RLCF   xAB,W
059DC:  MOVWF  xB1
059DE:  RLCF   xB0,F
059E0:  RLCF   xB1,F
059E2:  RLCF   xB0,F
059E4:  RLCF   xB1,F
059E6:  RLCF   xB0,F
059E8:  RLCF   xB1,F
059EA:  MOVLW  F0
059EC:  ANDWF  xB0,F
059EE:  MOVLW  41
059F0:  SUBWF  xAF,W
059F2:  ADDLW  0A
059F4:  ADDWF  xB0,W
059F6:  MOVWF  01
059F8:  MOVLW  00
059FA:  ADDWFC xB1,W
059FC:  MOVFF  01,7AA
05A00:  MOVWF  xAB
....................  
....................             c = s[index++];c = toupper(c); 
05A02:  MOVF   xAE,W
05A04:  INCF   xAE,F
05A06:  ADDWF  xA8,W
05A08:  MOVWF  FE9
05A0A:  MOVLW  00
05A0C:  ADDWFC xA9,W
05A0E:  MOVWF  FEA
05A10:  MOVFF  FEF,7AF
05A14:  MOVF   xAF,W
05A16:  SUBLW  60
05A18:  BC    5A26
05A1A:  MOVF   xAF,W
05A1C:  SUBLW  7A
05A1E:  BNC   5A26
05A20:  MOVF   xAF,W
05A22:  ANDLW  DF
05A24:  BRA    5A28
05A26:  MOVF   xAF,W
05A28:  MOVWF  xAF
05A2A:  BRA    5984
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
05A2C:  MOVF   xAD,W
05A2E:  SUBLW  0A
05A30:  BNZ   5A40
05A32:  DECFSZ xAC,W
05A34:  BRA    5A40
....................       result = -result; 
05A36:  COMF   xAA,F
05A38:  COMF   xAB,F
05A3A:  INCF   xAA,F
05A3C:  BTFSC  FD8.2
05A3E:  INCF   xAB,F
....................  
....................    return(result); 
05A40:  MOVFF  7AA,01
05A44:  MOVFF  7AB,02
05A48:  MOVLB  0
05A4A:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
053E8:  MOVLB  7
053EA:  CLRF   xAF
053EC:  CLRF   xAE
053EE:  CLRF   xAD
053F0:  MOVLW  7F
053F2:  MOVWF  xAC
053F4:  CLRF   xB3
053F6:  CLRF   xB2
053F8:  CLRF   xB1
053FA:  CLRF   xB0
053FC:  BSF    xB4.0
053FE:  BCF    xB4.1
05400:  BCF    xB4.2
05402:  CLRF   xB6
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
05404:  MOVF   xA8,W
05406:  IORWF  xA9,W
05408:  BNZ   5414
....................       return 0; 
0540A:  CLRF   00
0540C:  CLRF   01
0540E:  CLRF   02
05410:  CLRF   03
05412:  BRA    563E
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
05414:  MOVF   xB6,W
05416:  INCF   xB6,F
05418:  ADDWF  xA8,W
0541A:  MOVWF  FE9
0541C:  MOVLW  00
0541E:  ADDWFC xA9,W
05420:  MOVWF  FEA
05422:  MOVFF  FEF,7B5
05426:  MOVF   xB5,F
05428:  BTFSC  FD8.2
0542A:  BRA    55C2
....................    { 
....................       if (skip && !isspace(c)) 
0542C:  BTFSS  xB4.0
0542E:  BRA    544E
05430:  MOVF   xB5,W
05432:  SUBLW  20
05434:  BZ    544E
....................       { 
....................          skip = 0; 
05436:  BCF    xB4.0
....................          if (c == '+') 
05438:  MOVF   xB5,W
0543A:  SUBLW  2B
0543C:  BNZ   5444
....................          { 
....................             sign = 0; 
0543E:  BCF    xB4.1
....................             continue; 
05440:  BRA    55AA
....................          }             
05442:  BRA    544E
....................          else if (c == '-') 
05444:  MOVF   xB5,W
05446:  SUBLW  2D
05448:  BNZ   544E
....................          { 
....................             sign = 1; 
0544A:  BSF    xB4.1
....................             continue; 
0544C:  BRA    55AA
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0544E:  BTFSC  xB4.0
05450:  BRA    5460
05452:  MOVF   xB5,W
05454:  SUBLW  2E
05456:  BNZ   5460
05458:  BTFSC  xB4.2
0545A:  BRA    5460
....................          point = 1; 
0545C:  BSF    xB4.2
0545E:  BRA    55AA
....................       else if (!skip && isdigit(c)) 
05460:  BTFSC  xB4.0
05462:  BRA    55A4
05464:  MOVF   xB5,W
05466:  SUBLW  2F
05468:  BTFSC  FD8.0
0546A:  BRA    55A4
0546C:  MOVF   xB5,W
0546E:  SUBLW  39
05470:  BTFSS  FD8.0
05472:  BRA    55A4
....................       { 
....................          c -= '0'; 
05474:  MOVLW  30
05476:  SUBWF  xB5,F
....................          if (point) 
05478:  BTFSS  xB4.2
0547A:  BRA    552A
....................          { 
....................             pow10 = pow10 * 10.0; 
0547C:  MOVFF  7AF,7E2
05480:  MOVFF  7AE,7E1
05484:  MOVFF  7AD,7E0
05488:  MOVFF  7AC,7DF
0548C:  CLRF   xE6
0548E:  CLRF   xE5
05490:  MOVLW  20
05492:  MOVWF  xE4
05494:  MOVLW  82
05496:  MOVWF  xE3
05498:  MOVLB  0
0549A:  CALL   20B6
0549E:  MOVFF  03,7AF
054A2:  MOVFF  02,7AE
054A6:  MOVFF  01,7AD
054AA:  MOVFF  00,7AC
....................             result += (float)c / pow10;    
054AE:  MOVLB  7
054B0:  CLRF   xE4
054B2:  MOVFF  7B5,7E3
054B6:  MOVLB  0
054B8:  CALL   21AC
054BC:  MOVFF  03,7BA
054C0:  MOVFF  02,7B9
054C4:  MOVFF  01,7B8
054C8:  MOVFF  00,7B7
054CC:  MOVFF  03,7DB
054D0:  MOVFF  02,7DA
054D4:  MOVFF  01,7D9
054D8:  MOVFF  00,7D8
054DC:  MOVFF  7AF,7DF
054E0:  MOVFF  7AE,7DE
054E4:  MOVFF  7AD,7DD
054E8:  MOVFF  7AC,7DC
054EC:  CALL   1F58
054F0:  BCF    FD8.1
054F2:  MOVFF  7B3,7E6
054F6:  MOVFF  7B2,7E5
054FA:  MOVFF  7B1,7E4
054FE:  MOVFF  7B0,7E3
05502:  MOVFF  03,7EA
05506:  MOVFF  02,7E9
0550A:  MOVFF  01,7E8
0550E:  MOVFF  00,7E7
05512:  CALL   1CE0
05516:  MOVFF  03,7B3
0551A:  MOVFF  02,7B2
0551E:  MOVFF  01,7B1
05522:  MOVFF  00,7B0
....................          } 
05526:  BRA    55A0
05528:  MOVLB  7
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0552A:  CLRF   xE2
0552C:  CLRF   xE1
0552E:  MOVLW  20
05530:  MOVWF  xE0
05532:  MOVLW  82
05534:  MOVWF  xDF
05536:  MOVFF  7B3,7E6
0553A:  MOVFF  7B2,7E5
0553E:  MOVFF  7B1,7E4
05542:  MOVFF  7B0,7E3
05546:  MOVLB  0
05548:  CALL   20B6
0554C:  MOVFF  03,7BA
05550:  MOVFF  02,7B9
05554:  MOVFF  01,7B8
05558:  MOVFF  00,7B7
0555C:  MOVLB  7
0555E:  CLRF   xE4
05560:  MOVFF  7B5,7E3
05564:  MOVLB  0
05566:  CALL   21AC
0556A:  BCF    FD8.1
0556C:  MOVFF  7BA,7E6
05570:  MOVFF  7B9,7E5
05574:  MOVFF  7B8,7E4
05578:  MOVFF  7B7,7E3
0557C:  MOVFF  03,7EA
05580:  MOVFF  02,7E9
05584:  MOVFF  01,7E8
05588:  MOVFF  00,7E7
0558C:  CALL   1CE0
05590:  MOVFF  03,7B3
05594:  MOVFF  02,7B2
05598:  MOVFF  01,7B1
0559C:  MOVFF  00,7B0
....................          } 
....................       } 
055A0:  BRA    55AC
055A2:  MOVLB  7
....................       else if (!skip) 
055A4:  BTFSC  xB4.0
055A6:  BRA    55AA
....................          break; 
055A8:  BRA    55C2
055AA:  MOVLB  0
055AC:  MOVLB  7
055AE:  MOVF   xB6,W
055B0:  INCF   xB6,F
055B2:  ADDWF  xA8,W
055B4:  MOVWF  FE9
055B6:  MOVLW  00
055B8:  ADDWFC xA9,W
055BA:  MOVWF  FEA
055BC:  MOVFF  FEF,7B5
055C0:  BRA    5426
....................    } 
....................  
....................    if (sign) 
055C2:  BTFSS  xB4.1
055C4:  BRA    55FA
....................       result = -1*result; 
055C6:  CLRF   xE2
055C8:  CLRF   xE1
055CA:  MOVLW  80
055CC:  MOVWF  xE0
055CE:  MOVLW  7F
055D0:  MOVWF  xDF
055D2:  MOVFF  7B3,7E6
055D6:  MOVFF  7B2,7E5
055DA:  MOVFF  7B1,7E4
055DE:  MOVFF  7B0,7E3
055E2:  MOVLB  0
055E4:  CALL   20B6
055E8:  MOVFF  03,7B3
055EC:  MOVFF  02,7B2
055F0:  MOVFF  01,7B1
055F4:  MOVFF  00,7B0
055F8:  MOVLB  7
....................        
....................    if(endptr) 
055FA:  MOVF   xAA,W
055FC:  IORWF  xAB,W
055FE:  BZ    562E
....................    { 
....................       if (ptr) { 
05600:  MOVF   xB6,F
05602:  BZ    561C
....................          ptr--; 
05604:  DECF   xB6,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
05606:  MOVFF  7AA,FE9
0560A:  MOVFF  7AB,FEA
0560E:  MOVF   xB6,W
05610:  ADDWF  xA8,W
05612:  MOVWF  FEF
05614:  MOVLW  00
05616:  ADDWFC xA9,W
05618:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0561A:  BRA    562E
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0561C:  MOVFF  7AA,FE9
05620:  MOVFF  7AB,FEA
05624:  MOVFF  7A9,FEC
05628:  MOVF   FED,F
0562A:  MOVFF  7A8,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0562E:  MOVFF  7B0,00
05632:  MOVFF  7B1,01
05636:  MOVFF  7B2,02
0563A:  MOVFF  7B3,03
0563E:  MOVLB  0
05640:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
02298:  MOVLB  7
0229A:  BCF    xDE.0
....................    y = x; 
0229C:  MOVFF  7D2,7D7
022A0:  MOVFF  7D1,7D6
022A4:  MOVFF  7D0,7D5
022A8:  MOVFF  7CF,7D4
....................  
....................    if (x < 0) 
022AC:  MOVFF  7D2,7E2
022B0:  MOVFF  7D1,7E1
022B4:  MOVFF  7D0,7E0
022B8:  MOVFF  7CF,7DF
022BC:  CLRF   xE6
022BE:  CLRF   xE5
022C0:  CLRF   xE4
022C2:  CLRF   xE3
022C4:  MOVLB  0
022C6:  RCALL  21E2
022C8:  BNC   22D6
....................    { 
....................       s = 1; 
022CA:  MOVLB  7
022CC:  BSF    xDE.0
....................       y = -y; 
022CE:  MOVF   xD5,W
022D0:  XORLW  80
022D2:  MOVWF  xD5
022D4:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
022D6:  MOVFF  7D7,7E2
022DA:  MOVFF  7D6,7E1
022DE:  MOVFF  7D5,7E0
022E2:  MOVFF  7D4,7DF
022E6:  MOVLB  7
022E8:  CLRF   xE6
022EA:  CLRF   xE5
022EC:  CLRF   xE4
022EE:  MOVLW  8E
022F0:  MOVWF  xE3
022F2:  MOVLB  0
022F4:  RCALL  21E2
022F6:  BC    22FA
022F8:  BNZ   2328
....................       res = (float32)(unsigned int16)y; 
022FA:  MOVFF  7D7,7E2
022FE:  MOVFF  7D6,7E1
02302:  MOVFF  7D5,7E0
02306:  MOVFF  7D4,7DF
0230A:  RCALL  225C
0230C:  MOVFF  02,7E4
02310:  MOVFF  01,7E3
02314:  RCALL  21AC
02316:  MOVFF  03,7DB
0231A:  MOVFF  02,7DA
0231E:  MOVFF  01,7D9
02322:  MOVFF  00,7D8
02326:  BRA    24B6
....................  
....................  else if (y < 10000000.0) 
02328:  MOVFF  7D7,7E2
0232C:  MOVFF  7D6,7E1
02330:  MOVFF  7D5,7E0
02334:  MOVFF  7D4,7DF
02338:  MOVLW  80
0233A:  MOVLB  7
0233C:  MOVWF  xE6
0233E:  MOVLW  96
02340:  MOVWF  xE5
02342:  MOVLW  18
02344:  MOVWF  xE4
02346:  MOVLW  96
02348:  MOVWF  xE3
0234A:  MOVLB  0
0234C:  RCALL  21E2
0234E:  BTFSS  FD8.0
02350:  BRA    24A6
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
02352:  MOVFF  7D7,7E2
02356:  MOVFF  7D6,7E1
0235A:  MOVFF  7D5,7E0
0235E:  MOVFF  7D4,7DF
02362:  MOVLB  7
02364:  CLRF   xE6
02366:  CLRF   xE5
02368:  CLRF   xE4
0236A:  MOVLW  70
0236C:  MOVWF  xE3
0236E:  MOVLB  0
02370:  RCALL  20B6
02372:  MOVFF  03,7E2
02376:  MOVFF  02,7E1
0237A:  MOVFF  01,7E0
0237E:  MOVFF  00,7DF
02382:  RCALL  225C
02384:  MOVFF  02,7DD
02388:  MOVFF  01,7DC
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0238C:  MOVFF  7D7,7E2
02390:  MOVFF  7D6,7E1
02394:  MOVFF  7D5,7E0
02398:  MOVFF  7D4,7DF
0239C:  MOVLB  7
0239E:  CLRF   xE6
023A0:  CLRF   xE5
023A2:  CLRF   xE4
023A4:  MOVLW  70
023A6:  MOVWF  xE3
023A8:  MOVLB  0
023AA:  RCALL  20B6
023AC:  MOVFF  03,7E2
023B0:  MOVFF  02,7E1
023B4:  MOVFF  01,7E0
023B8:  MOVFF  00,7DF
023BC:  MOVFF  7DD,7E4
023C0:  MOVFF  7DC,7E3
023C4:  RCALL  21AC
023C6:  BSF    FD8.1
023C8:  MOVFF  7E2,7E6
023CC:  MOVFF  7E1,7E5
023D0:  MOVFF  7E0,7E4
023D4:  MOVFF  7DF,7E3
023D8:  MOVFF  03,7EA
023DC:  MOVFF  02,7E9
023E0:  MOVFF  01,7E8
023E4:  MOVFF  00,7E7
023E8:  RCALL  1CE0
023EA:  MOVLB  7
023EC:  CLRF   xE2
023EE:  CLRF   xE1
023F0:  CLRF   xE0
023F2:  MOVLW  8E
023F4:  MOVWF  xDF
023F6:  MOVFF  03,7E6
023FA:  MOVFF  02,7E5
023FE:  MOVFF  01,7E4
02402:  MOVFF  00,7E3
02406:  MOVLB  0
02408:  RCALL  20B6
0240A:  MOVFF  03,7D7
0240E:  MOVFF  02,7D6
02412:  MOVFF  01,7D5
02416:  MOVFF  00,7D4
....................       res = 32768.0*(float32)l; 
0241A:  MOVFF  7DD,7E4
0241E:  MOVFF  7DC,7E3
02422:  RCALL  21AC
02424:  MOVLB  7
02426:  CLRF   xE2
02428:  CLRF   xE1
0242A:  CLRF   xE0
0242C:  MOVLW  8E
0242E:  MOVWF  xDF
02430:  MOVFF  03,7E6
02434:  MOVFF  02,7E5
02438:  MOVFF  01,7E4
0243C:  MOVFF  00,7E3
02440:  MOVLB  0
02442:  RCALL  20B6
02444:  MOVFF  03,7DB
02448:  MOVFF  02,7DA
0244C:  MOVFF  01,7D9
02450:  MOVFF  00,7D8
....................       res += (float32)(unsigned int16)y; 
02454:  MOVFF  7D7,7E2
02458:  MOVFF  7D6,7E1
0245C:  MOVFF  7D5,7E0
02460:  MOVFF  7D4,7DF
02464:  RCALL  225C
02466:  MOVFF  02,7E4
0246A:  MOVFF  01,7E3
0246E:  RCALL  21AC
02470:  BCF    FD8.1
02472:  MOVFF  7DB,7E6
02476:  MOVFF  7DA,7E5
0247A:  MOVFF  7D9,7E4
0247E:  MOVFF  7D8,7E3
02482:  MOVFF  03,7EA
02486:  MOVFF  02,7E9
0248A:  MOVFF  01,7E8
0248E:  MOVFF  00,7E7
02492:  RCALL  1CE0
02494:  MOVFF  03,7DB
02498:  MOVFF  02,7DA
0249C:  MOVFF  01,7D9
024A0:  MOVFF  00,7D8
....................    } 
024A4:  BRA    24B6
....................  
....................  else 
....................   res = y; 
024A6:  MOVFF  7D7,7DB
024AA:  MOVFF  7D6,7DA
024AE:  MOVFF  7D5,7D9
024B2:  MOVFF  7D4,7D8
....................  
....................  y = y - (float32)(unsigned int16)y; 
024B6:  MOVFF  7D7,7E2
024BA:  MOVFF  7D6,7E1
024BE:  MOVFF  7D5,7E0
024C2:  MOVFF  7D4,7DF
024C6:  RCALL  225C
024C8:  MOVFF  02,7E4
024CC:  MOVFF  01,7E3
024D0:  RCALL  21AC
024D2:  BSF    FD8.1
024D4:  MOVFF  7D7,7E6
024D8:  MOVFF  7D6,7E5
024DC:  MOVFF  7D5,7E4
024E0:  MOVFF  7D4,7E3
024E4:  MOVFF  03,7EA
024E8:  MOVFF  02,7E9
024EC:  MOVFF  01,7E8
024F0:  MOVFF  00,7E7
024F4:  CALL   1CE0
024F8:  MOVFF  03,7D7
024FC:  MOVFF  02,7D6
02500:  MOVFF  01,7D5
02504:  MOVFF  00,7D4
....................  
....................  if (s) 
02508:  MOVLB  7
0250A:  BTFSS  xDE.0
0250C:  BRA    2514
....................   res = -res; 
0250E:  MOVF   xD9,W
02510:  XORLW  80
02512:  MOVWF  xD9
....................  
....................  if (y != 0) 
02514:  MOVFF  7D7,7E2
02518:  MOVFF  7D6,7E1
0251C:  MOVFF  7D5,7E0
02520:  MOVFF  7D4,7DF
02524:  CLRF   xE6
02526:  CLRF   xE5
02528:  CLRF   xE4
0252A:  CLRF   xE3
0252C:  MOVLB  0
0252E:  RCALL  21E2
02530:  BZ    25AA
....................  { 
....................   if (s == 1 && n == 0) 
02532:  MOVLB  7
02534:  BTFSS  xDE.0
02536:  BRA    2570
02538:  MOVF   xD3,F
0253A:  BNZ   2570
....................    res -= 1.0; 
0253C:  BSF    FD8.1
0253E:  MOVFF  7DB,7E6
02542:  MOVFF  7DA,7E5
02546:  MOVFF  7D9,7E4
0254A:  MOVFF  7D8,7E3
0254E:  CLRF   xEA
02550:  CLRF   xE9
02552:  CLRF   xE8
02554:  MOVLW  7F
02556:  MOVWF  xE7
02558:  MOVLB  0
0255A:  CALL   1CE0
0255E:  MOVFF  03,7DB
02562:  MOVFF  02,7DA
02566:  MOVFF  01,7D9
0256A:  MOVFF  00,7D8
0256E:  MOVLB  7
....................  
....................   if (s == 0 && n == 1) 
02570:  BTFSC  xDE.0
02572:  BRA    25AC
02574:  DECFSZ xD3,W
02576:  BRA    25AC
....................    res += 1.0; 
02578:  BCF    FD8.1
0257A:  MOVFF  7DB,7E6
0257E:  MOVFF  7DA,7E5
02582:  MOVFF  7D9,7E4
02586:  MOVFF  7D8,7E3
0258A:  CLRF   xEA
0258C:  CLRF   xE9
0258E:  CLRF   xE8
02590:  MOVLW  7F
02592:  MOVWF  xE7
02594:  MOVLB  0
02596:  CALL   1CE0
0259A:  MOVFF  03,7DB
0259E:  MOVFF  02,7DA
025A2:  MOVFF  01,7D9
025A6:  MOVFF  00,7D8
025AA:  MOVLB  7
....................  } 
....................  if (x == 0) 
025AC:  MOVFF  7D2,7E2
025B0:  MOVFF  7D1,7E1
025B4:  MOVFF  7D0,7E0
025B8:  MOVFF  7CF,7DF
025BC:  CLRF   xE6
025BE:  CLRF   xE5
025C0:  CLRF   xE4
025C2:  CLRF   xE3
025C4:  MOVLB  0
025C6:  RCALL  21E2
025C8:  BNZ   25D6
....................     res = 0; 
025CA:  MOVLB  7
025CC:  CLRF   xDB
025CE:  CLRF   xDA
025D0:  CLRF   xD9
025D2:  CLRF   xD8
025D4:  MOVLB  0
....................  
....................  return (res); 
025D6:  MOVFF  7D8,00
025DA:  MOVFF  7D9,01
025DE:  MOVFF  7DA,02
025E2:  MOVFF  7DB,03
025E6:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
02606:  MOVFF  7CE,7D2
0260A:  MOVFF  7CD,7D1
0260E:  MOVFF  7CC,7D0
02612:  MOVFF  7CB,7CF
02616:  MOVLB  7
02618:  CLRF   xD3
0261A:  MOVLB  0
0261C:  RCALL  2298
0261E:  GOTO   2720 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
025E8:  MOVFF  7CE,7D2
025EC:  MOVFF  7CD,7D1
025F0:  MOVFF  7CC,7D0
025F4:  MOVFF  7CB,7CF
025F8:  MOVLW  01
025FA:  MOVLB  7
025FC:  MOVWF  xD3
025FE:  MOVLB  0
02600:  RCALL  2298
02602:  GOTO   26DA (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
02622:  MOVFF  7C2,7E2
02626:  MOVFF  7C1,7E1
0262A:  MOVFF  7C0,7E0
0262E:  MOVFF  7BF,7DF
02632:  MOVLB  7
02634:  CLRF   xE6
02636:  CLRF   xE5
02638:  CLRF   xE4
0263A:  CLRF   xE3
0263C:  MOVLB  0
0263E:  RCALL  21E2
02640:  BTFSC  FD8.2
02642:  BRA    277A
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
02644:  MOVFF  7BE,7DB
02648:  MOVFF  7BD,7DA
0264C:  MOVFF  7BC,7D9
02650:  MOVFF  7BB,7D8
02654:  MOVFF  7C2,7DF
02658:  MOVFF  7C1,7DE
0265C:  MOVFF  7C0,7DD
02660:  MOVFF  7BF,7DC
02664:  RCALL  1F58
02666:  MOVFF  03,7CA
0266A:  MOVFF  02,7C9
0266E:  MOVFF  01,7C8
02672:  MOVFF  00,7C7
02676:  MOVFF  03,7E2
0267A:  MOVFF  02,7E1
0267E:  MOVFF  01,7E0
02682:  MOVFF  00,7DF
02686:  MOVLB  7
02688:  CLRF   xE6
0268A:  CLRF   xE5
0268C:  CLRF   xE4
0268E:  CLRF   xE3
02690:  MOVLB  0
02692:  RCALL  21E2
02694:  BNC   26DC
02696:  MOVFF  7BE,7DB
0269A:  MOVFF  7BD,7DA
0269E:  MOVFF  7BC,7D9
026A2:  MOVFF  7BB,7D8
026A6:  MOVFF  7C2,7DF
026AA:  MOVFF  7C1,7DE
026AE:  MOVFF  7C0,7DD
026B2:  MOVFF  7BF,7DC
026B6:  RCALL  1F58
026B8:  MOVFF  03,7CA
026BC:  MOVFF  02,7C9
026C0:  MOVFF  01,7C8
026C4:  MOVFF  00,7C7
026C8:  MOVFF  03,7CE
026CC:  MOVFF  02,7CD
026D0:  MOVFF  01,7CC
026D4:  MOVFF  00,7CB
026D8:  BRA    25E8
026DA:  BRA    2720
026DC:  MOVFF  7BE,7DB
026E0:  MOVFF  7BD,7DA
026E4:  MOVFF  7BC,7D9
026E8:  MOVFF  7BB,7D8
026EC:  MOVFF  7C2,7DF
026F0:  MOVFF  7C1,7DE
026F4:  MOVFF  7C0,7DD
026F8:  MOVFF  7BF,7DC
026FC:  RCALL  1F58
026FE:  MOVFF  03,7CA
02702:  MOVFF  02,7C9
02706:  MOVFF  01,7C8
0270A:  MOVFF  00,7C7
0270E:  MOVFF  03,7CE
02712:  MOVFF  02,7CD
02716:  MOVFF  01,7CC
0271A:  MOVFF  00,7CB
0271E:  BRA    2606
02720:  MOVFF  03,7C6
02724:  MOVFF  02,7C5
02728:  MOVFF  01,7C4
0272C:  MOVFF  00,7C3
....................       return(x-(i*y)); 
02730:  MOVFF  7C6,7E2
02734:  MOVFF  7C5,7E1
02738:  MOVFF  7C4,7E0
0273C:  MOVFF  7C3,7DF
02740:  MOVFF  7C2,7E6
02744:  MOVFF  7C1,7E5
02748:  MOVFF  7C0,7E4
0274C:  MOVFF  7BF,7E3
02750:  RCALL  20B6
02752:  BSF    FD8.1
02754:  MOVFF  7BE,7E6
02758:  MOVFF  7BD,7E5
0275C:  MOVFF  7BC,7E4
02760:  MOVFF  7BB,7E3
02764:  MOVFF  03,7EA
02768:  MOVFF  02,7E9
0276C:  MOVFF  01,7E8
02770:  MOVFF  00,7E7
02774:  CALL   1CE0
02778:  BRA    277A
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0277A:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
*
02B5A:  MOVFF  7C2,7E2
02B5E:  MOVFF  7C1,7E1
02B62:  MOVFF  7C0,7E0
02B66:  MOVFF  7BF,7DF
02B6A:  MOVLW  3B
02B6C:  MOVLB  7
02B6E:  MOVWF  xE6
02B70:  MOVLW  AA
02B72:  MOVWF  xE5
02B74:  MOVLW  38
02B76:  MOVWF  xE4
02B78:  MOVLW  7F
02B7A:  MOVWF  xE3
02B7C:  MOVLB  0
02B7E:  CALL   20B6
02B82:  MOVFF  03,7E2
02B86:  MOVFF  02,7E1
02B8A:  MOVFF  01,7E0
02B8E:  MOVFF  00,7DF
02B92:  CALL   225C
02B96:  MOVFF  01,7CF
....................    s = 0; 
02B9A:  MOVLB  7
02B9C:  BCF    xD0.0
....................    y = x; 
02B9E:  MOVFF  7C2,7C6
02BA2:  MOVFF  7C1,7C5
02BA6:  MOVFF  7C0,7C4
02BAA:  MOVFF  7BF,7C3
....................  
....................    if (x < 0) 
02BAE:  MOVFF  7C2,7E2
02BB2:  MOVFF  7C1,7E1
02BB6:  MOVFF  7C0,7E0
02BBA:  MOVFF  7BF,7DF
02BBE:  CLRF   xE6
02BC0:  CLRF   xE5
02BC2:  CLRF   xE4
02BC4:  CLRF   xE3
02BC6:  MOVLB  0
02BC8:  CALL   21E2
02BCC:  BNC   2BDC
....................    { 
....................       s = 1; 
02BCE:  MOVLB  7
02BD0:  BSF    xD0.0
....................       n = -n; 
02BD2:  NEGF   xCF
....................       y = -y; 
02BD4:  MOVF   xC4,W
02BD6:  XORLW  80
02BD8:  MOVWF  xC4
02BDA:  MOVLB  0
....................    } 
....................  
....................    res = 0.0; 
02BDC:  MOVLB  7
02BDE:  CLRF   xCA
02BE0:  CLRF   xC9
02BE2:  CLRF   xC8
02BE4:  CLRF   xC7
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
02BE6:  MOVLW  07
02BE8:  MOVWF  xD2
02BEA:  MOVLW  C7
02BEC:  MOVWF  FE9
02BEE:  MOVFF  7D2,FEA
02BF2:  MOVLW  7F
02BF4:  ADDWF  xCF,W
02BF6:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
02BF8:  MOVFF  7C6,7E2
02BFC:  MOVFF  7C5,7E1
02C00:  MOVFF  7C4,7E0
02C04:  MOVFF  7C3,7DF
02C08:  MOVLW  3B
02C0A:  MOVWF  xE6
02C0C:  MOVLW  AA
02C0E:  MOVWF  xE5
02C10:  MOVLW  38
02C12:  MOVWF  xE4
02C14:  MOVLW  7F
02C16:  MOVWF  xE3
02C18:  MOVLB  0
02C1A:  CALL   20B6
02C1E:  MOVFF  03,7D4
02C22:  MOVFF  02,7D3
02C26:  MOVFF  01,7D2
02C2A:  MOVFF  00,7D1
02C2E:  MOVLB  7
02C30:  CLRF   xD6
02C32:  MOVFF  7CF,7D5
02C36:  BTFSC  xD5.7
02C38:  DECF   xD6,F
02C3A:  MOVLB  0
02C3C:  RCALL  277C
02C3E:  BSF    FD8.1
02C40:  MOVFF  7D4,7E6
02C44:  MOVFF  7D3,7E5
02C48:  MOVFF  7D2,7E4
02C4C:  MOVFF  7D1,7E3
02C50:  MOVFF  03,7EA
02C54:  MOVFF  02,7E9
02C58:  MOVFF  01,7E8
02C5C:  MOVFF  00,7E7
02C60:  CALL   1CE0
02C64:  MOVFF  03,7C6
02C68:  MOVFF  02,7C5
02C6C:  MOVFF  01,7C4
02C70:  MOVFF  00,7C3
....................  
....................    r = pe[0]*y + pe[1]; 
02C74:  MOVLW  7C
02C76:  MOVLB  7
02C78:  MOVWF  xE2
02C7A:  MOVLW  88
02C7C:  MOVWF  xE1
02C7E:  MOVLW  59
02C80:  MOVWF  xE0
02C82:  MOVLW  72
02C84:  MOVWF  xDF
02C86:  MOVFF  7C6,7E6
02C8A:  MOVFF  7C5,7E5
02C8E:  MOVFF  7C4,7E4
02C92:  MOVFF  7C3,7E3
02C96:  MOVLB  0
02C98:  CALL   20B6
02C9C:  MOVFF  03,7D4
02CA0:  MOVFF  02,7D3
02CA4:  MOVFF  01,7D2
02CA8:  MOVFF  00,7D1
02CAC:  BCF    FD8.1
02CAE:  MOVFF  03,7E6
02CB2:  MOVFF  02,7E5
02CB6:  MOVFF  01,7E4
02CBA:  MOVFF  00,7E3
02CBE:  MOVLW  E0
02CC0:  MOVLB  7
02CC2:  MOVWF  xEA
02CC4:  MOVLW  97
02CC6:  MOVWF  xE9
02CC8:  MOVLW  26
02CCA:  MOVWF  xE8
02CCC:  MOVLW  75
02CCE:  MOVWF  xE7
02CD0:  MOVLB  0
02CD2:  CALL   1CE0
02CD6:  MOVFF  03,7CE
02CDA:  MOVFF  02,7CD
02CDE:  MOVFF  01,7CC
02CE2:  MOVFF  00,7CB
....................    r = r*y + pe[2]; 
02CE6:  MOVFF  7CE,7E2
02CEA:  MOVFF  7CD,7E1
02CEE:  MOVFF  7CC,7E0
02CF2:  MOVFF  7CB,7DF
02CF6:  MOVFF  7C6,7E6
02CFA:  MOVFF  7C5,7E5
02CFE:  MOVFF  7C4,7E4
02D02:  MOVFF  7C3,7E3
02D06:  CALL   20B6
02D0A:  MOVFF  03,7D4
02D0E:  MOVFF  02,7D3
02D12:  MOVFF  01,7D2
02D16:  MOVFF  00,7D1
02D1A:  BCF    FD8.1
02D1C:  MOVFF  03,7E6
02D20:  MOVFF  02,7E5
02D24:  MOVFF  01,7E4
02D28:  MOVFF  00,7E3
02D2C:  MOVLW  C4
02D2E:  MOVLB  7
02D30:  MOVWF  xEA
02D32:  MOVLW  1D
02D34:  MOVWF  xE9
02D36:  MOVLW  1E
02D38:  MOVWF  xE8
02D3A:  MOVLW  78
02D3C:  MOVWF  xE7
02D3E:  MOVLB  0
02D40:  CALL   1CE0
02D44:  MOVFF  03,7CE
02D48:  MOVFF  02,7CD
02D4C:  MOVFF  01,7CC
02D50:  MOVFF  00,7CB
....................    r = r*y + pe[3]; 
02D54:  MOVFF  7CE,7E2
02D58:  MOVFF  7CD,7E1
02D5C:  MOVFF  7CC,7E0
02D60:  MOVFF  7CB,7DF
02D64:  MOVFF  7C6,7E6
02D68:  MOVFF  7C5,7E5
02D6C:  MOVFF  7C4,7E4
02D70:  MOVFF  7C3,7E3
02D74:  CALL   20B6
02D78:  MOVFF  03,7D4
02D7C:  MOVFF  02,7D3
02D80:  MOVFF  01,7D2
02D84:  MOVFF  00,7D1
02D88:  BCF    FD8.1
02D8A:  MOVFF  03,7E6
02D8E:  MOVFF  02,7E5
02D92:  MOVFF  01,7E4
02D96:  MOVFF  00,7E3
02D9A:  MOVLW  5E
02D9C:  MOVLB  7
02D9E:  MOVWF  xEA
02DA0:  MOVLW  50
02DA2:  MOVWF  xE9
02DA4:  MOVLW  63
02DA6:  MOVWF  xE8
02DA8:  MOVLW  7A
02DAA:  MOVWF  xE7
02DAC:  MOVLB  0
02DAE:  CALL   1CE0
02DB2:  MOVFF  03,7CE
02DB6:  MOVFF  02,7CD
02DBA:  MOVFF  01,7CC
02DBE:  MOVFF  00,7CB
....................    r = r*y + pe[4]; 
02DC2:  MOVFF  7CE,7E2
02DC6:  MOVFF  7CD,7E1
02DCA:  MOVFF  7CC,7E0
02DCE:  MOVFF  7CB,7DF
02DD2:  MOVFF  7C6,7E6
02DD6:  MOVFF  7C5,7E5
02DDA:  MOVFF  7C4,7E4
02DDE:  MOVFF  7C3,7E3
02DE2:  CALL   20B6
02DE6:  MOVFF  03,7D4
02DEA:  MOVFF  02,7D3
02DEE:  MOVFF  01,7D2
02DF2:  MOVFF  00,7D1
02DF6:  BCF    FD8.1
02DF8:  MOVFF  03,7E6
02DFC:  MOVFF  02,7E5
02E00:  MOVFF  01,7E4
02E04:  MOVFF  00,7E3
02E08:  MOVLW  1A
02E0A:  MOVLB  7
02E0C:  MOVWF  xEA
02E0E:  MOVLW  FE
02E10:  MOVWF  xE9
02E12:  MOVLW  75
02E14:  MOVWF  xE8
02E16:  MOVLW  7C
02E18:  MOVWF  xE7
02E1A:  MOVLB  0
02E1C:  CALL   1CE0
02E20:  MOVFF  03,7CE
02E24:  MOVFF  02,7CD
02E28:  MOVFF  01,7CC
02E2C:  MOVFF  00,7CB
....................    r = r*y + pe[5]; 
02E30:  MOVFF  7CE,7E2
02E34:  MOVFF  7CD,7E1
02E38:  MOVFF  7CC,7E0
02E3C:  MOVFF  7CB,7DF
02E40:  MOVFF  7C6,7E6
02E44:  MOVFF  7C5,7E5
02E48:  MOVFF  7C4,7E4
02E4C:  MOVFF  7C3,7E3
02E50:  CALL   20B6
02E54:  MOVFF  03,7D4
02E58:  MOVFF  02,7D3
02E5C:  MOVFF  01,7D2
02E60:  MOVFF  00,7D1
02E64:  BCF    FD8.1
02E66:  MOVFF  03,7E6
02E6A:  MOVFF  02,7E5
02E6E:  MOVFF  01,7E4
02E72:  MOVFF  00,7E3
02E76:  MOVLW  18
02E78:  MOVLB  7
02E7A:  MOVWF  xEA
02E7C:  MOVLW  72
02E7E:  MOVWF  xE9
02E80:  MOVLW  31
02E82:  MOVWF  xE8
02E84:  MOVLW  7E
02E86:  MOVWF  xE7
02E88:  MOVLB  0
02E8A:  CALL   1CE0
02E8E:  MOVFF  03,7CE
02E92:  MOVFF  02,7CD
02E96:  MOVFF  01,7CC
02E9A:  MOVFF  00,7CB
....................  
....................    res = res*(1.0 + y*r); 
02E9E:  MOVFF  7C6,7E2
02EA2:  MOVFF  7C5,7E1
02EA6:  MOVFF  7C4,7E0
02EAA:  MOVFF  7C3,7DF
02EAE:  MOVFF  7CE,7E6
02EB2:  MOVFF  7CD,7E5
02EB6:  MOVFF  7CC,7E4
02EBA:  MOVFF  7CB,7E3
02EBE:  CALL   20B6
02EC2:  BCF    FD8.1
02EC4:  MOVLB  7
02EC6:  CLRF   xE6
02EC8:  CLRF   xE5
02ECA:  CLRF   xE4
02ECC:  MOVLW  7F
02ECE:  MOVWF  xE3
02ED0:  MOVFF  03,7EA
02ED4:  MOVFF  02,7E9
02ED8:  MOVFF  01,7E8
02EDC:  MOVFF  00,7E7
02EE0:  MOVLB  0
02EE2:  CALL   1CE0
02EE6:  MOVFF  7CA,7E2
02EEA:  MOVFF  7C9,7E1
02EEE:  MOVFF  7C8,7E0
02EF2:  MOVFF  7C7,7DF
02EF6:  MOVFF  03,7E6
02EFA:  MOVFF  02,7E5
02EFE:  MOVFF  01,7E4
02F02:  MOVFF  00,7E3
02F06:  CALL   20B6
02F0A:  MOVFF  03,7CA
02F0E:  MOVFF  02,7C9
02F12:  MOVFF  01,7C8
02F16:  MOVFF  00,7C7
....................  
....................    if (s) 
02F1A:  MOVLB  7
02F1C:  BTFSS  xD0.0
02F1E:  BRA    2F52
....................       res = 1.0/res; 
02F20:  CLRF   xDB
02F22:  CLRF   xDA
02F24:  CLRF   xD9
02F26:  MOVLW  7F
02F28:  MOVWF  xD8
02F2A:  MOVFF  7CA,7DF
02F2E:  MOVFF  7C9,7DE
02F32:  MOVFF  7C8,7DD
02F36:  MOVFF  7C7,7DC
02F3A:  MOVLB  0
02F3C:  CALL   1F58
02F40:  MOVFF  03,7CA
02F44:  MOVFF  02,7C9
02F48:  MOVFF  01,7C8
02F4C:  MOVFF  00,7C7
02F50:  MOVLB  7
....................    return(res); 
02F52:  MOVFF  7C7,00
02F56:  MOVFF  7C8,01
02F5A:  MOVFF  7C9,02
02F5E:  MOVFF  7CA,03
02F62:  MOVLB  0
02F64:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
027CC:  MOVFF  7C2,7C6
027D0:  MOVFF  7C1,7C5
027D4:  MOVFF  7C0,7C4
027D8:  MOVFF  7BF,7C3
....................  
....................    if (y != 1.0) 
027DC:  MOVFF  7C6,7E2
027E0:  MOVFF  7C5,7E1
027E4:  MOVFF  7C4,7E0
027E8:  MOVFF  7C3,7DF
027EC:  MOVLB  7
027EE:  CLRF   xE6
027F0:  CLRF   xE5
027F2:  CLRF   xE4
027F4:  MOVLW  7F
027F6:  MOVWF  xE3
027F8:  MOVLB  0
027FA:  RCALL  21E2
027FC:  BTFSC  FD8.2
027FE:  BRA    2B3C
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
02800:  MOVLW  07
02802:  MOVLB  7
02804:  MOVWF  xD5
02806:  MOVLW  C3
02808:  MOVWF  FE9
0280A:  MOVFF  7D5,FEA
0280E:  MOVLW  7E
02810:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
02812:  BSF    FD8.1
02814:  MOVFF  7C6,7E6
02818:  MOVFF  7C5,7E5
0281C:  MOVFF  7C4,7E4
02820:  MOVFF  7C3,7E3
02824:  CLRF   xEA
02826:  CLRF   xE9
02828:  CLRF   xE8
0282A:  MOVLW  7F
0282C:  MOVWF  xE7
0282E:  MOVLB  0
02830:  CALL   1CE0
02834:  MOVFF  03,7D7
02838:  MOVFF  02,7D6
0283C:  MOVFF  01,7D5
02840:  MOVFF  00,7D4
02844:  BCF    FD8.1
02846:  MOVFF  7C6,7E6
0284A:  MOVFF  7C5,7E5
0284E:  MOVFF  7C4,7E4
02852:  MOVFF  7C3,7E3
02856:  MOVLB  7
02858:  CLRF   xEA
0285A:  CLRF   xE9
0285C:  CLRF   xE8
0285E:  MOVLW  7F
02860:  MOVWF  xE7
02862:  MOVLB  0
02864:  CALL   1CE0
02868:  MOVFF  7D7,7DB
0286C:  MOVFF  7D6,7DA
02870:  MOVFF  7D5,7D9
02874:  MOVFF  7D4,7D8
02878:  MOVFF  03,7DF
0287C:  MOVFF  02,7DE
02880:  MOVFF  01,7DD
02884:  MOVFF  00,7DC
02888:  CALL   1F58
0288C:  MOVFF  03,7C6
02890:  MOVFF  02,7C5
02894:  MOVFF  01,7C4
02898:  MOVFF  00,7C3
....................  
....................       y2=y*y; 
0289C:  MOVFF  7C6,7E2
028A0:  MOVFF  7C5,7E1
028A4:  MOVFF  7C4,7E0
028A8:  MOVFF  7C3,7DF
028AC:  MOVFF  7C6,7E6
028B0:  MOVFF  7C5,7E5
028B4:  MOVFF  7C4,7E4
028B8:  MOVFF  7C3,7E3
028BC:  CALL   20B6
028C0:  MOVFF  03,7D2
028C4:  MOVFF  02,7D1
028C8:  MOVFF  01,7D0
028CC:  MOVFF  00,7CF
....................  
....................       res = pl[0]*y2 + pl[1]; 
028D0:  MOVLW  99
028D2:  MOVLB  7
028D4:  MOVWF  xE2
028D6:  MOVLW  47
028D8:  MOVWF  xE1
028DA:  MOVLW  8A
028DC:  MOVWF  xE0
028DE:  MOVLW  7F
028E0:  MOVWF  xDF
028E2:  MOVFF  7D2,7E6
028E6:  MOVFF  7D1,7E5
028EA:  MOVFF  7D0,7E4
028EE:  MOVFF  7CF,7E3
028F2:  MOVLB  0
028F4:  CALL   20B6
028F8:  MOVFF  03,7D7
028FC:  MOVFF  02,7D6
02900:  MOVFF  01,7D5
02904:  MOVFF  00,7D4
02908:  BCF    FD8.1
0290A:  MOVFF  03,7E6
0290E:  MOVFF  02,7E5
02912:  MOVFF  01,7E4
02916:  MOVFF  00,7E3
0291A:  MOVLB  7
0291C:  CLRF   xEA
0291E:  CLRF   xE9
02920:  CLRF   xE8
02922:  MOVLW  80
02924:  MOVWF  xE7
02926:  MOVLB  0
02928:  CALL   1CE0
0292C:  MOVFF  03,7CA
02930:  MOVFF  02,7C9
02934:  MOVFF  01,7C8
02938:  MOVFF  00,7C7
....................  
....................       r = ql[0]*y2 + ql[1]; 
0293C:  MOVLW  4C
0293E:  MOVLB  7
02940:  MOVWF  xE2
02942:  MOVLW  F3
02944:  MOVWF  xE1
02946:  MOVLW  3A
02948:  MOVWF  xE0
0294A:  MOVLW  7B
0294C:  MOVWF  xDF
0294E:  MOVFF  7D2,7E6
02952:  MOVFF  7D1,7E5
02956:  MOVFF  7D0,7E4
0295A:  MOVFF  7CF,7E3
0295E:  MOVLB  0
02960:  CALL   20B6
02964:  MOVFF  03,7D7
02968:  MOVFF  02,7D6
0296C:  MOVFF  01,7D5
02970:  MOVFF  00,7D4
02974:  BCF    FD8.1
02976:  MOVFF  03,7E6
0297A:  MOVFF  02,7E5
0297E:  MOVFF  01,7E4
02982:  MOVFF  00,7E3
02986:  MOVLW  2B
02988:  MOVLB  7
0298A:  MOVWF  xEA
0298C:  MOVLW  9D
0298E:  MOVWF  xE9
02990:  MOVLW  DF
02992:  MOVWF  xE8
02994:  MOVLW  7E
02996:  MOVWF  xE7
02998:  MOVLB  0
0299A:  CALL   1CE0
0299E:  MOVFF  03,7CE
029A2:  MOVFF  02,7CD
029A6:  MOVFF  01,7CC
029AA:  MOVFF  00,7CB
....................       r = r*y2 + 1.0; 
029AE:  MOVFF  7CE,7E2
029B2:  MOVFF  7CD,7E1
029B6:  MOVFF  7CC,7E0
029BA:  MOVFF  7CB,7DF
029BE:  MOVFF  7D2,7E6
029C2:  MOVFF  7D1,7E5
029C6:  MOVFF  7D0,7E4
029CA:  MOVFF  7CF,7E3
029CE:  CALL   20B6
029D2:  MOVFF  03,7D7
029D6:  MOVFF  02,7D6
029DA:  MOVFF  01,7D5
029DE:  MOVFF  00,7D4
029E2:  BCF    FD8.1
029E4:  MOVFF  03,7E6
029E8:  MOVFF  02,7E5
029EC:  MOVFF  01,7E4
029F0:  MOVFF  00,7E3
029F4:  MOVLB  7
029F6:  CLRF   xEA
029F8:  CLRF   xE9
029FA:  CLRF   xE8
029FC:  MOVLW  7F
029FE:  MOVWF  xE7
02A00:  MOVLB  0
02A02:  CALL   1CE0
02A06:  MOVFF  03,7CE
02A0A:  MOVFF  02,7CD
02A0E:  MOVFF  01,7CC
02A12:  MOVFF  00,7CB
....................  
....................       res = y*res/r; 
02A16:  MOVFF  7C6,7E2
02A1A:  MOVFF  7C5,7E1
02A1E:  MOVFF  7C4,7E0
02A22:  MOVFF  7C3,7DF
02A26:  MOVFF  7CA,7E6
02A2A:  MOVFF  7C9,7E5
02A2E:  MOVFF  7C8,7E4
02A32:  MOVFF  7C7,7E3
02A36:  CALL   20B6
02A3A:  MOVFF  03,7D7
02A3E:  MOVFF  02,7D6
02A42:  MOVFF  01,7D5
02A46:  MOVFF  00,7D4
02A4A:  MOVFF  03,7DB
02A4E:  MOVFF  02,7DA
02A52:  MOVFF  01,7D9
02A56:  MOVFF  00,7D8
02A5A:  MOVFF  7CE,7DF
02A5E:  MOVFF  7CD,7DE
02A62:  MOVFF  7CC,7DD
02A66:  MOVFF  7CB,7DC
02A6A:  CALL   1F58
02A6E:  MOVFF  03,7CA
02A72:  MOVFF  02,7C9
02A76:  MOVFF  01,7C8
02A7A:  MOVFF  00,7C7
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
02A7E:  MOVLW  07
02A80:  MOVLB  7
02A82:  MOVWF  xD5
02A84:  MOVLW  BF
02A86:  MOVWF  FE9
02A88:  MOVFF  7D5,FEA
02A8C:  MOVLW  7E
02A8E:  SUBWF  FEF,W
02A90:  MOVWF  xD3
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
02A92:  BTFSS  xD3.7
02A94:  BRA    2ABE
....................          r = -(float32)-n; 
02A96:  MOVLW  00
02A98:  BSF    FD8.0
02A9A:  SUBFWB xD3,W
02A9C:  CLRF   xD6
02A9E:  MOVWF  xD5
02AA0:  BTFSC  xD5.7
02AA2:  DECF   xD6,F
02AA4:  MOVLB  0
02AA6:  RCALL  277C
02AA8:  MOVFF  00,7CB
02AAC:  MOVF   01,W
02AAE:  XORLW  80
02AB0:  MOVLB  7
02AB2:  MOVWF  xCC
02AB4:  MOVFF  02,7CD
02AB8:  MOVFF  03,7CE
02ABC:  BRA    2ADE
....................       else 
....................          r = (float32)n; 
02ABE:  CLRF   xD6
02AC0:  MOVFF  7D3,7D5
02AC4:  BTFSC  xD5.7
02AC6:  DECF   xD6,F
02AC8:  MOVLB  0
02ACA:  RCALL  277C
02ACC:  MOVFF  03,7CE
02AD0:  MOVFF  02,7CD
02AD4:  MOVFF  01,7CC
02AD8:  MOVFF  00,7CB
02ADC:  MOVLB  7
....................  
....................       res += r*LN2; 
02ADE:  MOVFF  7CE,7E2
02AE2:  MOVFF  7CD,7E1
02AE6:  MOVFF  7CC,7E0
02AEA:  MOVFF  7CB,7DF
02AEE:  MOVLW  18
02AF0:  MOVWF  xE6
02AF2:  MOVLW  72
02AF4:  MOVWF  xE5
02AF6:  MOVLW  31
02AF8:  MOVWF  xE4
02AFA:  MOVLW  7E
02AFC:  MOVWF  xE3
02AFE:  MOVLB  0
02B00:  CALL   20B6
02B04:  BCF    FD8.1
02B06:  MOVFF  7CA,7E6
02B0A:  MOVFF  7C9,7E5
02B0E:  MOVFF  7C8,7E4
02B12:  MOVFF  7C7,7E3
02B16:  MOVFF  03,7EA
02B1A:  MOVFF  02,7E9
02B1E:  MOVFF  01,7E8
02B22:  MOVFF  00,7E7
02B26:  CALL   1CE0
02B2A:  MOVFF  03,7CA
02B2E:  MOVFF  02,7C9
02B32:  MOVFF  01,7C8
02B36:  MOVFF  00,7C7
....................    } 
02B3A:  BRA    2B48
....................  
....................    else 
....................       res = 0.0; 
02B3C:  MOVLB  7
02B3E:  CLRF   xCA
02B40:  CLRF   xC9
02B42:  CLRF   xC8
02B44:  CLRF   xC7
02B46:  MOVLB  0
....................  
....................    return(res); 
02B48:  MOVFF  7C7,00
02B4C:  MOVFF  7C8,01
02B50:  MOVFF  7C9,02
02B54:  MOVFF  7CA,03
02B58:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
02F66:  MOVFF  7B6,7E2
02F6A:  MOVFF  7B5,7E1
02F6E:  MOVFF  7B4,7E0
02F72:  MOVFF  7B3,7DF
02F76:  MOVLB  7
02F78:  CLRF   xE6
02F7A:  CLRF   xE5
02F7C:  CLRF   xE4
02F7E:  CLRF   xE3
02F80:  MOVLB  0
02F82:  CALL   21E2
02F86:  BTFSS  FD8.0
02F88:  BRA    313C
02F8A:  MOVFF  7BA,7BE
02F8E:  MOVFF  7B9,7BD
02F92:  MOVFF  7B8,7BC
02F96:  MOVFF  7B7,7BB
02F9A:  MOVLB  7
02F9C:  CLRF   xC2
02F9E:  CLRF   xC1
02FA0:  CLRF   xC0
02FA2:  MOVLW  7F
02FA4:  MOVWF  xBF
02FA6:  MOVLB  0
02FA8:  CALL   2622
02FAC:  MOVFF  03,7BE
02FB0:  MOVFF  02,7BD
02FB4:  MOVFF  01,7BC
02FB8:  MOVFF  00,7BB
02FBC:  MOVFF  03,7E2
02FC0:  MOVFF  02,7E1
02FC4:  MOVFF  01,7E0
02FC8:  MOVFF  00,7DF
02FCC:  MOVLB  7
02FCE:  CLRF   xE6
02FD0:  CLRF   xE5
02FD2:  CLRF   xE4
02FD4:  CLRF   xE3
02FD6:  MOVLB  0
02FD8:  CALL   21E2
02FDC:  BTFSS  FD8.2
02FDE:  BRA    313C
....................       if(fmod(y, 2) == 0) { 
02FE0:  MOVFF  7BA,7BE
02FE4:  MOVFF  7B9,7BD
02FE8:  MOVFF  7B8,7BC
02FEC:  MOVFF  7B7,7BB
02FF0:  MOVLB  7
02FF2:  CLRF   xC2
02FF4:  CLRF   xC1
02FF6:  CLRF   xC0
02FF8:  MOVLW  80
02FFA:  MOVWF  xBF
02FFC:  MOVLB  0
02FFE:  CALL   2622
03002:  MOVFF  03,7BE
03006:  MOVFF  02,7BD
0300A:  MOVFF  01,7BC
0300E:  MOVFF  00,7BB
03012:  MOVFF  03,7E2
03016:  MOVFF  02,7E1
0301A:  MOVFF  01,7E0
0301E:  MOVFF  00,7DF
03022:  MOVLB  7
03024:  CLRF   xE6
03026:  CLRF   xE5
03028:  CLRF   xE4
0302A:  CLRF   xE3
0302C:  MOVLB  0
0302E:  CALL   21E2
03032:  BNZ   30B6
....................          return (exp(log(-x) * y)); 
03034:  MOVFF  7B3,7BB
03038:  MOVLB  7
0303A:  MOVF   xB4,W
0303C:  XORLW  80
0303E:  MOVWF  xBC
03040:  MOVFF  7B5,7BD
03044:  MOVFF  7B6,7BE
03048:  MOVFF  7B6,7C2
0304C:  MOVFF  7B5,7C1
03050:  MOVWF  xC0
03052:  MOVFF  7B3,7BF
03056:  MOVLB  0
03058:  CALL   27CC
0305C:  MOVFF  03,7BE
03060:  MOVFF  02,7BD
03064:  MOVFF  01,7BC
03068:  MOVFF  00,7BB
0306C:  MOVFF  03,7E2
03070:  MOVFF  02,7E1
03074:  MOVFF  01,7E0
03078:  MOVFF  00,7DF
0307C:  MOVFF  7BA,7E6
03080:  MOVFF  7B9,7E5
03084:  MOVFF  7B8,7E4
03088:  MOVFF  7B7,7E3
0308C:  CALL   20B6
03090:  MOVFF  03,7BE
03094:  MOVFF  02,7BD
03098:  MOVFF  01,7BC
0309C:  MOVFF  00,7BB
030A0:  MOVFF  03,7C2
030A4:  MOVFF  02,7C1
030A8:  MOVFF  01,7C0
030AC:  MOVFF  00,7BF
030B0:  RCALL  2B5A
030B2:  BRA    327A
....................       } else { 
030B4:  BRA    313A
....................          return (-exp(log(-x) * y)); 
030B6:  MOVFF  7B3,7BB
030BA:  MOVLB  7
030BC:  MOVF   xB4,W
030BE:  XORLW  80
030C0:  MOVWF  xBC
030C2:  MOVFF  7B5,7BD
030C6:  MOVFF  7B6,7BE
030CA:  MOVFF  7B6,7C2
030CE:  MOVFF  7B5,7C1
030D2:  MOVWF  xC0
030D4:  MOVFF  7B3,7BF
030D8:  MOVLB  0
030DA:  CALL   27CC
030DE:  MOVFF  03,7BE
030E2:  MOVFF  02,7BD
030E6:  MOVFF  01,7BC
030EA:  MOVFF  00,7BB
030EE:  MOVFF  03,7E2
030F2:  MOVFF  02,7E1
030F6:  MOVFF  01,7E0
030FA:  MOVFF  00,7DF
030FE:  MOVFF  7BA,7E6
03102:  MOVFF  7B9,7E5
03106:  MOVFF  7B8,7E4
0310A:  MOVFF  7B7,7E3
0310E:  CALL   20B6
03112:  MOVFF  03,7BE
03116:  MOVFF  02,7BD
0311A:  MOVFF  01,7BC
0311E:  MOVFF  00,7BB
03122:  MOVFF  03,7C2
03126:  MOVFF  02,7C1
0312A:  MOVFF  01,7C0
0312E:  MOVFF  00,7BF
03132:  RCALL  2B5A
03134:  MOVLW  80
03136:  XORWF  01,F
03138:  BRA    327A
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
0313A:  BRA    327A
0313C:  MOVFF  7B6,7E2
03140:  MOVFF  7B5,7E1
03144:  MOVFF  7B4,7E0
03148:  MOVFF  7B3,7DF
0314C:  MOVLB  7
0314E:  CLRF   xE6
03150:  CLRF   xE5
03152:  CLRF   xE4
03154:  CLRF   xE3
03156:  MOVLB  0
03158:  CALL   21E2
0315C:  BNC   31BE
0315E:  MOVFF  7BA,7BE
03162:  MOVFF  7B9,7BD
03166:  MOVFF  7B8,7BC
0316A:  MOVFF  7B7,7BB
0316E:  MOVLB  7
03170:  CLRF   xC2
03172:  CLRF   xC1
03174:  CLRF   xC0
03176:  MOVLW  7F
03178:  MOVWF  xBF
0317A:  MOVLB  0
0317C:  CALL   2622
03180:  MOVFF  03,7BE
03184:  MOVFF  02,7BD
03188:  MOVFF  01,7BC
0318C:  MOVFF  00,7BB
03190:  MOVFF  03,7E2
03194:  MOVFF  02,7E1
03198:  MOVFF  01,7E0
0319C:  MOVFF  00,7DF
031A0:  MOVLB  7
031A2:  CLRF   xE6
031A4:  CLRF   xE5
031A6:  CLRF   xE4
031A8:  CLRF   xE3
031AA:  MOVLB  0
031AC:  CALL   21E2
031B0:  BZ    31BE
....................       return 0; 
031B2:  CLRF   00
031B4:  CLRF   01
031B6:  CLRF   02
031B8:  CLRF   03
031BA:  BRA    327A
....................    } else { 
031BC:  BRA    327A
....................       if(x != 0 || 0 >= y) { 
031BE:  MOVFF  7B6,7E2
031C2:  MOVFF  7B5,7E1
031C6:  MOVFF  7B4,7E0
031CA:  MOVFF  7B3,7DF
031CE:  MOVLB  7
031D0:  CLRF   xE6
031D2:  CLRF   xE5
031D4:  CLRF   xE4
031D6:  CLRF   xE3
031D8:  MOVLB  0
031DA:  CALL   21E2
031DE:  BNZ   3204
031E0:  MOVFF  7BA,7E2
031E4:  MOVFF  7B9,7E1
031E8:  MOVFF  7B8,7E0
031EC:  MOVFF  7B7,7DF
031F0:  MOVLB  7
031F2:  CLRF   xE6
031F4:  CLRF   xE5
031F6:  CLRF   xE4
031F8:  CLRF   xE3
031FA:  MOVLB  0
031FC:  CALL   21E2
03200:  BC    3204
03202:  BNZ   3272
....................          return (exp(log(x) * y)); 
03204:  MOVFF  7B6,7C2
03208:  MOVFF  7B5,7C1
0320C:  MOVFF  7B4,7C0
03210:  MOVFF  7B3,7BF
03214:  CALL   27CC
03218:  MOVFF  03,7BE
0321C:  MOVFF  02,7BD
03220:  MOVFF  01,7BC
03224:  MOVFF  00,7BB
03228:  MOVFF  03,7E2
0322C:  MOVFF  02,7E1
03230:  MOVFF  01,7E0
03234:  MOVFF  00,7DF
03238:  MOVFF  7BA,7E6
0323C:  MOVFF  7B9,7E5
03240:  MOVFF  7B8,7E4
03244:  MOVFF  7B7,7E3
03248:  CALL   20B6
0324C:  MOVFF  03,7BE
03250:  MOVFF  02,7BD
03254:  MOVFF  01,7BC
03258:  MOVFF  00,7BB
0325C:  MOVFF  03,7C2
03260:  MOVFF  02,7C1
03264:  MOVFF  01,7C0
03268:  MOVFF  00,7BF
0326C:  RCALL  2B5A
0326E:  BRA    327A
....................       } else return 0; 
03270:  BRA    327A
03272:  CLRF   00
03274:  CLRF   01
03276:  CLRF   02
03278:  CLRF   03
....................    } 
0327A:  GOTO   3D2C (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <STDIO.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #define SDAPIN PIN_B0 
.................... #define SCLPIN PIN_B1 
....................  
.................... #define SENSORBOARDA PIN_B5 
.................... #define SENSORBOARDB PIN_B4 
....................  
.................... #define TESTER 1 
.................... #define NOTOSMOBOT 1 
.................... #define ADCREZ 1024 
.................... #define OSMOBOT 0    // this not the main board, but the programmer 
.................... #define TIRHTEMP 1 
.................... char adcBuff[20]; 
.................... char bt_cmd[50]; // buffer where the command is kept for parsing.  Added July 10, 2015 
.................... char rec_buffer[65]; 
.................... unsigned int16 reading[128];  // this is the linear array 
.................... unsigned int8 streamCntr = 0; 
.................... unsigned int8 dispCntr = 0; 
.................... int1 writeReady = 0; 
.................... unsigned int8 xCntr = 0; 
.................... unsigned int8 yCntr = 0; 
.................... unsigned int16 stufftocheck; 
....................  
.................... #fuses  NOWDT, NOLVP, NOBROWNOUT, NOPROTECT, PUT  
.................... #use delay(crystal=20000000, clock=20000000) 
*
011F0:  MOVLW  07
011F2:  MOVWF  FEA
011F4:  MOVLW  C1
011F6:  MOVWF  FE9
011F8:  MOVF   FEF,W
011FA:  BZ    1216
011FC:  MOVLW  06
011FE:  MOVWF  01
01200:  CLRF   00
01202:  DECFSZ 00,F
01204:  BRA    1202
01206:  DECFSZ 01,F
01208:  BRA    1200
0120A:  MOVLW  7B
0120C:  MOVWF  00
0120E:  DECFSZ 00,F
01210:  BRA    120E
01212:  DECFSZ FEF,F
01214:  BRA    11FC
01216:  RETURN 0
....................  
....................  
.................... #use i2c(stream=PH_LIGHT, MASTER, sda=SDAPIN, scl=SCLPIN, fast=10000)    // this is the master I2c for talking with removote sensor boards.  There is only one I2c on this chip. 
*
0363A:  MOVLW  08
0363C:  MOVWF  01
0363E:  MOVLW  50
03640:  MOVWF  00
03642:  DECFSZ 00,F
03644:  BRA    3642
03646:  BCF    F8A.1
03648:  BCF    F93.1
0364A:  MOVLW  51
0364C:  MOVWF  00
0364E:  DECFSZ 00,F
03650:  BRA    364E
03652:  MOVLB  7
03654:  RLCF   xB4,F
03656:  BCF    F8A.0
03658:  BTFSC  FD8.0
0365A:  BSF    F93.0
0365C:  BTFSS  FD8.0
0365E:  BCF    F93.0
03660:  BSF    F93.1
03662:  BTFSS  F81.1
03664:  BRA    3662
03666:  DECFSZ 01,F
03668:  BRA    366C
0366A:  BRA    3670
0366C:  MOVLB  0
0366E:  BRA    363E
03670:  MOVLW  50
03672:  MOVWF  00
03674:  DECFSZ 00,F
03676:  BRA    3674
03678:  BCF    F8A.1
0367A:  BCF    F93.1
0367C:  NOP   
0367E:  BSF    F93.0
03680:  MOVLW  51
03682:  MOVWF  00
03684:  DECFSZ 00,F
03686:  BRA    3684
03688:  MOVLW  51
0368A:  MOVWF  00
0368C:  DECFSZ 00,F
0368E:  BRA    368C
03690:  BSF    F93.1
03692:  BTFSS  F81.1
03694:  BRA    3692
03696:  CLRF   01
03698:  MOVLW  51
0369A:  MOVWF  00
0369C:  DECFSZ 00,F
0369E:  BRA    369C
036A0:  BTFSC  F81.0
036A2:  BSF    01.0
036A4:  BCF    F8A.1
036A6:  BCF    F93.1
036A8:  BCF    F8A.0
036AA:  BCF    F93.0
036AC:  MOVLB  0
036AE:  RETURN 0
036B0:  MOVLW  08
036B2:  MOVLB  7
036B4:  MOVWF  xB5
036B6:  MOVFF  00,7B6
036BA:  BSF    F93.0
036BC:  MOVLW  51
036BE:  MOVWF  00
036C0:  DECFSZ 00,F
036C2:  BRA    36C0
036C4:  BSF    F93.1
036C6:  BTFSS  F81.1
036C8:  BRA    36C6
036CA:  BTFSC  F81.0
036CC:  BSF    FD8.0
036CE:  BTFSS  F81.0
036D0:  BCF    FD8.0
036D2:  RLCF   01,F
036D4:  MOVLW  50
036D6:  MOVWF  00
036D8:  DECFSZ 00,F
036DA:  BRA    36D8
036DC:  BCF    F93.1
036DE:  BCF    F8A.1
036E0:  DECFSZ xB5,F
036E2:  BRA    36BA
036E4:  BSF    F93.0
036E6:  MOVLW  51
036E8:  MOVWF  00
036EA:  DECFSZ 00,F
036EC:  BRA    36EA
036EE:  BCF    F8A.0
036F0:  MOVF   xB6,W
036F2:  BTFSS  FD8.2
036F4:  BCF    F93.0
036F6:  NOP   
036F8:  BSF    F93.1
036FA:  BTFSS  F81.1
036FC:  BRA    36FA
036FE:  MOVLW  50
03700:  MOVWF  00
03702:  DECFSZ 00,F
03704:  BRA    3702
03706:  BCF    F8A.1
03708:  BCF    F93.1
0370A:  MOVLW  51
0370C:  MOVWF  00
0370E:  DECFSZ 00,F
03710:  BRA    370E
03712:  BCF    F8A.0
03714:  BCF    F93.0
03716:  MOVLB  0
03718:  RETURN 0
.................... #use rs232(uart1, baud=9600, xmit=PIN_C6, rcv=PIN_C7, stream=BT) 
*
04F3E:  BTFSS  F9E.4
04F40:  BRA    4F3E
04F42:  MOVWF  FAD
04F44:  RETURN 0
....................  
.................... void selectsensor(int sensornumber); 
.................... int readlineararray(void); 
.................... int16 DORaw, WTRaw, NH4Raw; 
....................  
.................... typedef struct outputDataStruct { 
....................     char deviceID[16]; 
....................     unsigned int8 hour; 
....................     unsigned int8 minute; 
....................     unsigned int8 second; 
....................     unsigned int8 day; 
....................     unsigned int8 month; 
....................     unsigned int16 year; 
....................     unsigned int8 taosVersion; 
....................     float dOxy; 
....................     float wTemp; 
....................     float pH; 
....................     float pHLow; 
....................     float WhiteBalance; 
....................     float tdsLevel; 
....................     float wLevel; 
....................     float lLevelX; 
....................     float lLevelY; 
....................  
....................     int32 lLevelRed; 
....................     int32 lLevelGreen; 
....................     int32 lLevelBlue; 
....................     int32 lLevelClear; 
....................     int8 time; 
....................     int16 date; 
....................  
....................  
....................     float lLevelScale; 
....................     float rH, averagepH; 
....................     float aTemp; 
....................     int16 cO2; 
....................     float nh3; 
....................     float dPoint; 
....................     char DIEHARD[8]; 
.................... } outputData; 
....................  
....................  
.................... outputData sysOutput; 
.................... unsigned int16 selectitem; // this is the var used for local configurations 
.................... //int16 DORaw, WTRaw, NH4Raw, CO2Raw, stuffit,NHWhiteRaw, NHRedRaw,NHGreenRaw, NHBlueRaw; 
.................... int16 stuffit; 
.................... int8 startupdate = 0; // this is the flag to start an upload  
.................... int16 th,tl,hh,hl;  // variables for 1050 RH and temp sensor 
....................  
.................... #include <CU20045SCPB-U1J.c> 
.................... /////////////Configuration//////////////////// 
.................... #define RSPIN PIN_E2 
.................... #define WRPIN PIN_E1 
.................... #define RDPIN PIN_E0 
.................... #define WRITEPORT PORT_D 
....................  
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /////////////Definitions////////////////////// 
.................... #ifndef BYTE 
.................... #define BYTE int8 
.................... #endif 
.................... #ifndef BOOL 
.................... #define BOOL int1 
.................... #endif 
....................  
.................... #ifndef HIGH 
.................... #define HIGH 1 
.................... #endif 
....................  
.................... #ifndef LOW 
.................... #define LOW 0 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
....................  
.................... void initDispIO(void) 
.................... { 
.................... output_bit(WRPIN,HIGH); 
*
011DC:  BSF    F8D.1
011DE:  BCF    F96.1
.................... output_bit(RDPIN,HIGH); 
011E0:  BSF    F8D.0
011E2:  BCF    F96.0
.................... output_bit(RSPIN,LOW); 
011E4:  BCF    F8D.2
011E6:  BCF    F96.2
.................... output_d(0x00); 
011E8:  CLRF   F95
011EA:  CLRF   F8C
011EC:  GOTO   8FA4 (RETURN)
.................... } 
....................  
....................  
.................... void output_d_flipped(BYTE val){ 
.................... output_bit(PIN_D0,(val&(1<<7))); 
*
01218:  MOVLB  7
0121A:  BTFSC  xCB.7
0121C:  BRA    1222
0121E:  BCF    F8C.0
01220:  BRA    1224
01222:  BSF    F8C.0
01224:  BCF    F95.0
.................... output_bit(PIN_D1,(val&(1<<6))); 
01226:  BTFSC  xCB.6
01228:  BRA    122E
0122A:  BCF    F8C.1
0122C:  BRA    1230
0122E:  BSF    F8C.1
01230:  BCF    F95.1
.................... output_bit(PIN_D2,(val&(1<<5))); 
01232:  BTFSC  xCB.5
01234:  BRA    123A
01236:  BCF    F8C.2
01238:  BRA    123C
0123A:  BSF    F8C.2
0123C:  BCF    F95.2
.................... output_bit(PIN_D3,(val&(1<<4))); 
0123E:  BTFSC  xCB.4
01240:  BRA    1246
01242:  BCF    F8C.3
01244:  BRA    1248
01246:  BSF    F8C.3
01248:  BCF    F95.3
.................... output_bit(PIN_D4,(val&(1<<3))); 
0124A:  BTFSC  xCB.3
0124C:  BRA    1252
0124E:  BCF    F8C.4
01250:  BRA    1254
01252:  BSF    F8C.4
01254:  BCF    F95.4
.................... output_bit(PIN_D5,(val&(1<<2))); 
01256:  BTFSC  xCB.2
01258:  BRA    125E
0125A:  BCF    F8C.5
0125C:  BRA    1260
0125E:  BSF    F8C.5
01260:  BCF    F95.5
.................... output_bit(PIN_D6,(val&(1<<1))); 
01262:  BTFSC  xCB.1
01264:  BRA    126A
01266:  BCF    F8C.6
01268:  BRA    126C
0126A:  BSF    F8C.6
0126C:  BCF    F95.6
.................... output_bit(PIN_D7,(val&(1<<0))); 
0126E:  BTFSC  xCB.0
01270:  BRA    1276
01272:  BCF    F8C.7
01274:  BRA    1278
01276:  BSF    F8C.7
01278:  BCF    F95.7
0127A:  MOVLB  0
0127C:  GOTO   1286 (RETURN)
.................... } 
....................  
....................  
.................... BYTE readByte(BOOL RSval) 
.................... { 
.................... output_bit(RDPIN,HIGH); 
.................... delay_cycles(1); 
.................... output_bit(RSPIN,RSval); 
.................... delay_cycles(1); 
.................... output_bit(RDPIN,LOW); 
.................... delay_cycles(1); 
.................... BYTE dataVal=input_d(); 
.................... delay_cycles(1); 
.................... output_bit(RDPIN,HIGH); 
.................... delay_cycles(1); 
....................  
.................... return dataVal; 
.................... } 
....................  
....................  
....................  
.................... BOOL writeByte(BOOL RSval, BYTE val){ 
.................... //RSval=RSval&0x01; 
.................... //BYTE startByte = (0x00|(RSval));	//Sets startByte depending on RSval 
.................... //BYTE stopByte = (0x02|(RSval));	//Sets stopByte depending on RSval 
....................  
.................... /* 
.................... if((readByte(0)&0x80)==1){ 
....................  
.................... delay_cycles(255); 
....................  
.................... } 
.................... else 
.................... { 
....................  
.................... } 
.................... */ 
.................... output_d_flipped(val); 
01280:  MOVFF  7CA,7CB
01284:  BRA    1218
.................... output_bit(WRPIN,HIGH); 
01286:  BSF    F8D.1
01288:  BCF    F96.1
.................... ////RS is LOW when writing and HIGH otherwise 
.................... //output_d(val); 
....................  
.................... //output_d(0xff); 
....................  
....................  
.................... if(RSval!=0) 
0128A:  MOVLB  7
0128C:  MOVF   xC9,F
0128E:  BZ    1296
.................... { 
.................... output_bit(RSPIN,HIGH); 
01290:  BSF    F8D.2
01292:  BCF    F96.2
.................... } 
01294:  BRA    129A
.................... else{ 
.................... output_bit(RSPIN,LOW); 
01296:  BCF    F8D.2
01298:  BCF    F96.2
.................... } 
.................... output_bit(WRPIN,HIGH); 
0129A:  BSF    F8D.1
0129C:  BCF    F96.1
.................... //delay_cycles(1); 
.................... output_bit(WRPIN,LOW); 
0129E:  BCF    F8D.1
012A0:  BCF    F96.1
.................... //output_E(0x00);	//Write RS	"START" 
.................... //delay_cycles(1); 
....................  
....................  
....................  
.................... //delay_cycles(1); 
.................... //output_E(0x02);	//Write RS ... & RW HIGH "STOP" 
.................... output_bit(WRPIN,HIGH); 
012A2:  BSF    F8D.1
012A4:  BCF    F96.1
.................... //delay_cycles(1); 
.................... return HIGH; 
012A6:  MOVLW  01
012A8:  MOVWF  01
012AA:  MOVLB  0
012AC:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... BOOL writeChar(BYTE val){ 
.................... writeByte(1,val); 
*
01324:  MOVLW  01
01326:  MOVLB  7
01328:  MOVWF  xC9
0132A:  MOVFF  7C8,7CA
0132E:  MOVLB  0
01330:  RCALL  1280
.................... return HIGH; 
01332:  MOVLW  01
01334:  MOVWF  01
01336:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... BOOL writeCharPos(BYTE xPos, BYTE yPos, BYTE strPtr) 
.................... { 
....................  
....................  
.................... BYTE WAMpos=0x80+xPos+(0x20*yPos); 
.................... writeByte(0,WAMpos);	//Set WAM Address 
....................  
.................... int i=0; 
....................  
....................  
.................... writeChar(strPtr); 
.................... return HIGH; 
.................... } 
....................  
....................  
.................... void clearLine(int8 xPos, int8 yPos){ 
....................  
.................... BYTE linePos=((0x20*yPos)+0x80); 
.................... writeByte(0,linePos); 
.................... for(int ct=0; ct<20; ct++) 
.................... { 
.................... writeChar(' '); 
.................... } 
.................... BYTE WAMpos=0x80+xPos+(0x20*yPos); 
.................... writeByte(0,WAMpos);	//Set WAM Address 
.................... } 
....................  
....................  
....................  
....................  
.................... BOOL writeString(BYTE xPos, BYTE yPos, BYTE strPtr[]) 
01338:  MOVLB  7
0133A:  MOVF   xC1,W
0133C:  MULLW  20
0133E:  MOVF   FF3,W
01340:  ADDLW  80
01342:  MOVWF  xC4
.................... { 
....................  
.................... BYTE linePos=((0x20*yPos)+0x80); 
.................... writeByte(0,linePos); 
01344:  CLRF   xC9
01346:  MOVFF  7C4,7CA
0134A:  MOVLB  0
0134C:  RCALL  1280
.................... //for(int ct=0; ct<20; ct++) 
.................... //{ 
.................... //writeChar(' '); 
.................... //} 
....................  
.................... BYTE WAMpos=0x80+xPos+(0x20*yPos); 
0134E:  MOVLW  80
01350:  MOVLB  7
01352:  ADDWF  xC0,W
01354:  MOVWF  xC7
01356:  MOVF   xC1,W
01358:  MULLW  20
0135A:  MOVF   FF3,W
0135C:  ADDWF  xC7,W
0135E:  MOVWF  xC5
.................... writeByte(0,WAMpos);	//Set WAM Address 
01360:  CLRF   xC9
01362:  MOVFF  7C5,7CA
01366:  MOVLB  0
01368:  RCALL  1280
....................  
.................... int i=0; 
0136A:  MOVLB  7
0136C:  CLRF   xC6
....................  
.................... while(strPtr[i]!='\0') 
0136E:  MOVF   xC6,W
01370:  ADDWF  xC2,W
01372:  MOVWF  FE9
01374:  MOVLW  00
01376:  ADDWFC xC3,W
01378:  MOVWF  FEA
0137A:  MOVF   FEF,F
0137C:  BZ    13A0
.................... { 
.................... writeChar(strPtr[i]); 
0137E:  MOVF   xC6,W
01380:  ADDWF  xC2,W
01382:  MOVWF  FE9
01384:  MOVLW  00
01386:  ADDWFC xC3,W
01388:  MOVWF  FEA
0138A:  MOVFF  FEF,7C8
0138E:  MOVLB  0
01390:  RCALL  1324
.................... i++; 
01392:  MOVLB  7
01394:  INCF   xC6,F
.................... if(i>=20) 
01396:  MOVF   xC6,W
01398:  SUBLW  13
0139A:  BC    139E
.................... { 
.................... break; 
0139C:  BRA    13A0
.................... } 
0139E:  BRA    136E
....................  
.................... } 
.................... return HIGH; 
013A0:  MOVLW  01
013A2:  MOVWF  01
013A4:  MOVLB  0
013A6:  RETURN 0
.................... } 
....................  
....................  
.................... void clearDisplay(){ 
.................... writeByte(0,0x01);	//Clear Display 
*
0130C:  MOVLB  7
0130E:  CLRF   xC9
01310:  MOVLW  01
01312:  MOVWF  xCA
01314:  MOVLB  0
01316:  RCALL  1280
.................... delay_ms(5); 
01318:  MOVLW  05
0131A:  MOVLB  7
0131C:  MOVWF  xC1
0131E:  MOVLB  0
01320:  RCALL  11F0
01322:  RETURN 0
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... void initDisplay(void){ 
.................... writeByte(0,0x3F);	//Set 8 bit mode 
*
012AE:  MOVLB  7
012B0:  CLRF   xC9
012B2:  MOVLW  3F
012B4:  MOVWF  xCA
012B6:  MOVLB  0
012B8:  RCALL  1280
.................... delay_cycles(127); 
012BA:  MOVLW  2A
012BC:  MOVWF  00
012BE:  DECFSZ 00,F
012C0:  BRA    12BE
.................... writeByte(0,0x01);	//Clear Display 
012C2:  MOVLB  7
012C4:  CLRF   xC9
012C6:  MOVLW  01
012C8:  MOVWF  xCA
012CA:  MOVLB  0
012CC:  RCALL  1280
.................... delay_ms(5); 
012CE:  MOVLW  05
012D0:  MOVLB  7
012D2:  MOVWF  xC1
012D4:  MOVLB  0
012D6:  RCALL  11F0
.................... //writeByte(0,0x02);	//Cursor Home 
.................... writeByte(0,0x06);	//Entry Mode Set 
012D8:  MOVLB  7
012DA:  CLRF   xC9
012DC:  MOVLW  06
012DE:  MOVWF  xCA
012E0:  MOVLB  0
012E2:  RCALL  1280
.................... writeByte(0,0x0F);	//Display On Cursor On 
012E4:  MOVLB  7
012E6:  CLRF   xC9
012E8:  MOVLW  0F
012EA:  MOVWF  xCA
012EC:  MOVLB  0
012EE:  RCALL  1280
.................... writeByte(0,0x10);	//Cursor Shift 
012F0:  MOVLB  7
012F2:  CLRF   xC9
012F4:  MOVLW  10
012F6:  MOVWF  xCA
012F8:  MOVLB  0
012FA:  RCALL  1280
.................... writeByte(0,0x80);	//Set WAM Address 
012FC:  MOVLB  7
012FE:  CLRF   xC9
01300:  MOVLW  80
01302:  MOVWF  xCA
01304:  MOVLB  0
01306:  RCALL  1280
01308:  GOTO   8FC0 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... #include "G:\OsmobotLocalDisplay Via Bluetooth\VacDisplayRoutines.c" 
....................  
....................  
....................  
.................... void VacDisplayinit(void) 
.................... { 
.................... 	//wait(1000000);	 
.................... 	delay_ms(1000); 
.................... 	output_high(RDPIN); // Pin 11 E/(~RD) 
.................... 	output_high(WRPIN);//pin 10 R/~WR 
.................... 	output_d(0x0F);	//  Dispaly Turns ON, Blink Off. 
.................... 	output_low(RSPIN); // Pin 9 RS  
.................... 	output_low(WRPIN); //Pin 10 ~WR 
.................... 	output_high(WRPIN);//pin 10 R/~WR 
.................... } 
....................  
.................... void VacWriteChar(char letter) 
.................... { 
.................... 	//wait(10); 
....................     int stuff; 
....................     stuff = writeChar(letter); 
*
04172:  MOVFF  7AC,7C8
04176:  CALL   1324
0417A:  MOVFF  01,7AD
0417E:  RETURN 0
....................      
.................... 	} 
....................  
....................  
....................  
.................... void VacSetXY(int X, int Y) 
.................... { 
.................... 	//output_low(RSPIN); 
.................... 	//output_d(0x06); //  Address counter incremented, cursor shift en 
.................... //	output_low(WRPIN); //Pin 10 ~WR 
.................... 	//output_high(WRPIN);//pin 10 R/~WR*/ 
....................     writeByte(0,0x06);	//Address counter incremented, cursor shift en 
*
040E0:  MOVLB  7
040E2:  CLRF   xC9
040E4:  MOVLW  06
040E6:  MOVWF  xCA
040E8:  MOVLB  0
040EA:  CALL   1280
....................     writeByte(0,0x02);	//Move cursor home 
040EE:  MOVLB  7
040F0:  CLRF   xC9
040F2:  MOVLW  02
040F4:  MOVWF  xCA
040F6:  MOVLB  0
040F8:  CALL   1280
.................... 	int location=0; 
040FC:  MOVLB  7
040FE:  CLRF   xAE
.................... 	switch (Y) 
04100:  MOVLW  01
04102:  SUBWF  xAD,W
04104:  ADDLW  FC
04106:  BC    4132
04108:  ADDLW  04
0410A:  MOVLB  0
0410C:  GOTO   4150
.................... 	{ 
.................... 	case 1 : 
.................... 		location = 128; 
04110:  MOVLW  80
04112:  MOVLB  7
04114:  MOVWF  xAE
.................... 		break;	 
04116:  BRA    4132
....................  
.................... 	case 2 : 
.................... 		location = 160; 
04118:  MOVLW  A0
0411A:  MOVLB  7
0411C:  MOVWF  xAE
.................... 		break;	 
0411E:  BRA    4132
.................... 		 
.................... 	case 3 : 
.................... 		location = 192; 
04120:  MOVLW  C0
04122:  MOVLB  7
04124:  MOVWF  xAE
.................... 		break;	 
04126:  BRA    4132
.................... 	 
.................... 	case 4 : 
.................... 		location = 224; 
04128:  MOVLW  E0
0412A:  MOVLB  7
0412C:  MOVWF  xAE
.................... 		break;	 
0412E:  BRA    4132
04130:  MOVLB  7
.................... 	} 
.................... 	location = location + x; 
04132:  MOVF   xAC,W
04134:  ADDWF  xAE,F
....................     //    writeByte(0,0x0d);	//Clear Display 
....................     writeByte(0,location);	//Clear Display 
04136:  CLRF   xC9
04138:  MOVFF  7AE,7CA
0413C:  MOVLB  0
0413E:  CALL   1280
.................... //	output_d(location); 
.................... //	wait(100); 
.................... //	delay_us(100); 
.................... //	output_low(WRPIN); // write pin low 
.................... //	wait(100); 
.................... 	delay_us(100); 
04142:  MOVLW  A6
04144:  MOVWF  00
04146:  DECFSZ 00,F
04148:  BRA    4146
0414A:  NOP   
0414C:  GOTO   418C (RETURN)
.................... //	output_high(WRPIN); // write pin high 
.................... } 
....................  
.................... void VacDisplayString(char* string) 
.................... { 
.................... 	 
.................... 	int i; 
.................... 	int len = strlen(string); 
.................... 	//for length of string, take i-th position and output 
.................... 	for (i = 0; i < len; i++) 
.................... 	{ 
.................... 		VacWriteChar(string[i]); 
.................... 	} 
....................  
.................... } 
.................... //*********************************************** 
.................... //  The Y input is from 0 to 3.  0 is the top line and 3 is the bottom line on the VFD 
.................... //*********************************************** 
.................... void Display_XYString(int x, int y, char* string) 
.................... { 
.................... 	if (y < 5) 
....................     { 
....................     VacSetXY(x,y); 
.................... //	wait(50); 
.................... 	delay_ms(100); 
.................... 	VacDisplayString(string); 
....................     } 
.................... } 
....................  
....................  
....................  
.................... //**************************************************************** 
.................... // Created November 22, 2016 
.................... // Display the selected items on the VFD.  This is only used on the PIC18 CPUS for testing and production. 
.................... // Returns nothing. 
.................... // A max of 16 items can be selected.  Only four of the selected items are displayed.  The format goes  ITEM  RAWDATA  CONVERTEDDATA 
.................... //**************************************************************** 
.................... void displayselecteddata(int16 selectitem) 
.................... { 
....................     int linenumber = 1; 
....................     clearDisplay(); 
....................     if (selectitem & 0x0004) 
....................     { 
....................     sprintf(adcBuff, "DO %Lu %f  ",DORaw,sysOutput.dOxy); 
....................     Display_XYString(0,linenumber,adcBuff);  
....................         //  1  sysOutput.dOxy     
....................     linenumber++; 
....................     } 
....................     if (selectitem & 0x0400) 
....................     { 
....................     sprintf(adcBuff, "WT %Lu  %f   ",WTRaw,sysOutput.wTemp); 
....................     Display_XYString(0,linenumber,adcBuff); 
....................         //  2  sysOutput.wTemp     
....................     linenumber++; 
....................     }   
....................     if (selectitem & 0x1000) 
....................     { 
....................     sprintf(adcBuff, "NH4 %Lu  %f",NH4Raw,sysOutput.nh3); 
....................     Display_XYString(0,linenumber,adcBuff);  
....................         //  2  sysOutput.nh4     
....................     linenumber++; 
....................     }  
....................     if (selectitem & 0x0200) 
....................     { 
....................     sprintf(adcBuff, "CO2 %Lu ppm",sysOutput.cO2); 
....................     Display_XYString(0,linenumber,adcBuff);  
....................         //  2  sysOutput.co2     
....................     linenumber++; 
....................     }  
....................  if (selectitem & 0x0002) 
....................     { 
....................     sprintf(adcBuff, "AT+RH %fC %f%%",sysOutput.aTemp,sysOutput.rH); 
....................     Display_XYString(0,linenumber,adcBuff);  
....................         //  2  This is the air temperature and RH    
....................     linenumber++; 
....................     }  
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Feb 18, 2017 
.................... // Creates a bar graph on one row of the VFD. 
.................... //  An array is entered with the threashold limit. 
.................... //  The third element is the row number.  Starts from 1 to 4 
....................  
.................... //  The bar graphs scales 128 points into 20. 
.................... // Nothing is returned. 
.................... //****************************************************************************** 
.................... void displaybar(int threashold, int row) 
.................... { 
....................     int x; 
....................      
....................     VacSetXY(0x00,row);    
*
04180:  MOVLB  7
04182:  CLRF   xAC
04184:  MOVFF  7AA,7AD
04188:  MOVLB  0
0418A:  BRA    40E0
....................     for (x=0; x < 128; x=x+7) 
0418C:  MOVLB  7
0418E:  CLRF   xAB
04190:  MOVF   xAB,W
04192:  SUBLW  7F
04194:  BNC   41F8
....................     { 
....................         if (reading[x] > threashold) 
04196:  BCF    FD8.0
04198:  RLCF   xAB,W
0419A:  CLRF   03
0419C:  ADDLW  A6
0419E:  MOVWF  FE9
041A0:  MOVLW  00
041A2:  ADDWFC 03,W
041A4:  MOVWF  FEA
041A6:  MOVFF  FEC,7AD
041AA:  MOVF   FED,F
041AC:  MOVFF  FEF,7AC
041B0:  MOVF   xAD,F
041B2:  BNZ   41BA
041B4:  MOVF   xAC,W
041B6:  SUBWF  xA9,W
041B8:  BC    41C4
....................             VacWriteChar(0x14); 
041BA:  MOVLW  14
041BC:  MOVWF  xAC
041BE:  MOVLB  0
041C0:  RCALL  4172
041C2:  MOVLB  7
....................          if (reading[x] <= threashold) 
041C4:  BCF    FD8.0
041C6:  RLCF   xAB,W
041C8:  CLRF   03
041CA:  ADDLW  A6
041CC:  MOVWF  FE9
041CE:  MOVLW  00
041D0:  ADDWFC 03,W
041D2:  MOVWF  FEA
041D4:  MOVFF  FEC,7AD
041D8:  MOVF   FED,F
041DA:  MOVFF  FEF,7AC
041DE:  MOVF   xAD,F
041E0:  BNZ   41F2
041E2:  MOVF   xAC,W
041E4:  SUBWF  xA9,W
041E6:  BNC   41F2
....................             VacWriteChar(0x20);            
041E8:  MOVLW  20
041EA:  MOVWF  xAC
041EC:  MOVLB  0
041EE:  RCALL  4172
041F0:  MOVLB  7
041F2:  MOVLW  07
041F4:  ADDWF  xAB,F
041F6:  BRA    4190
....................     } 
041F8:  MOVLB  0
041FA:  GOTO   4364 (RETURN)
....................      
....................      
.................... } 
....................  
.................... #include <MasterReadWriteTeRemoteDevice.c> 
....................  
....................  
.................... #ifdef NOTOSMOBOT 
.................... #include "CommonPassedDataFromMaterToSlave.h" 
.................... //********************************************************************************************** 
.................... // Created November 23, 2016 
.................... //these are the calibration varibles so far on the tester.   
.................... //********************************************************************************************** 
....................  
.................... typedef struct { 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
.................... float eccal1x; 
.................... float eccal2x; 
.................... float eccal3x; 
.................... float eccal1y; 
.................... float eccal2y; 
.................... float eccal3y; 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... }Calstuff; 
.................... Calstuff sysInput;  
.................... /* 
....................  
.................... typedef struct inputDataStruct{ 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... float eccal1x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal1y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3y;    //  This the EC data point  Added July 18, 2016 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... }inputData; 
.................... inputData sysInput; 
....................  
.................... */ 
....................  
.................... #ifdef SLAVE 
....................  
.................... float Temp1DOOne; 
.................... float Temp1DOTwo; 
.................... float Temp1DOThree; 
.................... float Temp2DOOne; 
.................... float Temp2DOTwo; 
.................... float Temp2DOThree; 
.................... float Temp3DOOne; 
.................... float Temp3DOTwo; 
.................... float Temp3DOThree; 
.................... float Temp1ReadingOne; 
.................... float Temp1ReadingTwo; 
.................... float Temp1ReadingThree; 
.................... float Temp2ReadingOne; 
.................... float Temp2ReadingTwo; 
.................... float Temp2ReadingThree; 
.................... float Temp3ReadingOne; 
.................... float Temp3ReadingTwo; 
.................... float Temp3ReadingThree; 
....................  
.................... unsigned int16 TempOne; 
.................... unsigned int16 TempTwo; 
.................... unsigned int16 TempThree; 
....................  
.................... #endif 
....................  
.................... int16 CO2Raw,NHredRaw,NHGreenRaw,NHBlueRaw,NHWhiteRaw,DpHredRaw,DpHGreenRaw,DpHBlueRaw,DpHWhiteRaw; 
.................... #else 
.................... int16  DORaw, WTRaw, NH4Raw, CO2Raw,NHredRaw,NHGreenRaw,NHBlueRaw,NHWhiteRaw; 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #ifndef BTTestEvent 
.................... void BTTestEvent(void); 
.................... #endif 
.................... //  See the slave include file calle ITwoSeeGeneralCommunicationSlave.c  for the data structure for sending data to the master.  All  
.................... //  updates to the data structure are done on the Slave include file.  Not the master. 
....................  
.................... // Added Oct 24, 2016 
.................... // These routines are moved to a sharable file for the Osmobot and all other programs to read/write to i2c sensors. 
.................... // This routine is used in the Osmobot where there are no printf for a display. 
.................... int ReadRemoteDeviceOsmobot(int deviceaddress) 
.................... { 
....................      
....................     int x; 
....................     //  Selection of 0  internal Digital DO and NH4 sensor 
....................     //  Selection of 1  Top RJ45 connector 
....................     //  Selection of 2  Bottom RJ45 connector     
....................     //  Selection of 3  no connection 
....................             selectsensor(deviceaddress);  // this sets the SCL to the right I2C device. 
....................      
....................     	    i2c_start(PH_LIGHT); 
.................... 			i2c_write(PH_LIGHT,0xa0);  //Move the address number left on and add a zero.  This is the command with address to write data to the address pointer 
.................... 			i2c_write(PH_LIGHT,0x00);  //This is the locations of the first buffer to address 
.................... 			i2c_stop(PH_LIGHT); 
....................              
....................             i2c_start(PH_LIGHT);  // start again 
....................             i2c_write(PH_LIGHT,0xa1);   // this starts the reading from the device.  Remember that a 1 in the first place is the command to send data from the device to the Master. 
....................             delay_ms(75); 
....................             for (x=0; x < 65; x++)            // read 128 locations and quit.  Put this in the returned array.   
....................             { 
....................                 rec_buffer[x] =  i2c_read(PH_LIGHT,FALSE); 
....................              //   sprintf(adcBuff, "%i",rec_buffer[x]); 
....................  
....................              //  adcStrCntr=0; 
....................  
....................             //    while(adcBuff[adcStrCntr]!= '\0') 
....................              //   { 
....................             //    writeCharPos(adcStrCntr,0,adcBuff[adcStrCntr]); 
....................              //   adcStrCntr++; 
....................              //   } 
....................                  delay_ms(1); 
....................             } 
....................             x++; 
....................             rec_buffer[x] =  i2c_read(PH_LIGHT,FALSE); 
....................             i2c_stop(PH_LIGHT); 
....................      
....................     return(1); 
.................... } 
....................  
....................  
....................  
.................... //  See the slave include file calle ITwoSeeGeneralCommunicationSlave.c  for the data structure for sending data to the master.  All  
.................... //  updates to the data structure are done on the Slave include file.  Not the master. 
....................  
....................  
....................  
.................... int ReadRemoteDevice(int deviceaddress) 
.................... { 
....................      
....................     int x; 
....................  
....................     //  Selection of 0  internal Digital DO and NH4 sensor 
....................     //  Selection of 1  Top RJ45 connector 
....................     //  Selection of 2  Bottom RJ45 connector     
....................     //  Selection of 3  no connection 
....................             selectsensor(deviceaddress);  // this sets the SCL to the right I2C device. 
*
0783C:  MOVFF  791,7B4
07840:  CALL   35F6
....................      
....................     	    i2c_start(PH_LIGHT); 
07844:  BSF    F93.0
07846:  MOVLW  50
07848:  MOVWF  00
0784A:  DECFSZ 00,F
0784C:  BRA    784A
0784E:  BSF    F93.1
07850:  MOVLW  51
07852:  MOVWF  00
07854:  DECFSZ 00,F
07856:  BRA    7854
07858:  BCF    F8A.0
0785A:  BCF    F93.0
0785C:  MOVLW  50
0785E:  MOVWF  00
07860:  DECFSZ 00,F
07862:  BRA    7860
07864:  BCF    F8A.1
07866:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0xa0);  //Move the address number left on and add a zero.  This is the command with address to write data to the address pointer 
07868:  MOVLW  A0
0786A:  MOVLB  7
0786C:  MOVWF  xB4
0786E:  MOVLB  0
07870:  CALL   363A
.................... 			i2c_write(PH_LIGHT,0x00);  //This is the locations of the first buffer to address 
07874:  MOVLB  7
07876:  CLRF   xB4
07878:  MOVLB  0
0787A:  CALL   363A
.................... 			i2c_stop(PH_LIGHT); 
0787E:  BCF    F93.0
07880:  NOP   
07882:  BSF    F93.1
07884:  BTFSS  F81.1
07886:  BRA    7884
07888:  MOVLW  50
0788A:  MOVWF  00
0788C:  DECFSZ 00,F
0788E:  BRA    788C
07890:  BRA    7892
07892:  NOP   
07894:  BSF    F93.0
07896:  MOVLW  50
07898:  MOVWF  00
0789A:  DECFSZ 00,F
0789C:  BRA    789A
....................              
....................             i2c_start(PH_LIGHT);  // start again 
0789E:  BSF    F93.0
078A0:  MOVLW  50
078A2:  MOVWF  00
078A4:  DECFSZ 00,F
078A6:  BRA    78A4
078A8:  BSF    F93.1
078AA:  MOVLW  51
078AC:  MOVWF  00
078AE:  DECFSZ 00,F
078B0:  BRA    78AE
078B2:  BCF    F8A.0
078B4:  BCF    F93.0
078B6:  MOVLW  50
078B8:  MOVWF  00
078BA:  DECFSZ 00,F
078BC:  BRA    78BA
078BE:  BCF    F8A.1
078C0:  BCF    F93.1
....................             i2c_write(PH_LIGHT,0xa1);   // this starts the reading from the device.  Remember that a 1 in the first place is the command to send data from the device to the Master. 
078C2:  MOVLW  A1
078C4:  MOVLB  7
078C6:  MOVWF  xB4
078C8:  MOVLB  0
078CA:  CALL   363A
....................             delay_ms(75); 
078CE:  MOVLW  4B
078D0:  MOVLB  7
078D2:  MOVWF  xC1
078D4:  MOVLB  0
078D6:  CALL   11F0
....................             for (x=0; x < 65; x++)            // read 128 locations and quit.  Put this in the returned array.   
078DA:  MOVLB  7
078DC:  CLRF   x92
078DE:  MOVF   x92,W
078E0:  SUBLW  40
078E2:  BNC   7914
....................             { 
....................                 rec_buffer[x] =  i2c_read(PH_LIGHT); 
078E4:  CLRF   03
078E6:  MOVF   x92,W
078E8:  ADDLW  65
078EA:  MOVWF  FE9
078EC:  MOVLW  00
078EE:  ADDWFC 03,W
078F0:  MOVWF  FEA
078F2:  MOVLW  01
078F4:  MOVWF  00
078F6:  MOVLB  0
078F8:  CALL   36B0
078FC:  MOVFF  01,FEF
....................                // sprintf(adcBuff, "%i %i",rec_buffer[x],deviceaddress); 
....................               //  Display_XYString(0,1,adcBuff);  
....................                 //adcStrCntr=0; 
....................  
....................                 //while(adcBuff[adcStrCntr]!= '\0') 
....................                 //{ 
....................                 //writeCharPos(adcStrCntr,0,adcBuff[adcStrCntr]); 
....................                // adcStrCntr++; 
....................                 //} 
.................... #if OSMOBOT 
....................                 BTBasicTest(); 
.................... #else 
....................                 BTTestEvent();   // check for the data coming back to displayable 
07900:  RCALL  77A2
.................... #endif                
....................                 delay_ms(10); 
07902:  MOVLW  0A
07904:  MOVLB  7
07906:  MOVWF  xC1
07908:  MOVLB  0
0790A:  CALL   11F0
0790E:  MOVLB  7
07910:  INCF   x92,F
07912:  BRA    78DE
....................             } 
....................             x++; 
07914:  INCF   x92,F
....................             rec_buffer[x] =  i2c_read(PH_LIGHT,FALSE); 
07916:  CLRF   03
07918:  MOVF   x92,W
0791A:  ADDLW  65
0791C:  MOVWF  FE9
0791E:  MOVLW  00
07920:  ADDWFC 03,W
07922:  MOVWF  FEA
07924:  CLRF   00
07926:  MOVLB  0
07928:  CALL   36B0
0792C:  MOVFF  01,FEF
....................             i2c_stop(PH_LIGHT); 
07930:  BCF    F93.0
07932:  NOP   
07934:  BSF    F93.1
07936:  BTFSS  F81.1
07938:  BRA    7936
0793A:  MOVLW  50
0793C:  MOVWF  00
0793E:  DECFSZ 00,F
07940:  BRA    793E
07942:  BRA    7944
07944:  NOP   
07946:  BSF    F93.0
07948:  MOVLW  50
0794A:  MOVWF  00
0794C:  DECFSZ 00,F
0794E:  BRA    794C
....................      
....................     return(1); 
07950:  MOVLW  01
07952:  MOVWF  01
07954:  RETURN 0
.................... } 
....................  
....................   
....................     
.................... //******************************************************************************* 
.................... // Created October 28, 2016 
.................... // This routine takes the returned array of data from the remote device and moves it into the selected data startures. 
.................... //  It returns nothing. 
.................... // if the data in the returned array is 0xFF, nothing is done.   
.................... //  The data structure is connected with the listing above. 
.................... //  The input is the array that needs to have the data moved into.  The numbering starts at 0 and goes through 4.  This means five different sensors can be used at the same time. 
.................... // If the same sensor is used, it is kept straight where the data sits and is sent to the server. 
.................... //  As of now, the input is ignorned because there is only one array.   
.................... //******************************************************************************* 
....................     void  moveReceivedData(int portid) 
....................     { 
....................         float tempvar; 
....................         int16 tempvarint; 
....................          // there are 100 points in the transmit buffer. 
....................            // water temperature 
....................             if ((rec_buffer[6] != 0xFF) && (rec_buffer[5] != 0xFF)) 
07956:  INCFSZ x6B,W
07958:  BRA    795C
0795A:  BRA    79F8
0795C:  INCFSZ x6A,W
0795E:  BRA    7962
07960:  BRA    79F8
....................             { 
....................               tempvar = (float) rec_buffer[5]; 
07962:  MOVLB  7
07964:  CLRF   xE4
07966:  MOVFF  6A,7E3
0796A:  MOVLB  0
0796C:  CALL   21AC
07970:  MOVFF  03,795
07974:  MOVFF  02,794
07978:  MOVFF  01,793
0797C:  MOVFF  00,792
....................               sysOutput.wTemp = tempvar  + ((float) rec_buffer[6])/100; 
07980:  MOVLB  7
07982:  CLRF   xE4
07984:  MOVFF  6B,7E3
07988:  MOVLB  0
0798A:  CALL   21AC
0798E:  MOVFF  03,79B
07992:  MOVFF  02,79A
07996:  MOVFF  01,799
0799A:  MOVFF  00,798
0799E:  MOVFF  03,7DB
079A2:  MOVFF  02,7DA
079A6:  MOVFF  01,7D9
079AA:  MOVFF  00,7D8
079AE:  MOVLB  7
079B0:  CLRF   xDF
079B2:  CLRF   xDE
079B4:  MOVLW  48
079B6:  MOVWF  xDD
079B8:  MOVLW  85
079BA:  MOVWF  xDC
079BC:  MOVLB  0
079BE:  CALL   1F58
079C2:  BCF    FD8.1
079C4:  MOVFF  795,7E6
079C8:  MOVFF  794,7E5
079CC:  MOVFF  793,7E4
079D0:  MOVFF  792,7E3
079D4:  MOVFF  03,7EA
079D8:  MOVFF  02,7E9
079DC:  MOVFF  01,7E8
079E0:  MOVFF  00,7E7
079E4:  CALL   1CE0
079E8:  MOVFF  03,1D2
079EC:  MOVFF  02,1D1
079F0:  MOVFF  01,1D0
079F4:  MOVFF  00,1CF
....................             } 
....................          
....................          
....................             // CO2 
....................             if ((rec_buffer[7] != 0xFF) && (rec_buffer[8] != 0xFF)) 
079F8:  INCFSZ x6C,W
079FA:  BRA    79FE
079FC:  BRA    7A2C
079FE:  INCFSZ x6D,W
07A00:  BRA    7A04
07A02:  BRA    7A2C
....................             { 
....................                  tempvarint = rec_buffer[7]; 
07A04:  MOVLB  7
07A06:  CLRF   x97
07A08:  MOVFF  6C,796
....................                  tempvarint = tempvarint*256 + rec_buffer[8]; 
07A0C:  MOVFF  796,799
07A10:  CLRF   x98
07A12:  MOVLB  0
07A14:  MOVF   x6D,W
07A16:  MOVLB  7
07A18:  ADDWF  x98,W
07A1A:  MOVWF  x96
07A1C:  MOVLW  00
07A1E:  ADDWFC x99,W
07A20:  MOVWF  x97
....................                  sysOutput.cO2 = tempvarint; 
07A22:  MOVFF  797,213
07A26:  MOVFF  796,212
07A2A:  MOVLB  0
....................             }        
....................              // Air Temperature 
....................             if ((rec_buffer[9] != 0xFF) && (rec_buffer[10] != 0xFF)) 
07A2C:  INCFSZ x6E,W
07A2E:  BRA    7A32
07A30:  BRA    7ACE
07A32:  INCFSZ x6F,W
07A34:  BRA    7A38
07A36:  BRA    7ACE
....................             { 
....................             tempvar = (float) rec_buffer[9]; 
07A38:  MOVLB  7
07A3A:  CLRF   xE4
07A3C:  MOVFF  6E,7E3
07A40:  MOVLB  0
07A42:  CALL   21AC
07A46:  MOVFF  03,795
07A4A:  MOVFF  02,794
07A4E:  MOVFF  01,793
07A52:  MOVFF  00,792
....................             sysOutput.aTemp = tempvar  + ((float) rec_buffer[10])/100; 
07A56:  MOVLB  7
07A58:  CLRF   xE4
07A5A:  MOVFF  6F,7E3
07A5E:  MOVLB  0
07A60:  CALL   21AC
07A64:  MOVFF  03,79B
07A68:  MOVFF  02,79A
07A6C:  MOVFF  01,799
07A70:  MOVFF  00,798
07A74:  MOVFF  03,7DB
07A78:  MOVFF  02,7DA
07A7C:  MOVFF  01,7D9
07A80:  MOVFF  00,7D8
07A84:  MOVLB  7
07A86:  CLRF   xDF
07A88:  CLRF   xDE
07A8A:  MOVLW  48
07A8C:  MOVWF  xDD
07A8E:  MOVLW  85
07A90:  MOVWF  xDC
07A92:  MOVLB  0
07A94:  CALL   1F58
07A98:  BCF    FD8.1
07A9A:  MOVFF  795,7E6
07A9E:  MOVFF  794,7E5
07AA2:  MOVFF  793,7E4
07AA6:  MOVFF  792,7E3
07AAA:  MOVFF  03,7EA
07AAE:  MOVFF  02,7E9
07AB2:  MOVFF  01,7E8
07AB6:  MOVFF  00,7E7
07ABA:  CALL   1CE0
07ABE:  MOVFF  03,211
07AC2:  MOVFF  02,210
07AC6:  MOVFF  01,20F
07ACA:  MOVFF  00,20E
....................             }          
....................             // Air RH 
....................             if ((rec_buffer[11] != 0xFF) && (rec_buffer[12] != 0xFF)) 
07ACE:  INCFSZ x70,W
07AD0:  BRA    7AD4
07AD2:  BRA    7B70
07AD4:  INCFSZ x71,W
07AD6:  BRA    7ADA
07AD8:  BRA    7B70
....................             { 
....................             tempvar = (float) rec_buffer[11]; 
07ADA:  MOVLB  7
07ADC:  CLRF   xE4
07ADE:  MOVFF  70,7E3
07AE2:  MOVLB  0
07AE4:  CALL   21AC
07AE8:  MOVFF  03,795
07AEC:  MOVFF  02,794
07AF0:  MOVFF  01,793
07AF4:  MOVFF  00,792
....................             sysOutput.rH = tempvar  + ((float) rec_buffer[12])/100; 
07AF8:  MOVLB  7
07AFA:  CLRF   xE4
07AFC:  MOVFF  71,7E3
07B00:  MOVLB  0
07B02:  CALL   21AC
07B06:  MOVFF  03,79B
07B0A:  MOVFF  02,79A
07B0E:  MOVFF  01,799
07B12:  MOVFF  00,798
07B16:  MOVFF  03,7DB
07B1A:  MOVFF  02,7DA
07B1E:  MOVFF  01,7D9
07B22:  MOVFF  00,7D8
07B26:  MOVLB  7
07B28:  CLRF   xDF
07B2A:  CLRF   xDE
07B2C:  MOVLW  48
07B2E:  MOVWF  xDD
07B30:  MOVLW  85
07B32:  MOVWF  xDC
07B34:  MOVLB  0
07B36:  CALL   1F58
07B3A:  BCF    FD8.1
07B3C:  MOVFF  795,7E6
07B40:  MOVFF  794,7E5
07B44:  MOVFF  793,7E4
07B48:  MOVFF  792,7E3
07B4C:  MOVFF  03,7EA
07B50:  MOVFF  02,7E9
07B54:  MOVFF  01,7E8
07B58:  MOVFF  00,7E7
07B5C:  CALL   1CE0
07B60:  MOVFF  03,209
07B64:  MOVFF  02,208
07B68:  MOVFF  01,207
07B6C:  MOVFF  00,206
....................             }       
....................             // DO 
....................             if ((rec_buffer[3] != 0xFF) && (rec_buffer[4] != 0xFF)) 
07B70:  INCFSZ x68,W
07B72:  BRA    7B76
07B74:  BRA    7C12
07B76:  INCFSZ x69,W
07B78:  BRA    7B7C
07B7A:  BRA    7C12
....................             { 
....................             tempvar = (float) rec_buffer[3]; 
07B7C:  MOVLB  7
07B7E:  CLRF   xE4
07B80:  MOVFF  68,7E3
07B84:  MOVLB  0
07B86:  CALL   21AC
07B8A:  MOVFF  03,795
07B8E:  MOVFF  02,794
07B92:  MOVFF  01,793
07B96:  MOVFF  00,792
....................             sysOutput.dOxy = tempvar  + ((float) rec_buffer[4])/100; 
07B9A:  MOVLB  7
07B9C:  CLRF   xE4
07B9E:  MOVFF  69,7E3
07BA2:  MOVLB  0
07BA4:  CALL   21AC
07BA8:  MOVFF  03,79B
07BAC:  MOVFF  02,79A
07BB0:  MOVFF  01,799
07BB4:  MOVFF  00,798
07BB8:  MOVFF  03,7DB
07BBC:  MOVFF  02,7DA
07BC0:  MOVFF  01,7D9
07BC4:  MOVFF  00,7D8
07BC8:  MOVLB  7
07BCA:  CLRF   xDF
07BCC:  CLRF   xDE
07BCE:  MOVLW  48
07BD0:  MOVWF  xDD
07BD2:  MOVLW  85
07BD4:  MOVWF  xDC
07BD6:  MOVLB  0
07BD8:  CALL   1F58
07BDC:  BCF    FD8.1
07BDE:  MOVFF  795,7E6
07BE2:  MOVFF  794,7E5
07BE6:  MOVFF  793,7E4
07BEA:  MOVFF  792,7E3
07BEE:  MOVFF  03,7EA
07BF2:  MOVFF  02,7E9
07BF6:  MOVFF  01,7E8
07BFA:  MOVFF  00,7E7
07BFE:  CALL   1CE0
07C02:  MOVFF  03,1CE
07C06:  MOVFF  02,1CD
07C0A:  MOVFF  01,1CC
07C0E:  MOVFF  00,1CB
....................             }   
....................               // NH4-NH3 
....................             if ((rec_buffer[1] != 0xFF) && (rec_buffer[2] != 0xFF)) 
07C12:  INCFSZ x66,W
07C14:  BRA    7C18
07C16:  BRA    7CB4
07C18:  INCFSZ x67,W
07C1A:  BRA    7C1E
07C1C:  BRA    7CB4
....................             { 
....................             tempvar = (float) rec_buffer[1]; 
07C1E:  MOVLB  7
07C20:  CLRF   xE4
07C22:  MOVFF  66,7E3
07C26:  MOVLB  0
07C28:  CALL   21AC
07C2C:  MOVFF  03,795
07C30:  MOVFF  02,794
07C34:  MOVFF  01,793
07C38:  MOVFF  00,792
....................             sysOutput.nh3 = tempvar  + ((float) rec_buffer[2])/100; 
07C3C:  MOVLB  7
07C3E:  CLRF   xE4
07C40:  MOVFF  67,7E3
07C44:  MOVLB  0
07C46:  CALL   21AC
07C4A:  MOVFF  03,79B
07C4E:  MOVFF  02,79A
07C52:  MOVFF  01,799
07C56:  MOVFF  00,798
07C5A:  MOVFF  03,7DB
07C5E:  MOVFF  02,7DA
07C62:  MOVFF  01,7D9
07C66:  MOVFF  00,7D8
07C6A:  MOVLB  7
07C6C:  CLRF   xDF
07C6E:  CLRF   xDE
07C70:  MOVLW  48
07C72:  MOVWF  xDD
07C74:  MOVLW  85
07C76:  MOVWF  xDC
07C78:  MOVLB  0
07C7A:  CALL   1F58
07C7E:  BCF    FD8.1
07C80:  MOVFF  795,7E6
07C84:  MOVFF  794,7E5
07C88:  MOVFF  793,7E4
07C8C:  MOVFF  792,7E3
07C90:  MOVFF  03,7EA
07C94:  MOVFF  02,7E9
07C98:  MOVFF  01,7E8
07C9C:  MOVFF  00,7E7
07CA0:  CALL   1CE0
07CA4:  MOVFF  03,217
07CA8:  MOVFF  02,216
07CAC:  MOVFF  01,215
07CB0:  MOVFF  00,214
....................             }     
....................             if ((rec_buffer[15] != 0xFF) && (rec_buffer[16] != 0xFF)) 
07CB4:  INCFSZ x74,W
07CB6:  BRA    7CBA
07CB8:  BRA    7CE8
07CBA:  INCFSZ x75,W
07CBC:  BRA    7CC0
07CBE:  BRA    7CE8
....................             { 
....................                  tempvarint = rec_buffer[15]; 
07CC0:  MOVLB  7
07CC2:  CLRF   x97
07CC4:  MOVFF  74,796
....................                  tempvarint = tempvarint*256 + rec_buffer[16]; 
07CC8:  MOVFF  796,799
07CCC:  CLRF   x98
07CCE:  MOVLB  0
07CD0:  MOVF   x75,W
07CD2:  MOVLB  7
07CD4:  ADDWF  x98,W
07CD6:  MOVWF  x96
07CD8:  MOVLW  00
07CDA:  ADDWFC x99,W
07CDC:  MOVWF  x97
....................                  DORaw = tempvarint; 
07CDE:  MOVFF  797,1AE
07CE2:  MOVFF  796,1AD
07CE6:  MOVLB  0
....................             }  
....................             if ((rec_buffer[17] != 0xFF) && (rec_buffer[18] != 0xFF)) 
07CE8:  INCFSZ x76,W
07CEA:  BRA    7CEE
07CEC:  BRA    7D1C
07CEE:  INCFSZ x77,W
07CF0:  BRA    7CF4
07CF2:  BRA    7D1C
....................             { 
....................                  tempvarint = rec_buffer[17]; 
07CF4:  MOVLB  7
07CF6:  CLRF   x97
07CF8:  MOVFF  76,796
....................                  tempvarint = tempvarint*256 + rec_buffer[18]; 
07CFC:  MOVFF  796,799
07D00:  CLRF   x98
07D02:  MOVLB  0
07D04:  MOVF   x77,W
07D06:  MOVLB  7
07D08:  ADDWF  x98,W
07D0A:  MOVWF  x96
07D0C:  MOVLW  00
07D0E:  ADDWFC x99,W
07D10:  MOVWF  x97
....................                  NH4Raw = tempvarint; 
07D12:  MOVFF  797,1B2
07D16:  MOVFF  796,1B1
07D1A:  MOVLB  0
....................             }  
....................             if ((rec_buffer[13] != 0xFF) && (rec_buffer[14] != 0xFF)) 
07D1C:  INCFSZ x72,W
07D1E:  BRA    7D22
07D20:  BRA    7D50
07D22:  INCFSZ x73,W
07D24:  BRA    7D28
07D26:  BRA    7D50
....................             { 
....................                  tempvarint = rec_buffer[13]; 
07D28:  MOVLB  7
07D2A:  CLRF   x97
07D2C:  MOVFF  72,796
....................                  tempvarint = tempvarint*256 + rec_buffer[14]; 
07D30:  MOVFF  796,799
07D34:  CLRF   x98
07D36:  MOVLB  0
07D38:  MOVF   x73,W
07D3A:  MOVLB  7
07D3C:  ADDWF  x98,W
07D3E:  MOVWF  x96
07D40:  MOVLW  00
07D42:  ADDWFC x99,W
07D44:  MOVWF  x97
....................                  WTRaw = tempvarint; 
07D46:  MOVFF  797,1B0
07D4A:  MOVFF  796,1AF
07D4E:  MOVLB  0
....................             }  
....................         // Added Feb 26, 2017 
....................         // these items are the raw numbers for NH4 
....................         //RED 
....................             if ((rec_buffer[19] != 0xFF) && (rec_buffer[20] != 0xFF)) 
07D50:  INCFSZ x78,W
07D52:  BRA    7D56
07D54:  BRA    7D84
07D56:  INCFSZ x79,W
07D58:  BRA    7D5C
07D5A:  BRA    7D84
....................             { 
....................                  tempvarint = rec_buffer[19]; 
07D5C:  MOVLB  7
07D5E:  CLRF   x97
07D60:  MOVFF  78,796
....................                  tempvarint = tempvarint*256 + rec_buffer[20]; 
07D64:  MOVFF  796,799
07D68:  CLRF   x98
07D6A:  MOVLB  0
07D6C:  MOVF   x79,W
07D6E:  MOVLB  7
07D70:  ADDWF  x98,W
07D72:  MOVWF  x96
07D74:  MOVLW  00
07D76:  ADDWFC x99,W
07D78:  MOVWF  x97
....................                  NHredRaw = tempvarint; 
07D7A:  MOVFF  797,2B7
07D7E:  MOVFF  796,2B6
07D82:  MOVLB  0
....................             } 
....................         //GREEN 
....................             if ((rec_buffer[21] != 0xFF) && (rec_buffer[22] != 0xFF)) 
07D84:  INCFSZ x7A,W
07D86:  BRA    7D8A
07D88:  BRA    7DB8
07D8A:  INCFSZ x7B,W
07D8C:  BRA    7D90
07D8E:  BRA    7DB8
....................             { 
....................                  tempvarint = rec_buffer[21]; 
07D90:  MOVLB  7
07D92:  CLRF   x97
07D94:  MOVFF  7A,796
....................                  tempvarint = tempvarint*256 + rec_buffer[22]; 
07D98:  MOVFF  796,799
07D9C:  CLRF   x98
07D9E:  MOVLB  0
07DA0:  MOVF   x7B,W
07DA2:  MOVLB  7
07DA4:  ADDWF  x98,W
07DA6:  MOVWF  x96
07DA8:  MOVLW  00
07DAA:  ADDWFC x99,W
07DAC:  MOVWF  x97
....................                  NHGreenRaw = tempvarint; 
07DAE:  MOVFF  797,2B9
07DB2:  MOVFF  796,2B8
07DB6:  MOVLB  0
....................             } 
....................         //BLUE 
....................             if ((rec_buffer[23] != 0xFF) && (rec_buffer[24] != 0xFF)) 
07DB8:  INCFSZ x7C,W
07DBA:  BRA    7DBE
07DBC:  BRA    7DEC
07DBE:  INCFSZ x7D,W
07DC0:  BRA    7DC4
07DC2:  BRA    7DEC
....................             { 
....................                  tempvarint = rec_buffer[23]; 
07DC4:  MOVLB  7
07DC6:  CLRF   x97
07DC8:  MOVFF  7C,796
....................                  tempvarint = tempvarint*256 + rec_buffer[24]; 
07DCC:  MOVFF  796,799
07DD0:  CLRF   x98
07DD2:  MOVLB  0
07DD4:  MOVF   x7D,W
07DD6:  MOVLB  7
07DD8:  ADDWF  x98,W
07DDA:  MOVWF  x96
07DDC:  MOVLW  00
07DDE:  ADDWFC x99,W
07DE0:  MOVWF  x97
....................                  NHBlueRaw = tempvarint; 
07DE2:  MOVFF  797,2BB
07DE6:  MOVFF  796,2BA
07DEA:  MOVLB  0
....................             }  
....................         //WHITE 
....................             if ((rec_buffer[25] != 0xFF) && (rec_buffer[26] != 0xFF)) 
07DEC:  INCFSZ x7E,W
07DEE:  BRA    7DF2
07DF0:  BRA    7E20
07DF2:  INCFSZ x7F,W
07DF4:  BRA    7DF8
07DF6:  BRA    7E20
....................             { 
....................                  tempvarint = rec_buffer[25]; 
07DF8:  MOVLB  7
07DFA:  CLRF   x97
07DFC:  MOVFF  7E,796
....................                  tempvarint = tempvarint*256 + rec_buffer[26]; 
07E00:  MOVFF  796,799
07E04:  CLRF   x98
07E06:  MOVLB  0
07E08:  MOVF   x7F,W
07E0A:  MOVLB  7
07E0C:  ADDWF  x98,W
07E0E:  MOVWF  x96
07E10:  MOVLW  00
07E12:  ADDWFC x99,W
07E14:  MOVWF  x97
....................                  NHWhiteRaw = tempvarint; 
07E16:  MOVFF  797,2BD
07E1A:  MOVFF  796,2BC
07E1E:  MOVLB  0
....................             }          
....................         // Added April 3, 2017         
....................              //RED 
....................                 // these items are the raw numbers for the Oscean Optics DpH Patch 
....................             if ((rec_buffer[27] != 0xFF) && (rec_buffer[28] != 0xFF)) 
07E20:  INCFSZ x80,W
07E22:  BRA    7E26
07E24:  BRA    7E54
07E26:  INCFSZ x81,W
07E28:  BRA    7E2C
07E2A:  BRA    7E54
....................             { 
....................                  tempvarint = rec_buffer[27]; 
07E2C:  MOVLB  7
07E2E:  CLRF   x97
07E30:  MOVFF  80,796
....................                  tempvarint = tempvarint*256 + rec_buffer[28]; 
07E34:  MOVFF  796,799
07E38:  CLRF   x98
07E3A:  MOVLB  0
07E3C:  MOVF   x81,W
07E3E:  MOVLB  7
07E40:  ADDWF  x98,W
07E42:  MOVWF  x96
07E44:  MOVLW  00
07E46:  ADDWFC x99,W
07E48:  MOVWF  x97
....................                  DpHredRaw = tempvarint; 
07E4A:  MOVFF  797,2BF
07E4E:  MOVFF  796,2BE
07E52:  MOVLB  0
....................             } 
....................         //GREEN 
....................             if ((rec_buffer[31] != 0xFF) && (rec_buffer[32] != 0xFF)) 
07E54:  INCFSZ x84,W
07E56:  BRA    7E5A
07E58:  BRA    7E88
07E5A:  INCFSZ x85,W
07E5C:  BRA    7E60
07E5E:  BRA    7E88
....................             { 
....................                  tempvarint = rec_buffer[31]; 
07E60:  MOVLB  7
07E62:  CLRF   x97
07E64:  MOVFF  84,796
....................                  tempvarint = tempvarint*256 + rec_buffer[32]; 
07E68:  MOVFF  796,799
07E6C:  CLRF   x98
07E6E:  MOVLB  0
07E70:  MOVF   x85,W
07E72:  MOVLB  7
07E74:  ADDWF  x98,W
07E76:  MOVWF  x96
07E78:  MOVLW  00
07E7A:  ADDWFC x99,W
07E7C:  MOVWF  x97
....................                  DpHGreenRaw = tempvarint; 
07E7E:  MOVFF  797,2C1
07E82:  MOVFF  796,2C0
07E86:  MOVLB  0
....................             } 
....................         //BLUE 
....................             if ((rec_buffer[33] != 0xFF) && (rec_buffer[34] != 0xFF)) 
07E88:  INCFSZ x86,W
07E8A:  BRA    7E8E
07E8C:  BRA    7EBC
07E8E:  INCFSZ x87,W
07E90:  BRA    7E94
07E92:  BRA    7EBC
....................             { 
....................                  tempvarint = rec_buffer[33]; 
07E94:  MOVLB  7
07E96:  CLRF   x97
07E98:  MOVFF  86,796
....................                  tempvarint = tempvarint*256 + rec_buffer[34]; 
07E9C:  MOVFF  796,799
07EA0:  CLRF   x98
07EA2:  MOVLB  0
07EA4:  MOVF   x87,W
07EA6:  MOVLB  7
07EA8:  ADDWF  x98,W
07EAA:  MOVWF  x96
07EAC:  MOVLW  00
07EAE:  ADDWFC x99,W
07EB0:  MOVWF  x97
....................                  DpHBlueRaw = tempvarint; 
07EB2:  MOVFF  797,2C3
07EB6:  MOVFF  796,2C2
07EBA:  MOVLB  0
....................             }  
....................         //WHITE 
....................             if ((rec_buffer[35] != 0xFF) && (rec_buffer[36] != 0xFF)) 
07EBC:  INCFSZ x88,W
07EBE:  BRA    7EC2
07EC0:  BRA    7EF0
07EC2:  INCFSZ x89,W
07EC4:  BRA    7EC8
07EC6:  BRA    7EF0
....................             { 
....................                  tempvarint = rec_buffer[35]; 
07EC8:  MOVLB  7
07ECA:  CLRF   x97
07ECC:  MOVFF  88,796
....................                  tempvarint = tempvarint*256 + rec_buffer[36]; 
07ED0:  MOVFF  796,799
07ED4:  CLRF   x98
07ED6:  MOVLB  0
07ED8:  MOVF   x89,W
07EDA:  MOVLB  7
07EDC:  ADDWF  x98,W
07EDE:  MOVWF  x96
07EE0:  MOVLW  00
07EE2:  ADDWFC x99,W
07EE4:  MOVWF  x97
....................                 DpHWhiteRaw = tempvarint; 
07EE6:  MOVFF  797,2C5
07EEA:  MOVFF  796,2C4
07EEE:  MOVLB  0
....................             }            
07EF0:  RETURN 0
....................          
....................          
....................         }     
....................          
....................      
....................      
.................... //****************************************************************************** 
.................... // Created November 24, 2016 
.................... // Calibrations Data is sent to the remote unit.  Another routine call this routine. 
.................... // Data input: 
.................... // int DeviceSelected  -- this is the IO port 
.................... // int VariableIDNumber  -- this is the same on the receiving device.  This is defined here 
.................... // int Variable Length 
.................... // pointer to the Variable  -- this is used to send the data to the remote device.  Characters are not sent to the remote device, but data 
.................... // Returned data: 
.................... // A 0 is returned if all is well.  A 1 is returned if it did not hear it. 
.................... // Each calibration number is sent with an address and pointer.  There is no dump of multi cal numbers.   
.................... //******************************************************************************* 
.................... int sendConfigData(int deviceaddress, int8 VarIDNumber)  
.................... { 
....................        int x; 
....................        unsigned int8 *data; 
....................        unsigned char length; 
....................  
....................     //  Selection of 0  internal Digital DO and NH4 sensor 
....................     //  Selection of 1  Top RJ45 connector 
....................     //  Selection of 2  Bottom RJ45 connector     
....................     //  Selection of 3  no connection 
....................             selectsensor(deviceaddress);  // this sets the SCL to the right I2C device. 
*
085DC:  MOVFF  770,7B4
085E0:  CALL   35F6
....................   
....................              
....................     	    i2c_start(PH_LIGHT); 
085E4:  BSF    F93.0
085E6:  MOVLW  50
085E8:  MOVWF  00
085EA:  DECFSZ 00,F
085EC:  BRA    85EA
085EE:  BSF    F93.1
085F0:  MOVLW  51
085F2:  MOVWF  00
085F4:  DECFSZ 00,F
085F6:  BRA    85F4
085F8:  BCF    F8A.0
085FA:  BCF    F93.0
085FC:  MOVLW  50
085FE:  MOVWF  00
08600:  DECFSZ 00,F
08602:  BRA    8600
08604:  BCF    F8A.1
08606:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0xa0);  //Move the address number left on and add a zero.  This is the command with address to write data to the address pointer 
08608:  MOVLW  A0
0860A:  MOVLB  7
0860C:  MOVWF  xB4
0860E:  MOVLB  0
08610:  CALL   363A
.................... 			i2c_write(PH_LIGHT,VarIDNumber);  //This is the locations of the first buffer to address 
08614:  MOVFF  771,7B4
08618:  CALL   363A
....................             length = sizeof(sysInput.nh4pt1cal1of3); 
0861C:  MOVLW  02
0861E:  MOVLB  7
08620:  MOVWF  x75
....................             data = &sysInput.nh4pt1cal1of3; 
08622:  MOVWF  x74
08624:  MOVLW  3F
08626:  MOVWF  x73
....................             while (length--) { 
08628:  MOVF   x75,W
0862A:  DECF   x75,F
0862C:  XORLW  00
0862E:  BZ    8650
....................                i2c_write(PH_LIGHT, *data++); 
08630:  MOVFF  774,03
08634:  MOVF   x73,W
08636:  INCF   x73,F
08638:  BTFSC  FD8.2
0863A:  INCF   x74,F
0863C:  MOVWF  FE9
0863E:  MOVFF  03,FEA
08642:  MOVFF  FEF,7B4
08646:  MOVLB  0
08648:  CALL   363A
0864C:  MOVLB  7
0864E:  BRA    8628
....................                 }  
....................             length = sizeof(sysInput.nh4pt1cal2of3); 
08650:  MOVLW  02
08652:  MOVWF  x75
....................             data = &sysInput.nh4pt1cal2of3; 
08654:  MOVWF  x74
08656:  MOVLW  41
08658:  MOVWF  x73
....................             while (length--) { 
0865A:  MOVF   x75,W
0865C:  DECF   x75,F
0865E:  XORLW  00
08660:  BZ    8682
....................                i2c_write(PH_LIGHT, *data++); 
08662:  MOVFF  774,03
08666:  MOVF   x73,W
08668:  INCF   x73,F
0866A:  BTFSC  FD8.2
0866C:  INCF   x74,F
0866E:  MOVWF  FE9
08670:  MOVFF  03,FEA
08674:  MOVFF  FEF,7B4
08678:  MOVLB  0
0867A:  CALL   363A
0867E:  MOVLB  7
08680:  BRA    865A
....................                 }  
....................             length = sizeof(sysInput.nh4pt1cal3of3); 
08682:  MOVLW  02
08684:  MOVWF  x75
....................             data = &sysInput.nh4pt1cal3of3; 
08686:  MOVWF  x74
08688:  MOVLW  43
0868A:  MOVWF  x73
....................             while (length--) { 
0868C:  MOVF   x75,W
0868E:  DECF   x75,F
08690:  XORLW  00
08692:  BZ    86B4
....................                i2c_write(PH_LIGHT, *data++); 
08694:  MOVFF  774,03
08698:  MOVF   x73,W
0869A:  INCF   x73,F
0869C:  BTFSC  FD8.2
0869E:  INCF   x74,F
086A0:  MOVWF  FE9
086A2:  MOVFF  03,FEA
086A6:  MOVFF  FEF,7B4
086AA:  MOVLB  0
086AC:  CALL   363A
086B0:  MOVLB  7
086B2:  BRA    868C
....................                 }  
....................             length = sizeof(sysInput.nh4pt2cal1of3); 
086B4:  MOVLW  02
086B6:  MOVWF  x75
....................             data = &sysInput.nh4pt2cal1of3; 
086B8:  MOVWF  x74
086BA:  MOVLW  45
086BC:  MOVWF  x73
....................             while (length--) { 
086BE:  MOVF   x75,W
086C0:  DECF   x75,F
086C2:  XORLW  00
086C4:  BZ    86E6
....................                i2c_write(PH_LIGHT, *data++); 
086C6:  MOVFF  774,03
086CA:  MOVF   x73,W
086CC:  INCF   x73,F
086CE:  BTFSC  FD8.2
086D0:  INCF   x74,F
086D2:  MOVWF  FE9
086D4:  MOVFF  03,FEA
086D8:  MOVFF  FEF,7B4
086DC:  MOVLB  0
086DE:  CALL   363A
086E2:  MOVLB  7
086E4:  BRA    86BE
....................                 }  
....................             length = sizeof(sysInput.nh4pt2cal2of3); 
086E6:  MOVLW  02
086E8:  MOVWF  x75
....................             data = &sysInput.nh4pt2cal2of3; 
086EA:  MOVWF  x74
086EC:  MOVLW  47
086EE:  MOVWF  x73
....................             while (length--) { 
086F0:  MOVF   x75,W
086F2:  DECF   x75,F
086F4:  XORLW  00
086F6:  BZ    8718
....................                i2c_write(PH_LIGHT, *data++); 
086F8:  MOVFF  774,03
086FC:  MOVF   x73,W
086FE:  INCF   x73,F
08700:  BTFSC  FD8.2
08702:  INCF   x74,F
08704:  MOVWF  FE9
08706:  MOVFF  03,FEA
0870A:  MOVFF  FEF,7B4
0870E:  MOVLB  0
08710:  CALL   363A
08714:  MOVLB  7
08716:  BRA    86F0
....................                 }      
....................             length = sizeof(sysInput.nh4pt2cal3of3); 
08718:  MOVLW  02
0871A:  MOVWF  x75
....................             data = &sysInput.nh4pt2cal3of3; 
0871C:  MOVWF  x74
0871E:  MOVLW  49
08720:  MOVWF  x73
....................             while (length--) { 
08722:  MOVF   x75,W
08724:  DECF   x75,F
08726:  XORLW  00
08728:  BZ    874A
....................                i2c_write(PH_LIGHT, *data++); 
0872A:  MOVFF  774,03
0872E:  MOVF   x73,W
08730:  INCF   x73,F
08732:  BTFSC  FD8.2
08734:  INCF   x74,F
08736:  MOVWF  FE9
08738:  MOVFF  03,FEA
0873C:  MOVFF  FEF,7B4
08740:  MOVLB  0
08742:  CALL   363A
08746:  MOVLB  7
08748:  BRA    8722
....................                 }  
....................             length = sizeof(sysInput.nh4pt3cal1of3); 
0874A:  MOVLW  02
0874C:  MOVWF  x75
....................             data = &sysInput.nh4pt3cal1of3; 
0874E:  MOVWF  x74
08750:  MOVLW  4B
08752:  MOVWF  x73
....................             while (length--) { 
08754:  MOVF   x75,W
08756:  DECF   x75,F
08758:  XORLW  00
0875A:  BZ    877C
....................                i2c_write(PH_LIGHT, *data++); 
0875C:  MOVFF  774,03
08760:  MOVF   x73,W
08762:  INCF   x73,F
08764:  BTFSC  FD8.2
08766:  INCF   x74,F
08768:  MOVWF  FE9
0876A:  MOVFF  03,FEA
0876E:  MOVFF  FEF,7B4
08772:  MOVLB  0
08774:  CALL   363A
08778:  MOVLB  7
0877A:  BRA    8754
....................                 }  
....................             length = sizeof(sysInput.nh4pt3cal2of3); 
0877C:  MOVLW  02
0877E:  MOVWF  x75
....................             data = &sysInput.nh4pt3cal2of3; 
08780:  MOVWF  x74
08782:  MOVLW  4D
08784:  MOVWF  x73
....................             while (length--) { 
08786:  MOVF   x75,W
08788:  DECF   x75,F
0878A:  XORLW  00
0878C:  BZ    87AE
....................                i2c_write(PH_LIGHT, *data++); 
0878E:  MOVFF  774,03
08792:  MOVF   x73,W
08794:  INCF   x73,F
08796:  BTFSC  FD8.2
08798:  INCF   x74,F
0879A:  MOVWF  FE9
0879C:  MOVFF  03,FEA
087A0:  MOVFF  FEF,7B4
087A4:  MOVLB  0
087A6:  CALL   363A
087AA:  MOVLB  7
087AC:  BRA    8786
....................                 }      
....................             length = sizeof(sysInput.nh4pt3cal3of3); 
087AE:  MOVLW  02
087B0:  MOVWF  x75
....................             data = &sysInput.nh4pt3cal1of3; 
087B2:  MOVWF  x74
087B4:  MOVLW  4B
087B6:  MOVWF  x73
....................             while (length--) { 
087B8:  MOVF   x75,W
087BA:  DECF   x75,F
087BC:  XORLW  00
087BE:  BZ    87E0
....................                i2c_write(PH_LIGHT, *data++); 
087C0:  MOVFF  774,03
087C4:  MOVF   x73,W
087C6:  INCF   x73,F
087C8:  BTFSC  FD8.2
087CA:  INCF   x74,F
087CC:  MOVWF  FE9
087CE:  MOVFF  03,FEA
087D2:  MOVFF  FEF,7B4
087D6:  MOVLB  0
087D8:  CALL   363A
087DC:  MOVLB  7
087DE:  BRA    87B8
....................                 }  
....................              
....................             
....................              
....................             length = sizeof(sysInput.nh4pt1returnednumber); 
087E0:  MOVLW  04
087E2:  MOVWF  x75
....................             data = &sysInput.nh4pt1returnednumber; 
087E4:  MOVLW  02
087E6:  MOVWF  x74
087E8:  MOVLW  51
087EA:  MOVWF  x73
....................             while (length--) { 
087EC:  MOVF   x75,W
087EE:  DECF   x75,F
087F0:  XORLW  00
087F2:  BZ    8814
....................                i2c_write(PH_LIGHT, *data++); 
087F4:  MOVFF  774,03
087F8:  MOVF   x73,W
087FA:  INCF   x73,F
087FC:  BTFSC  FD8.2
087FE:  INCF   x74,F
08800:  MOVWF  FE9
08802:  MOVFF  03,FEA
08806:  MOVFF  FEF,7B4
0880A:  MOVLB  0
0880C:  CALL   363A
08810:  MOVLB  7
08812:  BRA    87EC
....................                 }  
....................             length = sizeof(sysInput.nh4pt2returnednumber); 
08814:  MOVLW  04
08816:  MOVWF  x75
....................             data = &sysInput.nh4pt2returnednumber; 
08818:  MOVLW  02
0881A:  MOVWF  x74
0881C:  MOVLW  55
0881E:  MOVWF  x73
....................             while (length--) { 
08820:  MOVF   x75,W
08822:  DECF   x75,F
08824:  XORLW  00
08826:  BZ    8848
....................                i2c_write(PH_LIGHT, *data++); 
08828:  MOVFF  774,03
0882C:  MOVF   x73,W
0882E:  INCF   x73,F
08830:  BTFSC  FD8.2
08832:  INCF   x74,F
08834:  MOVWF  FE9
08836:  MOVFF  03,FEA
0883A:  MOVFF  FEF,7B4
0883E:  MOVLB  0
08840:  CALL   363A
08844:  MOVLB  7
08846:  BRA    8820
....................                 }  
....................             length = sizeof(sysInput.nh4pt3returnednumber); 
08848:  MOVLW  04
0884A:  MOVWF  x75
....................             data = &sysInput.nh4pt3returnednumber; 
0884C:  MOVLW  02
0884E:  MOVWF  x74
08850:  MOVLW  59
08852:  MOVWF  x73
....................             while (length--) { 
08854:  MOVF   x75,W
08856:  DECF   x75,F
08858:  XORLW  00
0885A:  BZ    887C
....................                i2c_write(PH_LIGHT, *data++); 
0885C:  MOVFF  774,03
08860:  MOVF   x73,W
08862:  INCF   x73,F
08864:  BTFSC  FD8.2
08866:  INCF   x74,F
08868:  MOVWF  FE9
0886A:  MOVFF  03,FEA
0886E:  MOVFF  FEF,7B4
08872:  MOVLB  0
08874:  CALL   363A
08878:  MOVLB  7
0887A:  BRA    8854
....................                 }  
....................              
....................              
....................              
....................             // this is sending all of the DO stuff 
....................              
....................             length = sizeof(sysInput.DOpt1cal1of3); 
0887C:  MOVLW  02
0887E:  MOVWF  x75
....................             data = &sysInput.DOpt1cal1of3; 
08880:  MOVWF  x74
08882:  MOVLW  5D
08884:  MOVWF  x73
....................             while (length--) { 
08886:  MOVF   x75,W
08888:  DECF   x75,F
0888A:  XORLW  00
0888C:  BZ    88AE
....................                i2c_write(PH_LIGHT, *data++); 
0888E:  MOVFF  774,03
08892:  MOVF   x73,W
08894:  INCF   x73,F
08896:  BTFSC  FD8.2
08898:  INCF   x74,F
0889A:  MOVWF  FE9
0889C:  MOVFF  03,FEA
088A0:  MOVFF  FEF,7B4
088A4:  MOVLB  0
088A6:  CALL   363A
088AA:  MOVLB  7
088AC:  BRA    8886
....................                 }  
....................             length = sizeof(sysInput.DOpt1cal2of3); 
088AE:  MOVLW  02
088B0:  MOVWF  x75
....................             data = &sysInput.DOpt1cal2of3; 
088B2:  MOVWF  x74
088B4:  MOVLW  5F
088B6:  MOVWF  x73
....................             while (length--) { 
088B8:  MOVF   x75,W
088BA:  DECF   x75,F
088BC:  XORLW  00
088BE:  BZ    88E0
....................                i2c_write(PH_LIGHT, *data++); 
088C0:  MOVFF  774,03
088C4:  MOVF   x73,W
088C6:  INCF   x73,F
088C8:  BTFSC  FD8.2
088CA:  INCF   x74,F
088CC:  MOVWF  FE9
088CE:  MOVFF  03,FEA
088D2:  MOVFF  FEF,7B4
088D6:  MOVLB  0
088D8:  CALL   363A
088DC:  MOVLB  7
088DE:  BRA    88B8
....................                 }  
....................             length = sizeof(sysInput.DOpt1cal3of3); 
088E0:  MOVLW  02
088E2:  MOVWF  x75
....................             data = &sysInput.DOpt1cal3of3; 
088E4:  MOVWF  x74
088E6:  MOVLW  61
088E8:  MOVWF  x73
....................             while (length--) { 
088EA:  MOVF   x75,W
088EC:  DECF   x75,F
088EE:  XORLW  00
088F0:  BZ    8912
....................                i2c_write(PH_LIGHT, *data++); 
088F2:  MOVFF  774,03
088F6:  MOVF   x73,W
088F8:  INCF   x73,F
088FA:  BTFSC  FD8.2
088FC:  INCF   x74,F
088FE:  MOVWF  FE9
08900:  MOVFF  03,FEA
08904:  MOVFF  FEF,7B4
08908:  MOVLB  0
0890A:  CALL   363A
0890E:  MOVLB  7
08910:  BRA    88EA
....................                 }  
....................             length = sizeof(sysInput.DOpt2cal1of3); 
08912:  MOVLW  02
08914:  MOVWF  x75
....................             data = &sysInput.DOpt2cal2of3; 
08916:  MOVWF  x74
08918:  MOVLW  65
0891A:  MOVWF  x73
....................             while (length--) { 
0891C:  MOVF   x75,W
0891E:  DECF   x75,F
08920:  XORLW  00
08922:  BZ    8944
....................                i2c_write(PH_LIGHT, *data++); 
08924:  MOVFF  774,03
08928:  MOVF   x73,W
0892A:  INCF   x73,F
0892C:  BTFSC  FD8.2
0892E:  INCF   x74,F
08930:  MOVWF  FE9
08932:  MOVFF  03,FEA
08936:  MOVFF  FEF,7B4
0893A:  MOVLB  0
0893C:  CALL   363A
08940:  MOVLB  7
08942:  BRA    891C
....................                 }  
....................             length = sizeof(sysInput.DOpt2cal2of3); 
08944:  MOVLW  02
08946:  MOVWF  x75
....................             data = &sysInput.DOpt2cal2of3; 
08948:  MOVWF  x74
0894A:  MOVLW  65
0894C:  MOVWF  x73
....................             while (length--) { 
0894E:  MOVF   x75,W
08950:  DECF   x75,F
08952:  XORLW  00
08954:  BZ    8976
....................                i2c_write(PH_LIGHT, *data++); 
08956:  MOVFF  774,03
0895A:  MOVF   x73,W
0895C:  INCF   x73,F
0895E:  BTFSC  FD8.2
08960:  INCF   x74,F
08962:  MOVWF  FE9
08964:  MOVFF  03,FEA
08968:  MOVFF  FEF,7B4
0896C:  MOVLB  0
0896E:  CALL   363A
08972:  MOVLB  7
08974:  BRA    894E
....................                 }      
....................             length = sizeof(sysInput.DOpt2cal3of3); 
08976:  MOVLW  02
08978:  MOVWF  x75
....................             data = &sysInput.DOpt2cal3of3; 
0897A:  MOVWF  x74
0897C:  MOVLW  67
0897E:  MOVWF  x73
....................             while (length--) { 
08980:  MOVF   x75,W
08982:  DECF   x75,F
08984:  XORLW  00
08986:  BZ    89A8
....................                i2c_write(PH_LIGHT, *data++); 
08988:  MOVFF  774,03
0898C:  MOVF   x73,W
0898E:  INCF   x73,F
08990:  BTFSC  FD8.2
08992:  INCF   x74,F
08994:  MOVWF  FE9
08996:  MOVFF  03,FEA
0899A:  MOVFF  FEF,7B4
0899E:  MOVLB  0
089A0:  CALL   363A
089A4:  MOVLB  7
089A6:  BRA    8980
....................                 }  
....................             length = sizeof(sysInput.DOpt3cal1of3); 
089A8:  MOVLW  02
089AA:  MOVWF  x75
....................             data = &sysInput.DOpt3cal1of3; 
089AC:  MOVWF  x74
089AE:  MOVLW  69
089B0:  MOVWF  x73
....................             while (length--) { 
089B2:  MOVF   x75,W
089B4:  DECF   x75,F
089B6:  XORLW  00
089B8:  BZ    89DA
....................                i2c_write(PH_LIGHT, *data++); 
089BA:  MOVFF  774,03
089BE:  MOVF   x73,W
089C0:  INCF   x73,F
089C2:  BTFSC  FD8.2
089C4:  INCF   x74,F
089C6:  MOVWF  FE9
089C8:  MOVFF  03,FEA
089CC:  MOVFF  FEF,7B4
089D0:  MOVLB  0
089D2:  CALL   363A
089D6:  MOVLB  7
089D8:  BRA    89B2
....................                 }  
....................             length = sizeof(sysInput.DOpt3cal2of3); 
089DA:  MOVLW  02
089DC:  MOVWF  x75
....................             data = &sysInput.DOpt3cal2of3; 
089DE:  MOVWF  x74
089E0:  MOVLW  6B
089E2:  MOVWF  x73
....................             while (length--) { 
089E4:  MOVF   x75,W
089E6:  DECF   x75,F
089E8:  XORLW  00
089EA:  BZ    8A0C
....................                i2c_write(PH_LIGHT, *data++); 
089EC:  MOVFF  774,03
089F0:  MOVF   x73,W
089F2:  INCF   x73,F
089F4:  BTFSC  FD8.2
089F6:  INCF   x74,F
089F8:  MOVWF  FE9
089FA:  MOVFF  03,FEA
089FE:  MOVFF  FEF,7B4
08A02:  MOVLB  0
08A04:  CALL   363A
08A08:  MOVLB  7
08A0A:  BRA    89E4
....................                 }      
....................             length = sizeof(sysInput.DOpt3cal3of3); 
08A0C:  MOVLW  02
08A0E:  MOVWF  x75
....................             data = &sysInput.DOpt3cal3of3; 
08A10:  MOVWF  x74
08A12:  MOVLW  6D
08A14:  MOVWF  x73
....................             while (length--) { 
08A16:  MOVF   x75,W
08A18:  DECF   x75,F
08A1A:  XORLW  00
08A1C:  BZ    8A3E
....................                i2c_write(PH_LIGHT, *data++); 
08A1E:  MOVFF  774,03
08A22:  MOVF   x73,W
08A24:  INCF   x73,F
08A26:  BTFSC  FD8.2
08A28:  INCF   x74,F
08A2A:  MOVWF  FE9
08A2C:  MOVFF  03,FEA
08A30:  MOVFF  FEF,7B4
08A34:  MOVLB  0
08A36:  CALL   363A
08A3A:  MOVLB  7
08A3C:  BRA    8A16
....................                 }  
....................              
....................             
....................              
....................             length = sizeof(sysInput.DOpt1returnednumber); 
08A3E:  MOVLW  04
08A40:  MOVWF  x75
....................             data = &sysInput.nh4pt1returnednumber; 
08A42:  MOVLW  02
08A44:  MOVWF  x74
08A46:  MOVLW  51
08A48:  MOVWF  x73
....................             while (length--) { 
08A4A:  MOVF   x75,W
08A4C:  DECF   x75,F
08A4E:  XORLW  00
08A50:  BZ    8A72
....................                i2c_write(PH_LIGHT, *data++); 
08A52:  MOVFF  774,03
08A56:  MOVF   x73,W
08A58:  INCF   x73,F
08A5A:  BTFSC  FD8.2
08A5C:  INCF   x74,F
08A5E:  MOVWF  FE9
08A60:  MOVFF  03,FEA
08A64:  MOVFF  FEF,7B4
08A68:  MOVLB  0
08A6A:  CALL   363A
08A6E:  MOVLB  7
08A70:  BRA    8A4A
....................                 }  
....................             length = sizeof(sysInput.DOpt2returnednumber); 
08A72:  MOVLW  04
08A74:  MOVWF  x75
....................             data = &sysInput.nh4pt2returnednumber; 
08A76:  MOVLW  02
08A78:  MOVWF  x74
08A7A:  MOVLW  55
08A7C:  MOVWF  x73
....................             while (length--) { 
08A7E:  MOVF   x75,W
08A80:  DECF   x75,F
08A82:  XORLW  00
08A84:  BZ    8AA6
....................                i2c_write(PH_LIGHT, *data++); 
08A86:  MOVFF  774,03
08A8A:  MOVF   x73,W
08A8C:  INCF   x73,F
08A8E:  BTFSC  FD8.2
08A90:  INCF   x74,F
08A92:  MOVWF  FE9
08A94:  MOVFF  03,FEA
08A98:  MOVFF  FEF,7B4
08A9C:  MOVLB  0
08A9E:  CALL   363A
08AA2:  MOVLB  7
08AA4:  BRA    8A7E
....................                 }  
....................             length = sizeof(sysInput.DOpt3returnednumber); 
08AA6:  MOVLW  04
08AA8:  MOVWF  x75
....................             data = &sysInput.nh4pt3returnednumber; 
08AAA:  MOVLW  02
08AAC:  MOVWF  x74
08AAE:  MOVLW  59
08AB0:  MOVWF  x73
....................             while (length--) { 
08AB2:  MOVF   x75,W
08AB4:  DECF   x75,F
08AB6:  XORLW  00
08AB8:  BZ    8ADA
....................                i2c_write(PH_LIGHT, *data++); 
08ABA:  MOVFF  774,03
08ABE:  MOVF   x73,W
08AC0:  INCF   x73,F
08AC2:  BTFSC  FD8.2
08AC4:  INCF   x74,F
08AC6:  MOVWF  FE9
08AC8:  MOVFF  03,FEA
08ACC:  MOVFF  FEF,7B4
08AD0:  MOVLB  0
08AD2:  CALL   363A
08AD6:  MOVLB  7
08AD8:  BRA    8AB2
....................                 }         
....................          
....................              
....................             // This is the therimister stuff 
....................              
....................              
....................             length = sizeof(sysInput.Thermisterpt1cal1of3); 
08ADA:  MOVLW  02
08ADC:  MOVWF  x75
....................             data = &sysInput.Thermisterpt1cal1of3; 
08ADE:  MOVWF  x74
08AE0:  MOVLW  7B
08AE2:  MOVWF  x73
....................             while (length--) { 
08AE4:  MOVF   x75,W
08AE6:  DECF   x75,F
08AE8:  XORLW  00
08AEA:  BZ    8B0C
....................                i2c_write(PH_LIGHT, *data++); 
08AEC:  MOVFF  774,03
08AF0:  MOVF   x73,W
08AF2:  INCF   x73,F
08AF4:  BTFSC  FD8.2
08AF6:  INCF   x74,F
08AF8:  MOVWF  FE9
08AFA:  MOVFF  03,FEA
08AFE:  MOVFF  FEF,7B4
08B02:  MOVLB  0
08B04:  CALL   363A
08B08:  MOVLB  7
08B0A:  BRA    8AE4
....................                 }  
....................             length = sizeof(sysInput.Thermisterpt1cal2of3); 
08B0C:  MOVLW  02
08B0E:  MOVWF  x75
....................             data = &sysInput.Thermisterpt1cal2of3; 
08B10:  MOVWF  x74
08B12:  MOVLW  7D
08B14:  MOVWF  x73
....................             while (length--) { 
08B16:  MOVF   x75,W
08B18:  DECF   x75,F
08B1A:  XORLW  00
08B1C:  BZ    8B3E
....................                i2c_write(PH_LIGHT, *data++); 
08B1E:  MOVFF  774,03
08B22:  MOVF   x73,W
08B24:  INCF   x73,F
08B26:  BTFSC  FD8.2
08B28:  INCF   x74,F
08B2A:  MOVWF  FE9
08B2C:  MOVFF  03,FEA
08B30:  MOVFF  FEF,7B4
08B34:  MOVLB  0
08B36:  CALL   363A
08B3A:  MOVLB  7
08B3C:  BRA    8B16
....................                 }      
....................             length = sizeof(sysInput.Thermisterpt1cal3of3); 
08B3E:  MOVLW  02
08B40:  MOVWF  x75
....................             data = &sysInput.Thermisterpt1cal3of3; 
08B42:  MOVWF  x74
08B44:  MOVLW  7F
08B46:  MOVWF  x73
....................             while (length--) { 
08B48:  MOVF   x75,W
08B4A:  DECF   x75,F
08B4C:  XORLW  00
08B4E:  BZ    8B70
....................                i2c_write(PH_LIGHT, *data++); 
08B50:  MOVFF  774,03
08B54:  MOVF   x73,W
08B56:  INCF   x73,F
08B58:  BTFSC  FD8.2
08B5A:  INCF   x74,F
08B5C:  MOVWF  FE9
08B5E:  MOVFF  03,FEA
08B62:  MOVFF  FEF,7B4
08B66:  MOVLB  0
08B68:  CALL   363A
08B6C:  MOVLB  7
08B6E:  BRA    8B48
....................                 }  
....................              
....................              
....................                length = sizeof(sysInput.Thermisterpt1returnednumber); 
08B70:  MOVLW  04
08B72:  MOVWF  x75
....................             data = &sysInput.Thermisterpt1returnednumber; 
08B74:  MOVLW  02
08B76:  MOVWF  x74
08B78:  MOVLW  81
08B7A:  MOVWF  x73
....................             while (length--) { 
08B7C:  MOVF   x75,W
08B7E:  DECF   x75,F
08B80:  XORLW  00
08B82:  BZ    8BA4
....................                i2c_write(PH_LIGHT, *data++); 
08B84:  MOVFF  774,03
08B88:  MOVF   x73,W
08B8A:  INCF   x73,F
08B8C:  BTFSC  FD8.2
08B8E:  INCF   x74,F
08B90:  MOVWF  FE9
08B92:  MOVFF  03,FEA
08B96:  MOVFF  FEF,7B4
08B9A:  MOVLB  0
08B9C:  CALL   363A
08BA0:  MOVLB  7
08BA2:  BRA    8B7C
....................                 }  
....................             length = sizeof(sysInput.Thermisterpt2returnednumber); 
08BA4:  MOVLW  04
08BA6:  MOVWF  x75
....................             data = &sysInput.Thermisterpt2returnednumber; 
08BA8:  MOVLW  02
08BAA:  MOVWF  x74
08BAC:  MOVLW  85
08BAE:  MOVWF  x73
....................             while (length--) { 
08BB0:  MOVF   x75,W
08BB2:  DECF   x75,F
08BB4:  XORLW  00
08BB6:  BZ    8BD8
....................                i2c_write(PH_LIGHT, *data++); 
08BB8:  MOVFF  774,03
08BBC:  MOVF   x73,W
08BBE:  INCF   x73,F
08BC0:  BTFSC  FD8.2
08BC2:  INCF   x74,F
08BC4:  MOVWF  FE9
08BC6:  MOVFF  03,FEA
08BCA:  MOVFF  FEF,7B4
08BCE:  MOVLB  0
08BD0:  CALL   363A
08BD4:  MOVLB  7
08BD6:  BRA    8BB0
....................                 }  
....................             length = sizeof(sysInput.Thermisterpt3returnednumber); 
08BD8:  MOVLW  04
08BDA:  MOVWF  x75
....................             data = &sysInput.Thermisterpt3returnednumber; 
08BDC:  MOVLW  02
08BDE:  MOVWF  x74
08BE0:  MOVLW  89
08BE2:  MOVWF  x73
....................             while (length--) { 
08BE4:  MOVF   x75,W
08BE6:  DECF   x75,F
08BE8:  XORLW  00
08BEA:  BZ    8C0C
....................                i2c_write(PH_LIGHT, *data++); 
08BEC:  MOVFF  774,03
08BF0:  MOVF   x73,W
08BF2:  INCF   x73,F
08BF4:  BTFSC  FD8.2
08BF6:  INCF   x74,F
08BF8:  MOVWF  FE9
08BFA:  MOVFF  03,FEA
08BFE:  MOVFF  FEF,7B4
08C02:  MOVLB  0
08C04:  CALL   363A
08C08:  MOVLB  7
08C0A:  BRA    8BE4
....................                 }           
....................              
....................       //  this is where additional calibrations are added.  It has to be before the stop and the last I2C write to trigger the receiving unit for saving data. 
.................... 			i2c_stop(PH_LIGHT); 
08C0C:  BCF    F93.0
08C0E:  NOP   
08C10:  BSF    F93.1
08C12:  BTFSS  F81.1
08C14:  BRA    8C12
08C16:  MOVLW  50
08C18:  MOVWF  00
08C1A:  DECFSZ 00,F
08C1C:  BRA    8C1A
08C1E:  BRA    8C20
08C20:  NOP   
08C22:  BSF    F93.0
08C24:  MOVLW  50
08C26:  MOVWF  00
08C28:  DECFSZ 00,F
08C2A:  BRA    8C28
....................              
....................     	    i2c_start(PH_LIGHT); 
08C2C:  BSF    F93.0
08C2E:  MOVLW  50
08C30:  MOVWF  00
08C32:  DECFSZ 00,F
08C34:  BRA    8C32
08C36:  BSF    F93.1
08C38:  MOVLW  51
08C3A:  MOVWF  00
08C3C:  DECFSZ 00,F
08C3E:  BRA    8C3C
08C40:  BCF    F8A.0
08C42:  BCF    F93.0
08C44:  MOVLW  50
08C46:  MOVWF  00
08C48:  DECFSZ 00,F
08C4A:  BRA    8C48
08C4C:  BCF    F8A.1
08C4E:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0xa0);  //Move the address number left on and add a zero.  This is the command with address to write data to the address pointer 
08C50:  MOVLW  A0
08C52:  MOVWF  xB4
08C54:  MOVLB  0
08C56:  CALL   363A
.................... 			i2c_write(PH_LIGHT,0x02);  //This is the locations of the first buffer to address            
08C5A:  MOVLW  02
08C5C:  MOVLB  7
08C5E:  MOVWF  xB4
08C60:  MOVLB  0
08C62:  CALL   363A
.................... 			i2c_write(PH_LIGHT,0x01);  //Set this location (0x02) to 1 to tell the receiver that all calibrations are uploaded and ready for EEPROMing.            
08C66:  MOVLW  01
08C68:  MOVLB  7
08C6A:  MOVWF  xB4
08C6C:  MOVLB  0
08C6E:  CALL   363A
....................  			i2c_stop(PH_LIGHT);            
08C72:  BCF    F93.0
08C74:  NOP   
08C76:  BSF    F93.1
08C78:  BTFSS  F81.1
08C7A:  BRA    8C78
08C7C:  MOVLW  50
08C7E:  MOVWF  00
08C80:  DECFSZ 00,F
08C82:  BRA    8C80
08C84:  BRA    8C86
08C86:  NOP   
08C88:  BSF    F93.0
08C8A:  MOVLW  50
08C8C:  MOVWF  00
08C8E:  DECFSZ 00,F
08C90:  BRA    8C8E
....................              
....................      return(0);        
08C92:  MOVLW  00
08C94:  MOVWF  01
08C96:  GOTO   90E8 (RETURN)
.................... } 
....................      
....................     
....................          
....................  
.................... #include "G:\OsmobotLocalDisplay Via Bluetooth\BluetoothRoutines.c" 
....................  
.................... int8 parsebluetoothcommand(void); 
.................... int savelocalconfigurations(int16 selectitem); 
.................... int SaveConfiguration(void); 
.................... int debugnumber = 0;  //Added July 13, 2015.  It keeps the current state of the debug routine calls.  Default is zero; or not in debug/calibration mode. 
....................  
.................... int CurrentCommand; 
.................... char scr[64];  
.................... char SplitResult[30][11];  
.................... unsigned int8 CommandModeOrNot = 0;   //  this is used to echo characters back to the unit.   
.................... int passed = 0;  // this is the pass once through flag 
....................  
.................... #define VAR_NAMESFORSETTING 8     //Created July 22, 2015    This is the number of varaibles to be parsed for setting new values to. 
.................... #define BT_COMMAND_SIZE 11 
....................  
.................... unsigned char settingvariables[VAR_NAMESFORSETTING][BT_COMMAND_SIZE]= 
.................... { 
....................    "?",      //This is a BT HC-05 command response    Show all of the avaiable commands 
....................    "display",     //This turns on and off the toggle to display something on the VFD.   Added nov 22, 2016 
....................    "set",     //this is the returned address of a BT device 
....................    "default",     // this command sets the EEPROM to the default values for the calibrations and instrumenetations.  After a program, all of the eeproms are cleared 
....................    "showconfig",   // this displays all of the current values for configurations 
....................    "saveconfig",   // this saves the current calibration values in EEPROM 
....................    "update",       // this updates the remote unit with the current configurations 
....................    "rst"           // this restarts this unit.  not the remote 
.................... }; 
....................  
....................  
.................... #define BT_NUM_SUBCOMMANDS 34     //This needs to be updated to the next command when a command is added. 
....................  
....................  
.................... unsigned char bluetoothsecond[BT_NUM_SUBCOMMANDS][BT_COMMAND_SIZE]= 
.................... { 
....................    "pph",      //Option 1, position of the pH sensors.  It displays all of the light values. 
....................    "at",     //Show all data from all instruments 
....................    "do",      //   for DO 
....................    "ph",     // ph with bulb 
....................    "wd",  //Show the current water depth 
....................    "phbulb",   //Changed from -> This sets up the position for the DO light pipe.  This is changed to showing current reading of the ph bulb.  May 19, 2016 
....................    "clear",     ///Clears the selected display and sets everyuthing to zero 
....................    "lux",    //  this is the command used show the full command set for Bluetooth.  If this is not correct, it shows a "users" version.  Added Augest 17, 2015. 
....................    "ec",    //Returns constant readings from the ec measurement. 
....................    "co2",    // This starts the program to run the DO patch with decay 
....................    "wt",      // this displays the current water temperature 
....................    "par",     // this displays the current water temperature 
....................    "nh4",     // this displays the current ammonia in the water  Added Jan 19, 2016 
....................    "retnh41",   // 13  the return value of ammonia point 1  This is the low point for the analog nh4 probe 
....................    "retnh42",    // 14  the return value of ammonia point 2 
....................    "retnh43",   // 15  the return value of ammonia point 3  This is the high point for the analog nh4 probe 
....................    "nh4pt1",   // 16 this is the input calibrations for ammonia,  it is for variable  nh4pt1cal1of3   This is the low point for the analog nh4 probe 
....................    "nh4pt2",   // 17 this is the input calibrations for ammonia,  it is for variable  nh4pt1cal2of3  This is the high point for the analog nh4 probe 
....................    "nh4pt3",   // 18  this is the input calibrations for ammonia,  it is for variable  nh4pt1cal3of3 
....................    "nh4pt4",   // 19  this is the input calibrations for ammonia,  it is for variable  nh4pt2cal1of3 
....................    "nh4pt5",   // 20  this is the input calibrations for ammonia,  it is for variable  nh4pt2cal2of3 
....................    "nh4pt6",   // 21  this is the input calibrations for ammonia,  it is for variable  nh4pt2cal3of3 
....................    "nh4pt7",   // 22 this is the input calibrations for ammonia,  it is for variable  nh4pt3cal1of3 
....................    "nh4pt8",   // 23 this is the input calibrations for ammonia,  it is for variable  nh4pt3cal2of3 
....................    "nh4pt9",    // 24 this is the input calibrations for ammonia,  it is for variable  nh4pt3cal3of3 
....................    "DOpt1",    // 25 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt2",    // 26 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt3",    // 27 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt4",    // 28 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt5",    // 29 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt6",    // 30 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt7",    // 31 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt8",    // 32 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt9"    // 33 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
.................... }; 
....................  
.................... /* 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
.................... float eccal1x; 
.................... float eccal2x; 
.................... float eccal3x; 
.................... float eccal1y; 
.................... float eccal2y; 
.................... float eccal3y; 
....................                  */ 
....................  
.................... //************************************************************************************************************ 
.................... // Created March 25, 2015 
.................... // This is a general parsing routine where it takes a sting and seperates it into sections with a delimiter and an end of sting. 
.................... //  The parameters going into this routine are as follows: 
.................... //  String as a pointer 
.................... //  delimiter 
.................... //  endofstring 
.................... // The output is in some array I have not figured out yet. 
.................... //  Each Item can not be more than 20 characters long 
.................... //************************************************************************************************************ 
.................... void split(char *EndOfLine) 
*
04F46:  MOVLW  20
04F48:  MOVLB  7
04F4A:  MOVWF  x9B
.................... 	{ 
....................  
.................... int counter, row, letterlocation;   //This is the row for each item.  It is bumped up one when a delimieter is found.  letterlocation is the place where the cureent charater is saved. 
.................... char delimiter = ' '; 
.................... char  counter2,currentchar,endofchar, endoflinechar,junkcheck; 
.................... counter = 0;  //This is the start of the first location in the given string. 
04F4C:  CLRF   x98
.................... endoflinechar = EndOfLine[0]; 
04F4E:  MOVFF  796,FE9
04F52:  MOVFF  797,FEA
04F56:  MOVFF  FEF,79F
....................  
.................... for (row = 0; row < 30; row++) 
04F5A:  CLRF   x99
04F5C:  MOVF   x99,W
04F5E:  SUBLW  1D
04F60:  BTFSS  FD8.0
04F62:  BRA    5048
.................... 	{ 
.................... 	for (letterlocation=0; letterlocation < 30; letterlocation++) 
04F64:  CLRF   x9A
04F66:  MOVF   x9A,W
04F68:  SUBLW  1D
04F6A:  BNC   502A
.................... 		{ 
.................... 		counter2 = delimiter; 
04F6C:  MOVFF  79B,79C
.................... 		currentchar = scr[counter]; 
04F70:  CLRF   03
04F72:  MOVF   x98,W
04F74:  ADDLW  C8
04F76:  MOVWF  FE9
04F78:  MOVLW  02
04F7A:  ADDWFC 03,W
04F7C:  MOVWF  FEA
04F7E:  MOVFF  FEF,79D
.................... 		junkcheck = scr[counter]; 
04F82:  CLRF   03
04F84:  MOVF   x98,W
04F86:  ADDLW  C8
04F88:  MOVWF  FE9
04F8A:  MOVLW  02
04F8C:  ADDWFC 03,W
04F8E:  MOVWF  FEA
04F90:  MOVFF  FEF,7A0
.................... 		if (currentchar != counter2) 
04F94:  MOVF   x9C,W
04F96:  SUBWF  x9D,W
04F98:  BZ    4FF0
.................... 			{ 
....................             if (letterlocation < 11) 
04F9A:  MOVF   x9A,W
04F9C:  SUBLW  0A
04F9E:  BNC   4FEE
....................                { 
.................... 				SplitResult[row][letterlocation]=scr[counter]; 
04FA0:  CLRF   xB5
04FA2:  MOVFF  799,7B4
04FA6:  CLRF   xB7
04FA8:  MOVLW  0B
04FAA:  MOVWF  xB6
04FAC:  MOVLB  0
04FAE:  RCALL  4CE8
04FB0:  MOVFF  01,7A1
04FB4:  MOVLB  7
04FB6:  MOVF   x9A,W
04FB8:  ADDWF  01,W
04FBA:  MOVWF  01
04FBC:  MOVLW  00
04FBE:  ADDWFC 02,W
04FC0:  MOVWF  03
04FC2:  MOVF   01,W
04FC4:  ADDLW  08
04FC6:  MOVWF  01
04FC8:  MOVLW  03
04FCA:  ADDWFC 03,F
04FCC:  MOVFF  03,7A2
04FD0:  CLRF   03
04FD2:  MOVF   x98,W
04FD4:  ADDLW  C8
04FD6:  MOVWF  FE9
04FD8:  MOVLW  02
04FDA:  ADDWFC 03,W
04FDC:  MOVWF  FEA
04FDE:  MOVFF  FEF,7A3
04FE2:  MOVFF  7A2,FEA
04FE6:  MOVFF  01,FE9
04FEA:  MOVFF  7A3,FEF
....................                 } 
.................... 			} 
04FEE:  BRA    5024
.................... 			else 
.................... 			{ 
.................... 			SplitResult[row][letterlocation]=0x00; 
04FF0:  CLRF   xB5
04FF2:  MOVFF  799,7B4
04FF6:  CLRF   xB7
04FF8:  MOVLW  0B
04FFA:  MOVWF  xB6
04FFC:  MOVLB  0
04FFE:  RCALL  4CE8
05000:  MOVFF  01,7A1
05004:  MOVLB  7
05006:  MOVF   x9A,W
05008:  ADDWF  01,W
0500A:  MOVWF  01
0500C:  MOVLW  00
0500E:  ADDWFC 02,W
05010:  MOVWF  03
05012:  MOVF   01,W
05014:  ADDLW  08
05016:  MOVWF  FE9
05018:  MOVLW  03
0501A:  ADDWFC 03,W
0501C:  MOVWF  FEA
0501E:  CLRF   FEF
.................... 			counter++; 
05020:  INCF   x98,F
.................... 			break; 
05022:  BRA    502A
.................... 			} 
.................... 		counter++; 
05024:  INCF   x98,F
05026:  INCF   x9A,F
05028:  BRA    4F66
.................... 		} 
.................... 	endofchar = scr[counter]; 
0502A:  CLRF   03
0502C:  MOVF   x98,W
0502E:  ADDLW  C8
05030:  MOVWF  FE9
05032:  MOVLW  02
05034:  ADDWFC 03,W
05036:  MOVWF  FEA
05038:  MOVFF  FEF,79E
.................... 	if (endofchar == endoflinechar) 
0503C:  MOVF   x9F,W
0503E:  SUBWF  x9E,W
05040:  BNZ   5044
.................... 		{ 
.................... 		break; 
05042:  BRA    5048
.................... 		} 
05044:  INCF   x99,F
05046:  BRA    4F5C
.................... 	} 
05048:  MOVLB  0
0504A:  GOTO   7814 (RETURN)
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Created July 10, 2015 
.................... // See below: 
.................... //Summary: Finds a command from the global list of commands. 
.................... //Param: A pointer to the command string. 
.................... //Returns: The command number if the command is found in the command list. 
.................... //         0xFF if the command isn't found 
.................... //***************************************************************************** 
....................  
.................... int BT_FindCommand(void) 
.................... { 
....................    unsigned char buf[BT_COMMAND_SIZE]; 
....................    int i,stuff; 
....................  
....................    for (i=0; i<VAR_NAMESFORSETTING; i++) 
*
051BC:  MOVLB  7
051BE:  CLRF   xB3
051C0:  MOVF   xB3,W
051C2:  SUBLW  07
051C4:  BNC   5220
....................    { 
....................       strcpy(buf, &settingvariables[i][0]); 
051C6:  MOVF   xB3,W
051C8:  MULLW  0B
051CA:  MOVF   FF3,W
051CC:  CLRF   xB6
051CE:  MOVWF  xB5
051D0:  MOVLW  54
051D2:  ADDWF  xB5,W
051D4:  MOVWF  01
051D6:  MOVLW  04
051D8:  ADDWFC xB6,W
051DA:  MOVWF  03
051DC:  MOVFF  01,7B7
051E0:  MOVWF  xB8
051E2:  MOVLW  07
051E4:  MOVWF  FEA
051E6:  MOVLW  A8
051E8:  MOVWF  FE9
051EA:  MOVFF  03,FE2
051EE:  MOVFF  01,FE1
051F2:  MOVF   FE7,F
051F4:  MOVFF  FE6,FEE
051F8:  BNZ   51F2
....................       if (stricmp(buf, bt_cmd)==0)    
051FA:  MOVLW  07
051FC:  MOVWF  xB6
051FE:  MOVLW  A8
05200:  MOVWF  xB5
05202:  CLRF   xB8
05204:  MOVLW  33
05206:  MOVWF  xB7
05208:  MOVLB  0
0520A:  RCALL  50B4
0520C:  MOVF   01,F
0520E:  BNZ   521A
....................          return(i); 
05210:  MOVLB  7
05212:  MOVFF  7B3,01
05216:  BRA    5224
05218:  MOVLB  0
0521A:  MOVLB  7
0521C:  INCF   xB3,F
0521E:  BRA    51C0
....................    } 
....................    return(0xFF); 
05220:  MOVLW  FF
05222:  MOVWF  01
05224:  MOVLB  0
05226:  GOTO   6420 (RETURN)
.................... } 
....................  
.................... int1 parseChar(char vala){ 
.................... char tempBuff[2]; 
....................  
.................... int1 newLine=0; 
.................... ////////OLD 
.................... /* 
.................... 	writeChar(val); 
.................... 	dispCntr++; 
.................... 	writeReady=0; 
.................... */ 
....................  
.................... if(vala==10) 
.................... 	{	 
.................... 	xCntr=0; 
.................... 	yCntr++; 
.................... 	newLine=1; 
.................... 	} 
.................... else{ 
.................... writeCharPos(xCntr,yCntr,vala); 
.................... xCntr++; 
.................... 	} 
.................... return newLine; 
.................... } 
.................... ////////////////////////RS232 Interrupt////////////////////// 
....................  
.................... #define BT_BUFF_SIZE 64 
....................  
.................... int16 BTnext_in  = 0; 
.................... int16 BTnext_out = 0; 
.................... int8 BTbuffer[BT_BUFF_SIZE]; 
....................  
.................... //char * BT_GetCMD(char *in) 
.................... void MoveOverReceivedData(int pointernumber) 
.................... 	{ 
.................... 	int8 x,leadingzero,y; 
....................     // get rid of leading zeros 
.................... 	for (x=0; x< 11; x++) 
.................... 		{   
....................             adcBuff[x] = SplitResult[pointernumber][x]; 
....................              
....................         } 
.................... 	} 
....................  
....................  
.................... //char * BT_GetCMD(char *in) 
.................... void BT_GetCMD(void) 
.................... 	{ 
.................... 	int8 x; 
.................... 	for (x=0; x< 18; x++) 
*
0504E:  MOVLB  7
05050:  CLRF   xA8
05052:  MOVF   xA8,W
05054:  SUBLW  11
05056:  BNC   5086
.................... 		{ 
.................... 		bt_cmd[x] = SplitResult[0][x]; 
05058:  CLRF   03
0505A:  MOVF   xA8,W
0505C:  ADDLW  33
0505E:  MOVWF  01
05060:  MOVLW  00
05062:  ADDWFC 03,F
05064:  MOVLW  08
05066:  ADDWF  xA8,W
05068:  MOVWF  FE9
0506A:  MOVLW  03
0506C:  MOVWF  FEA
0506E:  BTFSC  FD8.0
05070:  INCF   FEA,F
05072:  MOVFF  FEF,7AB
05076:  MOVFF  03,FEA
0507A:  MOVFF  01,FE9
0507E:  MOVFF  7AB,FEF
05082:  INCF   xA8,F
05084:  BRA    5052
.................... 		} 
05086:  MOVLB  0
05088:  GOTO   6402 (RETURN)
.................... 	} 
....................  
....................  
.................... //////////////////////////////////////////////////////////// 
....................  
.................... #define BTbkbhit (BTnext_in != BTnext_out) 
.................... //#define bkbhitDebug (next_in != next_outDebug) 
....................  
.................... int8 BTbgetc() 
.................... { 
....................    int8 c; 
....................  
....................    while(!BTbkbhit); 
*
04EFA:  MOVLB  6
04EFC:  MOVF   x24,W
04EFE:  SUBWF  x22,W
04F00:  BNZ   4F08
04F02:  MOVF   x25,W
04F04:  SUBWF  x23,W
04F06:  BZ    4EFC
....................    c = BTbuffer[BTnext_out]; 
04F08:  MOVLW  26
04F0A:  ADDWF  x24,W
04F0C:  MOVWF  FE9
04F0E:  MOVLW  06
04F10:  ADDWFC x25,W
04F12:  MOVWF  FEA
04F14:  MOVFF  FEF,796
....................    BTnext_out = (BTnext_out+1) % sizeof(BTbuffer);  
04F18:  MOVLW  01
04F1A:  ADDWF  x24,W
04F1C:  MOVLB  7
04F1E:  MOVWF  x97
04F20:  MOVLW  00
04F22:  MOVLB  6
04F24:  ADDWFC x25,W
04F26:  MOVLB  7
04F28:  MOVF   x97,W
04F2A:  ANDLW  3F
04F2C:  MOVLB  6
04F2E:  MOVWF  x24
04F30:  CLRF   x25
....................    return c; 
04F32:  MOVLB  7
04F34:  MOVFF  796,01
04F38:  MOVLB  0
04F3A:  GOTO   77BE (RETURN)
.................... } 
....................  
.................... //********************************************************************* 
.................... // Updated November 15, 2016 
.................... // Below tests for a character from the bluetooth and then parses the command.  It does not run the command that is done in the  
.................... // lexal analyzer.   
.................... // Tokens are seperated by spaces 
.................... // Lines are teminated by CR/LF  depending on the terminal program used. 
.................... // The result returned is a -1 for fail and a 0 for OK. 
.................... //********************************************************************* 
....................  
....................  
.................... void BTTestEvent(void) 
.................... 	{ 
.................... 	 
.................... static int8 countcharacter; 
.................... char endofline[] = "\r"; 
*
077A2:  MOVLW  0D
077A4:  MOVLB  7
077A6:  MOVWF  x93
077A8:  CLRF   x94
....................  
.................... 	if(BTbkbhit){ 
077AA:  MOVLB  6
077AC:  MOVF   x24,W
077AE:  SUBWF  x22,W
077B0:  BNZ   77B8
077B2:  MOVF   x25,W
077B4:  SUBWF  x23,W
077B6:  BZ    7838
....................  
.................... 		char cvl =BTbgetc(); 		//getBTChar(); 
077B8:  MOVLB  0
077BA:  GOTO   4EFA
077BE:  MOVFF  01,795
.................... 		if (CommandModeOrNot == 0) 
077C2:  MOVLB  4
077C4:  MOVF   x52,F
077C6:  BNZ   77D4
....................         { 
....................          putc(cvl,BT); 
077C8:  MOVLB  7
077CA:  MOVF   x95,W
077CC:  MOVLB  0
077CE:  CALL   4F3E
077D2:  MOVLB  4
....................         } 
.................... //  This is a carraige return.  This section takes the line sent from the command line and places it into a string where  
.................... //  it will be parsed into commands through the operating system. 
.................... if (cvl == 0x0D)   
077D4:  MOVLB  7
077D6:  MOVF   x95,W
077D8:  SUBLW  0D
077DA:  BNZ   7822
.................... 	{ 
....................     	if (CommandModeOrNot == 0) 
077DC:  MOVLB  4
077DE:  MOVF   x52,F
077E0:  BNZ   77F2
....................             { 
.................... 		putc('\r',BT);    //Send back to the terminal the CR and LF. 
077E2:  MOVLW  0D
077E4:  MOVLB  0
077E6:  CALL   4F3E
.................... 		putc('\n',BT); 
077EA:  MOVLW  0A
077EC:  CALL   4F3E
077F0:  MOVLB  4
....................             } 
.................... 	scr[countcharacter] = '\0';    // Insert the CR to end the command string.   
077F2:  CLRF   03
077F4:  MOVLB  6
077F6:  MOVF   x66,W
077F8:  ADDLW  C8
077FA:  MOVWF  FE9
077FC:  MOVLW  02
077FE:  ADDWFC 03,W
07800:  MOVWF  FEA
07802:  CLRF   FEF
.................... 	split(&endofline);    //Split the command into the array of tokens.  The first location starts at 0 which is the command requested. 
07804:  MOVLW  07
07806:  MOVLB  7
07808:  MOVWF  x97
0780A:  MOVLW  93
0780C:  MOVWF  x96
0780E:  MOVLB  0
07810:  GOTO   4F46
.................... 	countcharacter = 0; 
07814:  MOVLB  6
07816:  CLRF   x66
.................... 	parsebluetoothcommand();   // Parse and execute the command(s).... 
07818:  MOVLB  0
0781A:  GOTO   63FE
.................... 	} 
0781E:  BRA    783A
07820:  MOVLB  7
.................... 	else 
.................... 	{ 
.................... 	//This section adds the current typed character to the array called "scr".  When there is a CR, it then resets to zero and parses the command line. 
.................... 	scr[countcharacter]=cvl;   // Add the current character to the array; waiting for the rest of the command. 
07822:  CLRF   03
07824:  MOVLB  6
07826:  MOVF   x66,W
07828:  ADDLW  C8
0782A:  MOVWF  FE9
0782C:  MOVLW  02
0782E:  ADDWFC 03,W
07830:  MOVWF  FEA
07832:  MOVFF  795,FEF
.................... 	countcharacter++;   // Kick the counter to the RDA_isrointer location. 
07836:  INCF   x66,F
07838:  MOVLB  0
.................... 				//  Return back to the operating system to do other stuff. 
....................  
.................... 	} 
....................  
.................... 	} 
0783A:  RETURN 0
.................... } 
....................    
....................  
.................... //char * BT_GetCMD(char *in) 
.................... void BT_GetNextCMD(void) 
.................... 	{ 
.................... 	int8 x; 
.................... 	for (x=0; x< 35; x++) 
*
0522A:  MOVLB  7
0522C:  CLRF   xA8
0522E:  MOVF   xA8,W
05230:  SUBLW  22
05232:  BNC   5262
.................... 		{ 
.................... 		bt_cmd[x] = SplitResult[1][x]; 
05234:  CLRF   03
05236:  MOVF   xA8,W
05238:  ADDLW  33
0523A:  MOVWF  01
0523C:  MOVLW  00
0523E:  ADDWFC 03,F
05240:  MOVLW  13
05242:  ADDWF  xA8,W
05244:  MOVWF  FE9
05246:  MOVLW  03
05248:  MOVWF  FEA
0524A:  BTFSC  FD8.0
0524C:  INCF   FEA,F
0524E:  MOVFF  FEF,7AB
05252:  MOVFF  03,FEA
05256:  MOVFF  01,FE9
0525A:  MOVFF  7AB,FEF
0525E:  INCF   xA8,F
05260:  BRA    522E
.................... 		} 
05262:  MOVLB  0
05264:  RETURN 0
.................... 	} 
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Created July 10, 2015 
.................... // See below: 
.................... //Summary: Finds a command from the global list of commands. 
.................... //Param: A pointer to the command string. 
.................... //Returns: The command number if the command is found in the command list. 
.................... //         0xFF if the command isn't found 
.................... //***************************************************************************** 
....................  
.................... int BT_FindSubCommand(void) 
.................... { 
....................    unsigned char buf[BT_COMMAND_SIZE]; 
....................    int i; 
....................  
....................    for (i=0; i<BT_NUM_SUBCOMMANDS; i++) 
05266:  MOVLB  7
05268:  CLRF   xB3
0526A:  MOVF   xB3,W
0526C:  SUBLW  21
0526E:  BNC   52DA
....................    { 
....................       strcpy(buf, &bluetoothsecond[i][0]); 
05270:  CLRF   xB5
05272:  MOVFF  7B3,7B4
05276:  CLRF   xB7
05278:  MOVLW  0B
0527A:  MOVWF  xB6
0527C:  MOVLB  0
0527E:  RCALL  4CE8
05280:  MOVFF  02,7B5
05284:  MOVFF  01,7B4
05288:  MOVLW  AC
0528A:  MOVLB  7
0528C:  ADDWF  01,W
0528E:  MOVWF  01
05290:  MOVLW  04
05292:  ADDWFC 02,W
05294:  MOVWF  03
05296:  MOVFF  01,7B6
0529A:  MOVWF  xB7
0529C:  MOVLW  07
0529E:  MOVWF  FEA
052A0:  MOVLW  A8
052A2:  MOVWF  FE9
052A4:  MOVFF  03,FE2
052A8:  MOVFF  01,FE1
052AC:  MOVF   FE7,F
052AE:  MOVFF  FE6,FEE
052B2:  BNZ   52AC
....................       if (stricmp(buf, bt_cmd)==0) 
052B4:  MOVLW  07
052B6:  MOVWF  xB6
052B8:  MOVLW  A8
052BA:  MOVWF  xB5
052BC:  CLRF   xB8
052BE:  MOVLW  33
052C0:  MOVWF  xB7
052C2:  MOVLB  0
052C4:  RCALL  50B4
052C6:  MOVF   01,F
052C8:  BNZ   52D4
....................          return(i); 
052CA:  MOVLB  7
052CC:  MOVFF  7B3,01
052D0:  BRA    52DE
052D2:  MOVLB  0
052D4:  MOVLB  7
052D6:  INCF   xB3,F
052D8:  BRA    526A
....................    } 
....................  
....................    return(0xFF); 
052DA:  MOVLW  FF
052DC:  MOVWF  01
052DE:  MOVLB  0
052E0:  RETURN 0
.................... } 
....................  
....................  
.................... //char * BT_GetCMD(char *in) 
.................... //This routine gets the thrid item in the command line.  It is normally a number that is converted for setting variables. 
.................... void BT_GetLastCMD(void) 
.................... 	{ 
.................... 	int8 x; 
.................... 	for (x=0; x< 35; x++) 
*
053AC:  MOVLB  7
053AE:  CLRF   xA8
053B0:  MOVF   xA8,W
053B2:  SUBLW  22
053B4:  BNC   53E4
.................... 		{ 
.................... 		bt_cmd[x] = SplitResult[2][x]; 
053B6:  CLRF   03
053B8:  MOVF   xA8,W
053BA:  ADDLW  33
053BC:  MOVWF  01
053BE:  MOVLW  00
053C0:  ADDWFC 03,F
053C2:  MOVLW  1E
053C4:  ADDWF  xA8,W
053C6:  MOVWF  FE9
053C8:  MOVLW  03
053CA:  MOVWF  FEA
053CC:  BTFSC  FD8.0
053CE:  INCF   FEA,F
053D0:  MOVFF  FEF,7AB
053D4:  MOVFF  03,FEA
053D8:  MOVFF  01,FE9
053DC:  MOVFF  7AB,FEF
053E0:  INCF   xA8,F
053E2:  BRA    53B0
.................... 		} 
053E4:  MOVLB  0
053E6:  RETURN 0
.................... 	} 
....................  
....................  
.................... //********************************************************************* 
.................... // Updated July 10, 2015 
.................... // Below tests for a character from the bluetooth and then parses the command.  It does not run the command that is done in the  
.................... // lexal analyzer.   
.................... // Tokens are seperated by spaces 
.................... // Lines are teminated by CR/LF  depending on the terminal program used. 
.................... // The result returned is a -1 for fail and a 0 for OK. 
.................... //********************************************************************* 
.................... /* 
....................  
.................... void BTBasicTest(void) 
.................... 	{ 
.................... 	 
.................... static int8 countcharacter; 
....................  
.................... 	if(BTbkbhit){ 
....................  
.................... 		char cvl =BTbgetc(); 		//getWIFIChar(); 
.................... 		//putc(cvl,BT); 
....................         if (CommandModeOrNot) 
....................         { 
....................        //  writeChar(cvl); 
....................         } 
.................... //  This is a carraige return.  This section takes the line sent from the command line and places it into a string where  
.................... //  it will be parsed into commands through the operating system. 
....................        if (cvl != '\r') 
....................        { 
.................... if (cvl == '\n') 
.................... 	{ 
.................... 		//putc('\r',BT);    //Send back to the terminal the CR and LF. 
....................        // writeChar('\r'); 
.................... 		//putc('\n',BT); 
....................        // writeChar('\n'); 
....................      
....................  
.................... 	bt_cmd[countcharacter] = '\0';    // Insert the CR to end the command string.   
....................     if (CommandModeOrNot==0) 
....................     { 
....................     passed = 0;  // clear flag     
....................  //   split(&bt_cmd,0x3A, '\n');    //Split the command into the array of tokens.  This splits for showing commands back from the BT device. 
....................     } 
....................     else 
....................     { 
.................... //     split(&bt_cmd,0x2C, '\n');    //Split the command into the array of tokens.  This splits all of the characters for showing data 
....................      BT_GetCMD(); 
....................      CurrentCommand =  BT_FindCommand(); 
.................... //     split(&bt_cmd,0x20, '\n');    //Split the command into the array of tokens.  This splits all of the characters for showing data 
....................      BT_GetCMD(); 
....................      CurrentCommand =  BT_FindCommand();      
....................      if (CurrentCommand!=0xff) 
....................      { 
....................          if ((CurrentCommand == 3) && (passed != 1)) 
....................          {     
....................               passed = 1;  // set the passed ito  
....................               CurrentCommand=99; 
....................               return; 
....................          } 
....................      }     
....................      
....................     } 
.................... //char * BT_GetCMD(char *in) 
....................     BT_GetCMD(); 
....................  
.................... 	countcharacter = 0; 
....................     CurrentCommand =  BT_FindCommand(); 
....................     CurrentCommand++; 
.................... 	//parsebluetoothcommand();   // Parse and execut the command(s).... 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 	//This section adds the current typed charater to the array called "scr".  When there is a CR, it then resets to zero and parses the command line. 
.................... 	bt_cmd[countcharacter]=cvl;   // Add the current character to the array; waiting for the rest of the command. 
.................... 	countcharacter++;   // Kick the counter to the pointer location. 
.................... 				//  Return back to the operating system to do other stuff. 
....................  
....................  
.................... //**************************************************** 
.................... // Created Oct. 20, 2015 
.................... // This sections checks for ESC sequencies and then does them. 
.................... //**************************************************** 
....................  
.................... 	} 
....................        } 
.................... 	} 
.................... } 
....................  
.................... */ 
.................... //**************************************************************************** 
.................... // Created July 9, 2015 
.................... // This is the main parsing routine for call fuctions commanded by Bluetooth.  This is called when a completed 
.................... // CR and LF are found from the remote bluetooth device.   
.................... // The output of this routine are called routines and the returned value is a -1 if there is an parsing error. 
.................... //  Return -1 if error 
.................... //  Return 0 if no error 
.................... //  The input to the function is an array of commands split into each command on each array pointer. 
.................... //  The end of the parsed line is a CR and/or LF. 
.................... // Updated/completed  July 10, 2015 
.................... // This is the main parsing routine for bluetooth.  It takes the remove commands from the Osmobot and/or the terminal and runs them. 
.................... // The inputs are as follows: 
.................... // The split command array is global and does not need to be passed. 
.................... //  
.................... // The output are as follows:  it returns an int8 where a -1 means it failed and a 0 means it made it. 
.................... //**************************************************************************** 
.................... int8 parsebluetoothcommand(void) 
.................... 	{ 
.................... 	int stuff, ScaleLevel,routernumber,exit,choice,changefolder; 
....................     int16 selection,selecteditems; 
.................... 	float ClearTemp,ScaleLevelfloat; 
....................     //char arryit[255]; 
.................... 	BT_GetCMD(); 
*
063FE:  GOTO   504E
....................     fprintf(BT,"%s\r\n",bt_cmd); 
06402:  CLRF   FEA
06404:  MOVLW  33
06406:  MOVWF  FE9
06408:  GOTO   508C
0640C:  MOVLW  0D
0640E:  BTFSS  F9E.4
06410:  BRA    640E
06412:  MOVWF  FAD
06414:  MOVLW  0A
06416:  BTFSS  F9E.4
06418:  BRA    6416
0641A:  MOVWF  FAD
....................   //  fprintf(BT,"Here is the command number - >%i\r\n",BT_FindCommand()); 
.................... 	switch(BT_FindCommand()) 
0641C:  GOTO   51BC
06420:  MOVF   01,W
06422:  BZ    645A
06424:  XORLW  01
06426:  BZ    650A
06428:  XORLW  03
0642A:  BTFSC  FD8.2
0642C:  BRA    65C8
0642E:  XORLW  01
06430:  BTFSC  FD8.2
06432:  GOTO   6DAC
06436:  XORLW  07
06438:  BTFSC  FD8.2
0643A:  GOTO   6E48
0643E:  XORLW  01
06440:  BTFSC  FD8.2
06442:  GOTO   7762
06446:  XORLW  03
06448:  BTFSC  FD8.2
0644A:  GOTO   7774
0644E:  XORLW  01
06450:  BTFSC  FD8.2
06452:  GOTO   778A
06456:  GOTO   778E
....................          { 
....................             case 0:  //help  as command "?" 
....................                fprintf(BT,"Osmobot Testing and Configuration Help\n\r"); 
0645A:  MOVLW  F0
0645C:  MOVWF  FF6
0645E:  MOVLW  00
06460:  MOVWF  FF7
06462:  CALL   1C20
....................                fprintf(BT,"Below is a list of all the commands this unit can do.  Fabuary 11, 2017\n\r"); 
06466:  MOVLW  1A
06468:  MOVWF  FF6
0646A:  MOVLW  01
0646C:  MOVWF  FF7
0646E:  CALL   1C20
....................                fprintf(BT,"showconfig          Dumps all of the current calibrations for all sensors to date to the display.\n\r"); 
06472:  MOVLW  64
06474:  MOVWF  FF6
06476:  MOVLW  01
06478:  MOVWF  FF7
0647A:  CALL   1C20
....................                fprintf(BT,"saveconfig          Saves all of the current calibration in EEPROM on this device.  It's used as default for initalizing new units.\n\r"); 
0647E:  MOVLW  C8
06480:  MOVWF  FF6
06482:  MOVLW  01
06484:  MOVWF  FF7
06486:  CALL   1C20
....................                fprintf(BT,"display             Command to set or reset items to the VFD  display. Only 4 items can be shown at the same time.  All else will be truncated.\n\r"); 
0648A:  MOVLW  4E
0648C:  MOVWF  FF6
0648E:  MOVLW  02
06490:  MOVWF  FF7
06492:  CALL   1C20
....................                fprintf(BT,"                    Here are the options.\n\r"); 
06496:  MOVLW  E0
06498:  MOVWF  FF6
0649A:  MOVLW  02
0649C:  MOVWF  FF7
0649E:  CALL   1C20
....................                fprintf(BT,"                    pph do  ph  wd  phbulb  clear lux  ec   wt  par  nh4 \n\r"); 
064A2:  MOVLW  0C
064A4:  MOVWF  FF6
064A6:  MOVLW  03
064A8:  MOVWF  FF7
064AA:  CALL   1C20
....................                fprintf(BT,"default             This sets all of the calibration to default values.\n\r"); 
064AE:  MOVLW  58
064B0:  MOVWF  FF6
064B2:  MOVLW  03
064B4:  MOVWF  FF7
064B6:  CALL   1C20
....................                fprintf(BT,"update              It shoots the current calibration values to the remote device.\n\r"); 
064BA:  MOVLW  A2
064BC:  MOVWF  FF6
064BE:  MOVLW  03
064C0:  MOVWF  FF7
064C2:  CALL   1C20
....................                fprintf(BT,"set                 Sets the calibration var.  The format is >set varname value.  One space in between.\n\r"); 
064C6:  MOVLW  F8
064C8:  MOVWF  FF6
064CA:  MOVLW  03
064CC:  MOVWF  FF7
064CE:  CALL   1C20
....................                fprintf(BT,"                            Use the showconfig command to display the var names in ().\n\r");     
064D2:  MOVLW  62
064D4:  MOVWF  FF6
064D6:  MOVLW  04
064D8:  MOVWF  FF7
064DA:  CALL   1C20
....................                fprintf(BT,"rst                 reboot this unit.\n\r");     
064DE:  MOVLW  BC
064E0:  MOVWF  FF6
064E2:  MOVLW  04
064E4:  MOVWF  FF7
064E6:  CALL   1C20
....................                 
....................                fprintf(BT,"\n\r");                
064EA:  MOVLW  0A
064EC:  BTFSS  F9E.4
064EE:  BRA    64EC
064F0:  MOVWF  FAD
064F2:  MOVLW  0D
064F4:  BTFSS  F9E.4
064F6:  BRA    64F4
064F8:  MOVWF  FAD
....................                fprintf(BT,"end of line\n\r");                
064FA:  MOVLW  E4
064FC:  MOVWF  FF6
064FE:  MOVLW  04
06500:  MOVWF  FF7
06502:  CALL   1C20
....................                break;                
06506:  GOTO   779A
....................             case 1:  //this is the display command clear    The second command on the line is the sensor needed 
....................                debugnumber = 0;    //This clears the desired routine and exits back to the main loop.  Added July 13, 2015 
0650A:  MOVLB  2
0650C:  CLRF   xC6
.................... 			   BT_GetNextCMD(); 
0650E:  MOVLB  0
06510:  CALL   522A
.................... 			   debugnumber = BT_FindSubCommand(); 
06514:  CALL   5266
06518:  MOVFF  01,2C6
....................              //  fprintf(BT,"debugnumber -> %i\n\r",debugnumber);   
....................                if (debugnumber == 6) 
0651C:  MOVLB  2
0651E:  MOVF   xC6,W
06520:  SUBLW  06
06522:  BNZ   655C
....................                { 
....................                     if (savelocalconfigurations(0x0000)) 
06524:  MOVLB  7
06526:  CLRF   xA9
06528:  CLRF   xA8
0652A:  MOVLB  0
0652C:  CALL   52E2
06530:  MOVF   01,F
06532:  BZ    6542
....................                      { 
....................                     fprintf(BT,"Error Saving Local Configuration\n\r");     
06534:  MOVLW  F2
06536:  MOVWF  FF6
06538:  MOVLW  04
0653A:  MOVWF  FF7
0653C:  CALL   1C20
....................                     } 
06540:  BRA    6556
....................                     else 
....................                     { 
....................                     selectitem = 0x0000;  // clears the run time varaibles 
06542:  MOVLB  2
06544:  CLRF   x25
06546:  CLRF   x24
....................                     fprintf(BT,"Local Configurations Cleared\n\r");   
06548:  MOVLW  16
0654A:  MOVWF  FF6
0654C:  MOVLW  05
0654E:  MOVWF  FF7
06550:  MOVLB  0
06552:  CALL   1C20
....................                     } 
....................                     break; 
06556:  GOTO   779A
0655A:  MOVLB  2
....................                } 
....................                selecteditems = 0x0001; 
0655C:  MOVLB  7
0655E:  CLRF   x9F
06560:  MOVLW  01
06562:  MOVWF  x9E
....................                selection = selecteditems<<debugnumber; 
06564:  MOVFF  79F,79D
06568:  MOVFF  79E,79C
0656C:  MOVLB  2
0656E:  MOVF   xC6,W
06570:  MOVWF  00
06572:  BZ    6588
06574:  BCF    FD8.0
06576:  MOVLB  7
06578:  RLCF   x9C,F
0657A:  RLCF   x9D,F
0657C:  DECFSZ 00,F
0657E:  BRA    6582
06580:  BRA    6586
06582:  MOVLB  2
06584:  BRA    6574
06586:  MOVLB  2
....................                selectitem ^= selection; 
06588:  MOVLB  7
0658A:  MOVF   x9C,W
0658C:  MOVLB  2
0658E:  XORWF  x24,F
06590:  MOVLB  7
06592:  MOVF   x9D,W
06594:  MOVLB  2
06596:  XORWF  x25,F
....................                if (savelocalconfigurations(selectitem)) 
06598:  MOVFF  225,7A9
0659C:  MOVFF  224,7A8
065A0:  MOVLB  0
065A2:  CALL   52E2
065A6:  MOVF   01,F
065A8:  BZ    65B8
....................                { 
....................                  fprintf(BT,"Error Saving Local Configuration\n\r");     
065AA:  MOVLW  36
065AC:  MOVWF  FF6
065AE:  MOVLW  05
065B0:  MOVWF  FF7
065B2:  CALL   1C20
....................                } 
065B6:  BRA    65C4
....................                else 
....................                { 
....................                   fprintf(BT,"Local Configurations Saved\n\r");  
065B8:  MOVLW  5A
065BA:  MOVWF  FF6
065BC:  MOVLW  05
065BE:  MOVWF  FF7
065C0:  CALL   1C20
....................                //   fprintf(BT,"saved local config -> %Lx\n\r",selectitem);  
....................                } 
....................                break; 
065C4:  GOTO   779A
....................             case 2:  //this is the set command 
.................... 				BT_GetNextCMD(); 
065C8:  CALL   522A
.................... 			    debugnumber = BT_FindSubCommand(); 
065CC:  CALL   5266
065D0:  MOVFF  01,2C6
....................                 switch(debugnumber) 
065D4:  MOVLB  2
065D6:  MOVF   xC6,W
065D8:  XORLW  0D
065DA:  MOVLB  0
065DC:  BZ    6658
065DE:  XORLW  03
065E0:  BTFSC  FD8.2
065E2:  BRA    66D0
065E4:  XORLW  01
065E6:  BTFSC  FD8.2
065E8:  BRA    673C
065EA:  XORLW  1F
065EC:  BTFSC  FD8.2
065EE:  BRA    67B4
065F0:  XORLW  01
065F2:  BTFSC  FD8.2
065F4:  BRA    6810
065F6:  XORLW  03
065F8:  BTFSC  FD8.2
065FA:  BRA    6860
065FC:  XORLW  01
065FE:  BTFSC  FD8.2
06600:  BRA    68BC
06602:  XORLW  07
06604:  BTFSC  FD8.2
06606:  BRA    6918
06608:  XORLW  01
0660A:  BTFSC  FD8.2
0660C:  BRA    6974
0660E:  XORLW  03
06610:  BTFSC  FD8.2
06612:  BRA    69D0
06614:  XORLW  01
06616:  BTFSC  FD8.2
06618:  BRA    6A2C
0661A:  XORLW  0F
0661C:  BTFSC  FD8.2
0661E:  BRA    6A88
06620:  XORLW  01
06622:  BTFSC  FD8.2
06624:  BRA    6AD8
06626:  XORLW  03
06628:  BTFSC  FD8.2
0662A:  BRA    6B28
0662C:  XORLW  01
0662E:  BTFSC  FD8.2
06630:  BRA    6B78
06632:  XORLW  07
06634:  BTFSC  FD8.2
06636:  BRA    6BC8
06638:  XORLW  01
0663A:  BTFSC  FD8.2
0663C:  BRA    6C18
0663E:  XORLW  03
06640:  BTFSC  FD8.2
06642:  BRA    6C68
06644:  XORLW  01
06646:  BTFSC  FD8.2
06648:  BRA    6CB8
0664A:  XORLW  3F
0664C:  BTFSC  FD8.2
0664E:  BRA    6D08
06650:  XORLW  01
06652:  BTFSC  FD8.2
06654:  BRA    6D58
06656:  BRA    6DA8
....................                 { 
....................                     case 13: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06658:  CALL   53AC
....................                             sysInput.nh4pt1returnednumber = atof(bt_cmd); 
0665C:  MOVLB  7
0665E:  CLRF   xA9
06660:  MOVLW  33
06662:  MOVWF  xA8
06664:  CLRF   xAB
06666:  CLRF   xAA
06668:  MOVLB  0
0666A:  CALL   53E8
0666E:  MOVFF  03,254
06672:  MOVFF  02,253
06676:  MOVFF  01,252
0667A:  MOVFF  00,251
....................                             fprintf(BT,"(retnh41)  nh4pt1returnednumber set to %f\n\r",sysInput.nh4pt1returnednumber);   
0667E:  MOVLW  78
06680:  MOVWF  FF6
06682:  MOVLW  05
06684:  MOVWF  FF7
06686:  MOVLW  27
06688:  MOVLB  7
0668A:  MOVWF  xA8
0668C:  MOVLB  0
0668E:  CALL   5642
06692:  MOVLW  89
06694:  MOVWF  FE9
06696:  MOVFF  254,7AB
0669A:  MOVFF  253,7AA
0669E:  MOVFF  252,7A9
066A2:  MOVFF  251,7A8
066A6:  MOVLW  02
066A8:  MOVLB  7
066AA:  MOVWF  xAC
066AC:  MOVLB  0
066AE:  CALL   566C
066B2:  MOVLW  0A
066B4:  BTFSS  F9E.4
066B6:  BRA    66B4
066B8:  MOVWF  FAD
066BA:  MOVLW  0D
066BC:  BTFSS  F9E.4
066BE:  BRA    66BC
066C0:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe output low number.\n\r");  
066C2:  MOVLW  A4
066C4:  MOVWF  FF6
066C6:  MOVLW  05
066C8:  MOVWF  FF7
066CA:  CALL   1C20
....................                             break; 
066CE:  BRA    6DA8
....................                     case 14: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
066D0:  CALL   53AC
....................                             sysInput.nh4pt2returnednumber = atof(bt_cmd); 
066D4:  MOVLB  7
066D6:  CLRF   xA9
066D8:  MOVLW  33
066DA:  MOVWF  xA8
066DC:  CLRF   xAB
066DE:  CLRF   xAA
066E0:  MOVLB  0
066E2:  CALL   53E8
066E6:  MOVFF  03,258
066EA:  MOVFF  02,257
066EE:  MOVFF  01,256
066F2:  MOVFF  00,255
....................                             fprintf(BT,"(retnh42)  nh4pt2returnednumber set to %f\n\r",sysInput.nh4pt2returnednumber);                             
066F6:  MOVLW  D8
066F8:  MOVWF  FF6
066FA:  MOVLW  05
066FC:  MOVWF  FF7
066FE:  MOVLW  27
06700:  MOVLB  7
06702:  MOVWF  xA8
06704:  MOVLB  0
06706:  CALL   5642
0670A:  MOVLW  89
0670C:  MOVWF  FE9
0670E:  MOVFF  258,7AB
06712:  MOVFF  257,7AA
06716:  MOVFF  256,7A9
0671A:  MOVFF  255,7A8
0671E:  MOVLW  02
06720:  MOVLB  7
06722:  MOVWF  xAC
06724:  MOVLB  0
06726:  CALL   566C
0672A:  MOVLW  0A
0672C:  BTFSS  F9E.4
0672E:  BRA    672C
06730:  MOVWF  FAD
06732:  MOVLW  0D
06734:  BTFSS  F9E.4
06736:  BRA    6734
06738:  MOVWF  FAD
....................                             break; 
0673A:  BRA    6DA8
....................                     case 15: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
0673C:  CALL   53AC
....................                             sysInput.nh4pt3returnednumber = atof(bt_cmd); 
06740:  MOVLB  7
06742:  CLRF   xA9
06744:  MOVLW  33
06746:  MOVWF  xA8
06748:  CLRF   xAB
0674A:  CLRF   xAA
0674C:  MOVLB  0
0674E:  CALL   53E8
06752:  MOVFF  03,25C
06756:  MOVFF  02,25B
0675A:  MOVFF  01,25A
0675E:  MOVFF  00,259
....................                             fprintf(BT,"(retnh43)  nh4pt3returnednumber set to %f\n\r",sysInput.nh4pt3returnednumber);   
06762:  MOVLW  04
06764:  MOVWF  FF6
06766:  MOVLW  06
06768:  MOVWF  FF7
0676A:  MOVLW  27
0676C:  MOVLB  7
0676E:  MOVWF  xA8
06770:  MOVLB  0
06772:  CALL   5642
06776:  MOVLW  89
06778:  MOVWF  FE9
0677A:  MOVFF  25C,7AB
0677E:  MOVFF  25B,7AA
06782:  MOVFF  25A,7A9
06786:  MOVFF  259,7A8
0678A:  MOVLW  02
0678C:  MOVLB  7
0678E:  MOVWF  xAC
06790:  MOVLB  0
06792:  CALL   566C
06796:  MOVLW  0A
06798:  BTFSS  F9E.4
0679A:  BRA    6798
0679C:  MOVWF  FAD
0679E:  MOVLW  0D
067A0:  BTFSS  F9E.4
067A2:  BRA    67A0
067A4:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe output high number.\n\r");  
067A6:  MOVLW  30
067A8:  MOVWF  FF6
067AA:  MOVLW  06
067AC:  MOVWF  FF7
067AE:  CALL   1C20
....................                             break; 
067B2:  BRA    6DA8
....................                     case 16: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
067B4:  CALL   53AC
....................                             sysInput.nh4pt1cal1of3 = atol(bt_cmd); 
067B8:  MOVLB  7
067BA:  CLRF   xA9
067BC:  MOVLW  33
067BE:  MOVWF  xA8
067C0:  MOVLB  0
067C2:  CALL   5868
067C6:  MOVFF  02,240
067CA:  MOVFF  01,23F
....................                             fprintf(BT,"(nh4pt1)  nh4pt1cal1of3 set to %Lu\n\r",sysInput.nh4pt1cal1of3);   
067CE:  MOVLW  64
067D0:  MOVWF  FF6
067D2:  MOVLW  06
067D4:  MOVWF  FF7
067D6:  MOVLW  1F
067D8:  MOVLB  7
067DA:  MOVWF  xA8
067DC:  MOVLB  0
067DE:  CALL   5642
067E2:  MOVLW  10
067E4:  MOVWF  FE9
067E6:  MOVFF  240,7A9
067EA:  MOVFF  23F,7A8
067EE:  CALL   5A4C
067F2:  MOVLW  0A
067F4:  BTFSS  F9E.4
067F6:  BRA    67F4
067F8:  MOVWF  FAD
067FA:  MOVLW  0D
067FC:  BTFSS  F9E.4
067FE:  BRA    67FC
06800:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
06802:  MOVLW  8A
06804:  MOVWF  FF6
06806:  MOVLW  06
06808:  MOVWF  FF7
0680A:  CALL   1C20
....................                             break; 
0680E:  BRA    6DA8
....................                     case 17: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06810:  CALL   53AC
....................                             sysInput.nh4pt1cal2of3 = atol(bt_cmd); 
06814:  MOVLB  7
06816:  CLRF   xA9
06818:  MOVLW  33
0681A:  MOVWF  xA8
0681C:  MOVLB  0
0681E:  CALL   5868
06822:  MOVFF  02,242
06826:  MOVFF  01,241
....................                             fprintf(BT,"(nh4pt2)  nh4pt1cal2of3 set to %Lu\n\r",sysInput.nh4pt1cal2of3);                             
0682A:  MOVLW  BC
0682C:  MOVWF  FF6
0682E:  MOVLW  06
06830:  MOVWF  FF7
06832:  MOVLW  1F
06834:  MOVLB  7
06836:  MOVWF  xA8
06838:  MOVLB  0
0683A:  CALL   5642
0683E:  MOVLW  10
06840:  MOVWF  FE9
06842:  MOVFF  242,7A9
06846:  MOVFF  241,7A8
0684A:  CALL   5A4C
0684E:  MOVLW  0A
06850:  BTFSS  F9E.4
06852:  BRA    6850
06854:  MOVWF  FAD
06856:  MOVLW  0D
06858:  BTFSS  F9E.4
0685A:  BRA    6858
0685C:  MOVWF  FAD
....................                             break; 
0685E:  BRA    6DA8
....................                     case 18: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06860:  CALL   53AC
....................                             sysInput.nh4pt1cal3of3 = atol(bt_cmd); 
06864:  MOVLB  7
06866:  CLRF   xA9
06868:  MOVLW  33
0686A:  MOVWF  xA8
0686C:  MOVLB  0
0686E:  CALL   5868
06872:  MOVFF  02,244
06876:  MOVFF  01,243
....................                             fprintf(BT,"(nh4pt3)  nh4pt1cal3of3 set to %Lu\n\r",sysInput.nh4pt1cal3of3);   
0687A:  MOVLW  E2
0687C:  MOVWF  FF6
0687E:  MOVLW  06
06880:  MOVWF  FF7
06882:  MOVLW  1F
06884:  MOVLB  7
06886:  MOVWF  xA8
06888:  MOVLB  0
0688A:  CALL   5642
0688E:  MOVLW  10
06890:  MOVWF  FE9
06892:  MOVFF  244,7A9
06896:  MOVFF  243,7A8
0689A:  CALL   5A4C
0689E:  MOVLW  0A
068A0:  BTFSS  F9E.4
068A2:  BRA    68A0
068A4:  MOVWF  FAD
068A6:  MOVLW  0D
068A8:  BTFSS  F9E.4
068AA:  BRA    68A8
068AC:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
068AE:  MOVLW  08
068B0:  MOVWF  FF6
068B2:  MOVLW  07
068B4:  MOVWF  FF7
068B6:  CALL   1C20
....................                             break; 
068BA:  BRA    6DA8
....................                     case 19: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
068BC:  CALL   53AC
....................                             sysInput.nh4pt2cal1of3 = atol(bt_cmd); 
068C0:  MOVLB  7
068C2:  CLRF   xA9
068C4:  MOVLW  33
068C6:  MOVWF  xA8
068C8:  MOVLB  0
068CA:  CALL   5868
068CE:  MOVFF  02,246
068D2:  MOVFF  01,245
....................                             fprintf(BT,"(nh4pt4)  nh4pt2cal1of3 set to %Lu\n\r",sysInput.nh4pt2cal1of3);   
068D6:  MOVLW  3A
068D8:  MOVWF  FF6
068DA:  MOVLW  07
068DC:  MOVWF  FF7
068DE:  MOVLW  1F
068E0:  MOVLB  7
068E2:  MOVWF  xA8
068E4:  MOVLB  0
068E6:  CALL   5642
068EA:  MOVLW  10
068EC:  MOVWF  FE9
068EE:  MOVFF  246,7A9
068F2:  MOVFF  245,7A8
068F6:  CALL   5A4C
068FA:  MOVLW  0A
068FC:  BTFSS  F9E.4
068FE:  BRA    68FC
06900:  MOVWF  FAD
06902:  MOVLW  0D
06904:  BTFSS  F9E.4
06906:  BRA    6904
06908:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
0690A:  MOVLW  60
0690C:  MOVWF  FF6
0690E:  MOVLW  07
06910:  MOVWF  FF7
06912:  CALL   1C20
....................                             break; 
06916:  BRA    6DA8
....................                     case 20: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06918:  CALL   53AC
....................                             sysInput.nh4pt2cal2of3 = atol(bt_cmd); 
0691C:  MOVLB  7
0691E:  CLRF   xA9
06920:  MOVLW  33
06922:  MOVWF  xA8
06924:  MOVLB  0
06926:  CALL   5868
0692A:  MOVFF  02,248
0692E:  MOVFF  01,247
....................                             fprintf(BT,"(nh4pt5)  nh4pt2cal2of3 set to %Lu\n\r",sysInput.nh4pt2cal2of3);   
06932:  MOVLW  92
06934:  MOVWF  FF6
06936:  MOVLW  07
06938:  MOVWF  FF7
0693A:  MOVLW  1F
0693C:  MOVLB  7
0693E:  MOVWF  xA8
06940:  MOVLB  0
06942:  CALL   5642
06946:  MOVLW  10
06948:  MOVWF  FE9
0694A:  MOVFF  248,7A9
0694E:  MOVFF  247,7A8
06952:  CALL   5A4C
06956:  MOVLW  0A
06958:  BTFSS  F9E.4
0695A:  BRA    6958
0695C:  MOVWF  FAD
0695E:  MOVLW  0D
06960:  BTFSS  F9E.4
06962:  BRA    6960
06964:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
06966:  MOVLW  B8
06968:  MOVWF  FF6
0696A:  MOVLW  07
0696C:  MOVWF  FF7
0696E:  CALL   1C20
....................                             break; 
06972:  BRA    6DA8
....................                     case 21: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06974:  CALL   53AC
....................                             sysInput.nh4pt2cal3of3 = atol(bt_cmd); 
06978:  MOVLB  7
0697A:  CLRF   xA9
0697C:  MOVLW  33
0697E:  MOVWF  xA8
06980:  MOVLB  0
06982:  CALL   5868
06986:  MOVFF  02,24A
0698A:  MOVFF  01,249
....................                             fprintf(BT,"(nh4pt6)  nh4pt2cal3of3 set to %Lu\n\r",sysInput.nh4pt2cal3of3);   
0698E:  MOVLW  EA
06990:  MOVWF  FF6
06992:  MOVLW  07
06994:  MOVWF  FF7
06996:  MOVLW  1F
06998:  MOVLB  7
0699A:  MOVWF  xA8
0699C:  MOVLB  0
0699E:  CALL   5642
069A2:  MOVLW  10
069A4:  MOVWF  FE9
069A6:  MOVFF  24A,7A9
069AA:  MOVFF  249,7A8
069AE:  CALL   5A4C
069B2:  MOVLW  0A
069B4:  BTFSS  F9E.4
069B6:  BRA    69B4
069B8:  MOVWF  FAD
069BA:  MOVLW  0D
069BC:  BTFSS  F9E.4
069BE:  BRA    69BC
069C0:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
069C2:  MOVLW  10
069C4:  MOVWF  FF6
069C6:  MOVLW  08
069C8:  MOVWF  FF7
069CA:  CALL   1C20
....................                             break; 
069CE:  BRA    6DA8
....................                     case 22: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
069D0:  CALL   53AC
....................                             sysInput.nh4pt3cal1of3 = atol(bt_cmd); 
069D4:  MOVLB  7
069D6:  CLRF   xA9
069D8:  MOVLW  33
069DA:  MOVWF  xA8
069DC:  MOVLB  0
069DE:  CALL   5868
069E2:  MOVFF  02,24C
069E6:  MOVFF  01,24B
....................                             fprintf(BT,"(nh4pt7)  nh4pt3cal1of3 set to %Lu\n\r",sysInput.nh4pt3cal1of3);   
069EA:  MOVLW  42
069EC:  MOVWF  FF6
069EE:  MOVLW  08
069F0:  MOVWF  FF7
069F2:  MOVLW  1F
069F4:  MOVLB  7
069F6:  MOVWF  xA8
069F8:  MOVLB  0
069FA:  CALL   5642
069FE:  MOVLW  10
06A00:  MOVWF  FE9
06A02:  MOVFF  24C,7A9
06A06:  MOVFF  24B,7A8
06A0A:  CALL   5A4C
06A0E:  MOVLW  0A
06A10:  BTFSS  F9E.4
06A12:  BRA    6A10
06A14:  MOVWF  FAD
06A16:  MOVLW  0D
06A18:  BTFSS  F9E.4
06A1A:  BRA    6A18
06A1C:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
06A1E:  MOVLW  68
06A20:  MOVWF  FF6
06A22:  MOVLW  08
06A24:  MOVWF  FF7
06A26:  CALL   1C20
....................                             break; 
06A2A:  BRA    6DA8
....................                     case 23: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06A2C:  CALL   53AC
....................                             sysInput.nh4pt2cal2of3 = atol(bt_cmd); 
06A30:  MOVLB  7
06A32:  CLRF   xA9
06A34:  MOVLW  33
06A36:  MOVWF  xA8
06A38:  MOVLB  0
06A3A:  CALL   5868
06A3E:  MOVFF  02,248
06A42:  MOVFF  01,247
....................                             fprintf(BT,"(nh4pt8)  nh4pt3cal2of3 set to %Lu\n\r",sysInput.nh4pt3cal2of3);   
06A46:  MOVLW  9A
06A48:  MOVWF  FF6
06A4A:  MOVLW  08
06A4C:  MOVWF  FF7
06A4E:  MOVLW  1F
06A50:  MOVLB  7
06A52:  MOVWF  xA8
06A54:  MOVLB  0
06A56:  CALL   5642
06A5A:  MOVLW  10
06A5C:  MOVWF  FE9
06A5E:  MOVFF  24E,7A9
06A62:  MOVFF  24D,7A8
06A66:  CALL   5A4C
06A6A:  MOVLW  0A
06A6C:  BTFSS  F9E.4
06A6E:  BRA    6A6C
06A70:  MOVWF  FAD
06A72:  MOVLW  0D
06A74:  BTFSS  F9E.4
06A76:  BRA    6A74
06A78:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
06A7A:  MOVLW  C0
06A7C:  MOVWF  FF6
06A7E:  MOVLW  08
06A80:  MOVWF  FF7
06A82:  CALL   1C20
....................                             break; 
06A86:  BRA    6DA8
....................                     case 24: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06A88:  CALL   53AC
....................                             sysInput.nh4pt3cal3of3 = atol(bt_cmd); 
06A8C:  MOVLB  7
06A8E:  CLRF   xA9
06A90:  MOVLW  33
06A92:  MOVWF  xA8
06A94:  MOVLB  0
06A96:  CALL   5868
06A9A:  MOVFF  02,250
06A9E:  MOVFF  01,24F
....................                             fprintf(BT,"(nh4pt9)  nh4pt3cal3of3 set to %Lu\n\r",sysInput.nh4pt3cal3of3);   
06AA2:  MOVLW  F2
06AA4:  MOVWF  FF6
06AA6:  MOVLW  08
06AA8:  MOVWF  FF7
06AAA:  MOVLW  1F
06AAC:  MOVLB  7
06AAE:  MOVWF  xA8
06AB0:  MOVLB  0
06AB2:  CALL   5642
06AB6:  MOVLW  10
06AB8:  MOVWF  FE9
06ABA:  MOVFF  250,7A9
06ABE:  MOVFF  24F,7A8
06AC2:  CALL   5A4C
06AC6:  MOVLW  0A
06AC8:  BTFSS  F9E.4
06ACA:  BRA    6AC8
06ACC:  MOVWF  FAD
06ACE:  MOVLW  0D
06AD0:  BTFSS  F9E.4
06AD2:  BRA    6AD0
06AD4:  MOVWF  FAD
....................                             break; 
06AD6:  BRA    6DA8
....................                     case 25: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06AD8:  CALL   53AC
....................                             sysInput.DOpt1cal1of3 = atol(bt_cmd); 
06ADC:  MOVLB  7
06ADE:  CLRF   xA9
06AE0:  MOVLW  33
06AE2:  MOVWF  xA8
06AE4:  MOVLB  0
06AE6:  CALL   5868
06AEA:  MOVFF  02,25E
06AEE:  MOVFF  01,25D
....................                             fprintf(BT,"(DOpt1)  DOpt1cal1of3 set to %Lu\n\r",sysInput.DOpt1cal1of3);   
06AF2:  MOVLW  18
06AF4:  MOVWF  FF6
06AF6:  MOVLW  09
06AF8:  MOVWF  FF7
06AFA:  MOVLW  1D
06AFC:  MOVLB  7
06AFE:  MOVWF  xA8
06B00:  MOVLB  0
06B02:  CALL   5642
06B06:  MOVLW  10
06B08:  MOVWF  FE9
06B0A:  MOVFF  25E,7A9
06B0E:  MOVFF  25D,7A8
06B12:  CALL   5A4C
06B16:  MOVLW  0A
06B18:  BTFSS  F9E.4
06B1A:  BRA    6B18
06B1C:  MOVWF  FAD
06B1E:  MOVLW  0D
06B20:  BTFSS  F9E.4
06B22:  BRA    6B20
06B24:  MOVWF  FAD
....................                             break; 
06B26:  BRA    6DA8
....................                     case 26: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06B28:  CALL   53AC
....................                             sysInput.DOpt1cal2of3 = atol(bt_cmd); 
06B2C:  MOVLB  7
06B2E:  CLRF   xA9
06B30:  MOVLW  33
06B32:  MOVWF  xA8
06B34:  MOVLB  0
06B36:  CALL   5868
06B3A:  MOVFF  02,260
06B3E:  MOVFF  01,25F
....................                             fprintf(BT,"(DOpt2)  DOpt1cal2of3 set to %Lu\n\r",sysInput.DOpt1cal2of3);   
06B42:  MOVLW  3C
06B44:  MOVWF  FF6
06B46:  MOVLW  09
06B48:  MOVWF  FF7
06B4A:  MOVLW  1D
06B4C:  MOVLB  7
06B4E:  MOVWF  xA8
06B50:  MOVLB  0
06B52:  CALL   5642
06B56:  MOVLW  10
06B58:  MOVWF  FE9
06B5A:  MOVFF  260,7A9
06B5E:  MOVFF  25F,7A8
06B62:  CALL   5A4C
06B66:  MOVLW  0A
06B68:  BTFSS  F9E.4
06B6A:  BRA    6B68
06B6C:  MOVWF  FAD
06B6E:  MOVLW  0D
06B70:  BTFSS  F9E.4
06B72:  BRA    6B70
06B74:  MOVWF  FAD
....................                             break; 
06B76:  BRA    6DA8
....................                     case 27: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06B78:  CALL   53AC
....................                             sysInput.DOpt1cal3of3 = atol(bt_cmd); 
06B7C:  MOVLB  7
06B7E:  CLRF   xA9
06B80:  MOVLW  33
06B82:  MOVWF  xA8
06B84:  MOVLB  0
06B86:  CALL   5868
06B8A:  MOVFF  02,262
06B8E:  MOVFF  01,261
....................                             fprintf(BT,"(DOpt3)  DOpt1cal3of3 set to %Lu\n\r",sysInput.DOpt1cal3of3);   
06B92:  MOVLW  60
06B94:  MOVWF  FF6
06B96:  MOVLW  09
06B98:  MOVWF  FF7
06B9A:  MOVLW  1D
06B9C:  MOVLB  7
06B9E:  MOVWF  xA8
06BA0:  MOVLB  0
06BA2:  CALL   5642
06BA6:  MOVLW  10
06BA8:  MOVWF  FE9
06BAA:  MOVFF  262,7A9
06BAE:  MOVFF  261,7A8
06BB2:  CALL   5A4C
06BB6:  MOVLW  0A
06BB8:  BTFSS  F9E.4
06BBA:  BRA    6BB8
06BBC:  MOVWF  FAD
06BBE:  MOVLW  0D
06BC0:  BTFSS  F9E.4
06BC2:  BRA    6BC0
06BC4:  MOVWF  FAD
....................                             break; 
06BC6:  BRA    6DA8
....................                     case 28: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06BC8:  CALL   53AC
....................                             sysInput.DOpt2cal1of3 = atol(bt_cmd); 
06BCC:  MOVLB  7
06BCE:  CLRF   xA9
06BD0:  MOVLW  33
06BD2:  MOVWF  xA8
06BD4:  MOVLB  0
06BD6:  CALL   5868
06BDA:  MOVFF  02,264
06BDE:  MOVFF  01,263
....................                             fprintf(BT,"(DOpt4)  DOpt2cal1of3 set to %Lu\n\r",sysInput.DOpt2cal1of3);   
06BE2:  MOVLW  84
06BE4:  MOVWF  FF6
06BE6:  MOVLW  09
06BE8:  MOVWF  FF7
06BEA:  MOVLW  1D
06BEC:  MOVLB  7
06BEE:  MOVWF  xA8
06BF0:  MOVLB  0
06BF2:  CALL   5642
06BF6:  MOVLW  10
06BF8:  MOVWF  FE9
06BFA:  MOVFF  264,7A9
06BFE:  MOVFF  263,7A8
06C02:  CALL   5A4C
06C06:  MOVLW  0A
06C08:  BTFSS  F9E.4
06C0A:  BRA    6C08
06C0C:  MOVWF  FAD
06C0E:  MOVLW  0D
06C10:  BTFSS  F9E.4
06C12:  BRA    6C10
06C14:  MOVWF  FAD
....................                             break; 
06C16:  BRA    6DA8
....................                     case 29: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06C18:  CALL   53AC
....................                             sysInput.DOpt2cal2of3 = atol(bt_cmd); 
06C1C:  MOVLB  7
06C1E:  CLRF   xA9
06C20:  MOVLW  33
06C22:  MOVWF  xA8
06C24:  MOVLB  0
06C26:  CALL   5868
06C2A:  MOVFF  02,266
06C2E:  MOVFF  01,265
....................                             fprintf(BT,"(DOpt5)  DOpt2cal2of3 set to %Lu\n\r",sysInput.DOpt2cal2of3);   
06C32:  MOVLW  A8
06C34:  MOVWF  FF6
06C36:  MOVLW  09
06C38:  MOVWF  FF7
06C3A:  MOVLW  1D
06C3C:  MOVLB  7
06C3E:  MOVWF  xA8
06C40:  MOVLB  0
06C42:  CALL   5642
06C46:  MOVLW  10
06C48:  MOVWF  FE9
06C4A:  MOVFF  266,7A9
06C4E:  MOVFF  265,7A8
06C52:  CALL   5A4C
06C56:  MOVLW  0A
06C58:  BTFSS  F9E.4
06C5A:  BRA    6C58
06C5C:  MOVWF  FAD
06C5E:  MOVLW  0D
06C60:  BTFSS  F9E.4
06C62:  BRA    6C60
06C64:  MOVWF  FAD
....................                             break; 
06C66:  BRA    6DA8
....................                     case 30: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06C68:  CALL   53AC
....................                             sysInput.DOpt2cal3of3 = atol(bt_cmd); 
06C6C:  MOVLB  7
06C6E:  CLRF   xA9
06C70:  MOVLW  33
06C72:  MOVWF  xA8
06C74:  MOVLB  0
06C76:  CALL   5868
06C7A:  MOVFF  02,268
06C7E:  MOVFF  01,267
....................                             fprintf(BT,"(DOpt6)  DOpt2cal3of3 set to %Lu\n\r",sysInput.DOpt2cal3of3);   
06C82:  MOVLW  CC
06C84:  MOVWF  FF6
06C86:  MOVLW  09
06C88:  MOVWF  FF7
06C8A:  MOVLW  1D
06C8C:  MOVLB  7
06C8E:  MOVWF  xA8
06C90:  MOVLB  0
06C92:  CALL   5642
06C96:  MOVLW  10
06C98:  MOVWF  FE9
06C9A:  MOVFF  268,7A9
06C9E:  MOVFF  267,7A8
06CA2:  CALL   5A4C
06CA6:  MOVLW  0A
06CA8:  BTFSS  F9E.4
06CAA:  BRA    6CA8
06CAC:  MOVWF  FAD
06CAE:  MOVLW  0D
06CB0:  BTFSS  F9E.4
06CB2:  BRA    6CB0
06CB4:  MOVWF  FAD
....................                             break; 
06CB6:  BRA    6DA8
....................                     case 31: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06CB8:  CALL   53AC
....................                             sysInput.DOpt3cal1of3 = atol(bt_cmd); 
06CBC:  MOVLB  7
06CBE:  CLRF   xA9
06CC0:  MOVLW  33
06CC2:  MOVWF  xA8
06CC4:  MOVLB  0
06CC6:  CALL   5868
06CCA:  MOVFF  02,26A
06CCE:  MOVFF  01,269
....................                             fprintf(BT,"(DOpt17  DOpt3cal1of3 set to %Lu\n\r",sysInput.DOpt3cal1of3);   
06CD2:  MOVLW  F0
06CD4:  MOVWF  FF6
06CD6:  MOVLW  09
06CD8:  MOVWF  FF7
06CDA:  MOVLW  1D
06CDC:  MOVLB  7
06CDE:  MOVWF  xA8
06CE0:  MOVLB  0
06CE2:  CALL   5642
06CE6:  MOVLW  10
06CE8:  MOVWF  FE9
06CEA:  MOVFF  26A,7A9
06CEE:  MOVFF  269,7A8
06CF2:  CALL   5A4C
06CF6:  MOVLW  0A
06CF8:  BTFSS  F9E.4
06CFA:  BRA    6CF8
06CFC:  MOVWF  FAD
06CFE:  MOVLW  0D
06D00:  BTFSS  F9E.4
06D02:  BRA    6D00
06D04:  MOVWF  FAD
....................                             break; 
06D06:  BRA    6DA8
....................                     case 32: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06D08:  CALL   53AC
....................                             sysInput.DOpt3cal2of3 = atol(bt_cmd); 
06D0C:  MOVLB  7
06D0E:  CLRF   xA9
06D10:  MOVLW  33
06D12:  MOVWF  xA8
06D14:  MOVLB  0
06D16:  CALL   5868
06D1A:  MOVFF  02,26C
06D1E:  MOVFF  01,26B
....................                             fprintf(BT,"(DOpt8)  DOpt3cal2of3 set to %Lu\n\r",sysInput.DOpt3cal2of3);   
06D22:  MOVLW  14
06D24:  MOVWF  FF6
06D26:  MOVLW  0A
06D28:  MOVWF  FF7
06D2A:  MOVLW  1D
06D2C:  MOVLB  7
06D2E:  MOVWF  xA8
06D30:  MOVLB  0
06D32:  CALL   5642
06D36:  MOVLW  10
06D38:  MOVWF  FE9
06D3A:  MOVFF  26C,7A9
06D3E:  MOVFF  26B,7A8
06D42:  CALL   5A4C
06D46:  MOVLW  0A
06D48:  BTFSS  F9E.4
06D4A:  BRA    6D48
06D4C:  MOVWF  FAD
06D4E:  MOVLW  0D
06D50:  BTFSS  F9E.4
06D52:  BRA    6D50
06D54:  MOVWF  FAD
....................                             break; 
06D56:  BRA    6DA8
....................                     case 33: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06D58:  CALL   53AC
....................                             sysInput.DOpt3cal3of3 = atol(bt_cmd); 
06D5C:  MOVLB  7
06D5E:  CLRF   xA9
06D60:  MOVLW  33
06D62:  MOVWF  xA8
06D64:  MOVLB  0
06D66:  CALL   5868
06D6A:  MOVFF  02,26E
06D6E:  MOVFF  01,26D
....................                             fprintf(BT,"(DOpt9)  DOpt3cal3of3 set to %Lu\n\r",sysInput.DOpt3cal3of3);   
06D72:  MOVLW  38
06D74:  MOVWF  FF6
06D76:  MOVLW  0A
06D78:  MOVWF  FF7
06D7A:  MOVLW  1D
06D7C:  MOVLB  7
06D7E:  MOVWF  xA8
06D80:  MOVLB  0
06D82:  CALL   5642
06D86:  MOVLW  10
06D88:  MOVWF  FE9
06D8A:  MOVFF  26E,7A9
06D8E:  MOVFF  26D,7A8
06D92:  CALL   5A4C
06D96:  MOVLW  0A
06D98:  BTFSS  F9E.4
06D9A:  BRA    6D98
06D9C:  MOVWF  FAD
06D9E:  MOVLW  0D
06DA0:  BTFSS  F9E.4
06DA2:  BRA    6DA0
06DA4:  MOVWF  FAD
....................                             break; 
06DA6:  BRA    6DA8
....................                     default: 
....................                         break; 
....................                 } 
....................                 
.................... 			    //debugnumber = 0;   // turns off the debuging command when exited.  Added July 23, 2015 
....................                 
....................                 
....................  			  // fprintf(BT,"Entering into first CAL routine.  Number %i\n\r",debugnumber); 
....................                break; 
06DA8:  GOTO   779A
....................             case 3:  //this sets all of the calibrations values to defaults 
....................                 fprintf(BT,"Setting all calibration values to default.  Do a saveconfig to save it in EEPROM.\n\r"); 
06DAC:  MOVLW  5C
06DAE:  MOVWF  FF6
06DB0:  MOVLW  0A
06DB2:  MOVWF  FF7
06DB4:  CALL   1C20
....................                 sysInput.nh4pt1cal1of3 = 0; 
06DB8:  MOVLB  2
06DBA:  CLRF   x40
06DBC:  CLRF   x3F
....................                 sysInput.nh4pt1cal2of3 = 600; 
06DBE:  MOVLW  02
06DC0:  MOVWF  x42
06DC2:  MOVLW  58
06DC4:  MOVWF  x41
....................                 sysInput.nh4pt1cal3of3 = 1200; 
06DC6:  MOVLW  04
06DC8:  MOVWF  x44
06DCA:  MOVLW  B0
06DCC:  MOVWF  x43
....................                 sysInput.nh4pt2cal1of3 = 0; 
06DCE:  CLRF   x46
06DD0:  CLRF   x45
....................                 sysInput.nh4pt2cal2of3 = 0; 
06DD2:  CLRF   x48
06DD4:  CLRF   x47
....................                 sysInput.nh4pt2cal3of3 = 0; 
06DD6:  CLRF   x4A
06DD8:  CLRF   x49
....................                 sysInput.nh4pt3cal1of3 = 0; 
06DDA:  CLRF   x4C
06DDC:  CLRF   x4B
....................                 sysInput.nh4pt3cal2of3 = 0; 
06DDE:  CLRF   x4E
06DE0:  CLRF   x4D
....................                 sysInput.nh4pt3cal3of3 = 0; 
06DE2:  CLRF   x50
06DE4:  CLRF   x4F
....................                 sysInput.nh4pt1returnednumber = 2.5; 
06DE6:  CLRF   x54
06DE8:  CLRF   x53
06DEA:  MOVLW  20
06DEC:  MOVWF  x52
06DEE:  MOVLW  80
06DF0:  MOVWF  x51
....................                 sysInput.nh4pt2returnednumber = 75.0; 
06DF2:  CLRF   x58
06DF4:  CLRF   x57
06DF6:  MOVLW  16
06DF8:  MOVWF  x56
06DFA:  MOVLW  85
06DFC:  MOVWF  x55
....................                 sysInput.nh4pt3returnednumber = 150.0; 
06DFE:  CLRF   x5C
06E00:  CLRF   x5B
06E02:  MOVLW  16
06E04:  MOVWF  x5A
06E06:  MOVLW  86
06E08:  MOVWF  x59
....................                 sysInput.Thermisterpt1returnednumber = 40.0; 
06E0A:  CLRF   x84
06E0C:  CLRF   x83
06E0E:  MOVLW  20
06E10:  MOVWF  x82
06E12:  MOVLW  84
06E14:  MOVWF  x81
....................                 sysInput.Thermisterpt2returnednumber = 21.0; 
06E16:  CLRF   x88
06E18:  CLRF   x87
06E1A:  MOVLW  28
06E1C:  MOVWF  x86
06E1E:  MOVLW  83
06E20:  MOVWF  x85
....................                 sysInput.Thermisterpt3returnednumber = 0.0; 
06E22:  CLRF   x8C
06E24:  CLRF   x8B
06E26:  CLRF   x8A
06E28:  CLRF   x89
....................                 sysInput.Thermisterpt1cal1of3 = 5000; 
06E2A:  MOVLW  13
06E2C:  MOVWF  x7C
06E2E:  MOVLW  88
06E30:  MOVWF  x7B
....................                 sysInput.Thermisterpt1cal2of3 = 2500; 
06E32:  MOVLW  09
06E34:  MOVWF  x7E
06E36:  MOVLW  C4
06E38:  MOVWF  x7D
....................                 sysInput.Thermisterpt1cal3of3 = 500; 
06E3A:  MOVLW  01
06E3C:  MOVWF  x80
06E3E:  MOVLW  F4
06E40:  MOVWF  x7F
....................                break; 
06E42:  MOVLB  0
06E44:  GOTO   779A
....................             case 4:     // showconfig    // the strcture is on the Master include file 
....................                 /* 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
....................  
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
....................                  */ 
....................                 fprintf(BT,"Current Calibrations\n\r");    
06E48:  MOVLW  B0
06E4A:  MOVWF  FF6
06E4C:  MOVLW  0A
06E4E:  MOVWF  FF7
06E50:  CALL   1C20
....................                 fprintf(BT,"phcallow = %f\n\r",sysInput.phcallow);  
06E54:  MOVLW  C8
06E56:  MOVWF  FF6
06E58:  MOVLW  0A
06E5A:  MOVWF  FF7
06E5C:  MOVLW  0B
06E5E:  MOVLB  7
06E60:  MOVWF  xA8
06E62:  MOVLB  0
06E64:  CALL   5642
06E68:  MOVLW  89
06E6A:  MOVWF  FE9
06E6C:  MOVFF  236,7AB
06E70:  MOVFF  235,7AA
06E74:  MOVFF  234,7A9
06E78:  MOVFF  233,7A8
06E7C:  MOVLW  02
06E7E:  MOVLB  7
06E80:  MOVWF  xAC
06E82:  MOVLB  0
06E84:  CALL   566C
06E88:  MOVLW  0A
06E8A:  BTFSS  F9E.4
06E8C:  BRA    6E8A
06E8E:  MOVWF  FAD
06E90:  MOVLW  0D
06E92:  BTFSS  F9E.4
06E94:  BRA    6E92
06E96:  MOVWF  FAD
....................                 fprintf(BT,"phcalhigh = %f\n\r",sysInput.phcalhigh);  
06E98:  MOVLW  D8
06E9A:  MOVWF  FF6
06E9C:  MOVLW  0A
06E9E:  MOVWF  FF7
06EA0:  MOVLW  0C
06EA2:  MOVLB  7
06EA4:  MOVWF  xA8
06EA6:  MOVLB  0
06EA8:  CALL   5642
06EAC:  MOVLW  89
06EAE:  MOVWF  FE9
06EB0:  MOVFF  23A,7AB
06EB4:  MOVFF  239,7AA
06EB8:  MOVFF  238,7A9
06EBC:  MOVFF  237,7A8
06EC0:  MOVLW  02
06EC2:  MOVLB  7
06EC4:  MOVWF  xAC
06EC6:  MOVLB  0
06EC8:  CALL   566C
06ECC:  MOVLW  0A
06ECE:  BTFSS  F9E.4
06ED0:  BRA    6ECE
06ED2:  MOVWF  FAD
06ED4:  MOVLW  0D
06ED6:  BTFSS  F9E.4
06ED8:  BRA    6ED6
06EDA:  MOVWF  FAD
....................                 fprintf(BT,"phnumberupper = %f\n\r",sysInput.phnumberupper);  
06EDC:  MOVLW  EA
06EDE:  MOVWF  FF6
06EE0:  MOVLW  0A
06EE2:  MOVWF  FF7
06EE4:  MOVLW  10
06EE6:  MOVLB  7
06EE8:  MOVWF  xA8
06EEA:  MOVLB  0
06EEC:  CALL   5642
06EF0:  MOVLW  89
06EF2:  MOVWF  FE9
06EF4:  MOVFF  23E,7AB
06EF8:  MOVFF  23D,7AA
06EFC:  MOVFF  23C,7A9
06F00:  MOVFF  23B,7A8
06F04:  MOVLW  02
06F06:  MOVLB  7
06F08:  MOVWF  xAC
06F0A:  MOVLB  0
06F0C:  CALL   566C
06F10:  MOVLW  0A
06F12:  BTFSS  F9E.4
06F14:  BRA    6F12
06F16:  MOVWF  FAD
06F18:  MOVLW  0D
06F1A:  BTFSS  F9E.4
06F1C:  BRA    6F1A
06F1E:  MOVWF  FAD
....................                  
....................                 fprintf(BT,"(nh4pt1) nh4pt1cal1of3 = %Lu\n\r",sysInput.nh4pt1cal1of3); 
06F20:  MOVLW  00
06F22:  MOVWF  FF6
06F24:  MOVLW  0B
06F26:  MOVWF  FF7
06F28:  MOVLW  19
06F2A:  MOVLB  7
06F2C:  MOVWF  xA8
06F2E:  MOVLB  0
06F30:  CALL   5642
06F34:  MOVLW  10
06F36:  MOVWF  FE9
06F38:  MOVFF  240,7A9
06F3C:  MOVFF  23F,7A8
06F40:  CALL   5A4C
06F44:  MOVLW  0A
06F46:  BTFSS  F9E.4
06F48:  BRA    6F46
06F4A:  MOVWF  FAD
06F4C:  MOVLW  0D
06F4E:  BTFSS  F9E.4
06F50:  BRA    6F4E
06F52:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt2) nh4pt1cal2of3 = %Lu\n\r",sysInput.nh4pt1cal2of3); 
06F54:  MOVLW  20
06F56:  MOVWF  FF6
06F58:  MOVLW  0B
06F5A:  MOVWF  FF7
06F5C:  MOVLW  19
06F5E:  MOVLB  7
06F60:  MOVWF  xA8
06F62:  MOVLB  0
06F64:  CALL   5642
06F68:  MOVLW  10
06F6A:  MOVWF  FE9
06F6C:  MOVFF  242,7A9
06F70:  MOVFF  241,7A8
06F74:  CALL   5A4C
06F78:  MOVLW  0A
06F7A:  BTFSS  F9E.4
06F7C:  BRA    6F7A
06F7E:  MOVWF  FAD
06F80:  MOVLW  0D
06F82:  BTFSS  F9E.4
06F84:  BRA    6F82
06F86:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt3) nh4pt1cal3of3 = %Lu\n\r",sysInput.nh4pt1cal3of3); 
06F88:  MOVLW  40
06F8A:  MOVWF  FF6
06F8C:  MOVLW  0B
06F8E:  MOVWF  FF7
06F90:  MOVLW  19
06F92:  MOVLB  7
06F94:  MOVWF  xA8
06F96:  MOVLB  0
06F98:  CALL   5642
06F9C:  MOVLW  10
06F9E:  MOVWF  FE9
06FA0:  MOVFF  244,7A9
06FA4:  MOVFF  243,7A8
06FA8:  CALL   5A4C
06FAC:  MOVLW  0A
06FAE:  BTFSS  F9E.4
06FB0:  BRA    6FAE
06FB2:  MOVWF  FAD
06FB4:  MOVLW  0D
06FB6:  BTFSS  F9E.4
06FB8:  BRA    6FB6
06FBA:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt4) nh4pt2cal1of3 = %Lu\n\r",sysInput.nh4pt2cal1of3); 
06FBC:  MOVLW  60
06FBE:  MOVWF  FF6
06FC0:  MOVLW  0B
06FC2:  MOVWF  FF7
06FC4:  MOVLW  19
06FC6:  MOVLB  7
06FC8:  MOVWF  xA8
06FCA:  MOVLB  0
06FCC:  CALL   5642
06FD0:  MOVLW  10
06FD2:  MOVWF  FE9
06FD4:  MOVFF  246,7A9
06FD8:  MOVFF  245,7A8
06FDC:  CALL   5A4C
06FE0:  MOVLW  0A
06FE2:  BTFSS  F9E.4
06FE4:  BRA    6FE2
06FE6:  MOVWF  FAD
06FE8:  MOVLW  0D
06FEA:  BTFSS  F9E.4
06FEC:  BRA    6FEA
06FEE:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt5) nh4pt2cal2of3 = %Lu\n\r",sysInput.nh4pt2cal2of3); 
06FF0:  MOVLW  80
06FF2:  MOVWF  FF6
06FF4:  MOVLW  0B
06FF6:  MOVWF  FF7
06FF8:  MOVLW  19
06FFA:  MOVLB  7
06FFC:  MOVWF  xA8
06FFE:  MOVLB  0
07000:  CALL   5642
07004:  MOVLW  10
07006:  MOVWF  FE9
07008:  MOVFF  248,7A9
0700C:  MOVFF  247,7A8
07010:  CALL   5A4C
07014:  MOVLW  0A
07016:  BTFSS  F9E.4
07018:  BRA    7016
0701A:  MOVWF  FAD
0701C:  MOVLW  0D
0701E:  BTFSS  F9E.4
07020:  BRA    701E
07022:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt6) nh4pt2cal3of3 = %Lu\n\r",sysInput.nh4pt2cal3of3); 
07024:  MOVLW  A0
07026:  MOVWF  FF6
07028:  MOVLW  0B
0702A:  MOVWF  FF7
0702C:  MOVLW  19
0702E:  MOVLB  7
07030:  MOVWF  xA8
07032:  MOVLB  0
07034:  CALL   5642
07038:  MOVLW  10
0703A:  MOVWF  FE9
0703C:  MOVFF  24A,7A9
07040:  MOVFF  249,7A8
07044:  CALL   5A4C
07048:  MOVLW  0A
0704A:  BTFSS  F9E.4
0704C:  BRA    704A
0704E:  MOVWF  FAD
07050:  MOVLW  0D
07052:  BTFSS  F9E.4
07054:  BRA    7052
07056:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt7) nh4pt3cal1of3 = %Lu\n\r",sysInput.nh4pt3cal1of3); 
07058:  MOVLW  C0
0705A:  MOVWF  FF6
0705C:  MOVLW  0B
0705E:  MOVWF  FF7
07060:  MOVLW  19
07062:  MOVLB  7
07064:  MOVWF  xA8
07066:  MOVLB  0
07068:  CALL   5642
0706C:  MOVLW  10
0706E:  MOVWF  FE9
07070:  MOVFF  24C,7A9
07074:  MOVFF  24B,7A8
07078:  CALL   5A4C
0707C:  MOVLW  0A
0707E:  BTFSS  F9E.4
07080:  BRA    707E
07082:  MOVWF  FAD
07084:  MOVLW  0D
07086:  BTFSS  F9E.4
07088:  BRA    7086
0708A:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt8) nh4pt3cal2of3 = %Lu\n\r",sysInput.nh4pt3cal2of3); 
0708C:  MOVLW  E0
0708E:  MOVWF  FF6
07090:  MOVLW  0B
07092:  MOVWF  FF7
07094:  MOVLW  19
07096:  MOVLB  7
07098:  MOVWF  xA8
0709A:  MOVLB  0
0709C:  CALL   5642
070A0:  MOVLW  10
070A2:  MOVWF  FE9
070A4:  MOVFF  24E,7A9
070A8:  MOVFF  24D,7A8
070AC:  CALL   5A4C
070B0:  MOVLW  0A
070B2:  BTFSS  F9E.4
070B4:  BRA    70B2
070B6:  MOVWF  FAD
070B8:  MOVLW  0D
070BA:  BTFSS  F9E.4
070BC:  BRA    70BA
070BE:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt9) nh4pt3cal3of3 = %Lu\n\r",sysInput.nh4pt3cal3of3);  
070C0:  MOVLW  00
070C2:  MOVWF  FF6
070C4:  MOVLW  0C
070C6:  MOVWF  FF7
070C8:  MOVLW  19
070CA:  MOVLB  7
070CC:  MOVWF  xA8
070CE:  MOVLB  0
070D0:  CALL   5642
070D4:  MOVLW  10
070D6:  MOVWF  FE9
070D8:  MOVFF  250,7A9
070DC:  MOVFF  24F,7A8
070E0:  CALL   5A4C
070E4:  MOVLW  0A
070E6:  BTFSS  F9E.4
070E8:  BRA    70E6
070EA:  MOVWF  FAD
070EC:  MOVLW  0D
070EE:  BTFSS  F9E.4
070F0:  BRA    70EE
070F2:  MOVWF  FAD
....................  
....................                 fprintf(BT,"(retnh41) nh4pt1returnednumber = %f\n\r",sysInput.nh4pt1returnednumber);  
070F4:  MOVLW  20
070F6:  MOVWF  FF6
070F8:  MOVLW  0C
070FA:  MOVWF  FF7
070FC:  MOVLW  21
070FE:  MOVLB  7
07100:  MOVWF  xA8
07102:  MOVLB  0
07104:  CALL   5642
07108:  MOVLW  89
0710A:  MOVWF  FE9
0710C:  MOVFF  254,7AB
07110:  MOVFF  253,7AA
07114:  MOVFF  252,7A9
07118:  MOVFF  251,7A8
0711C:  MOVLW  02
0711E:  MOVLB  7
07120:  MOVWF  xAC
07122:  MOVLB  0
07124:  CALL   566C
07128:  MOVLW  0A
0712A:  BTFSS  F9E.4
0712C:  BRA    712A
0712E:  MOVWF  FAD
07130:  MOVLW  0D
07132:  BTFSS  F9E.4
07134:  BRA    7132
07136:  MOVWF  FAD
....................                 fprintf(BT,"(retnh42) nh4pt2returnednumber = %f\n\r",sysInput.nh4pt2returnednumber);  
07138:  MOVLW  46
0713A:  MOVWF  FF6
0713C:  MOVLW  0C
0713E:  MOVWF  FF7
07140:  MOVLW  21
07142:  MOVLB  7
07144:  MOVWF  xA8
07146:  MOVLB  0
07148:  CALL   5642
0714C:  MOVLW  89
0714E:  MOVWF  FE9
07150:  MOVFF  258,7AB
07154:  MOVFF  257,7AA
07158:  MOVFF  256,7A9
0715C:  MOVFF  255,7A8
07160:  MOVLW  02
07162:  MOVLB  7
07164:  MOVWF  xAC
07166:  MOVLB  0
07168:  CALL   566C
0716C:  MOVLW  0A
0716E:  BTFSS  F9E.4
07170:  BRA    716E
07172:  MOVWF  FAD
07174:  MOVLW  0D
07176:  BTFSS  F9E.4
07178:  BRA    7176
0717A:  MOVWF  FAD
....................                 fprintf(BT,"(retnh43) nh4pt3returnednumber = %f\n\r",sysInput.nh4pt3returnednumber);   
0717C:  MOVLW  6C
0717E:  MOVWF  FF6
07180:  MOVLW  0C
07182:  MOVWF  FF7
07184:  MOVLW  21
07186:  MOVLB  7
07188:  MOVWF  xA8
0718A:  MOVLB  0
0718C:  CALL   5642
07190:  MOVLW  89
07192:  MOVWF  FE9
07194:  MOVFF  25C,7AB
07198:  MOVFF  25B,7AA
0719C:  MOVFF  25A,7A9
071A0:  MOVFF  259,7A8
071A4:  MOVLW  02
071A6:  MOVLB  7
071A8:  MOVWF  xAC
071AA:  MOVLB  0
071AC:  CALL   566C
071B0:  MOVLW  0A
071B2:  BTFSS  F9E.4
071B4:  BRA    71B2
071B6:  MOVWF  FAD
071B8:  MOVLW  0D
071BA:  BTFSS  F9E.4
071BC:  BRA    71BA
071BE:  MOVWF  FAD
....................                  
....................                 fprintf(BT,"(DOpt1) DOpt1cal1of3 = %Lu\n\r",sysInput.DOpt1cal1of3); 
071C0:  MOVLW  92
071C2:  MOVWF  FF6
071C4:  MOVLW  0C
071C6:  MOVWF  FF7
071C8:  MOVLW  17
071CA:  MOVLB  7
071CC:  MOVWF  xA8
071CE:  MOVLB  0
071D0:  CALL   5642
071D4:  MOVLW  10
071D6:  MOVWF  FE9
071D8:  MOVFF  25E,7A9
071DC:  MOVFF  25D,7A8
071E0:  CALL   5A4C
071E4:  MOVLW  0A
071E6:  BTFSS  F9E.4
071E8:  BRA    71E6
071EA:  MOVWF  FAD
071EC:  MOVLW  0D
071EE:  BTFSS  F9E.4
071F0:  BRA    71EE
071F2:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt2) DOpt1cal2of3 = %Lu\n\r",sysInput.DOpt1cal2of3); 
071F4:  MOVLW  B0
071F6:  MOVWF  FF6
071F8:  MOVLW  0C
071FA:  MOVWF  FF7
071FC:  MOVLW  17
071FE:  MOVLB  7
07200:  MOVWF  xA8
07202:  MOVLB  0
07204:  CALL   5642
07208:  MOVLW  10
0720A:  MOVWF  FE9
0720C:  MOVFF  260,7A9
07210:  MOVFF  25F,7A8
07214:  CALL   5A4C
07218:  MOVLW  0A
0721A:  BTFSS  F9E.4
0721C:  BRA    721A
0721E:  MOVWF  FAD
07220:  MOVLW  0D
07222:  BTFSS  F9E.4
07224:  BRA    7222
07226:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt3) DOpt1cal3of3 = %Lu\n\r",sysInput.DOpt1cal3of3); 
07228:  MOVLW  CE
0722A:  MOVWF  FF6
0722C:  MOVLW  0C
0722E:  MOVWF  FF7
07230:  MOVLW  17
07232:  MOVLB  7
07234:  MOVWF  xA8
07236:  MOVLB  0
07238:  CALL   5642
0723C:  MOVLW  10
0723E:  MOVWF  FE9
07240:  MOVFF  262,7A9
07244:  MOVFF  261,7A8
07248:  CALL   5A4C
0724C:  MOVLW  0A
0724E:  BTFSS  F9E.4
07250:  BRA    724E
07252:  MOVWF  FAD
07254:  MOVLW  0D
07256:  BTFSS  F9E.4
07258:  BRA    7256
0725A:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt4) DOpt2cal1of3 = %Lu\n\r",sysInput.DOpt2cal1of3); 
0725C:  MOVLW  EC
0725E:  MOVWF  FF6
07260:  MOVLW  0C
07262:  MOVWF  FF7
07264:  MOVLW  17
07266:  MOVLB  7
07268:  MOVWF  xA8
0726A:  MOVLB  0
0726C:  CALL   5642
07270:  MOVLW  10
07272:  MOVWF  FE9
07274:  MOVFF  264,7A9
07278:  MOVFF  263,7A8
0727C:  CALL   5A4C
07280:  MOVLW  0A
07282:  BTFSS  F9E.4
07284:  BRA    7282
07286:  MOVWF  FAD
07288:  MOVLW  0D
0728A:  BTFSS  F9E.4
0728C:  BRA    728A
0728E:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt5) DOpt2cal2of3 = %Lu\n\r",sysInput.DOpt2cal2of3); 
07290:  MOVLW  0A
07292:  MOVWF  FF6
07294:  MOVLW  0D
07296:  MOVWF  FF7
07298:  MOVLW  17
0729A:  MOVLB  7
0729C:  MOVWF  xA8
0729E:  MOVLB  0
072A0:  CALL   5642
072A4:  MOVLW  10
072A6:  MOVWF  FE9
072A8:  MOVFF  266,7A9
072AC:  MOVFF  265,7A8
072B0:  CALL   5A4C
072B4:  MOVLW  0A
072B6:  BTFSS  F9E.4
072B8:  BRA    72B6
072BA:  MOVWF  FAD
072BC:  MOVLW  0D
072BE:  BTFSS  F9E.4
072C0:  BRA    72BE
072C2:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt6) DOpt2cal3of3 = %Lu\n\r",sysInput.DOpt2cal3of3); 
072C4:  MOVLW  28
072C6:  MOVWF  FF6
072C8:  MOVLW  0D
072CA:  MOVWF  FF7
072CC:  MOVLW  17
072CE:  MOVLB  7
072D0:  MOVWF  xA8
072D2:  MOVLB  0
072D4:  CALL   5642
072D8:  MOVLW  10
072DA:  MOVWF  FE9
072DC:  MOVFF  268,7A9
072E0:  MOVFF  267,7A8
072E4:  CALL   5A4C
072E8:  MOVLW  0A
072EA:  BTFSS  F9E.4
072EC:  BRA    72EA
072EE:  MOVWF  FAD
072F0:  MOVLW  0D
072F2:  BTFSS  F9E.4
072F4:  BRA    72F2
072F6:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt7) DOpt3cal1of3 = %Lu\n\r",sysInput.DOpt3cal1of3); 
072F8:  MOVLW  46
072FA:  MOVWF  FF6
072FC:  MOVLW  0D
072FE:  MOVWF  FF7
07300:  MOVLW  17
07302:  MOVLB  7
07304:  MOVWF  xA8
07306:  MOVLB  0
07308:  CALL   5642
0730C:  MOVLW  10
0730E:  MOVWF  FE9
07310:  MOVFF  26A,7A9
07314:  MOVFF  269,7A8
07318:  CALL   5A4C
0731C:  MOVLW  0A
0731E:  BTFSS  F9E.4
07320:  BRA    731E
07322:  MOVWF  FAD
07324:  MOVLW  0D
07326:  BTFSS  F9E.4
07328:  BRA    7326
0732A:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt8) DOpt3cal2of3 = %Lu\n\r",sysInput.DOpt3cal2of3); 
0732C:  MOVLW  64
0732E:  MOVWF  FF6
07330:  MOVLW  0D
07332:  MOVWF  FF7
07334:  MOVLW  17
07336:  MOVLB  7
07338:  MOVWF  xA8
0733A:  MOVLB  0
0733C:  CALL   5642
07340:  MOVLW  10
07342:  MOVWF  FE9
07344:  MOVFF  26C,7A9
07348:  MOVFF  26B,7A8
0734C:  CALL   5A4C
07350:  MOVLW  0A
07352:  BTFSS  F9E.4
07354:  BRA    7352
07356:  MOVWF  FAD
07358:  MOVLW  0D
0735A:  BTFSS  F9E.4
0735C:  BRA    735A
0735E:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt9) DOpt3cal3of3 = %Lu\n\r",sysInput.DOpt3cal3of3);  
07360:  MOVLW  82
07362:  MOVWF  FF6
07364:  MOVLW  0D
07366:  MOVWF  FF7
07368:  MOVLW  17
0736A:  MOVLB  7
0736C:  MOVWF  xA8
0736E:  MOVLB  0
07370:  CALL   5642
07374:  MOVLW  10
07376:  MOVWF  FE9
07378:  MOVFF  26E,7A9
0737C:  MOVFF  26D,7A8
07380:  CALL   5A4C
07384:  MOVLW  0A
07386:  BTFSS  F9E.4
07388:  BRA    7386
0738A:  MOVWF  FAD
0738C:  MOVLW  0D
0738E:  BTFSS  F9E.4
07390:  BRA    738E
07392:  MOVWF  FAD
....................                  
....................                 fprintf(BT,"(DOret1) DOpt1returnednumber = %f\n\r",sysInput.DOpt1returnednumber);  
07394:  MOVLW  A0
07396:  MOVWF  FF6
07398:  MOVLW  0D
0739A:  MOVWF  FF7
0739C:  MOVLW  1F
0739E:  MOVLB  7
073A0:  MOVWF  xA8
073A2:  MOVLB  0
073A4:  CALL   5642
073A8:  MOVLW  89
073AA:  MOVWF  FE9
073AC:  MOVFF  272,7AB
073B0:  MOVFF  271,7AA
073B4:  MOVFF  270,7A9
073B8:  MOVFF  26F,7A8
073BC:  MOVLW  02
073BE:  MOVLB  7
073C0:  MOVWF  xAC
073C2:  MOVLB  0
073C4:  CALL   566C
073C8:  MOVLW  0A
073CA:  BTFSS  F9E.4
073CC:  BRA    73CA
073CE:  MOVWF  FAD
073D0:  MOVLW  0D
073D2:  BTFSS  F9E.4
073D4:  BRA    73D2
073D6:  MOVWF  FAD
....................                 fprintf(BT,"(DOret) DOpt2returnednumber = %f\n\r",sysInput.DOpt2returnednumber);  
073D8:  MOVLW  C4
073DA:  MOVWF  FF6
073DC:  MOVLW  0D
073DE:  MOVWF  FF7
073E0:  MOVLW  1E
073E2:  MOVLB  7
073E4:  MOVWF  xA8
073E6:  MOVLB  0
073E8:  CALL   5642
073EC:  MOVLW  89
073EE:  MOVWF  FE9
073F0:  MOVFF  276,7AB
073F4:  MOVFF  275,7AA
073F8:  MOVFF  274,7A9
073FC:  MOVFF  273,7A8
07400:  MOVLW  02
07402:  MOVLB  7
07404:  MOVWF  xAC
07406:  MOVLB  0
07408:  CALL   566C
0740C:  MOVLW  0A
0740E:  BTFSS  F9E.4
07410:  BRA    740E
07412:  MOVWF  FAD
07414:  MOVLW  0D
07416:  BTFSS  F9E.4
07418:  BRA    7416
0741A:  MOVWF  FAD
....................                 fprintf(BT,"(DOret3) DOpt3returnednumber = %f\n\r",sysInput.DOpt3returnednumber);    
0741C:  MOVLW  E8
0741E:  MOVWF  FF6
07420:  MOVLW  0D
07422:  MOVWF  FF7
07424:  MOVLW  1F
07426:  MOVLB  7
07428:  MOVWF  xA8
0742A:  MOVLB  0
0742C:  CALL   5642
07430:  MOVLW  89
07432:  MOVWF  FE9
07434:  MOVFF  27A,7AB
07438:  MOVFF  279,7AA
0743C:  MOVFF  278,7A9
07440:  MOVFF  277,7A8
07444:  MOVLW  02
07446:  MOVLB  7
07448:  MOVWF  xAC
0744A:  MOVLB  0
0744C:  CALL   566C
07450:  MOVLW  0A
07452:  BTFSS  F9E.4
07454:  BRA    7452
07456:  MOVWF  FAD
07458:  MOVLW  0D
0745A:  BTFSS  F9E.4
0745C:  BRA    745A
0745E:  MOVWF  FAD
....................                  
....................                 fprintf(BT,"(THpt1) Thermisterpt1cal1of3 = %Lu\n\r",sysInput.Thermisterpt1cal1of3); 
07460:  MOVLW  0C
07462:  MOVWF  FF6
07464:  MOVLW  0E
07466:  MOVWF  FF7
07468:  MOVLW  1F
0746A:  MOVLB  7
0746C:  MOVWF  xA8
0746E:  MOVLB  0
07470:  CALL   5642
07474:  MOVLW  10
07476:  MOVWF  FE9
07478:  MOVFF  27C,7A9
0747C:  MOVFF  27B,7A8
07480:  CALL   5A4C
07484:  MOVLW  0A
07486:  BTFSS  F9E.4
07488:  BRA    7486
0748A:  MOVWF  FAD
0748C:  MOVLW  0D
0748E:  BTFSS  F9E.4
07490:  BRA    748E
07492:  MOVWF  FAD
....................                 fprintf(BT,"(THpt2) Thermisterpt2cal1of3 = %Lu\n\r",sysInput.Thermisterpt1cal2of3); 
07494:  MOVLW  32
07496:  MOVWF  FF6
07498:  MOVLW  0E
0749A:  MOVWF  FF7
0749C:  MOVLW  1F
0749E:  MOVLB  7
074A0:  MOVWF  xA8
074A2:  MOVLB  0
074A4:  CALL   5642
074A8:  MOVLW  10
074AA:  MOVWF  FE9
074AC:  MOVFF  27E,7A9
074B0:  MOVFF  27D,7A8
074B4:  CALL   5A4C
074B8:  MOVLW  0A
074BA:  BTFSS  F9E.4
074BC:  BRA    74BA
074BE:  MOVWF  FAD
074C0:  MOVLW  0D
074C2:  BTFSS  F9E.4
074C4:  BRA    74C2
074C6:  MOVWF  FAD
....................                 fprintf(BT,"(THpt3) Thermisterpt3cal1of3 = %Lu\n\r",sysInput.Thermisterpt1cal3of3);  
074C8:  MOVLW  58
074CA:  MOVWF  FF6
074CC:  MOVLW  0E
074CE:  MOVWF  FF7
074D0:  MOVLW  1F
074D2:  MOVLB  7
074D4:  MOVWF  xA8
074D6:  MOVLB  0
074D8:  CALL   5642
074DC:  MOVLW  10
074DE:  MOVWF  FE9
074E0:  MOVFF  280,7A9
074E4:  MOVFF  27F,7A8
074E8:  CALL   5A4C
074EC:  MOVLW  0A
074EE:  BTFSS  F9E.4
074F0:  BRA    74EE
074F2:  MOVWF  FAD
074F4:  MOVLW  0D
074F6:  BTFSS  F9E.4
074F8:  BRA    74F6
074FA:  MOVWF  FAD
....................   
....................                 fprintf(BT,"(THret1) Thermisterpt1returnednumber = %f\n\r",sysInput.Thermisterpt1returnednumber);  
074FC:  MOVLW  7E
074FE:  MOVWF  FF6
07500:  MOVLW  0E
07502:  MOVWF  FF7
07504:  MOVLW  27
07506:  MOVLB  7
07508:  MOVWF  xA8
0750A:  MOVLB  0
0750C:  CALL   5642
07510:  MOVLW  89
07512:  MOVWF  FE9
07514:  MOVFF  284,7AB
07518:  MOVFF  283,7AA
0751C:  MOVFF  282,7A9
07520:  MOVFF  281,7A8
07524:  MOVLW  02
07526:  MOVLB  7
07528:  MOVWF  xAC
0752A:  MOVLB  0
0752C:  CALL   566C
07530:  MOVLW  0A
07532:  BTFSS  F9E.4
07534:  BRA    7532
07536:  MOVWF  FAD
07538:  MOVLW  0D
0753A:  BTFSS  F9E.4
0753C:  BRA    753A
0753E:  MOVWF  FAD
....................                 fprintf(BT,"(THret2) Thermisterpt2returnednumber = %f\n\r",sysInput.Thermisterpt2returnednumber);  
07540:  MOVLW  AA
07542:  MOVWF  FF6
07544:  MOVLW  0E
07546:  MOVWF  FF7
07548:  MOVLW  27
0754A:  MOVLB  7
0754C:  MOVWF  xA8
0754E:  MOVLB  0
07550:  CALL   5642
07554:  MOVLW  89
07556:  MOVWF  FE9
07558:  MOVFF  288,7AB
0755C:  MOVFF  287,7AA
07560:  MOVFF  286,7A9
07564:  MOVFF  285,7A8
07568:  MOVLW  02
0756A:  MOVLB  7
0756C:  MOVWF  xAC
0756E:  MOVLB  0
07570:  CALL   566C
07574:  MOVLW  0A
07576:  BTFSS  F9E.4
07578:  BRA    7576
0757A:  MOVWF  FAD
0757C:  MOVLW  0D
0757E:  BTFSS  F9E.4
07580:  BRA    757E
07582:  MOVWF  FAD
....................                 fprintf(BT,"(THret3) Thermisterpt3returnednumber = %f\n\r",sysInput.Thermisterpt3returnednumber);    
07584:  MOVLW  D6
07586:  MOVWF  FF6
07588:  MOVLW  0E
0758A:  MOVWF  FF7
0758C:  MOVLW  27
0758E:  MOVLB  7
07590:  MOVWF  xA8
07592:  MOVLB  0
07594:  CALL   5642
07598:  MOVLW  89
0759A:  MOVWF  FE9
0759C:  MOVFF  28C,7AB
075A0:  MOVFF  28B,7AA
075A4:  MOVFF  28A,7A9
075A8:  MOVFF  289,7A8
075AC:  MOVLW  02
075AE:  MOVLB  7
075B0:  MOVWF  xAC
075B2:  MOVLB  0
075B4:  CALL   566C
075B8:  MOVLW  0A
075BA:  BTFSS  F9E.4
075BC:  BRA    75BA
075BE:  MOVWF  FAD
075C0:  MOVLW  0D
075C2:  BTFSS  F9E.4
075C4:  BRA    75C2
075C6:  MOVWF  FAD
....................             
....................                 fprintf(BT,"eccal1x = %f\n\r",sysInput.eccal1x);  
075C8:  MOVLW  02
075CA:  MOVWF  FF6
075CC:  MOVLW  0F
075CE:  MOVWF  FF7
075D0:  MOVLW  0A
075D2:  MOVLB  7
075D4:  MOVWF  xA8
075D6:  MOVLB  0
075D8:  CALL   5642
075DC:  MOVLW  89
075DE:  MOVWF  FE9
075E0:  MOVFF  290,7AB
075E4:  MOVFF  28F,7AA
075E8:  MOVFF  28E,7A9
075EC:  MOVFF  28D,7A8
075F0:  MOVLW  02
075F2:  MOVLB  7
075F4:  MOVWF  xAC
075F6:  MOVLB  0
075F8:  CALL   566C
075FC:  MOVLW  0A
075FE:  BTFSS  F9E.4
07600:  BRA    75FE
07602:  MOVWF  FAD
07604:  MOVLW  0D
07606:  BTFSS  F9E.4
07608:  BRA    7606
0760A:  MOVWF  FAD
....................                 fprintf(BT,"eccal2x = %f\n\r",sysInput.eccal2x);  
0760C:  MOVLW  12
0760E:  MOVWF  FF6
07610:  MOVLW  0F
07612:  MOVWF  FF7
07614:  MOVLW  0A
07616:  MOVLB  7
07618:  MOVWF  xA8
0761A:  MOVLB  0
0761C:  CALL   5642
07620:  MOVLW  89
07622:  MOVWF  FE9
07624:  MOVFF  294,7AB
07628:  MOVFF  293,7AA
0762C:  MOVFF  292,7A9
07630:  MOVFF  291,7A8
07634:  MOVLW  02
07636:  MOVLB  7
07638:  MOVWF  xAC
0763A:  MOVLB  0
0763C:  CALL   566C
07640:  MOVLW  0A
07642:  BTFSS  F9E.4
07644:  BRA    7642
07646:  MOVWF  FAD
07648:  MOVLW  0D
0764A:  BTFSS  F9E.4
0764C:  BRA    764A
0764E:  MOVWF  FAD
....................                 fprintf(BT,"eccal3x = %f\n\r",sysInput.eccal3x);  
07650:  MOVLW  22
07652:  MOVWF  FF6
07654:  MOVLW  0F
07656:  MOVWF  FF7
07658:  MOVLW  0A
0765A:  MOVLB  7
0765C:  MOVWF  xA8
0765E:  MOVLB  0
07660:  CALL   5642
07664:  MOVLW  89
07666:  MOVWF  FE9
07668:  MOVFF  298,7AB
0766C:  MOVFF  297,7AA
07670:  MOVFF  296,7A9
07674:  MOVFF  295,7A8
07678:  MOVLW  02
0767A:  MOVLB  7
0767C:  MOVWF  xAC
0767E:  MOVLB  0
07680:  CALL   566C
07684:  MOVLW  0A
07686:  BTFSS  F9E.4
07688:  BRA    7686
0768A:  MOVWF  FAD
0768C:  MOVLW  0D
0768E:  BTFSS  F9E.4
07690:  BRA    768E
07692:  MOVWF  FAD
....................                  
....................                 fprintf(BT,"eccal1y = %f\n\r",sysInput.eccal1y);  
07694:  MOVLW  32
07696:  MOVWF  FF6
07698:  MOVLW  0F
0769A:  MOVWF  FF7
0769C:  MOVLW  0A
0769E:  MOVLB  7
076A0:  MOVWF  xA8
076A2:  MOVLB  0
076A4:  CALL   5642
076A8:  MOVLW  89
076AA:  MOVWF  FE9
076AC:  MOVFF  29C,7AB
076B0:  MOVFF  29B,7AA
076B4:  MOVFF  29A,7A9
076B8:  MOVFF  299,7A8
076BC:  MOVLW  02
076BE:  MOVLB  7
076C0:  MOVWF  xAC
076C2:  MOVLB  0
076C4:  CALL   566C
076C8:  MOVLW  0A
076CA:  BTFSS  F9E.4
076CC:  BRA    76CA
076CE:  MOVWF  FAD
076D0:  MOVLW  0D
076D2:  BTFSS  F9E.4
076D4:  BRA    76D2
076D6:  MOVWF  FAD
....................                 fprintf(BT,"eccal2y = %f\n\r",sysInput.eccal2y);  
076D8:  MOVLW  42
076DA:  MOVWF  FF6
076DC:  MOVLW  0F
076DE:  MOVWF  FF7
076E0:  MOVLW  0A
076E2:  MOVLB  7
076E4:  MOVWF  xA8
076E6:  MOVLB  0
076E8:  CALL   5642
076EC:  MOVLW  89
076EE:  MOVWF  FE9
076F0:  MOVFF  2A0,7AB
076F4:  MOVFF  29F,7AA
076F8:  MOVFF  29E,7A9
076FC:  MOVFF  29D,7A8
07700:  MOVLW  02
07702:  MOVLB  7
07704:  MOVWF  xAC
07706:  MOVLB  0
07708:  CALL   566C
0770C:  MOVLW  0A
0770E:  BTFSS  F9E.4
07710:  BRA    770E
07712:  MOVWF  FAD
07714:  MOVLW  0D
07716:  BTFSS  F9E.4
07718:  BRA    7716
0771A:  MOVWF  FAD
....................                 fprintf(BT,"eccal3y = %f\n\r",sysInput.eccal3y);   
0771C:  MOVLW  52
0771E:  MOVWF  FF6
07720:  MOVLW  0F
07722:  MOVWF  FF7
07724:  MOVLW  0A
07726:  MOVLB  7
07728:  MOVWF  xA8
0772A:  MOVLB  0
0772C:  CALL   5642
07730:  MOVLW  89
07732:  MOVWF  FE9
07734:  MOVFF  2A4,7AB
07738:  MOVFF  2A3,7AA
0773C:  MOVFF  2A2,7A9
07740:  MOVFF  2A1,7A8
07744:  MOVLW  02
07746:  MOVLB  7
07748:  MOVWF  xAC
0774A:  MOVLB  0
0774C:  CALL   566C
07750:  MOVLW  0A
07752:  BTFSS  F9E.4
07754:  BRA    7752
07756:  MOVWF  FAD
07758:  MOVLW  0D
0775A:  BTFSS  F9E.4
0775C:  BRA    775A
0775E:  MOVWF  FAD
....................                 break; 
07760:  BRA    779A
....................             case 5:   // saveconfig 
....................                 fprintf(BT,"Saving Calibrations into EEPROM\n\r");  
07762:  MOVLW  62
07764:  MOVWF  FF6
07766:  MOVLW  0F
07768:  MOVWF  FF7
0776A:  CALL   1C20
....................                 SaveConfiguration(); 
0776E:  GOTO   5B62
....................                 break; 
07772:  BRA    779A
....................             case 6:   //  update 
....................                 startupdate = 1;  // this sets the flag to do an update to the remote unit when all data polling is completed. 
07774:  MOVLW  01
07776:  MOVLB  2
07778:  MOVWF  x28
....................                 fprintf(BT,"Completing last polling before updating\n\r"); 
0777A:  MOVLW  84
0777C:  MOVWF  FF6
0777E:  MOVLW  0F
07780:  MOVWF  FF7
07782:  MOVLB  0
07784:  CALL   1C20
....................                 break; 
07788:  BRA    779A
....................             case 7: 
....................                 reset_cpu(); 
0778A:  RESET
....................                 break; 
0778C:  BRA    779A
....................             default: 
....................            //    fprintf(BT,"\r\nUnknown Command '%s', use 'help' or '?' to get list of commands\n\r", SplitResult[0][0]); 
....................                fprintf(BT,"\r\n>"); 
0778E:  MOVLW  AE
07790:  MOVWF  FF6
07792:  MOVLW  0F
07794:  MOVWF  FF7
07796:  CALL   1C20
....................                break; 
....................                 
....................          } 
....................      
.................... 	return(0); 
0779A:  MOVLW  00
0779C:  MOVWF  01
0779E:  GOTO   781E (RETURN)
.................... 	} 
....................  
....................  
.................... #include "G:\Osmobot4PostProduction\Instrumentation\CheapRHAndTemp.c" 
.................... #ifdef TESTER 
.................... //****************************************************************************** 
.................... // Created Jan 12, 2017 
.................... // This routine gets the current model number and serial number of the HDC1080 RH/Temp chip.   
.................... // Returned values are valid if the function returns a zero. 
.................... // The RH and Temp is saved in the normal OUTPUT varaibles if the devices is attached to the usnit. 
.................... // The index is used to select the RJ45 port needed.   
.................... // For this set of boards, it's set to one port as a default.  It still needs to be called with the default value in place. 
.................... //****************************************************************************** 
.................... int16 GetHDC1080Version(int index) 
.................... { 
....................     int16 version, tempver; 
.................... #ifndef COTWOSENSOR 
.................... 	selectsensor(index);   // make the selection to talk with this sensor. 
*
0371A:  MOVFF  7AF,7B4
0371E:  RCALL  35F6
.................... #endif 
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
....................  
.................... 	i2c_start(PH_LIGHT); 
03720:  BSF    F93.0
03722:  MOVLW  50
03724:  MOVWF  00
03726:  DECFSZ 00,F
03728:  BRA    3726
0372A:  BSF    F93.1
0372C:  MOVLW  51
0372E:  MOVWF  00
03730:  DECFSZ 00,F
03732:  BRA    3730
03734:  BCF    F8A.0
03736:  BCF    F93.0
03738:  MOVLW  50
0373A:  MOVWF  00
0373C:  DECFSZ 00,F
0373E:  BRA    373C
03740:  BCF    F8A.1
03742:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
03744:  MOVLW  80
03746:  MOVLB  7
03748:  MOVWF  xB4
0374A:  MOVLB  0
0374C:  RCALL  363A
.................... 	i2c_write(PH_LIGHT,0xFF);  //Send the command for reading the version 
0374E:  MOVLB  7
03750:  SETF   xB4
03752:  MOVLB  0
03754:  RCALL  363A
.................... 	i2c_stop(PH_LIGHT); 
03756:  BCF    F93.0
03758:  NOP   
0375A:  BSF    F93.1
0375C:  BTFSS  F81.1
0375E:  BRA    375C
03760:  MOVLW  50
03762:  MOVWF  00
03764:  DECFSZ 00,F
03766:  BRA    3764
03768:  BRA    376A
0376A:  NOP   
0376C:  BSF    F93.0
0376E:  MOVLW  50
03770:  MOVWF  00
03772:  DECFSZ 00,F
03774:  BRA    3772
....................     i2c_start(PH_LIGHT); 
03776:  BSF    F93.0
03778:  MOVLW  50
0377A:  MOVWF  00
0377C:  DECFSZ 00,F
0377E:  BRA    377C
03780:  BSF    F93.1
03782:  MOVLW  51
03784:  MOVWF  00
03786:  DECFSZ 00,F
03788:  BRA    3786
0378A:  BCF    F8A.0
0378C:  BCF    F93.0
0378E:  MOVLW  50
03790:  MOVWF  00
03792:  DECFSZ 00,F
03794:  BRA    3792
03796:  BCF    F8A.1
03798:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x81);  //Move the address number left on and add a one to make is a read command. 
0379A:  MOVLW  81
0379C:  MOVLB  7
0379E:  MOVWF  xB4
037A0:  MOVLB  0
037A2:  RCALL  363A
.................... 	tempver = i2c_read(PH_LIGHT); 
037A4:  MOVLW  01
037A6:  MOVWF  00
037A8:  RCALL  36B0
037AA:  MOVLB  7
037AC:  CLRF   xB3
037AE:  MOVFF  01,7B2
....................     version = i2c_read(PH_LIGHT); 
037B2:  MOVLW  01
037B4:  MOVWF  00
037B6:  MOVLB  0
037B8:  RCALL  36B0
037BA:  MOVLB  7
037BC:  CLRF   xB1
037BE:  MOVFF  01,7B0
.................... 	i2c_stop(PH_LIGHT); 
037C2:  BCF    F93.0
037C4:  NOP   
037C6:  BSF    F93.1
037C8:  BTFSS  F81.1
037CA:  BRA    37C8
037CC:  MOVLW  50
037CE:  MOVWF  00
037D0:  DECFSZ 00,F
037D2:  BRA    37D0
037D4:  BRA    37D6
037D6:  NOP   
037D8:  BSF    F93.0
037DA:  MOVLW  50
037DC:  MOVWF  00
037DE:  DECFSZ 00,F
037E0:  BRA    37DE
....................      version = version + (tempver<<8); 
037E2:  MOVLW  00
037E4:  ADDWF  xB0,F
037E6:  MOVF   xB2,W
037E8:  ADDWFC xB1,F
....................     return(version); 
037EA:  MOVFF  7B0,01
037EE:  MOVFF  7B1,02
037F2:  MOVLB  0
037F4:  RETURN 0
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Jan 13, 2017 
.................... // This routine inits the HDC1080 RH/Temp chip.   
.................... // No returned value.  Sets all measurements to max resolution which is 14 bits 
.................... // The index is used to select the RJ45 port needed.   
.................... // For this set of boards, it's set to one port as a default.  It still needs to be called with the default value in place. 
.................... //****************************************************************************** 
.................... void GetHDC1080init(int index) 
.................... { 
....................     int version, tempver; 
....................  
.................... #ifndef COTWOSENSOR 
.................... 	selectsensor(index);   // make the selection to talk with this sensor. 
*
03EA0:  MOVFF  79D,7B4
03EA4:  CALL   35F6
.................... #endif 
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
....................     // set the configuration register 
.................... 	i2c_start(PH_LIGHT); 
03EA8:  BSF    F93.0
03EAA:  MOVLW  50
03EAC:  MOVWF  00
03EAE:  DECFSZ 00,F
03EB0:  BRA    3EAE
03EB2:  BSF    F93.1
03EB4:  MOVLW  51
03EB6:  MOVWF  00
03EB8:  DECFSZ 00,F
03EBA:  BRA    3EB8
03EBC:  BCF    F8A.0
03EBE:  BCF    F93.0
03EC0:  MOVLW  50
03EC2:  MOVWF  00
03EC4:  DECFSZ 00,F
03EC6:  BRA    3EC4
03EC8:  BCF    F8A.1
03ECA:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
03ECC:  MOVLW  80
03ECE:  MOVLB  7
03ED0:  MOVWF  xB4
03ED2:  MOVLB  0
03ED4:  CALL   363A
.................... 	i2c_write(PH_LIGHT,0x02);  //Point the next two  bytes to the command register. 
03ED8:  MOVLW  02
03EDA:  MOVLB  7
03EDC:  MOVWF  xB4
03EDE:  MOVLB  0
03EE0:  CALL   363A
....................     i2c_write(PH_LIGHT,0x00);  // Send the MSB first.  In this case it is the default witch is 14 bits 
03EE4:  MOVLB  7
03EE6:  CLRF   xB4
03EE8:  MOVLB  0
03EEA:  CALL   363A
.................... 	i2c_write(PH_LIGHT,0x00);  //Send the configuration LSB 
03EEE:  MOVLB  7
03EF0:  CLRF   xB4
03EF2:  MOVLB  0
03EF4:  CALL   363A
.................... 	i2c_stop(PH_LIGHT); 
03EF8:  BCF    F93.0
03EFA:  NOP   
03EFC:  BSF    F93.1
03EFE:  BTFSS  F81.1
03F00:  BRA    3EFE
03F02:  MOVLW  50
03F04:  MOVWF  00
03F06:  DECFSZ 00,F
03F08:  BRA    3F06
03F0A:  BRA    3F0C
03F0C:  NOP   
03F0E:  BSF    F93.0
03F10:  MOVLW  50
03F12:  MOVWF  00
03F14:  DECFSZ 00,F
03F16:  BRA    3F14
....................     delay_ms(45);  //This is the time it takes to get the first measurement 
03F18:  MOVLW  2D
03F1A:  MOVLB  7
03F1C:  MOVWF  xC1
03F1E:  MOVLB  0
03F20:  CALL   11F0
03F24:  GOTO   3F2E (RETURN)
....................       
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Jan 11, 2017 
.................... // This routine gets the current reading of the HDC1080 RH/Temp chip.   
.................... // Returned values are valid if the runction returns a zero. 
.................... // The RH and Temp is saved in the normal OUTPUT varaibles if the devices is attached to the usnit. 
.................... // The index is used to select the RJ45 port needed.   
.................... // For this set of boards, it's set to one port as a default.  It still needs to be called with the default value in place. 
.................... //****************************************************************************** 
.................... float GetHDC1080RHTemp(int index) 
.................... { 
....................     unsigned int8 temphigh,templow,rhhigh, rhlow; 
....................     float t,h; 
....................     //int th,tl,hh,hl; 
....................     GetHDC1080init(index); 
03F28:  MOVFF  790,79D
03F2C:  BRA    3EA0
.................... #ifndef COTWOSENSOR 
.................... 	selectsensor(index);   // make the selection to talk with this sensor. 
03F2E:  MOVFF  790,7B4
03F32:  CALL   35F6
.................... #endif 
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
.................... // trigger tempeerature  measurement 
.................... 	i2c_start(PH_LIGHT); 
03F36:  BSF    F93.0
03F38:  MOVLW  50
03F3A:  MOVWF  00
03F3C:  DECFSZ 00,F
03F3E:  BRA    3F3C
03F40:  BSF    F93.1
03F42:  MOVLW  51
03F44:  MOVWF  00
03F46:  DECFSZ 00,F
03F48:  BRA    3F46
03F4A:  BCF    F8A.0
03F4C:  BCF    F93.0
03F4E:  MOVLW  50
03F50:  MOVWF  00
03F52:  DECFSZ 00,F
03F54:  BRA    3F52
03F56:  BCF    F8A.1
03F58:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
03F5A:  MOVLW  80
03F5C:  MOVLB  7
03F5E:  MOVWF  xB4
03F60:  MOVLB  0
03F62:  CALL   363A
.................... 	i2c_write(PH_LIGHT,0x00);  //Send the command for reading the version 
03F66:  MOVLB  7
03F68:  CLRF   xB4
03F6A:  MOVLB  0
03F6C:  CALL   363A
.................... //	i2c_stop(PH_LIGHT); 
....................     delay_ms(20);   // wait for measurement 
03F70:  MOVLW  14
03F72:  MOVLB  7
03F74:  MOVWF  xC1
03F76:  MOVLB  0
03F78:  CALL   11F0
....................      
....................      
....................      
....................  //   Start over to read the measurement.  This kicks the chip out of low power mode. 
....................     i2c_start(PH_LIGHT); 
03F7C:  BSF    F93.0
03F7E:  MOVLW  50
03F80:  MOVWF  00
03F82:  DECFSZ 00,F
03F84:  BRA    3F82
03F86:  BSF    F93.1
03F88:  MOVLW  51
03F8A:  MOVWF  00
03F8C:  DECFSZ 00,F
03F8E:  BRA    3F8C
03F90:  BTFSS  F81.1
03F92:  BRA    3F90
03F94:  BCF    F8A.0
03F96:  BCF    F93.0
03F98:  MOVLW  50
03F9A:  MOVWF  00
03F9C:  DECFSZ 00,F
03F9E:  BRA    3F9C
03FA0:  BCF    F8A.1
03FA2:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x81);  //Move the address number left on and add a one to make is a read command. 
03FA4:  MOVLW  81
03FA6:  MOVLB  7
03FA8:  MOVWF  xB4
03FAA:  MOVLB  0
03FAC:  CALL   363A
.................... 	temphigh = i2c_read(PH_LIGHT); 
03FB0:  MOVLW  01
03FB2:  MOVWF  00
03FB4:  CALL   36B0
03FB8:  MOVFF  01,791
....................     delay_ms(10);   // wait for measurement 
03FBC:  MOVLW  0A
03FBE:  MOVLB  7
03FC0:  MOVWF  xC1
03FC2:  MOVLB  0
03FC4:  CALL   11F0
....................       
....................     templow = i2c_read(PH_LIGHT,0); 
03FC8:  CLRF   00
03FCA:  CALL   36B0
03FCE:  MOVFF  01,792
....................   	i2c_stop(PH_LIGHT);   
03FD2:  BCF    F93.0
03FD4:  NOP   
03FD6:  BSF    F93.1
03FD8:  BTFSS  F81.1
03FDA:  BRA    3FD8
03FDC:  MOVLW  50
03FDE:  MOVWF  00
03FE0:  DECFSZ 00,F
03FE2:  BRA    3FE0
03FE4:  BRA    3FE6
03FE6:  NOP   
03FE8:  BSF    F93.0
03FEA:  MOVLW  50
03FEC:  MOVWF  00
03FEE:  DECFSZ 00,F
03FF0:  BRA    3FEE
....................    
....................      
....................     // trigger rh  measurement 
.................... 	i2c_start(PH_LIGHT); 
03FF2:  BSF    F93.0
03FF4:  MOVLW  50
03FF6:  MOVWF  00
03FF8:  DECFSZ 00,F
03FFA:  BRA    3FF8
03FFC:  BSF    F93.1
03FFE:  MOVLW  51
04000:  MOVWF  00
04002:  DECFSZ 00,F
04004:  BRA    4002
04006:  BCF    F8A.0
04008:  BCF    F93.0
0400A:  MOVLW  50
0400C:  MOVWF  00
0400E:  DECFSZ 00,F
04010:  BRA    400E
04012:  BCF    F8A.1
04014:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
04016:  MOVLW  80
04018:  MOVLB  7
0401A:  MOVWF  xB4
0401C:  MOVLB  0
0401E:  CALL   363A
.................... 	i2c_write(PH_LIGHT,0x01);  //Send the command for reading the version 
04022:  MOVLW  01
04024:  MOVLB  7
04026:  MOVWF  xB4
04028:  MOVLB  0
0402A:  CALL   363A
.................... //	i2c_stop(PH_LIGHT); 
....................     delay_ms(20);   // wait for measurement 
0402E:  MOVLW  14
04030:  MOVLB  7
04032:  MOVWF  xC1
04034:  MOVLB  0
04036:  CALL   11F0
....................      
....................   //   Start over to read the measurement.  This kicks the chip out of low power mode. 
....................     i2c_start(PH_LIGHT); 
0403A:  BSF    F93.0
0403C:  MOVLW  50
0403E:  MOVWF  00
04040:  DECFSZ 00,F
04042:  BRA    4040
04044:  BSF    F93.1
04046:  MOVLW  51
04048:  MOVWF  00
0404A:  DECFSZ 00,F
0404C:  BRA    404A
0404E:  BTFSS  F81.1
04050:  BRA    404E
04052:  BCF    F8A.0
04054:  BCF    F93.0
04056:  MOVLW  50
04058:  MOVWF  00
0405A:  DECFSZ 00,F
0405C:  BRA    405A
0405E:  BCF    F8A.1
04060:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x81);  //Move the address number left on and add a one to make is a read command.    
04062:  MOVLW  81
04064:  MOVLB  7
04066:  MOVWF  xB4
04068:  MOVLB  0
0406A:  CALL   363A
....................     rhhigh = i2c_read(PH_LIGHT); 
0406E:  MOVLW  01
04070:  MOVWF  00
04072:  CALL   36B0
04076:  MOVFF  01,793
....................        delay_ms(10);   // wait for measurement 
0407A:  MOVLW  0A
0407C:  MOVLB  7
0407E:  MOVWF  xC1
04080:  MOVLB  0
04082:  CALL   11F0
....................     rhlow = i2c_read(PH_LIGHT,0); 
04086:  CLRF   00
04088:  CALL   36B0
0408C:  MOVFF  01,794
.................... 	i2c_stop(PH_LIGHT); 
04090:  BCF    F93.0
04092:  NOP   
04094:  BSF    F93.1
04096:  BTFSS  F81.1
04098:  BRA    4096
0409A:  MOVLW  50
0409C:  MOVWF  00
0409E:  DECFSZ 00,F
040A0:  BRA    409E
040A2:  BRA    40A4
040A4:  NOP   
040A6:  BSF    F93.0
040A8:  MOVLW  50
040AA:  MOVWF  00
040AC:  DECFSZ 00,F
040AE:  BRA    40AC
....................      
....................     th = (int) temphigh; 
040B0:  MOVLB  2
040B2:  CLRF   x2A
040B4:  MOVFF  791,229
....................     tl = (int) templow; 
040B8:  CLRF   x2C
040BA:  MOVFF  792,22B
....................     hh = (int) rhhigh; 
040BE:  CLRF   x2E
040C0:  MOVFF  793,22D
....................     hl = (int) rhlow; 
040C4:  CLRF   x30
040C6:  MOVFF  794,22F
....................      
....................  //   t = (float) (th << 8 | tl); 
....................  //   h = (float) (hh << 8 | hl); 
....................  //   t = t * 165.0 / 65536.0 - 40.0; 
.................... //	h = h * 100.0 / 65536.0;	 
....................  
....................      
....................      
....................     return(t); 
040CA:  MOVFF  795,00
040CE:  MOVFF  796,01
040D2:  MOVFF  797,02
040D6:  MOVFF  798,03
040DA:  MOVLB  0
040DC:  GOTO   43CA (RETURN)
.................... } 
....................  
.................... #endif 
....................  
.................... #ifndef TIRHTEMP 
....................  
.................... float RHData, Temperature;   // These are the values for the coefenents for decay solutions. 
....................  
.................... //**************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // Init all of the I/O bits to make the RH/Temp sensor work 
.................... // Returns nothing 
.................... //**************************************************************************** 
.................... void initRHTemp(void) 
.................... 	{ 
.................... 	output_high(RHTEMP);   //This sets the output high. 
.................... 	} 
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // Find the check sum number 
.................... //  0 - all is good, 1 - all is bad 
.................... //**************************************************************************** 
.................... int16 CheckSumRHTemp(long RawRH, long RawTemp) 
.................... 	{ 
.................... 	int16 checksum2,checksum3; 
....................  
.................... 	checksum2 = (int16) 0xFF00 & RawRH; 
....................     checksum2 = checksum2>>8; 
.................... 	checksum2 = checksum2 + (int16) (0x00FF & RawRH); 
....................  
.................... 	checksum3 = (int16) (0xFF00 & RawTemp); 
....................     checksum3 = checksum3>>8; 
.................... 	checksum2 = checksum3 + checksum2 + (int16) (0x00FF & RawTemp); 
....................  
.................... 	return(0x00FF & checksum2); 
.................... 	} 
....................  
....................  
.................... //*************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // This routine returns the RH and Temps as float through global variables 
.................... // Returns 1 if there is an error.  a zero if there none 
.................... // All calculations for converion and reading the sensor is done here. 
.................... //*************************************************************************** 
.................... int GetTempRH(void) 
.................... 	{ 
.................... 	int x,y,w,counter; 
....................     long  RawRH, RawTemp, CheckSum;//These are the global varaibles for RH and Temperature 
....................  
....................  
.................... //  Send command out to the I/O pin 
.................... 	output_high(RHTEMP);   //This sets the output high. 
.................... 	output_low(RHTEMP);   //This sets the output high. 
.................... 	delay_ms(5); 
.................... 	output_high(RHTEMP);   //This sets the output high. 
.................... 	delay_us(40); 
.................... 	output_float(RHTEMP); 
.................... 	delay_us(20); 
....................  
.................... 	for (x=0; x < 5; x++) ///This waits to get out of the MCU command 
.................... 		{ 
.................... 		y=input_state(RHTEMP); 
.................... 		if (!y) break; 
.................... 		delay_us(10); 
.................... 		} 
.................... 	for (x=0; x < 20; x++)   //This waits through the zero and finds a 1 
.................... 		{ 
.................... 		y=input_state(RHTEMP); 
.................... 		if (y) break; 
.................... 		delay_us(10); 
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(10); 
.................... 		} 
.................... 	 
.................... //beginning of first bit zero 
.................... //Setup the for loop 
.................... RawRH = 0; /// Clear out the variable 
.................... for (counter=0; counter < 16; counter++) 
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the bit to time out the zero for the next bit 
.................... 		if (y) break; 
.................... 		delay_us(5); 
.................... 		} 
.................... 		w=y; 
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(5); 
.................... 		} 
....................  
.................... 	RawRH=RawRH<<1;	// Shift the whole word one bit left. 
.................... 	if (x > 6) 
.................... 		{ 
.................... 		RawRH = RawRH + 0x0001; 
.................... 		} 
.................... 	} 
.................... 	 
....................  
....................  
.................... RawTemp = 0; /// Clear out the variable 
.................... for (counter=0; counter < 16; counter++) 
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the bit to time out the zero for the next bit 
.................... 		if (y) break; 
.................... 		delay_us(5); 
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(5); 
.................... 		} 
.................... 	 
....................  
.................... 	RawTemp=RawTemp<<1;	// Shift the whole word one bit left. 
.................... 	if (x > 6) 
.................... 		{ 
.................... 		RawTemp = RawTemp + 0x0001; 
.................... 		} 
.................... 	} 
....................  
....................  
....................  
.................... CheckSum = 0; /// Clear out the variable 
.................... for (counter=0; counter < 8; counter++) 
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the bit to time out the zero for the next bit 
.................... 		if (y) break; 
.................... 		delay_us(5); 
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(5); 
.................... 		} 
.................... 	 
....................  
.................... 	CheckSum=CheckSum<<1;	// Shift the whole word one bit left. 
.................... 	if (x > 6) 
.................... 		{ 
.................... 		CheckSum = CheckSum + 0x0001; 
.................... 		} 
.................... 	} 
....................  
.................... 	RHData = (float)RawRH; 
....................  
.................... if (CheckSum == CheckSumRHTemp(RawRH,RawTemp)) 
.................... 	{ 
.................... 	RHData = (float)RawRH/10.0; 
....................     Temperature = ((float)RawTemp)/10.0; 
.................... 	return(0); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 	return(1); 
.................... 	} 
.................... 	} 
....................  
.................... #endif 
....................  
.................... #ifdef CHEAPEC  
.................... //************************************************************************************* 
.................... // Created September 2, 2015 
.................... // This routines calculated all of the values for a given set of decay equation. 
.................... //  The equation is y = AA + BBexp^-CCx.  This is an electrcial decay equation that has to be run several times to get the values for AA, BB and CC. 
.................... // It's assumed the first value is the highest ppm  with the lowst value for x as in imput. 
.................... // The result are gloabe variables for AA, BB and BC. 
.................... // AA is calculated by knowing the first assmetopt. 
....................  
.................... float solvefordecay(int32 measurement)	 
.................... 	{ 
....................  
.................... 	float eccheck;    //These are used for holding the caluclated values for the current returned iteration.  The x input is not needed because it's already defined. 
.................... 	int x; 
....................  
....................  
.................... //********************************************************************** 
.................... // Added Sept 3, 2015 
.................... // Updated with regression equations May 31, 2016 
.................... // The attempt to solve for a decaying curve is stopped for now.   
.................... // Currently a liner approach is used for three points. 
.................... //********************************************************************** 
.................... // Form the calibration data proved on the EEPROM, find all of the coef for the lineized LOG function. 
.................... //  Y = B + m(ln(x)) 
.................... // B =  
.................... // Find Y     
....................      
....................      
....................      
....................      
....................      
....................      
.................... eccheck = (float) measurement;   /// Change over the data type to a float for correct operations in the range testing. 
....................  
....................  
.................... if (eccheck > eccalibrationx[0])    
.................... 	{ 
.................... 	y = 0.0; 
.................... 	return(y);   //Send out the result if it's to a limit. 
.................... 	} 
....................  
.................... if (eccheck <= eccalibrationx[2]) 
.................... 	{ 
.................... 	y = 2000.0; 
.................... 	return(y);  //Send out the result if it's to a limit. 
.................... 	} 
....................  
.................... } 
....................  
....................  
....................  
.................... //************************************************************************************ 
.................... // Created Augest 24, 2015 
.................... // This routine measures the time delay for EC  or TDS.  It does this by cycling through a decay of an RC circute. 
.................... // The pinouts are as follwos: 
.................... // PICCPU    Function 
.................... // RC14     - C+ 
.................... // RC13     - C- 
.................... // RD0      - EC+ 
.................... // RD11     - EC- 
.................... // This is the firing order for measurement: 
.................... // EC1     input   low       low               input        measuere decay    high 
.................... // C+      high    input     measuere decay    high         low               input 
.................... // C-      low     low       low               high         high              high 
.................... // The returned results is an average of 16 measurements of plus and mnues measurentents at 1Khz 
.................... // returns a float with the current EC value. 
.................... //************************************************************************************* 
.................... float measureTDS(void) 
.................... 	{ 
....................  
.................... 	int statecounter,x; 
.................... 	int32 currentreadingunder=0,y,z;  // This is used as the state counter for the measurmeents.  It goes between 1 to seven. 
.................... 	int32 measurement=0, currentreading;   //This is the measurement accumlator and then it's averaged. 
.................... 	float result; 
....................  
.................... //  Set up the output and input for the EC meter. 
.................... /* 
.................... while(1) 
.................... 	{ 
.................... 	output_high(PIN_D10);    //  Define as EC1 
.................... 	output_low(PIN_D10);    //  Define as EC1 
.................... 	} 
.................... */ 
.................... output_high(PIN_D10);    //  Define as EC1- 
....................  
.................... //************************************************* 
.................... // Changed from the old board to the last version on March 28, 2016 
.................... // The two C+ and C- are changed from D0  & C13 to D8 and RD9 for C+ and RD8 for C- 
.................... // Old settings are below. 
.................... //output_high(PIN_D0);     // Define as C+   // Added September 6, 2015  Needs to be changed to RD9 for the new board 
.................... //output_float(PIN_C13);           // Define as C-   // Added September 6, 2015  Needs to be changed to RD8 for the new board 
.................... //************************************************************** 
....................  
.................... output_high(PIN_D9);     // Define as C+   // Added September 6, 2015  Needs to be changed to RD9 for the new board 
.................... output_float(PIN_D8);           // Define as C-   // Added September 6, 2015  Needs to be changed to RD8 for the new board 
....................  
.................... output_high(PIN_D11);    //  Define as EC2+   This is the negative direction charge compared to ground.  
.................... // input_state(); 
.................... //while(1) 
.................... //	{ 
.................... restart_wdt();   // restart the WD timer.  It set for 65 seconds 
.................... for (x = 1; x <=16; x++) 
.................... 	{ 
....................  
.................... 	for (statecounter = 1; statecounter < 7; statecounter++) 
.................... 		{ 
.................... 		switch(statecounter) 
.................... 			{ 
.................... 			case 1:     //  Charge Cap to max in + direction. 
.................... 				output_float(PIN_D10);    //  Define as EC- 
.................... 				input(PIN_D11);    //  Define as EC+    keep floarting to no interferiw with measurement.				 
.................... 				//output_high(PIN_D0);     // Define as C+ 
....................                 output_high(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				//output_low(PIN_C13);           // Define as C- 
....................                 output_low(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 				delay_us(100);   // Wait for the CAP to charge to Vcc.  Check on scope. 
.................... 				break; 
.................... 			case 2: 
.................... 				output_low(PIN_D11);    //  Define as EC+ 
.................... 				output_float(PIN_D10);    //  Define as EC-    keep floarting to no interferiw with measurement.				 
.................... //				input(PIN_D0);     // Define as C+ 
....................  
.................... 		//		output_low(PIN_D0);     // Define as C+ 
.................... 				//output_low(PIN_C13);           // Define as C- 
....................                 output_low(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 			//	currentreading = input(PIN_D11);   // update the output for the first one. 
.................... 				for (currentreading = 0; currentreading < 20000; currentreading++) 
.................... 					{ 
.................... 				//	fprintf(BT,"Current EC currentreading %i\n\r",currentreading); 
.................... 				/*	if (!input(PIN_D0)) 
.................... 							{ 
.................... 							 y = currentreading;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							}  */ 
....................  					if (!input(PIN_D9))   //New Board I/O pin  March 28, 2016 
.................... 							{ 
.................... 							 y = currentreading;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							}                    
.................... 					} 
.................... 				break; 
.................... 			case 3: 
.................... 			    input(PIN_D10);    //  Define as EC- 
.................... 				output_float(PIN_D11);    //  Define as EC+    keep floarting to no interferiw with measurement.				 
....................  
.................... 				//output_high(PIN_D0);     // Define as C+   //Discharge the CAP in the other direction. 
....................                 output_high(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				//output_high(PIN_C13);           // Define as C- 
....................                 output_high(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 				delay_us(100);   // Wait for the CAP to charge to Vcc.  Check on scope. 
....................  
.................... 				break; 
.................... 			case 4: 
.................... 				//output_high(PIN_C13);     // Define as C+ 
....................                 output_high(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 				//output_low(PIN_D0);           // Define as C- 
....................                 output_low(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				delay_us(100);   // Wait for the CAP to charge to Vcc.  Check on scope. 
.................... 				break; 
.................... 			case 5: 
.................... 				output_high(PIN_D10);    //  Define as EC- 
.................... 				output_float(PIN_D11);    //  Define as EC+    keep floarting to no interferiw with measurement.				 
.................... //				input(PIN_D0);     // Define as C+ 
....................  
.................... 		//		output_low(PIN_D0);     // Define as C+ 
.................... 			//	output_high(PIN_D0);           // Define as C+ 
.................... 			//	currentreading = input(PIN_D11);   // update the output for the first one. 
.................... 				for (currentreadingunder = 0; currentreadingunder < 20000; currentreadingunder++) 
.................... 					{ 
.................... 				//	fprintf(BT,"Current EC currentreading %i\n\r",currentreading); 
.................... 				/*	if (input(PIN_D0))    //  measure using C- 
.................... 							{ 
.................... 							 z = currentreadingunder;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							}  */ 
....................                     if (input(PIN_D9))    //  measure using C-  New Board I/O pin  March 28, 2016 
.................... 							{ 
.................... 							 z = currentreadingunder;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							} 
.................... 					} 
.................... 				break; 
....................  
.................... 			case 6: 
....................  
.................... 				//output_low(PIN_D0);     // Define as C+   //Discharge the CAP in the other direction. 
....................                 output_low(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				//output_low(PIN_C13);           // Define as C- 
....................                 output_low(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
....................  
....................  
....................  
.................... 				break; 
.................... 			default: 
....................  
....................  
.................... 				break; 
.................... 			} 
....................  
.................... 	 measurement =  measurement + y;   // Add together all of the 16 numbers. 
.................... currentreadingunder = currentreadingunder + z; 
.................... restart_wdt();   // restart the WD timer.  It set for 65 seconds 
.................... 		} 
....................  
....................  
.................... 	} 
.................... currentreadingunder = currentreadingunder/16; 
.................... 	measurement = measurement/16;   // Do the average 
....................  
....................  
.................... //********************************************************************************* 
.................... // Created Aug 10, 2016 
.................... // Set all EC probe levels to zero when leaving the routine. 
.................... //******************************************************************************** 
....................   output_low(PIN_D8);     //Set to low to prevent interference with pH bulb. 
....................   output_low(PIN_D9); 
....................   output_low(PIN_D10); 
....................   output_low(PIN_D11); 
....................  
.................... //************************************************************************************************ 
.................... // Created Sept 1, 2015 
.................... // Below takes the decay value from the C+ side and converts it into ppm.   
.................... // At this time there is no temperature compensation. 
.................... // At this time the calibration values are not saved in SD Card. 
.................... //************************************************************************************************ 
....................  
.................... //  Current measured data 
.................... //  Reading            ppm 
.................... //  36                 1553 
.................... //  51                 468 
.................... //  700                24 
....................  
.................... eccalibrationx[0] = 447.0; 
.................... eccalibrationx[1] = 44.0; 
.................... eccalibrationx[2] = 19.0; 
....................  
....................  
.................... eccalibrationy[0]  = 33.0; 
.................... eccalibrationy[1]  = 481.0; 
.................... eccalibrationy[2]  = 1718.0; 
....................  
....................  
.................... result = solvefordecay(measurement); // Solve for the current value for calibration for this EC meter 
.................... fprintf(BT,"Current EC reading top %Lu under %Lu  ppm %f\n\r",measurement,currentreadingunder,result); 
.................... result =  (float) measurement; 
.................... //measurement=0; 
.................... //} 
.................... //return(result);   // this is the old return  Changed April 14, 2016 
.................... return(result);	 
.................... 	}   // end of function. 
....................  
.................... #endif 
....................  
.................... //GPIO Initialization 
.................... #USE STANDARD_IO(d) 
.................... #USE STANDARD_IO(e) 
....................  
.................... #include "G:\Osmobot4PostProduction\Instrumentation\ECcalculation.c" 
....................  
....................  
....................  
.................... float bb,mm;   // this is the offset in the regression 
.................... // ************************************************************************************ 
.................... // Created June 10, 2016 
.................... // Get the regression raw data from the Unit serial number table. 
.................... // It gets the values and calculates all of the required averages and summations. 
.................... //************************************************************************************ 
.................... void getalleccalibration(void) { 
....................  
....................     float nn,eccalxaverage,eccalyaverage,sumofproducts,sumofxsquare,sumofysquare; 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created June 20, 2016 
.................... //  Calculate the averages of the x value and the y value 
.................... // Find x, y, ?(x2), ?(xy), ?(y2) 
.................... //******************************************************************************* 
.................... eccalxaverage = (log(sysInput.eccal1x) + log(sysInput.eccal2x) + log(sysInput.eccal3x))/3; 
.................... eccalyaverage = (sysInput.eccal1y  + sysInput.eccal2y + sysInput.eccal3y)/3; 
....................  
.................... //****************************************************************************** 
.................... //Created June 20, 2016 
.................... // Calculate the sum of the products of x times y 
.................... //****************************************************************************** 
.................... sumofproducts = log(sysInput.eccal1x) * sysInput.eccal1y + log(sysInput.eccal2x) * sysInput.eccal2y + log(sysInput.eccal3x) * sysInput.eccal3y; 
....................  
.................... //****************************************************************************** 
.................... //Created June 20, 2016 
.................... // Calculate the sum of the squares of x  
.................... //****************************************************************************** 
.................... sumofxsquare = log(sysInput.eccal1x) * log(sysInput.eccal1x) + log(sysInput.eccal2x) * log(sysInput.eccal2x) + log(sysInput.eccal3x) * log(sysInput.eccal3x); 
.................... //****************************************************************************** 
.................... //Created June 20, 2016 
.................... // Calculate the sum of the squares of y  
.................... //****************************************************************************** 
.................... sumofysquare = sysInput.eccal1y * sysInput.eccal1y + sysInput.eccal2y * sysInput.eccal2y + sysInput.eccal3y * sysInput.eccal3y; 
.................... nn=3.0;  // this is the number of data points 
....................  
.................... //   Find m = [?(xy) - n(x)(y)]/[?(x2) - n(x)2] 
....................  
.................... mm = (sumofproducts - nn*eccalxaverage*eccalyaverage)/(sumofxsquare-nn*eccalxaverage*eccalxaverage); 
.................... //echo ($mm. "<br>"); 
.................... // find   b = y - mx 
....................  
.................... bb = eccalyaverage - mm*eccalxaverage; 
.................... //echo ($bb. "<br>"); 
.................... // Calculate the fit ratio      [?(xy) - n(x)(y)]/sqrt[(?(x2) - n(x)2)(?(y2) - n(y)2)] 
.................... // Similarly, the equation y = axc can be linearlized to Ln(y) = Ln(a) + cLn(x). This is now linear in the variables Ln(y) and Ln(x).  
.................... } 
....................  
.................... //******************************************************************************************* 
.................... // Created June 21, 2016 
.................... //  This function returns the EC calculation for the graphs.  The coefficenst for $bb and $mm need to be run before hand. 
.................... //********************************************************************************************** 
.................... float findec(float inputreading){ 
....................  
....................     float outputreading; 
....................      
....................     getalleccalibration();   // Get the varaibles if they change.  Each time calculation is done, find all of the calibration numbers. 
....................      
.................... if (inputreading <= 0.0) 
....................      { 
....................       outputreading = 0.0; 
....................       } 
....................      else 
....................      { 
.................... outputreading = mm*log(inputreading) + bb; 
....................    } 
.................... //$outputreading =  $inputreading; 
.................... return(outputreading); 
.................... } 
....................  
....................  
.................... //********************************************************************************* 
.................... // Added May 21, 2015 
.................... // This is the calibrations for temperature on the thermister for water 
.................... //********************************************************************************* 
....................  
.................... float temp1 = 40.0; 
.................... float reading1 = 5140.00; 
.................... float temp2 = 20.0; 
.................... float reading2 = 11700.00; 
.................... float temp3 = 6.0; 
.................... float reading3 = 21594.00; 
.................... float tempa1, tempa2, tempa3; //Addded May 15, 2014 These are the coefecents for thermister calculation 
.................... float matx[3][3]; //This is the global diffinition of solving a 3X3 matrix equation. This is a scrach pad matrix used to pass arrays between functions. Added May 13, 2013 
.................... float matrixequation[3][3]; //  Added May 13, 2013  This is the array used for setting up the eqaution for solving a 3X3 equation. 
.................... float fourbyfourmatrix[4][4]; 
.................... float matrixequals[3]; 
....................  
.................... int colorlow, colorhigh;   // gain, scale;  //This is the pair of bytes used to return the current selected color. 
.................... unsigned int16 red,green,blue,clear; 
....................  
....................  
.................... //************************************************************************ 
.................... // Addded Sept 2, 2015 
.................... // Global varables for decay solution 
.................... //************************************************************************ 
.................... float eccalibrationy[4]; //The four numbers for the y axis or the ppm axis. 
.................... float eccalibrationx[4]; //The four numbers for the x axis or the count axis. 
.................... float x, y, z; //Color chart positions,coored. 
....................  
....................  
.................... //*************************************************************************** 
.................... // Created December 2, 2015 
.................... // Changed for the digital sensor board Oct 13, 2016 
.................... // This routine sets the encoder to select where the I2C clock signal goes to. 
.................... // It returns nothing. 
.................... // The input is number for 0 to 5;  each one selecting a sensor. 
.................... // Added March 17, 2016 
.................... //  SENSORBOARDA    0       1      0         1 
.................... //  SENSORBOARDB    0       0      1         1 
.................... //                in unit   top   bot Rj45   nothing 
.................... //*************************************************************************** 
....................  
.................... void selectsensor(int sensornumber) { 
....................     //fprintf(BT,"Device Number Selected %i\n\r",sensor number); 
....................     if (sensornumber > 3) // Set the high bit 
*
035F6:  MOVLB  7
035F8:  MOVF   xB4,W
035FA:  SUBLW  03
035FC:  BC    3602
....................     { 
....................         sensornumber = sensornumber - 4; // Remove the offset so the bottom part of the byte can be accessed 
035FE:  MOVLW  04
03600:  SUBWF  xB4,F
....................     } 
....................  
....................     if (sensornumber == 0) // Set the lower bits. 
03602:  MOVF   xB4,F
03604:  BNZ   360E
....................     { 
....................         output_low(SENSORBOARDA); // This is connected to the input for the A on both 74139 chips. 
03606:  BCF    F93.5
03608:  BCF    F8A.5
....................         output_low(SENSORBOARDB); // This is connected to the input for the B on both 74139 chips. 
0360A:  BCF    F93.4
0360C:  BCF    F8A.4
....................     } 
....................  
....................     if (sensornumber == 1) { 
0360E:  DECFSZ xB4,W
03610:  BRA    361A
....................         output_high(SENSORBOARDA); // This is connected to the input for the A on both 74139 chips. 
03612:  BCF    F93.5
03614:  BSF    F8A.5
....................         output_low(SENSORBOARDB); // This is connected to the input for the B on both 74139 chips. 
03616:  BCF    F93.4
03618:  BCF    F8A.4
....................     } 
....................     if (sensornumber == 2) { 
0361A:  MOVF   xB4,W
0361C:  SUBLW  02
0361E:  BNZ   3628
....................         output_low(SENSORBOARDA); // This is connected to the input for the A on both 74139 chips. 
03620:  BCF    F93.5
03622:  BCF    F8A.5
....................         output_high(SENSORBOARDB); // This is connected to the input for the B on both 74139 chips. 
03624:  BCF    F93.4
03626:  BSF    F8A.4
....................     } 
....................     if (sensornumber == 3) { 
03628:  MOVF   xB4,W
0362A:  SUBLW  03
0362C:  BNZ   3636
....................         output_high(SENSORBOARDA); // This is connected to the input for the A on both 74139 chips. 
0362E:  BCF    F93.5
03630:  BSF    F8A.5
....................         output_high(SENSORBOARDB); // This is connected to the input for the B on both 74139 chips. 
03632:  BCF    F93.4
03634:  BSF    F8A.4
....................     } 
03636:  MOVLB  0
03638:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... //*********************************************************************** 
.................... //Created September 26, 2016 
.................... // This routines returns the calucated pH from the given system inputs and of the calibration derived from the server. 
.................... // It returns a float 
.................... //*********************************************************************** 
....................  
.................... float CalculatepH(float ADCNumber) { 
....................  
....................     float mm, b, result; 
....................  
....................     mm = (sysInput.phnumberupper - 4.0) / (sysInput.phcalhigh - sysInput.phcallow); 
....................     //y = mx +b 
....................     // find b 
....................     // b = y - mx 
....................     b = sysInput.phnumberupper - mm * sysInput.phcalhigh; 
....................     result = ADCNumber * mm + b; 
....................  
....................  
....................  
....................     return (result); 
.................... } 
....................  
.................... #include <EEPROMReadWriteRoutines.c>     // this is included to connect to the master Osmobot. 
....................  
.................... #ifndef TESTER 
.................... #include "CommonPassedDataFromMaterToSlave.h" 
.................... #endif 
.................... //******************************************************************************* 
.................... // Create November 2, 2016 
.................... // Save this float into eeprom 
.................... // returns nothing. 
.................... //  give the pointer to the number, the location in eeprom and length 
.................... //****************************************************************************** 
.................... void eeprom_write_blocktest(int8 *ptr, unsigned int8 addr, unsigned char len) 
*
05B00:  MOVFF  7AD,7B1
05B04:  MOVFF  7AC,7B0
05B08:  MOVFF  7AE,7BA
.................... { 
....................   unsigned int8 *data = ptr; 
....................     unsigned int16 bufferin[4]; 
....................     unsigned int8 stuff = addr; 
....................    // len=len>>1;    // Since we are using 16 bits, two bytes are used at a time because of defs. 
....................   //  addr=addr<<1;   //mult by two offset to the correct location. 
....................  
....................    while (len--) { 
05B0C:  MOVLB  7
05B0E:  MOVF   xAF,W
05B10:  DECF   xAF,F
05B12:  XORLW  00
05B14:  BZ    5B5E
....................         write_eeprom(addr, *data++); 
05B16:  MOVF   xB1,W
05B18:  MOVWF  03
05B1A:  MOVF   xB0,W
05B1C:  INCF   xB0,F
05B1E:  BTFSC  FD8.2
05B20:  INCF   xB1,F
05B22:  MOVWF  FE9
05B24:  MOVFF  03,FEA
05B28:  MOVFF  FEF,7BB
05B2C:  MOVF   FF2,W
05B2E:  MOVWF  00
05B30:  BCF    FF2.7
05B32:  CLRF   FAA
05B34:  MOVFF  7AE,FA9
05B38:  MOVFF  7BB,FA8
05B3C:  BCF    FA6.6
05B3E:  BCF    FA6.7
05B40:  BSF    FA6.2
05B42:  MOVLB  F
05B44:  MOVLW  55
05B46:  MOVWF  FA7
05B48:  MOVLW  AA
05B4A:  MOVWF  FA7
05B4C:  BSF    FA6.1
05B4E:  BTFSC  FA6.1
05B50:  BRA    5B4E
05B52:  BCF    FA6.2
05B54:  MOVF   00,W
05B56:  IORWF  FF2,F
....................         //addr=addr+2;  // need to skip two bytes since this is a 16 bit CPU  
....................         addr++; 
05B58:  MOVLB  7
05B5A:  INCF   xAE,F
05B5C:  BRA    5B0E
....................         // this is commented out since this is on an 8 bit machine. 
....................     }  
05B5E:  MOVLB  0
05B60:  RETURN 0
....................   
.................... } 
....................  
....................  
....................  
....................  
.................... //******************************************************************* 
.................... // Created November 22, 2016 
.................... // Save the local configures for this machine into internal EEPROM   THIS ROUTINE IS USED ONLY ON 8 BIT CPUS 
.................... // Returns a 0 if it worked, it returns a 1 if failed. 
.................... // List of data saved for local unit configuration.  There is only 256 bytes on a PIC18F4550  And is saved as 8 bits, I think, not 16 at once 
.................... //  Here is the link to the data documintation for the configuration and calibration for remote sensors.  This points to the 16 bit CPUS 
.................... //#include "..\OsomobotCarbonDioxideDigitalSensor\OsomobotCarbonDioxideDigitalSensor.X\ITwoSeeGeneralCommunicationSlave.c"     // this is included to connect to the master Osmobot. 
.................... //  All saved calibration data is 16 bits.  That means two bytes per data point.  128 words.   
.................... // Which display items  -> int16      Address  120  or 0x78 
.................... //******************************************************************* 
.................... int SaveConfiguration(void) 
.................... { 
....................     int8 lowbyte,highbyte; 
....................     unsigned int16 items; 
....................      
....................      
....................     //this is all NH4 stuff 
....................     eeprom_write_blocktest(&sysInput.nh4pt1returnednumber, 0x12, sizeof sysInput.nh4pt1returnednumber);   // this is for nh4pt1returnednumber   This should be four bytes 
05B62:  MOVLW  02
05B64:  MOVLB  7
05B66:  MOVWF  xAD
05B68:  MOVLW  51
05B6A:  MOVWF  xAC
05B6C:  MOVLW  12
05B6E:  MOVWF  xAE
05B70:  MOVLW  04
05B72:  MOVWF  xAF
05B74:  MOVLB  0
05B76:  RCALL  5B00
....................     fprintf(BT,"*");    
05B78:  MOVLW  2A
05B7A:  BTFSS  F9E.4
05B7C:  BRA    5B7A
05B7E:  MOVWF  FAD
....................     eeprom_write_blocktest(&sysInput.nh4pt2returnednumber, 0x16, sizeof sysInput.nh4pt2returnednumber);   // this is for nh4pt1returnednumber   This should be four bytes 
05B80:  MOVLW  02
05B82:  MOVLB  7
05B84:  MOVWF  xAD
05B86:  MOVLW  55
05B88:  MOVWF  xAC
05B8A:  MOVLW  16
05B8C:  MOVWF  xAE
05B8E:  MOVLW  04
05B90:  MOVWF  xAF
05B92:  MOVLB  0
05B94:  RCALL  5B00
....................     fprintf(BT,"*");    
05B96:  MOVLW  2A
05B98:  BTFSS  F9E.4
05B9A:  BRA    5B98
05B9C:  MOVWF  FAD
....................     eeprom_write_blocktest(&sysInput.nh4pt3returnednumber, 0x1a, sizeof sysInput.nh4pt3returnednumber);   // this is for nh4pt1returnednumber   This should be four bytes 
05B9E:  MOVLW  02
05BA0:  MOVLB  7
05BA2:  MOVWF  xAD
05BA4:  MOVLW  59
05BA6:  MOVWF  xAC
05BA8:  MOVLW  1A
05BAA:  MOVWF  xAE
05BAC:  MOVLW  04
05BAE:  MOVWF  xAF
05BB0:  MOVLB  0
05BB2:  RCALL  5B00
....................     fprintf(BT,"*");    
05BB4:  MOVLW  2A
05BB6:  BTFSS  F9E.4
05BB8:  BRA    5BB6
05BBA:  MOVWF  FAD
.................... //  nh4pt1cal1of3 
....................     items = sysInput.nh4pt1cal1of3; 
05BBC:  MOVFF  240,7AB
05BC0:  MOVFF  23F,7AA
....................     lowbyte =(int8) items; 
05BC4:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05BC8:  MOVLB  7
05BCA:  MOVF   xAB,W
05BCC:  MOVWF  xA9
....................     write_eeprom(0x00,lowbyte); 
05BCE:  MOVF   FF2,W
05BD0:  MOVWF  00
05BD2:  BCF    FF2.7
05BD4:  CLRF   FAA
05BD6:  CLRF   FA9
05BD8:  MOVFF  7A8,FA8
05BDC:  BCF    FA6.6
05BDE:  BCF    FA6.7
05BE0:  BSF    FA6.2
05BE2:  MOVLB  F
05BE4:  MOVLW  55
05BE6:  MOVWF  FA7
05BE8:  MOVLW  AA
05BEA:  MOVWF  FA7
05BEC:  BSF    FA6.1
05BEE:  BTFSC  FA6.1
05BF0:  BRA    5BEE
05BF2:  BCF    FA6.2
05BF4:  MOVF   00,W
05BF6:  IORWF  FF2,F
....................     write_eeprom(0x01,highbyte);   
05BF8:  MOVFF  FF2,00
05BFC:  BCF    FF2.7
05BFE:  CLRF   FAA
05C00:  MOVLW  01
05C02:  MOVWF  FA9
05C04:  MOVFF  7A9,FA8
05C08:  BCF    FA6.6
05C0A:  BCF    FA6.7
05C0C:  BSF    FA6.2
05C0E:  MOVLW  55
05C10:  MOVWF  FA7
05C12:  MOVLW  AA
05C14:  MOVWF  FA7
05C16:  BSF    FA6.1
05C18:  BTFSC  FA6.1
05C1A:  BRA    5C18
05C1C:  BCF    FA6.2
05C1E:  MOVF   00,W
05C20:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05C22:  MOVLW  2A
05C24:  BTFSS  F9E.4
05C26:  BRA    5C24
05C28:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt1ca2of3 
....................     items = sysInput.nh4pt1cal2of3; 
05C2A:  MOVFF  242,7AB
05C2E:  MOVFF  241,7AA
....................     lowbyte =(int8) items; 
05C32:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05C36:  MOVLB  7
05C38:  MOVF   xAB,W
05C3A:  MOVWF  xA9
....................     write_eeprom(0x02,lowbyte); 
05C3C:  MOVF   FF2,W
05C3E:  MOVWF  00
05C40:  BCF    FF2.7
05C42:  CLRF   FAA
05C44:  MOVLW  02
05C46:  MOVWF  FA9
05C48:  MOVFF  7A8,FA8
05C4C:  BCF    FA6.6
05C4E:  BCF    FA6.7
05C50:  BSF    FA6.2
05C52:  MOVLB  F
05C54:  MOVLW  55
05C56:  MOVWF  FA7
05C58:  MOVLW  AA
05C5A:  MOVWF  FA7
05C5C:  BSF    FA6.1
05C5E:  BTFSC  FA6.1
05C60:  BRA    5C5E
05C62:  BCF    FA6.2
05C64:  MOVF   00,W
05C66:  IORWF  FF2,F
....................     write_eeprom(0x03,highbyte);   
05C68:  MOVFF  FF2,00
05C6C:  BCF    FF2.7
05C6E:  CLRF   FAA
05C70:  MOVLW  03
05C72:  MOVWF  FA9
05C74:  MOVFF  7A9,FA8
05C78:  BCF    FA6.6
05C7A:  BCF    FA6.7
05C7C:  BSF    FA6.2
05C7E:  MOVLW  55
05C80:  MOVWF  FA7
05C82:  MOVLW  AA
05C84:  MOVWF  FA7
05C86:  BSF    FA6.1
05C88:  BTFSC  FA6.1
05C8A:  BRA    5C88
05C8C:  BCF    FA6.2
05C8E:  MOVF   00,W
05C90:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05C92:  MOVLW  2A
05C94:  BTFSS  F9E.4
05C96:  BRA    5C94
05C98:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt1cal3of3 
....................     items = sysInput.nh4pt1cal3of3; 
05C9A:  MOVFF  244,7AB
05C9E:  MOVFF  243,7AA
....................     lowbyte =(int8) items; 
05CA2:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05CA6:  MOVLB  7
05CA8:  MOVF   xAB,W
05CAA:  MOVWF  xA9
....................     write_eeprom(0x04,lowbyte); 
05CAC:  MOVF   FF2,W
05CAE:  MOVWF  00
05CB0:  BCF    FF2.7
05CB2:  CLRF   FAA
05CB4:  MOVLW  04
05CB6:  MOVWF  FA9
05CB8:  MOVFF  7A8,FA8
05CBC:  BCF    FA6.6
05CBE:  BCF    FA6.7
05CC0:  BSF    FA6.2
05CC2:  MOVLB  F
05CC4:  MOVLW  55
05CC6:  MOVWF  FA7
05CC8:  MOVLW  AA
05CCA:  MOVWF  FA7
05CCC:  BSF    FA6.1
05CCE:  BTFSC  FA6.1
05CD0:  BRA    5CCE
05CD2:  BCF    FA6.2
05CD4:  MOVF   00,W
05CD6:  IORWF  FF2,F
....................     write_eeprom(0x05,highbyte);   
05CD8:  MOVFF  FF2,00
05CDC:  BCF    FF2.7
05CDE:  CLRF   FAA
05CE0:  MOVLW  05
05CE2:  MOVWF  FA9
05CE4:  MOVFF  7A9,FA8
05CE8:  BCF    FA6.6
05CEA:  BCF    FA6.7
05CEC:  BSF    FA6.2
05CEE:  MOVLW  55
05CF0:  MOVWF  FA7
05CF2:  MOVLW  AA
05CF4:  MOVWF  FA7
05CF6:  BSF    FA6.1
05CF8:  BTFSC  FA6.1
05CFA:  BRA    5CF8
05CFC:  BCF    FA6.2
05CFE:  MOVF   00,W
05D00:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05D02:  MOVLW  2A
05D04:  BTFSS  F9E.4
05D06:  BRA    5D04
05D08:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt2cal1of3 
....................     items = sysInput.nh4pt2cal1of3; 
05D0A:  MOVFF  246,7AB
05D0E:  MOVFF  245,7AA
....................     lowbyte =(int8) items; 
05D12:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05D16:  MOVLB  7
05D18:  MOVF   xAB,W
05D1A:  MOVWF  xA9
....................     write_eeprom(0x06,lowbyte); 
05D1C:  MOVF   FF2,W
05D1E:  MOVWF  00
05D20:  BCF    FF2.7
05D22:  CLRF   FAA
05D24:  MOVLW  06
05D26:  MOVWF  FA9
05D28:  MOVFF  7A8,FA8
05D2C:  BCF    FA6.6
05D2E:  BCF    FA6.7
05D30:  BSF    FA6.2
05D32:  MOVLB  F
05D34:  MOVLW  55
05D36:  MOVWF  FA7
05D38:  MOVLW  AA
05D3A:  MOVWF  FA7
05D3C:  BSF    FA6.1
05D3E:  BTFSC  FA6.1
05D40:  BRA    5D3E
05D42:  BCF    FA6.2
05D44:  MOVF   00,W
05D46:  IORWF  FF2,F
....................     write_eeprom(0x07,highbyte);   
05D48:  MOVFF  FF2,00
05D4C:  BCF    FF2.7
05D4E:  CLRF   FAA
05D50:  MOVLW  07
05D52:  MOVWF  FA9
05D54:  MOVFF  7A9,FA8
05D58:  BCF    FA6.6
05D5A:  BCF    FA6.7
05D5C:  BSF    FA6.2
05D5E:  MOVLW  55
05D60:  MOVWF  FA7
05D62:  MOVLW  AA
05D64:  MOVWF  FA7
05D66:  BSF    FA6.1
05D68:  BTFSC  FA6.1
05D6A:  BRA    5D68
05D6C:  BCF    FA6.2
05D6E:  MOVF   00,W
05D70:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05D72:  MOVLW  2A
05D74:  BTFSS  F9E.4
05D76:  BRA    5D74
05D78:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt2cal2of3 
....................     items = sysInput.nh4pt2cal2of3; 
05D7A:  MOVFF  248,7AB
05D7E:  MOVFF  247,7AA
....................     lowbyte =(int8) items; 
05D82:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05D86:  MOVLB  7
05D88:  MOVF   xAB,W
05D8A:  MOVWF  xA9
....................     write_eeprom(0x08,lowbyte); 
05D8C:  MOVF   FF2,W
05D8E:  MOVWF  00
05D90:  BCF    FF2.7
05D92:  CLRF   FAA
05D94:  MOVLW  08
05D96:  MOVWF  FA9
05D98:  MOVFF  7A8,FA8
05D9C:  BCF    FA6.6
05D9E:  BCF    FA6.7
05DA0:  BSF    FA6.2
05DA2:  MOVLB  F
05DA4:  MOVLW  55
05DA6:  MOVWF  FA7
05DA8:  MOVLW  AA
05DAA:  MOVWF  FA7
05DAC:  BSF    FA6.1
05DAE:  BTFSC  FA6.1
05DB0:  BRA    5DAE
05DB2:  BCF    FA6.2
05DB4:  MOVF   00,W
05DB6:  IORWF  FF2,F
....................     write_eeprom(0x09,highbyte);   
05DB8:  MOVFF  FF2,00
05DBC:  BCF    FF2.7
05DBE:  CLRF   FAA
05DC0:  MOVLW  09
05DC2:  MOVWF  FA9
05DC4:  MOVFF  7A9,FA8
05DC8:  BCF    FA6.6
05DCA:  BCF    FA6.7
05DCC:  BSF    FA6.2
05DCE:  MOVLW  55
05DD0:  MOVWF  FA7
05DD2:  MOVLW  AA
05DD4:  MOVWF  FA7
05DD6:  BSF    FA6.1
05DD8:  BTFSC  FA6.1
05DDA:  BRA    5DD8
05DDC:  BCF    FA6.2
05DDE:  MOVF   00,W
05DE0:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05DE2:  MOVLW  2A
05DE4:  BTFSS  F9E.4
05DE6:  BRA    5DE4
05DE8:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt2cal3of3 
....................     items = sysInput.nh4pt2cal3of3; 
05DEA:  MOVFF  24A,7AB
05DEE:  MOVFF  249,7AA
....................     lowbyte =(int8) items; 
05DF2:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05DF6:  MOVLB  7
05DF8:  MOVF   xAB,W
05DFA:  MOVWF  xA9
....................     write_eeprom(0x0a,lowbyte); 
05DFC:  MOVF   FF2,W
05DFE:  MOVWF  00
05E00:  BCF    FF2.7
05E02:  CLRF   FAA
05E04:  MOVLW  0A
05E06:  MOVWF  FA9
05E08:  MOVFF  7A8,FA8
05E0C:  BCF    FA6.6
05E0E:  BCF    FA6.7
05E10:  BSF    FA6.2
05E12:  MOVLB  F
05E14:  MOVLW  55
05E16:  MOVWF  FA7
05E18:  MOVLW  AA
05E1A:  MOVWF  FA7
05E1C:  BSF    FA6.1
05E1E:  BTFSC  FA6.1
05E20:  BRA    5E1E
05E22:  BCF    FA6.2
05E24:  MOVF   00,W
05E26:  IORWF  FF2,F
....................     write_eeprom(0x0b,highbyte);   
05E28:  MOVFF  FF2,00
05E2C:  BCF    FF2.7
05E2E:  CLRF   FAA
05E30:  MOVLW  0B
05E32:  MOVWF  FA9
05E34:  MOVFF  7A9,FA8
05E38:  BCF    FA6.6
05E3A:  BCF    FA6.7
05E3C:  BSF    FA6.2
05E3E:  MOVLW  55
05E40:  MOVWF  FA7
05E42:  MOVLW  AA
05E44:  MOVWF  FA7
05E46:  BSF    FA6.1
05E48:  BTFSC  FA6.1
05E4A:  BRA    5E48
05E4C:  BCF    FA6.2
05E4E:  MOVF   00,W
05E50:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05E52:  MOVLW  2A
05E54:  BTFSS  F9E.4
05E56:  BRA    5E54
05E58:  MOVWF  FAD
.................... //***************************************    
.................... //  nh4pt3cal1of3 
....................     items = sysInput.nh4pt3cal1of3; 
05E5A:  MOVFF  24C,7AB
05E5E:  MOVFF  24B,7AA
....................     lowbyte =(int8) items; 
05E62:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05E66:  MOVLB  7
05E68:  MOVF   xAB,W
05E6A:  MOVWF  xA9
....................     write_eeprom(0x0c,lowbyte); 
05E6C:  MOVF   FF2,W
05E6E:  MOVWF  00
05E70:  BCF    FF2.7
05E72:  CLRF   FAA
05E74:  MOVLW  0C
05E76:  MOVWF  FA9
05E78:  MOVFF  7A8,FA8
05E7C:  BCF    FA6.6
05E7E:  BCF    FA6.7
05E80:  BSF    FA6.2
05E82:  MOVLB  F
05E84:  MOVLW  55
05E86:  MOVWF  FA7
05E88:  MOVLW  AA
05E8A:  MOVWF  FA7
05E8C:  BSF    FA6.1
05E8E:  BTFSC  FA6.1
05E90:  BRA    5E8E
05E92:  BCF    FA6.2
05E94:  MOVF   00,W
05E96:  IORWF  FF2,F
....................     write_eeprom(0x0d,highbyte);   
05E98:  MOVFF  FF2,00
05E9C:  BCF    FF2.7
05E9E:  CLRF   FAA
05EA0:  MOVLW  0D
05EA2:  MOVWF  FA9
05EA4:  MOVFF  7A9,FA8
05EA8:  BCF    FA6.6
05EAA:  BCF    FA6.7
05EAC:  BSF    FA6.2
05EAE:  MOVLW  55
05EB0:  MOVWF  FA7
05EB2:  MOVLW  AA
05EB4:  MOVWF  FA7
05EB6:  BSF    FA6.1
05EB8:  BTFSC  FA6.1
05EBA:  BRA    5EB8
05EBC:  BCF    FA6.2
05EBE:  MOVF   00,W
05EC0:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05EC2:  MOVLW  2A
05EC4:  BTFSS  F9E.4
05EC6:  BRA    5EC4
05EC8:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt3cal2of3 
....................     items = sysInput.nh4pt3cal2of3; 
05ECA:  MOVFF  24E,7AB
05ECE:  MOVFF  24D,7AA
....................     lowbyte =(int8) items; 
05ED2:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05ED6:  MOVLB  7
05ED8:  MOVF   xAB,W
05EDA:  MOVWF  xA9
....................     write_eeprom(0x0e,lowbyte); 
05EDC:  MOVF   FF2,W
05EDE:  MOVWF  00
05EE0:  BCF    FF2.7
05EE2:  CLRF   FAA
05EE4:  MOVLW  0E
05EE6:  MOVWF  FA9
05EE8:  MOVFF  7A8,FA8
05EEC:  BCF    FA6.6
05EEE:  BCF    FA6.7
05EF0:  BSF    FA6.2
05EF2:  MOVLB  F
05EF4:  MOVLW  55
05EF6:  MOVWF  FA7
05EF8:  MOVLW  AA
05EFA:  MOVWF  FA7
05EFC:  BSF    FA6.1
05EFE:  BTFSC  FA6.1
05F00:  BRA    5EFE
05F02:  BCF    FA6.2
05F04:  MOVF   00,W
05F06:  IORWF  FF2,F
....................     write_eeprom(0x0f,highbyte);   
05F08:  MOVFF  FF2,00
05F0C:  BCF    FF2.7
05F0E:  CLRF   FAA
05F10:  MOVLW  0F
05F12:  MOVWF  FA9
05F14:  MOVFF  7A9,FA8
05F18:  BCF    FA6.6
05F1A:  BCF    FA6.7
05F1C:  BSF    FA6.2
05F1E:  MOVLW  55
05F20:  MOVWF  FA7
05F22:  MOVLW  AA
05F24:  MOVWF  FA7
05F26:  BSF    FA6.1
05F28:  BTFSC  FA6.1
05F2A:  BRA    5F28
05F2C:  BCF    FA6.2
05F2E:  MOVF   00,W
05F30:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05F32:  MOVLW  2A
05F34:  BTFSS  F9E.4
05F36:  BRA    5F34
05F38:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt3cal3of3 
....................     items = sysInput.nh4pt3cal3of3; 
05F3A:  MOVFF  250,7AB
05F3E:  MOVFF  24F,7AA
....................     lowbyte =(int8) items; 
05F42:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05F46:  MOVLB  7
05F48:  MOVF   xAB,W
05F4A:  MOVWF  xA9
....................     write_eeprom(0x10,lowbyte); 
05F4C:  MOVF   FF2,W
05F4E:  MOVWF  00
05F50:  BCF    FF2.7
05F52:  CLRF   FAA
05F54:  MOVLW  10
05F56:  MOVWF  FA9
05F58:  MOVFF  7A8,FA8
05F5C:  BCF    FA6.6
05F5E:  BCF    FA6.7
05F60:  BSF    FA6.2
05F62:  MOVLB  F
05F64:  MOVLW  55
05F66:  MOVWF  FA7
05F68:  MOVLW  AA
05F6A:  MOVWF  FA7
05F6C:  BSF    FA6.1
05F6E:  BTFSC  FA6.1
05F70:  BRA    5F6E
05F72:  BCF    FA6.2
05F74:  MOVF   00,W
05F76:  IORWF  FF2,F
....................     write_eeprom(0x11,highbyte);   
05F78:  MOVFF  FF2,00
05F7C:  BCF    FF2.7
05F7E:  CLRF   FAA
05F80:  MOVLW  11
05F82:  MOVWF  FA9
05F84:  MOVFF  7A9,FA8
05F88:  BCF    FA6.6
05F8A:  BCF    FA6.7
05F8C:  BSF    FA6.2
05F8E:  MOVLW  55
05F90:  MOVWF  FA7
05F92:  MOVLW  AA
05F94:  MOVWF  FA7
05F96:  BSF    FA6.1
05F98:  BTFSC  FA6.1
05F9A:  BRA    5F98
05F9C:  BCF    FA6.2
05F9E:  MOVF   00,W
05FA0:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05FA2:  MOVLW  2A
05FA4:  BTFSS  F9E.4
05FA6:  BRA    5FA4
05FA8:  MOVWF  FAD
.................... //***************************************    
....................      
.................... //Created Feb 27, 2017 
....................     //this is all DO stuff   
....................     // it starts after the NH4 stuff.  The first address for these numbers is 0x1E 
....................      
....................      
....................     //  DOpt1cal1of3 
....................     items = sysInput.DOpt1cal1of3; 
05FAA:  MOVFF  25E,7AB
05FAE:  MOVFF  25D,7AA
....................     lowbyte =(int8) items; 
05FB2:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05FB6:  MOVLB  7
05FB8:  MOVF   xAB,W
05FBA:  MOVWF  xA9
....................     write_eeprom(0x1E,lowbyte); 
05FBC:  MOVF   FF2,W
05FBE:  MOVWF  00
05FC0:  BCF    FF2.7
05FC2:  CLRF   FAA
05FC4:  MOVLW  1E
05FC6:  MOVWF  FA9
05FC8:  MOVFF  7A8,FA8
05FCC:  BCF    FA6.6
05FCE:  BCF    FA6.7
05FD0:  BSF    FA6.2
05FD2:  MOVLB  F
05FD4:  MOVLW  55
05FD6:  MOVWF  FA7
05FD8:  MOVLW  AA
05FDA:  MOVWF  FA7
05FDC:  BSF    FA6.1
05FDE:  BTFSC  FA6.1
05FE0:  BRA    5FDE
05FE2:  BCF    FA6.2
05FE4:  MOVF   00,W
05FE6:  IORWF  FF2,F
....................     write_eeprom(0x1F,highbyte);   
05FE8:  MOVFF  FF2,00
05FEC:  BCF    FF2.7
05FEE:  CLRF   FAA
05FF0:  MOVLW  1F
05FF2:  MOVWF  FA9
05FF4:  MOVFF  7A9,FA8
05FF8:  BCF    FA6.6
05FFA:  BCF    FA6.7
05FFC:  BSF    FA6.2
05FFE:  MOVLW  55
06000:  MOVWF  FA7
06002:  MOVLW  AA
06004:  MOVWF  FA7
06006:  BSF    FA6.1
06008:  BTFSC  FA6.1
0600A:  BRA    6008
0600C:  BCF    FA6.2
0600E:  MOVF   00,W
06010:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
06012:  MOVLW  2A
06014:  BTFSS  F9E.4
06016:  BRA    6014
06018:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt1cal2of3 
....................     items = sysInput.DOpt1cal2of3; 
0601A:  MOVFF  260,7AB
0601E:  MOVFF  25F,7AA
....................     lowbyte =(int8) items; 
06022:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
06026:  MOVLB  7
06028:  MOVF   xAB,W
0602A:  MOVWF  xA9
....................     write_eeprom(0x20,lowbyte); 
0602C:  MOVF   FF2,W
0602E:  MOVWF  00
06030:  BCF    FF2.7
06032:  CLRF   FAA
06034:  MOVLW  20
06036:  MOVWF  FA9
06038:  MOVFF  7A8,FA8
0603C:  BCF    FA6.6
0603E:  BCF    FA6.7
06040:  BSF    FA6.2
06042:  MOVLB  F
06044:  MOVLW  55
06046:  MOVWF  FA7
06048:  MOVLW  AA
0604A:  MOVWF  FA7
0604C:  BSF    FA6.1
0604E:  BTFSC  FA6.1
06050:  BRA    604E
06052:  BCF    FA6.2
06054:  MOVF   00,W
06056:  IORWF  FF2,F
....................     write_eeprom(0x21,highbyte);   
06058:  MOVFF  FF2,00
0605C:  BCF    FF2.7
0605E:  CLRF   FAA
06060:  MOVLW  21
06062:  MOVWF  FA9
06064:  MOVFF  7A9,FA8
06068:  BCF    FA6.6
0606A:  BCF    FA6.7
0606C:  BSF    FA6.2
0606E:  MOVLW  55
06070:  MOVWF  FA7
06072:  MOVLW  AA
06074:  MOVWF  FA7
06076:  BSF    FA6.1
06078:  BTFSC  FA6.1
0607A:  BRA    6078
0607C:  BCF    FA6.2
0607E:  MOVF   00,W
06080:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
06082:  MOVLW  2A
06084:  BTFSS  F9E.4
06086:  BRA    6084
06088:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt1cal3of3 
....................     items = sysInput.DOpt1cal3of3; 
0608A:  MOVFF  262,7AB
0608E:  MOVFF  261,7AA
....................     lowbyte =(int8) items; 
06092:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
06096:  MOVLB  7
06098:  MOVF   xAB,W
0609A:  MOVWF  xA9
....................     write_eeprom(0x22,lowbyte); 
0609C:  MOVF   FF2,W
0609E:  MOVWF  00
060A0:  BCF    FF2.7
060A2:  CLRF   FAA
060A4:  MOVLW  22
060A6:  MOVWF  FA9
060A8:  MOVFF  7A8,FA8
060AC:  BCF    FA6.6
060AE:  BCF    FA6.7
060B0:  BSF    FA6.2
060B2:  MOVLB  F
060B4:  MOVLW  55
060B6:  MOVWF  FA7
060B8:  MOVLW  AA
060BA:  MOVWF  FA7
060BC:  BSF    FA6.1
060BE:  BTFSC  FA6.1
060C0:  BRA    60BE
060C2:  BCF    FA6.2
060C4:  MOVF   00,W
060C6:  IORWF  FF2,F
....................     write_eeprom(0x23,highbyte);   
060C8:  MOVFF  FF2,00
060CC:  BCF    FF2.7
060CE:  CLRF   FAA
060D0:  MOVLW  23
060D2:  MOVWF  FA9
060D4:  MOVFF  7A9,FA8
060D8:  BCF    FA6.6
060DA:  BCF    FA6.7
060DC:  BSF    FA6.2
060DE:  MOVLW  55
060E0:  MOVWF  FA7
060E2:  MOVLW  AA
060E4:  MOVWF  FA7
060E6:  BSF    FA6.1
060E8:  BTFSC  FA6.1
060EA:  BRA    60E8
060EC:  BCF    FA6.2
060EE:  MOVF   00,W
060F0:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
060F2:  MOVLW  2A
060F4:  BTFSS  F9E.4
060F6:  BRA    60F4
060F8:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt2cal1of3 
....................     items = sysInput.DOpt2cal1of3; 
060FA:  MOVFF  264,7AB
060FE:  MOVFF  263,7AA
....................     lowbyte =(int8) items; 
06102:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
06106:  MOVLB  7
06108:  MOVF   xAB,W
0610A:  MOVWF  xA9
....................     write_eeprom(0x24,lowbyte); 
0610C:  MOVF   FF2,W
0610E:  MOVWF  00
06110:  BCF    FF2.7
06112:  CLRF   FAA
06114:  MOVLW  24
06116:  MOVWF  FA9
06118:  MOVFF  7A8,FA8
0611C:  BCF    FA6.6
0611E:  BCF    FA6.7
06120:  BSF    FA6.2
06122:  MOVLB  F
06124:  MOVLW  55
06126:  MOVWF  FA7
06128:  MOVLW  AA
0612A:  MOVWF  FA7
0612C:  BSF    FA6.1
0612E:  BTFSC  FA6.1
06130:  BRA    612E
06132:  BCF    FA6.2
06134:  MOVF   00,W
06136:  IORWF  FF2,F
....................     write_eeprom(0x25,highbyte);   
06138:  MOVFF  FF2,00
0613C:  BCF    FF2.7
0613E:  CLRF   FAA
06140:  MOVLW  25
06142:  MOVWF  FA9
06144:  MOVFF  7A9,FA8
06148:  BCF    FA6.6
0614A:  BCF    FA6.7
0614C:  BSF    FA6.2
0614E:  MOVLW  55
06150:  MOVWF  FA7
06152:  MOVLW  AA
06154:  MOVWF  FA7
06156:  BSF    FA6.1
06158:  BTFSC  FA6.1
0615A:  BRA    6158
0615C:  BCF    FA6.2
0615E:  MOVF   00,W
06160:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
06162:  MOVLW  2A
06164:  BTFSS  F9E.4
06166:  BRA    6164
06168:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt2cal2of3 
....................     items = sysInput.DOpt2cal2of3; 
0616A:  MOVFF  266,7AB
0616E:  MOVFF  265,7AA
....................     lowbyte =(int8) items; 
06172:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
06176:  MOVLB  7
06178:  MOVF   xAB,W
0617A:  MOVWF  xA9
....................     write_eeprom(0x26,lowbyte); 
0617C:  MOVF   FF2,W
0617E:  MOVWF  00
06180:  BCF    FF2.7
06182:  CLRF   FAA
06184:  MOVLW  26
06186:  MOVWF  FA9
06188:  MOVFF  7A8,FA8
0618C:  BCF    FA6.6
0618E:  BCF    FA6.7
06190:  BSF    FA6.2
06192:  MOVLB  F
06194:  MOVLW  55
06196:  MOVWF  FA7
06198:  MOVLW  AA
0619A:  MOVWF  FA7
0619C:  BSF    FA6.1
0619E:  BTFSC  FA6.1
061A0:  BRA    619E
061A2:  BCF    FA6.2
061A4:  MOVF   00,W
061A6:  IORWF  FF2,F
....................     write_eeprom(0x27,highbyte);   
061A8:  MOVFF  FF2,00
061AC:  BCF    FF2.7
061AE:  CLRF   FAA
061B0:  MOVLW  27
061B2:  MOVWF  FA9
061B4:  MOVFF  7A9,FA8
061B8:  BCF    FA6.6
061BA:  BCF    FA6.7
061BC:  BSF    FA6.2
061BE:  MOVLW  55
061C0:  MOVWF  FA7
061C2:  MOVLW  AA
061C4:  MOVWF  FA7
061C6:  BSF    FA6.1
061C8:  BTFSC  FA6.1
061CA:  BRA    61C8
061CC:  BCF    FA6.2
061CE:  MOVF   00,W
061D0:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
061D2:  MOVLW  2A
061D4:  BTFSS  F9E.4
061D6:  BRA    61D4
061D8:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt2cal3of3 
....................     items = sysInput.DOpt2cal3of3; 
061DA:  MOVFF  268,7AB
061DE:  MOVFF  267,7AA
....................     lowbyte =(int8) items; 
061E2:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
061E6:  MOVLB  7
061E8:  MOVF   xAB,W
061EA:  MOVWF  xA9
....................     write_eeprom(0x28,lowbyte); 
061EC:  MOVF   FF2,W
061EE:  MOVWF  00
061F0:  BCF    FF2.7
061F2:  CLRF   FAA
061F4:  MOVLW  28
061F6:  MOVWF  FA9
061F8:  MOVFF  7A8,FA8
061FC:  BCF    FA6.6
061FE:  BCF    FA6.7
06200:  BSF    FA6.2
06202:  MOVLB  F
06204:  MOVLW  55
06206:  MOVWF  FA7
06208:  MOVLW  AA
0620A:  MOVWF  FA7
0620C:  BSF    FA6.1
0620E:  BTFSC  FA6.1
06210:  BRA    620E
06212:  BCF    FA6.2
06214:  MOVF   00,W
06216:  IORWF  FF2,F
....................     write_eeprom(0x29,highbyte);   
06218:  MOVFF  FF2,00
0621C:  BCF    FF2.7
0621E:  CLRF   FAA
06220:  MOVLW  29
06222:  MOVWF  FA9
06224:  MOVFF  7A9,FA8
06228:  BCF    FA6.6
0622A:  BCF    FA6.7
0622C:  BSF    FA6.2
0622E:  MOVLW  55
06230:  MOVWF  FA7
06232:  MOVLW  AA
06234:  MOVWF  FA7
06236:  BSF    FA6.1
06238:  BTFSC  FA6.1
0623A:  BRA    6238
0623C:  BCF    FA6.2
0623E:  MOVF   00,W
06240:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
06242:  MOVLW  2A
06244:  BTFSS  F9E.4
06246:  BRA    6244
06248:  MOVWF  FAD
.................... //***************************************    
.................... //  DOpt3cal1of3 
....................     items = sysInput.DOpt3cal1of3; 
0624A:  MOVFF  26A,7AB
0624E:  MOVFF  269,7AA
....................     lowbyte =(int8) items; 
06252:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
06256:  MOVLB  7
06258:  MOVF   xAB,W
0625A:  MOVWF  xA9
....................     write_eeprom(0x2a,lowbyte); 
0625C:  MOVF   FF2,W
0625E:  MOVWF  00
06260:  BCF    FF2.7
06262:  CLRF   FAA
06264:  MOVLW  2A
06266:  MOVWF  FA9
06268:  MOVFF  7A8,FA8
0626C:  BCF    FA6.6
0626E:  BCF    FA6.7
06270:  BSF    FA6.2
06272:  MOVLB  F
06274:  MOVLW  55
06276:  MOVWF  FA7
06278:  MOVLW  AA
0627A:  MOVWF  FA7
0627C:  BSF    FA6.1
0627E:  BTFSC  FA6.1
06280:  BRA    627E
06282:  BCF    FA6.2
06284:  MOVF   00,W
06286:  IORWF  FF2,F
....................     write_eeprom(0x2b,highbyte);   
06288:  MOVFF  FF2,00
0628C:  BCF    FF2.7
0628E:  CLRF   FAA
06290:  MOVLW  2B
06292:  MOVWF  FA9
06294:  MOVFF  7A9,FA8
06298:  BCF    FA6.6
0629A:  BCF    FA6.7
0629C:  BSF    FA6.2
0629E:  MOVLW  55
062A0:  MOVWF  FA7
062A2:  MOVLW  AA
062A4:  MOVWF  FA7
062A6:  BSF    FA6.1
062A8:  BTFSC  FA6.1
062AA:  BRA    62A8
062AC:  BCF    FA6.2
062AE:  MOVF   00,W
062B0:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
062B2:  MOVLW  2A
062B4:  BTFSS  F9E.4
062B6:  BRA    62B4
062B8:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt3cal2of3 
....................     items = sysInput.DOpt3cal2of3; 
062BA:  MOVFF  26C,7AB
062BE:  MOVFF  26B,7AA
....................     lowbyte =(int8) items; 
062C2:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
062C6:  MOVLB  7
062C8:  MOVF   xAB,W
062CA:  MOVWF  xA9
....................     write_eeprom(0x2c,lowbyte); 
062CC:  MOVF   FF2,W
062CE:  MOVWF  00
062D0:  BCF    FF2.7
062D2:  CLRF   FAA
062D4:  MOVLW  2C
062D6:  MOVWF  FA9
062D8:  MOVFF  7A8,FA8
062DC:  BCF    FA6.6
062DE:  BCF    FA6.7
062E0:  BSF    FA6.2
062E2:  MOVLB  F
062E4:  MOVLW  55
062E6:  MOVWF  FA7
062E8:  MOVLW  AA
062EA:  MOVWF  FA7
062EC:  BSF    FA6.1
062EE:  BTFSC  FA6.1
062F0:  BRA    62EE
062F2:  BCF    FA6.2
062F4:  MOVF   00,W
062F6:  IORWF  FF2,F
....................     write_eeprom(0x2d,highbyte);   
062F8:  MOVFF  FF2,00
062FC:  BCF    FF2.7
062FE:  CLRF   FAA
06300:  MOVLW  2D
06302:  MOVWF  FA9
06304:  MOVFF  7A9,FA8
06308:  BCF    FA6.6
0630A:  BCF    FA6.7
0630C:  BSF    FA6.2
0630E:  MOVLW  55
06310:  MOVWF  FA7
06312:  MOVLW  AA
06314:  MOVWF  FA7
06316:  BSF    FA6.1
06318:  BTFSC  FA6.1
0631A:  BRA    6318
0631C:  BCF    FA6.2
0631E:  MOVF   00,W
06320:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
06322:  MOVLW  2A
06324:  BTFSS  F9E.4
06326:  BRA    6324
06328:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt3cal3of3 
....................     items = sysInput.DOpt3cal3of3; 
0632A:  MOVFF  26E,7AB
0632E:  MOVFF  26D,7AA
....................     lowbyte =(int8) items; 
06332:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
06336:  MOVLB  7
06338:  MOVF   xAB,W
0633A:  MOVWF  xA9
....................     write_eeprom(0x2e,lowbyte); 
0633C:  MOVF   FF2,W
0633E:  MOVWF  00
06340:  BCF    FF2.7
06342:  CLRF   FAA
06344:  MOVLW  2E
06346:  MOVWF  FA9
06348:  MOVFF  7A8,FA8
0634C:  BCF    FA6.6
0634E:  BCF    FA6.7
06350:  BSF    FA6.2
06352:  MOVLB  F
06354:  MOVLW  55
06356:  MOVWF  FA7
06358:  MOVLW  AA
0635A:  MOVWF  FA7
0635C:  BSF    FA6.1
0635E:  BTFSC  FA6.1
06360:  BRA    635E
06362:  BCF    FA6.2
06364:  MOVF   00,W
06366:  IORWF  FF2,F
....................     write_eeprom(0x2F,highbyte);   
06368:  MOVFF  FF2,00
0636C:  BCF    FF2.7
0636E:  CLRF   FAA
06370:  MOVLW  2F
06372:  MOVWF  FA9
06374:  MOVFF  7A9,FA8
06378:  BCF    FA6.6
0637A:  BCF    FA6.7
0637C:  BSF    FA6.2
0637E:  MOVLW  55
06380:  MOVWF  FA7
06382:  MOVLW  AA
06384:  MOVWF  FA7
06386:  BSF    FA6.1
06388:  BTFSC  FA6.1
0638A:  BRA    6388
0638C:  BCF    FA6.2
0638E:  MOVF   00,W
06390:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
06392:  MOVLW  2A
06394:  BTFSS  F9E.4
06396:  BRA    6394
06398:  MOVWF  FAD
.................... //***************************************  
....................     eeprom_write_blocktest(&sysInput.DOpt1returnednumber, 0x30, sizeof sysInput.DOpt1returnednumber);   // this is forDOpt1returnednumber   This should be four bytes 
0639A:  MOVLW  02
0639C:  MOVLB  7
0639E:  MOVWF  xAD
063A0:  MOVLW  6F
063A2:  MOVWF  xAC
063A4:  MOVLW  30
063A6:  MOVWF  xAE
063A8:  MOVLW  04
063AA:  MOVWF  xAF
063AC:  MOVLB  0
063AE:  CALL   5B00
....................     fprintf(BT,"*");    
063B2:  MOVLW  2A
063B4:  BTFSS  F9E.4
063B6:  BRA    63B4
063B8:  MOVWF  FAD
....................     eeprom_write_blocktest(&sysInput.DOpt2returnednumber, 0x34, sizeof sysInput.DOpt2returnednumber);   // this is for DOpt2returnednumber   This should be four bytes 
063BA:  MOVLW  02
063BC:  MOVLB  7
063BE:  MOVWF  xAD
063C0:  MOVLW  73
063C2:  MOVWF  xAC
063C4:  MOVLW  34
063C6:  MOVWF  xAE
063C8:  MOVLW  04
063CA:  MOVWF  xAF
063CC:  MOVLB  0
063CE:  CALL   5B00
....................     fprintf(BT,"*");    
063D2:  MOVLW  2A
063D4:  BTFSS  F9E.4
063D6:  BRA    63D4
063D8:  MOVWF  FAD
....................     eeprom_write_blocktest(&sysInput.DOpt3returnednumber, 0x38, sizeof sysInput.DOpt3returnednumber);   // this is forDOpt3returnednumber   This should be four bytes 
063DA:  MOVLW  02
063DC:  MOVLB  7
063DE:  MOVWF  xAD
063E0:  MOVLW  77
063E2:  MOVWF  xAC
063E4:  MOVLW  38
063E6:  MOVWF  xAE
063E8:  MOVLW  04
063EA:  MOVWF  xAF
063EC:  MOVLB  0
063EE:  CALL   5B00
....................     fprintf(BT,"*");  
063F2:  MOVLW  2A
063F4:  BTFSS  F9E.4
063F6:  BRA    63F4
063F8:  MOVWF  FAD
063FA:  GOTO   779A (RETURN)
....................      
....................      
....................      
....................  //Created Feb 27, 2017 
....................     //this is all Theremister stuff    
....................      
....................      
.................... } 
....................  
....................  
.................... //************************************************************** 
.................... // Created November 24, 2016 
.................... // This routine sucks in the data number as a float from the Interenal EEOPROM.  This is for the 8 bit version 
.................... //************************************************************** 
.................... float READ_FLOAT_EEPROM(int n) {  
....................    int i;  
....................    float data; 
....................  
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
*
01582:  MOVLB  7
01584:  CLRF   x75
01586:  MOVF   x75,W
01588:  SUBLW  03
0158A:  BNC   15CC
....................       *((int8*)&data + i) = read_eeprom(i + n); 
0158C:  MOVLW  07
0158E:  MOVWF  x7B
01590:  MOVLW  76
01592:  MOVWF  x7A
01594:  MOVF   x75,W
01596:  ADDWF  x7A,W
01598:  MOVWF  01
0159A:  MOVLW  00
0159C:  ADDWFC x7B,W
0159E:  MOVWF  03
015A0:  MOVF   01,W
015A2:  MOVWF  FE9
015A4:  MOVFF  03,FEA
015A8:  MOVF   x74,W
015AA:  ADDWF  x75,W
015AC:  MOVWF  x7C
015AE:  MOVFF  FF2,77D
015B2:  BCF    FF2.7
015B4:  CLRF   FAA
015B6:  MOVFF  77C,FA9
015BA:  BCF    FA6.6
015BC:  BCF    FA6.7
015BE:  BSF    FA6.0
015C0:  MOVF   FA8,W
015C2:  BTFSC  x7D.7
015C4:  BSF    FF2.7
015C6:  MOVWF  FEF
015C8:  INCF   x75,F
015CA:  BRA    1586
....................  
....................    return(data);  
015CC:  MOVFF  776,00
015D0:  MOVFF  777,01
015D4:  MOVFF  778,02
015D8:  MOVFF  779,03
015DC:  MOVLB  0
015DE:  RETURN 0
.................... } 
....................  
....................  
.................... void LoadConfigurations(void) 
.................... { 
....................     int8 lowbyte,highbyte; 
....................     unsigned int16 items; 
....................      
....................      
....................     sysInput.nh4pt1returnednumber = READ_FLOAT_EEPROM(0x12);   // this gets the four bytes from EEPROM to make   nh4pt1returnednumber   
015E0:  MOVLW  12
015E2:  MOVLB  7
015E4:  MOVWF  x74
015E6:  MOVLB  0
015E8:  RCALL  1582
015EA:  MOVFF  03,254
015EE:  MOVFF  02,253
015F2:  MOVFF  01,252
015F6:  MOVFF  00,251
....................     sysInput.nh4pt2returnednumber = READ_FLOAT_EEPROM(0x16);   // this gets the four bytes from EEPROM to make   nh4pt1returnednumber   
015FA:  MOVLW  16
015FC:  MOVLB  7
015FE:  MOVWF  x74
01600:  MOVLB  0
01602:  RCALL  1582
01604:  MOVFF  03,258
01608:  MOVFF  02,257
0160C:  MOVFF  01,256
01610:  MOVFF  00,255
....................     sysInput.nh4pt3returnednumber = READ_FLOAT_EEPROM(0x1a);   // this gets the four bytes from EEPROM to make   nh4pt1returnednumber   
01614:  MOVLW  1A
01616:  MOVLB  7
01618:  MOVWF  x74
0161A:  MOVLB  0
0161C:  RCALL  1582
0161E:  MOVFF  03,25C
01622:  MOVFF  02,25B
01626:  MOVFF  01,25A
0162A:  MOVFF  00,259
....................   //  nh4pt1cal1of3   
....................     lowbyte = read_eeprom(0x00); 
0162E:  MOVFF  FF2,774
01632:  BCF    FF2.7
01634:  CLRF   FAA
01636:  CLRF   FA9
01638:  BCF    FA6.6
0163A:  BCF    FA6.7
0163C:  BSF    FA6.0
0163E:  MOVF   FA8,W
01640:  MOVLB  7
01642:  BTFSC  x74.7
01644:  BSF    FF2.7
01646:  MOVWF  x70
....................     highbyte = read_eeprom(0x01); 
01648:  MOVFF  FF2,774
0164C:  BCF    FF2.7
0164E:  CLRF   FAA
01650:  MOVLW  01
01652:  MOVWF  FA9
01654:  BCF    FA6.6
01656:  BCF    FA6.7
01658:  BSF    FA6.0
0165A:  MOVF   FA8,W
0165C:  BTFSC  x74.7
0165E:  BSF    FF2.7
01660:  MOVWF  x71
....................     items = (int16) highbyte; 
01662:  CLRF   x73
01664:  MOVFF  771,772
....................     sysInput.nh4pt1cal1of3 = (items<<8) +  lowbyte;   
01668:  CLRF   x74
0166A:  MOVF   x70,W
0166C:  ADDWF  x74,W
0166E:  MOVLB  2
01670:  MOVWF  x3F
01672:  MOVLW  00
01674:  MOVLB  7
01676:  ADDWFC x72,W
01678:  MOVLB  2
0167A:  MOVWF  x40
.................... //*************************************** 
.................... //  nh4pt1ca2of3   
....................     lowbyte = read_eeprom(0x02); 
0167C:  MOVFF  FF2,774
01680:  BCF    FF2.7
01682:  CLRF   FAA
01684:  MOVLW  02
01686:  MOVWF  FA9
01688:  BCF    FA6.6
0168A:  BCF    FA6.7
0168C:  BSF    FA6.0
0168E:  MOVF   FA8,W
01690:  MOVLB  7
01692:  BTFSC  x74.7
01694:  BSF    FF2.7
01696:  MOVWF  x70
....................     highbyte = read_eeprom(0x03); 
01698:  MOVFF  FF2,774
0169C:  BCF    FF2.7
0169E:  CLRF   FAA
016A0:  MOVLW  03
016A2:  MOVWF  FA9
016A4:  BCF    FA6.6
016A6:  BCF    FA6.7
016A8:  BSF    FA6.0
016AA:  MOVF   FA8,W
016AC:  BTFSC  x74.7
016AE:  BSF    FF2.7
016B0:  MOVWF  x71
....................     items = (int16) highbyte; 
016B2:  CLRF   x73
016B4:  MOVFF  771,772
....................     sysInput.nh4pt1cal2of3 = (items<<8) +  lowbyte;   
016B8:  CLRF   x74
016BA:  MOVF   x70,W
016BC:  ADDWF  x74,W
016BE:  MOVLB  2
016C0:  MOVWF  x41
016C2:  MOVLW  00
016C4:  MOVLB  7
016C6:  ADDWFC x72,W
016C8:  MOVLB  2
016CA:  MOVWF  x42
.................... //*************************************** 
.................... //  nh4pt1ca3of3   
....................     lowbyte = read_eeprom(0x04); 
016CC:  MOVFF  FF2,774
016D0:  BCF    FF2.7
016D2:  CLRF   FAA
016D4:  MOVLW  04
016D6:  MOVWF  FA9
016D8:  BCF    FA6.6
016DA:  BCF    FA6.7
016DC:  BSF    FA6.0
016DE:  MOVF   FA8,W
016E0:  MOVLB  7
016E2:  BTFSC  x74.7
016E4:  BSF    FF2.7
016E6:  MOVWF  x70
....................     highbyte = read_eeprom(0x05); 
016E8:  MOVFF  FF2,774
016EC:  BCF    FF2.7
016EE:  CLRF   FAA
016F0:  MOVLW  05
016F2:  MOVWF  FA9
016F4:  BCF    FA6.6
016F6:  BCF    FA6.7
016F8:  BSF    FA6.0
016FA:  MOVF   FA8,W
016FC:  BTFSC  x74.7
016FE:  BSF    FF2.7
01700:  MOVWF  x71
....................     items = (int16) highbyte; 
01702:  CLRF   x73
01704:  MOVFF  771,772
....................     sysInput.nh4pt1cal3of3 = (items<<8) +  lowbyte;   
01708:  CLRF   x74
0170A:  MOVF   x70,W
0170C:  ADDWF  x74,W
0170E:  MOVLB  2
01710:  MOVWF  x43
01712:  MOVLW  00
01714:  MOVLB  7
01716:  ADDWFC x72,W
01718:  MOVLB  2
0171A:  MOVWF  x44
.................... //***************************************   
.................... //  nh4pt2ca1of3   
....................     lowbyte = read_eeprom(0x06); 
0171C:  MOVFF  FF2,774
01720:  BCF    FF2.7
01722:  CLRF   FAA
01724:  MOVLW  06
01726:  MOVWF  FA9
01728:  BCF    FA6.6
0172A:  BCF    FA6.7
0172C:  BSF    FA6.0
0172E:  MOVF   FA8,W
01730:  MOVLB  7
01732:  BTFSC  x74.7
01734:  BSF    FF2.7
01736:  MOVWF  x70
....................     highbyte = read_eeprom(0x07); 
01738:  MOVFF  FF2,774
0173C:  BCF    FF2.7
0173E:  CLRF   FAA
01740:  MOVLW  07
01742:  MOVWF  FA9
01744:  BCF    FA6.6
01746:  BCF    FA6.7
01748:  BSF    FA6.0
0174A:  MOVF   FA8,W
0174C:  BTFSC  x74.7
0174E:  BSF    FF2.7
01750:  MOVWF  x71
....................     items = (int16) highbyte; 
01752:  CLRF   x73
01754:  MOVFF  771,772
....................     sysInput.nh4pt2cal1of3 = (items<<8) +  lowbyte;   
01758:  CLRF   x74
0175A:  MOVF   x70,W
0175C:  ADDWF  x74,W
0175E:  MOVLB  2
01760:  MOVWF  x45
01762:  MOVLW  00
01764:  MOVLB  7
01766:  ADDWFC x72,W
01768:  MOVLB  2
0176A:  MOVWF  x46
.................... //***************************************     
.................... //  nh4pt2ca2of3   
....................     lowbyte = read_eeprom(0x08); 
0176C:  MOVFF  FF2,774
01770:  BCF    FF2.7
01772:  CLRF   FAA
01774:  MOVLW  08
01776:  MOVWF  FA9
01778:  BCF    FA6.6
0177A:  BCF    FA6.7
0177C:  BSF    FA6.0
0177E:  MOVF   FA8,W
01780:  MOVLB  7
01782:  BTFSC  x74.7
01784:  BSF    FF2.7
01786:  MOVWF  x70
....................     highbyte = read_eeprom(0x09); 
01788:  MOVFF  FF2,774
0178C:  BCF    FF2.7
0178E:  CLRF   FAA
01790:  MOVLW  09
01792:  MOVWF  FA9
01794:  BCF    FA6.6
01796:  BCF    FA6.7
01798:  BSF    FA6.0
0179A:  MOVF   FA8,W
0179C:  BTFSC  x74.7
0179E:  BSF    FF2.7
017A0:  MOVWF  x71
....................     items = (int16) highbyte; 
017A2:  CLRF   x73
017A4:  MOVFF  771,772
....................     sysInput.nh4pt2cal2of3 = (items<<8) +  lowbyte;   
017A8:  CLRF   x74
017AA:  MOVF   x70,W
017AC:  ADDWF  x74,W
017AE:  MOVLB  2
017B0:  MOVWF  x47
017B2:  MOVLW  00
017B4:  MOVLB  7
017B6:  ADDWFC x72,W
017B8:  MOVLB  2
017BA:  MOVWF  x48
.................... //***************************************     
.................... //  nh4pt2ca13of3   
....................     lowbyte = read_eeprom(0x0a); 
017BC:  MOVFF  FF2,774
017C0:  BCF    FF2.7
017C2:  CLRF   FAA
017C4:  MOVLW  0A
017C6:  MOVWF  FA9
017C8:  BCF    FA6.6
017CA:  BCF    FA6.7
017CC:  BSF    FA6.0
017CE:  MOVF   FA8,W
017D0:  MOVLB  7
017D2:  BTFSC  x74.7
017D4:  BSF    FF2.7
017D6:  MOVWF  x70
....................     highbyte = read_eeprom(0x0b); 
017D8:  MOVFF  FF2,774
017DC:  BCF    FF2.7
017DE:  CLRF   FAA
017E0:  MOVLW  0B
017E2:  MOVWF  FA9
017E4:  BCF    FA6.6
017E6:  BCF    FA6.7
017E8:  BSF    FA6.0
017EA:  MOVF   FA8,W
017EC:  BTFSC  x74.7
017EE:  BSF    FF2.7
017F0:  MOVWF  x71
....................     items = (int16) highbyte; 
017F2:  CLRF   x73
017F4:  MOVFF  771,772
....................     sysInput.nh4pt2cal3of3 = (items<<8) +  lowbyte;   
017F8:  CLRF   x74
017FA:  MOVF   x70,W
017FC:  ADDWF  x74,W
017FE:  MOVLB  2
01800:  MOVWF  x49
01802:  MOVLW  00
01804:  MOVLB  7
01806:  ADDWFC x72,W
01808:  MOVLB  2
0180A:  MOVWF  x4A
.................... //***************************************     
.................... //  nh4pt3ca1of3   
....................     lowbyte = read_eeprom(0x0c); 
0180C:  MOVFF  FF2,774
01810:  BCF    FF2.7
01812:  CLRF   FAA
01814:  MOVLW  0C
01816:  MOVWF  FA9
01818:  BCF    FA6.6
0181A:  BCF    FA6.7
0181C:  BSF    FA6.0
0181E:  MOVF   FA8,W
01820:  MOVLB  7
01822:  BTFSC  x74.7
01824:  BSF    FF2.7
01826:  MOVWF  x70
....................     highbyte = read_eeprom(0x0d); 
01828:  MOVFF  FF2,774
0182C:  BCF    FF2.7
0182E:  CLRF   FAA
01830:  MOVLW  0D
01832:  MOVWF  FA9
01834:  BCF    FA6.6
01836:  BCF    FA6.7
01838:  BSF    FA6.0
0183A:  MOVF   FA8,W
0183C:  BTFSC  x74.7
0183E:  BSF    FF2.7
01840:  MOVWF  x71
....................     items = (int16) highbyte; 
01842:  CLRF   x73
01844:  MOVFF  771,772
....................     sysInput.nh4pt3cal1of3 = (items<<8) +  lowbyte;   
01848:  CLRF   x74
0184A:  MOVF   x70,W
0184C:  ADDWF  x74,W
0184E:  MOVLB  2
01850:  MOVWF  x4B
01852:  MOVLW  00
01854:  MOVLB  7
01856:  ADDWFC x72,W
01858:  MOVLB  2
0185A:  MOVWF  x4C
.................... //***************************************     
.................... //  nh4pt3ca2of3   
....................     lowbyte = read_eeprom(0x0e); 
0185C:  MOVFF  FF2,774
01860:  BCF    FF2.7
01862:  CLRF   FAA
01864:  MOVLW  0E
01866:  MOVWF  FA9
01868:  BCF    FA6.6
0186A:  BCF    FA6.7
0186C:  BSF    FA6.0
0186E:  MOVF   FA8,W
01870:  MOVLB  7
01872:  BTFSC  x74.7
01874:  BSF    FF2.7
01876:  MOVWF  x70
....................     highbyte = read_eeprom(0x0f); 
01878:  MOVFF  FF2,774
0187C:  BCF    FF2.7
0187E:  CLRF   FAA
01880:  MOVLW  0F
01882:  MOVWF  FA9
01884:  BCF    FA6.6
01886:  BCF    FA6.7
01888:  BSF    FA6.0
0188A:  MOVF   FA8,W
0188C:  BTFSC  x74.7
0188E:  BSF    FF2.7
01890:  MOVWF  x71
....................     items = (int16) highbyte; 
01892:  CLRF   x73
01894:  MOVFF  771,772
....................     sysInput.nh4pt3cal2of3 = (items<<8) +  lowbyte;   
01898:  CLRF   x74
0189A:  MOVF   x70,W
0189C:  ADDWF  x74,W
0189E:  MOVLB  2
018A0:  MOVWF  x4D
018A2:  MOVLW  00
018A4:  MOVLB  7
018A6:  ADDWFC x72,W
018A8:  MOVLB  2
018AA:  MOVWF  x4E
.................... //***************************************     
.................... //  nh4pt3ca3of3   
....................     lowbyte = read_eeprom(0x10); 
018AC:  MOVFF  FF2,774
018B0:  BCF    FF2.7
018B2:  CLRF   FAA
018B4:  MOVLW  10
018B6:  MOVWF  FA9
018B8:  BCF    FA6.6
018BA:  BCF    FA6.7
018BC:  BSF    FA6.0
018BE:  MOVF   FA8,W
018C0:  MOVLB  7
018C2:  BTFSC  x74.7
018C4:  BSF    FF2.7
018C6:  MOVWF  x70
....................     highbyte = read_eeprom(0x11); 
018C8:  MOVFF  FF2,774
018CC:  BCF    FF2.7
018CE:  CLRF   FAA
018D0:  MOVLW  11
018D2:  MOVWF  FA9
018D4:  BCF    FA6.6
018D6:  BCF    FA6.7
018D8:  BSF    FA6.0
018DA:  MOVF   FA8,W
018DC:  BTFSC  x74.7
018DE:  BSF    FF2.7
018E0:  MOVWF  x71
....................     items = (int16) highbyte; 
018E2:  CLRF   x73
018E4:  MOVFF  771,772
....................     sysInput.nh4pt3cal3of3 = (items<<8) +  lowbyte;   
018E8:  CLRF   x74
018EA:  MOVF   x70,W
018EC:  ADDWF  x74,W
018EE:  MOVLB  2
018F0:  MOVWF  x4F
018F2:  MOVLW  00
018F4:  MOVLB  7
018F6:  ADDWFC x72,W
018F8:  MOVLB  2
018FA:  MOVWF  x50
.................... //***************************************     
....................     
....................      
....................      
....................      
.................... // load the DO stuff out of EEPROM   Added Feb 27, 2017 
....................  
....................     sysInput.DOpt1returnednumber = READ_FLOAT_EEPROM(0x30);   // this gets the four bytes from EEPROM to make   DOpt1returnednumber   
018FC:  MOVLW  30
018FE:  MOVLB  7
01900:  MOVWF  x74
01902:  MOVLB  0
01904:  RCALL  1582
01906:  MOVFF  03,272
0190A:  MOVFF  02,271
0190E:  MOVFF  01,270
01912:  MOVFF  00,26F
....................     sysInput.DOpt2returnednumber = READ_FLOAT_EEPROM(0x34);   // this gets the four bytes from EEPROM to make   DOpt2returnednumber   
01916:  MOVLW  34
01918:  MOVLB  7
0191A:  MOVWF  x74
0191C:  MOVLB  0
0191E:  RCALL  1582
01920:  MOVFF  03,276
01924:  MOVFF  02,275
01928:  MOVFF  01,274
0192C:  MOVFF  00,273
....................     sysInput.DOpt3returnednumber = READ_FLOAT_EEPROM(0x38);   // this gets the four bytes from EEPROM to make   DOpt3returnednumber   
01930:  MOVLW  38
01932:  MOVLB  7
01934:  MOVWF  x74
01936:  MOVLB  0
01938:  RCALL  1582
0193A:  MOVFF  03,27A
0193E:  MOVFF  02,279
01942:  MOVFF  01,278
01946:  MOVFF  00,277
....................   //  DOpt1cal1of3    
....................     lowbyte = read_eeprom(0x1e); 
0194A:  MOVFF  FF2,774
0194E:  BCF    FF2.7
01950:  CLRF   FAA
01952:  MOVLW  1E
01954:  MOVWF  FA9
01956:  BCF    FA6.6
01958:  BCF    FA6.7
0195A:  BSF    FA6.0
0195C:  MOVF   FA8,W
0195E:  MOVLB  7
01960:  BTFSC  x74.7
01962:  BSF    FF2.7
01964:  MOVWF  x70
....................     highbyte = read_eeprom(0x1f); 
01966:  MOVFF  FF2,774
0196A:  BCF    FF2.7
0196C:  CLRF   FAA
0196E:  MOVLW  1F
01970:  MOVWF  FA9
01972:  BCF    FA6.6
01974:  BCF    FA6.7
01976:  BSF    FA6.0
01978:  MOVF   FA8,W
0197A:  BTFSC  x74.7
0197C:  BSF    FF2.7
0197E:  MOVWF  x71
....................     items = (int16) highbyte; 
01980:  CLRF   x73
01982:  MOVFF  771,772
....................     sysInput.DOpt1cal1of3 = (items<<8) +  lowbyte;   
01986:  CLRF   x74
01988:  MOVF   x70,W
0198A:  ADDWF  x74,W
0198C:  MOVLB  2
0198E:  MOVWF  x5D
01990:  MOVLW  00
01992:  MOVLB  7
01994:  ADDWFC x72,W
01996:  MOVLB  2
01998:  MOVWF  x5E
.................... //*************************************** 
.................... //  DOpt1cal2of3    
....................     lowbyte = read_eeprom(0x20); 
0199A:  MOVFF  FF2,774
0199E:  BCF    FF2.7
019A0:  CLRF   FAA
019A2:  MOVLW  20
019A4:  MOVWF  FA9
019A6:  BCF    FA6.6
019A8:  BCF    FA6.7
019AA:  BSF    FA6.0
019AC:  MOVF   FA8,W
019AE:  MOVLB  7
019B0:  BTFSC  x74.7
019B2:  BSF    FF2.7
019B4:  MOVWF  x70
....................     highbyte = read_eeprom(0x21); 
019B6:  MOVFF  FF2,774
019BA:  BCF    FF2.7
019BC:  CLRF   FAA
019BE:  MOVLW  21
019C0:  MOVWF  FA9
019C2:  BCF    FA6.6
019C4:  BCF    FA6.7
019C6:  BSF    FA6.0
019C8:  MOVF   FA8,W
019CA:  BTFSC  x74.7
019CC:  BSF    FF2.7
019CE:  MOVWF  x71
....................     items = (int16) highbyte; 
019D0:  CLRF   x73
019D2:  MOVFF  771,772
....................     sysInput.DOpt1cal2of3 = (items<<8) +  lowbyte;   
019D6:  CLRF   x74
019D8:  MOVF   x70,W
019DA:  ADDWF  x74,W
019DC:  MOVLB  2
019DE:  MOVWF  x5F
019E0:  MOVLW  00
019E2:  MOVLB  7
019E4:  ADDWFC x72,W
019E6:  MOVLB  2
019E8:  MOVWF  x60
.................... //*************************************** 
.................... //  DOpt1cal3of3   
....................     lowbyte = read_eeprom(0x22); 
019EA:  MOVFF  FF2,774
019EE:  BCF    FF2.7
019F0:  CLRF   FAA
019F2:  MOVLW  22
019F4:  MOVWF  FA9
019F6:  BCF    FA6.6
019F8:  BCF    FA6.7
019FA:  BSF    FA6.0
019FC:  MOVF   FA8,W
019FE:  MOVLB  7
01A00:  BTFSC  x74.7
01A02:  BSF    FF2.7
01A04:  MOVWF  x70
....................     highbyte = read_eeprom(0x23); 
01A06:  MOVFF  FF2,774
01A0A:  BCF    FF2.7
01A0C:  CLRF   FAA
01A0E:  MOVLW  23
01A10:  MOVWF  FA9
01A12:  BCF    FA6.6
01A14:  BCF    FA6.7
01A16:  BSF    FA6.0
01A18:  MOVF   FA8,W
01A1A:  BTFSC  x74.7
01A1C:  BSF    FF2.7
01A1E:  MOVWF  x71
....................     items = (int16) highbyte; 
01A20:  CLRF   x73
01A22:  MOVFF  771,772
....................     sysInput.DOpt1cal3of3 = (items<<8) +  lowbyte;   
01A26:  CLRF   x74
01A28:  MOVF   x70,W
01A2A:  ADDWF  x74,W
01A2C:  MOVLB  2
01A2E:  MOVWF  x61
01A30:  MOVLW  00
01A32:  MOVLB  7
01A34:  ADDWFC x72,W
01A36:  MOVLB  2
01A38:  MOVWF  x62
.................... //***************************************   
.................... //  DOpt2cal1of3   
....................     lowbyte = read_eeprom(0x24); 
01A3A:  MOVFF  FF2,774
01A3E:  BCF    FF2.7
01A40:  CLRF   FAA
01A42:  MOVLW  24
01A44:  MOVWF  FA9
01A46:  BCF    FA6.6
01A48:  BCF    FA6.7
01A4A:  BSF    FA6.0
01A4C:  MOVF   FA8,W
01A4E:  MOVLB  7
01A50:  BTFSC  x74.7
01A52:  BSF    FF2.7
01A54:  MOVWF  x70
....................     highbyte = read_eeprom(0x25); 
01A56:  MOVFF  FF2,774
01A5A:  BCF    FF2.7
01A5C:  CLRF   FAA
01A5E:  MOVLW  25
01A60:  MOVWF  FA9
01A62:  BCF    FA6.6
01A64:  BCF    FA6.7
01A66:  BSF    FA6.0
01A68:  MOVF   FA8,W
01A6A:  BTFSC  x74.7
01A6C:  BSF    FF2.7
01A6E:  MOVWF  x71
....................     items = (int16) highbyte; 
01A70:  CLRF   x73
01A72:  MOVFF  771,772
....................     sysInput.DOpt2cal1of3 = (items<<8) +  lowbyte;   
01A76:  CLRF   x74
01A78:  MOVF   x70,W
01A7A:  ADDWF  x74,W
01A7C:  MOVLB  2
01A7E:  MOVWF  x63
01A80:  MOVLW  00
01A82:  MOVLB  7
01A84:  ADDWFC x72,W
01A86:  MOVLB  2
01A88:  MOVWF  x64
.................... //***************************************     
.................... //  DOpt2cal2of3   
....................     lowbyte = read_eeprom(0x26); 
01A8A:  MOVFF  FF2,774
01A8E:  BCF    FF2.7
01A90:  CLRF   FAA
01A92:  MOVLW  26
01A94:  MOVWF  FA9
01A96:  BCF    FA6.6
01A98:  BCF    FA6.7
01A9A:  BSF    FA6.0
01A9C:  MOVF   FA8,W
01A9E:  MOVLB  7
01AA0:  BTFSC  x74.7
01AA2:  BSF    FF2.7
01AA4:  MOVWF  x70
....................     highbyte = read_eeprom(0x27); 
01AA6:  MOVFF  FF2,774
01AAA:  BCF    FF2.7
01AAC:  CLRF   FAA
01AAE:  MOVLW  27
01AB0:  MOVWF  FA9
01AB2:  BCF    FA6.6
01AB4:  BCF    FA6.7
01AB6:  BSF    FA6.0
01AB8:  MOVF   FA8,W
01ABA:  BTFSC  x74.7
01ABC:  BSF    FF2.7
01ABE:  MOVWF  x71
....................     items = (int16) highbyte; 
01AC0:  CLRF   x73
01AC2:  MOVFF  771,772
....................     sysInput.DOpt2cal2of3 = (items<<8) +  lowbyte;   
01AC6:  CLRF   x74
01AC8:  MOVF   x70,W
01ACA:  ADDWF  x74,W
01ACC:  MOVLB  2
01ACE:  MOVWF  x65
01AD0:  MOVLW  00
01AD2:  MOVLB  7
01AD4:  ADDWFC x72,W
01AD6:  MOVLB  2
01AD8:  MOVWF  x66
.................... //***************************************     
.................... //  DOpt2cal3of3   
....................     lowbyte = read_eeprom(0x28); 
01ADA:  MOVFF  FF2,774
01ADE:  BCF    FF2.7
01AE0:  CLRF   FAA
01AE2:  MOVLW  28
01AE4:  MOVWF  FA9
01AE6:  BCF    FA6.6
01AE8:  BCF    FA6.7
01AEA:  BSF    FA6.0
01AEC:  MOVF   FA8,W
01AEE:  MOVLB  7
01AF0:  BTFSC  x74.7
01AF2:  BSF    FF2.7
01AF4:  MOVWF  x70
....................     highbyte = read_eeprom(0x29); 
01AF6:  MOVFF  FF2,774
01AFA:  BCF    FF2.7
01AFC:  CLRF   FAA
01AFE:  MOVLW  29
01B00:  MOVWF  FA9
01B02:  BCF    FA6.6
01B04:  BCF    FA6.7
01B06:  BSF    FA6.0
01B08:  MOVF   FA8,W
01B0A:  BTFSC  x74.7
01B0C:  BSF    FF2.7
01B0E:  MOVWF  x71
....................     items = (int16) highbyte; 
01B10:  CLRF   x73
01B12:  MOVFF  771,772
....................     sysInput.DOpt2cal3of3 = (items<<8) +  lowbyte;   
01B16:  CLRF   x74
01B18:  MOVF   x70,W
01B1A:  ADDWF  x74,W
01B1C:  MOVLB  2
01B1E:  MOVWF  x67
01B20:  MOVLW  00
01B22:  MOVLB  7
01B24:  ADDWFC x72,W
01B26:  MOVLB  2
01B28:  MOVWF  x68
.................... //***************************************     
.................... //  DOpt3cal1of3   
....................     lowbyte = read_eeprom(0x2a); 
01B2A:  MOVFF  FF2,774
01B2E:  BCF    FF2.7
01B30:  CLRF   FAA
01B32:  MOVLW  2A
01B34:  MOVWF  FA9
01B36:  BCF    FA6.6
01B38:  BCF    FA6.7
01B3A:  BSF    FA6.0
01B3C:  MOVF   FA8,W
01B3E:  MOVLB  7
01B40:  BTFSC  x74.7
01B42:  BSF    FF2.7
01B44:  MOVWF  x70
....................     highbyte = read_eeprom(0x2b); 
01B46:  MOVFF  FF2,774
01B4A:  BCF    FF2.7
01B4C:  CLRF   FAA
01B4E:  MOVLW  2B
01B50:  MOVWF  FA9
01B52:  BCF    FA6.6
01B54:  BCF    FA6.7
01B56:  BSF    FA6.0
01B58:  MOVF   FA8,W
01B5A:  BTFSC  x74.7
01B5C:  BSF    FF2.7
01B5E:  MOVWF  x71
....................     items = (int16) highbyte; 
01B60:  CLRF   x73
01B62:  MOVFF  771,772
....................     sysInput.DOpt3cal1of3 = (items<<8) +  lowbyte;   
01B66:  CLRF   x74
01B68:  MOVF   x70,W
01B6A:  ADDWF  x74,W
01B6C:  MOVLB  2
01B6E:  MOVWF  x69
01B70:  MOVLW  00
01B72:  MOVLB  7
01B74:  ADDWFC x72,W
01B76:  MOVLB  2
01B78:  MOVWF  x6A
.................... //***************************************     
.................... //  DOpt3cal2of3   
....................     lowbyte = read_eeprom(0x2c); 
01B7A:  MOVFF  FF2,774
01B7E:  BCF    FF2.7
01B80:  CLRF   FAA
01B82:  MOVLW  2C
01B84:  MOVWF  FA9
01B86:  BCF    FA6.6
01B88:  BCF    FA6.7
01B8A:  BSF    FA6.0
01B8C:  MOVF   FA8,W
01B8E:  MOVLB  7
01B90:  BTFSC  x74.7
01B92:  BSF    FF2.7
01B94:  MOVWF  x70
....................     highbyte = read_eeprom(0x2d); 
01B96:  MOVFF  FF2,774
01B9A:  BCF    FF2.7
01B9C:  CLRF   FAA
01B9E:  MOVLW  2D
01BA0:  MOVWF  FA9
01BA2:  BCF    FA6.6
01BA4:  BCF    FA6.7
01BA6:  BSF    FA6.0
01BA8:  MOVF   FA8,W
01BAA:  BTFSC  x74.7
01BAC:  BSF    FF2.7
01BAE:  MOVWF  x71
....................     items = (int16) highbyte; 
01BB0:  CLRF   x73
01BB2:  MOVFF  771,772
....................     sysInput.DOpt3cal2of3 = (items<<8) +  lowbyte;   
01BB6:  CLRF   x74
01BB8:  MOVF   x70,W
01BBA:  ADDWF  x74,W
01BBC:  MOVLB  2
01BBE:  MOVWF  x6B
01BC0:  MOVLW  00
01BC2:  MOVLB  7
01BC4:  ADDWFC x72,W
01BC6:  MOVLB  2
01BC8:  MOVWF  x6C
.................... //***************************************     
.................... //  DOpt3cal3of3   
....................     lowbyte = read_eeprom(0x2e); 
01BCA:  MOVFF  FF2,774
01BCE:  BCF    FF2.7
01BD0:  CLRF   FAA
01BD2:  MOVLW  2E
01BD4:  MOVWF  FA9
01BD6:  BCF    FA6.6
01BD8:  BCF    FA6.7
01BDA:  BSF    FA6.0
01BDC:  MOVF   FA8,W
01BDE:  MOVLB  7
01BE0:  BTFSC  x74.7
01BE2:  BSF    FF2.7
01BE4:  MOVWF  x70
....................     highbyte = read_eeprom(0x2f); 
01BE6:  MOVFF  FF2,774
01BEA:  BCF    FF2.7
01BEC:  CLRF   FAA
01BEE:  MOVLW  2F
01BF0:  MOVWF  FA9
01BF2:  BCF    FA6.6
01BF4:  BCF    FA6.7
01BF6:  BSF    FA6.0
01BF8:  MOVF   FA8,W
01BFA:  BTFSC  x74.7
01BFC:  BSF    FF2.7
01BFE:  MOVWF  x71
....................     items = (int16) highbyte; 
01C00:  CLRF   x73
01C02:  MOVFF  771,772
....................     sysInput.DOpt3cal3of3 = (items<<8) +  lowbyte;   
01C06:  CLRF   x74
01C08:  MOVF   x70,W
01C0A:  ADDWF  x74,W
01C0C:  MOVLB  2
01C0E:  MOVWF  x6D
01C10:  MOVLW  00
01C12:  MOVLB  7
01C14:  ADDWFC x72,W
01C16:  MOVLB  2
01C18:  MOVWF  x6E
01C1A:  MOVLB  0
01C1C:  GOTO   8FD4 (RETURN)
.................... //***************************************     
....................         
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //******************************************************************** 
.................... // Created November 22, 2016 
.................... // Load the local routines out of the internal EEPROM for the PIC18 series CPUs.  This does not work on the PIC24 or PIC33 CPUS 
.................... //  The data is saved different for each CPU for the data type.   
.................... //  Returns nothing. 
.................... //******************************************************************** 
.................... unsigned int16 getlocalconfigurations(void) 
.................... { 
....................     int8 lowbyte,highbyte; 
....................     unsigned int16 items; 
....................      
....................     lowbyte = read_eeprom(0x78); 
*
01526:  MOVFF  FF2,774
0152A:  BCF    FF2.7
0152C:  CLRF   FAA
0152E:  MOVLW  78
01530:  MOVWF  FA9
01532:  BCF    FA6.6
01534:  BCF    FA6.7
01536:  BSF    FA6.0
01538:  MOVF   FA8,W
0153A:  MOVLB  7
0153C:  BTFSC  x74.7
0153E:  BSF    FF2.7
01540:  MOVWF  x70
....................     highbyte = read_eeprom(0x79); 
01542:  MOVFF  FF2,774
01546:  BCF    FF2.7
01548:  CLRF   FAA
0154A:  MOVLW  79
0154C:  MOVWF  FA9
0154E:  BCF    FA6.6
01550:  BCF    FA6.7
01552:  BSF    FA6.0
01554:  MOVF   FA8,W
01556:  BTFSC  x74.7
01558:  BSF    FF2.7
0155A:  MOVWF  x71
....................     items = (int16) highbyte; 
0155C:  CLRF   x73
0155E:  MOVFF  771,772
....................     
....................     items = (items<<8) +  lowbyte; 
01562:  MOVFF  772,775
01566:  CLRF   x74
01568:  MOVF   x70,W
0156A:  ADDWF  x74,W
0156C:  MOVWF  x72
0156E:  MOVLW  00
01570:  ADDWFC x75,W
01572:  MOVWF  x73
....................     return(items); 
01574:  MOVFF  772,01
01578:  MOVFF  773,02
0157C:  MOVLB  0
0157E:  GOTO   8FC8 (RETURN)
.................... } 
....................  
.................... //********************************************************************** 
.................... // Created November 22, 2016 
.................... // This saves the local configurations to the EEPROM.  The data so far is only 16 bits. 
.................... // int16 word saved to address 
.................... // Returns if the data is save OK.  A 0 for OK, a 1 for not OK 
.................... //********************************************************************** 
.................... int savelocalconfigurations(int16 selectitem) 
.................... { 
....................     int8 lowbyte,highbyte; 
....................      unsigned int16 items; 
....................       
....................     lowbyte =(int8) selectitem; 
*
052E2:  MOVFF  7A8,7AA
....................     highbyte = (int8) (selectitem>>8); 
052E6:  MOVLB  7
052E8:  MOVF   xA9,W
052EA:  MOVWF  xAB
....................     write_eeprom(0x78,lowbyte); 
052EC:  MOVF   FF2,W
052EE:  MOVWF  00
052F0:  BCF    FF2.7
052F2:  CLRF   FAA
052F4:  MOVLW  78
052F6:  MOVWF  FA9
052F8:  MOVFF  7AA,FA8
052FC:  BCF    FA6.6
052FE:  BCF    FA6.7
05300:  BSF    FA6.2
05302:  MOVLB  F
05304:  MOVLW  55
05306:  MOVWF  FA7
05308:  MOVLW  AA
0530A:  MOVWF  FA7
0530C:  BSF    FA6.1
0530E:  BTFSC  FA6.1
05310:  BRA    530E
05312:  BCF    FA6.2
05314:  MOVF   00,W
05316:  IORWF  FF2,F
....................     write_eeprom(0x79,highbyte); 
05318:  MOVFF  FF2,00
0531C:  BCF    FF2.7
0531E:  CLRF   FAA
05320:  MOVLW  79
05322:  MOVWF  FA9
05324:  MOVFF  7AB,FA8
05328:  BCF    FA6.6
0532A:  BCF    FA6.7
0532C:  BSF    FA6.2
0532E:  MOVLW  55
05330:  MOVWF  FA7
05332:  MOVLW  AA
05334:  MOVWF  FA7
05336:  BSF    FA6.1
05338:  BTFSC  FA6.1
0533A:  BRA    5338
0533C:  BCF    FA6.2
0533E:  MOVF   00,W
05340:  IORWF  FF2,F
....................      
....................     lowbyte = read_eeprom(0x78); 
05342:  MOVFF  FF2,7AE
05346:  BCF    FF2.7
05348:  CLRF   FAA
0534A:  MOVLW  78
0534C:  MOVWF  FA9
0534E:  BCF    FA6.6
05350:  BCF    FA6.7
05352:  BSF    FA6.0
05354:  MOVF   FA8,W
05356:  MOVLB  7
05358:  BTFSC  xAE.7
0535A:  BSF    FF2.7
0535C:  MOVWF  xAA
....................     highbyte = read_eeprom(0x79); 
0535E:  MOVFF  FF2,7AE
05362:  BCF    FF2.7
05364:  CLRF   FAA
05366:  MOVLW  79
05368:  MOVWF  FA9
0536A:  BCF    FA6.6
0536C:  BCF    FA6.7
0536E:  BSF    FA6.0
05370:  MOVF   FA8,W
05372:  BTFSC  xAE.7
05374:  BSF    FF2.7
05376:  MOVWF  xAB
....................     items = (int16) highbyte; 
05378:  CLRF   xAD
0537A:  MOVFF  7AB,7AC
....................     
....................     items = (items<<8) +  lowbyte;  
0537E:  MOVFF  7AC,7AF
05382:  CLRF   xAE
05384:  MOVF   xAA,W
05386:  ADDWF  xAE,W
05388:  MOVWF  xAC
0538A:  MOVLW  00
0538C:  ADDWFC xAF,W
0538E:  MOVWF  xAD
....................      
....................     if (items == selectitem) 
05390:  MOVF   xA8,W
05392:  SUBWF  xAC,W
05394:  BNZ   53A4
05396:  MOVF   xA9,W
05398:  SUBWF  xAD,W
0539A:  BNZ   53A4
....................     { 
....................         return(0); 
0539C:  MOVLW  00
0539E:  MOVWF  01
053A0:  BRA    53A8
....................     } 
053A2:  BRA    53A8
....................     else 
....................     { 
....................         return(1); 
053A4:  MOVLW  01
053A6:  MOVWF  01
....................     } 
053A8:  MOVLB  0
053AA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... //********************************************************************* 
.................... // Created July 15, 2015 
.................... // Splash screen for 1 second before going into the main loop; 
.................... //  Give Version, credit to Erik and Paul 
.................... // Provide Version Date 
.................... //********************************************************************* 
....................  
.................... void splash(void) { 
....................     clearDisplay(); 
*
013A8:  RCALL  130C
....................     char teststr4[20] = "Ver 5.03 4/6/2017"; 
013AA:  MOVLW  56
013AC:  MOVLB  7
013AE:  MOVWF  x70
013B0:  MOVLW  65
013B2:  MOVWF  x71
013B4:  MOVLW  72
013B6:  MOVWF  x72
013B8:  MOVLW  20
013BA:  MOVWF  x73
013BC:  MOVLW  35
013BE:  MOVWF  x74
013C0:  MOVLW  2E
013C2:  MOVWF  x75
013C4:  MOVLW  30
013C6:  MOVWF  x76
013C8:  MOVLW  33
013CA:  MOVWF  x77
013CC:  MOVLW  20
013CE:  MOVWF  x78
013D0:  MOVLW  34
013D2:  MOVWF  x79
013D4:  MOVLW  2F
013D6:  MOVWF  x7A
013D8:  MOVLW  36
013DA:  MOVWF  x7B
013DC:  MOVLW  2F
013DE:  MOVWF  x7C
013E0:  MOVLW  32
013E2:  MOVWF  x7D
013E4:  MOVLW  30
013E6:  MOVWF  x7E
013E8:  MOVLW  31
013EA:  MOVWF  x7F
013EC:  MOVLW  37
013EE:  MOVWF  x80
013F0:  CLRF   x81
....................     char teststr1[20] = "Production Tester"; 
013F2:  MOVLW  50
013F4:  MOVWF  x84
013F6:  MOVLW  72
013F8:  MOVWF  x85
013FA:  MOVLW  6F
013FC:  MOVWF  x86
013FE:  MOVLW  64
01400:  MOVWF  x87
01402:  MOVLW  75
01404:  MOVWF  x88
01406:  MOVLW  63
01408:  MOVWF  x89
0140A:  MOVLW  74
0140C:  MOVWF  x8A
0140E:  MOVLW  69
01410:  MOVWF  x8B
01412:  MOVLW  6F
01414:  MOVWF  x8C
01416:  MOVLW  6E
01418:  MOVWF  x8D
0141A:  MOVLW  20
0141C:  MOVWF  x8E
0141E:  MOVLW  54
01420:  MOVWF  x8F
01422:  MOVLW  65
01424:  MOVWF  x90
01426:  MOVLW  73
01428:  MOVWF  x91
0142A:  MOVLW  74
0142C:  MOVWF  x92
0142E:  MOVLW  65
01430:  MOVWF  x93
01432:  MOVLW  72
01434:  MOVWF  x94
01436:  CLRF   x95
....................     char teststr2[20] = "Config Editor"; 
01438:  MOVLW  43
0143A:  MOVWF  x98
0143C:  MOVLW  6F
0143E:  MOVWF  x99
01440:  MOVLW  6E
01442:  MOVWF  x9A
01444:  MOVLW  66
01446:  MOVWF  x9B
01448:  MOVLW  69
0144A:  MOVWF  x9C
0144C:  MOVLW  67
0144E:  MOVWF  x9D
01450:  MOVLW  20
01452:  MOVWF  x9E
01454:  MOVLW  45
01456:  MOVWF  x9F
01458:  MOVLW  64
0145A:  MOVWF  xA0
0145C:  MOVLW  69
0145E:  MOVWF  xA1
01460:  MOVLW  74
01462:  MOVWF  xA2
01464:  MOVLW  6F
01466:  MOVWF  xA3
01468:  MOVLW  72
0146A:  MOVWF  xA4
0146C:  CLRF   xA5
....................     char teststr3[20] = "Paul Holowko-Titular"; 
0146E:  MOVLW  50
01470:  MOVWF  xAC
01472:  MOVLW  61
01474:  MOVWF  xAD
01476:  MOVLW  75
01478:  MOVWF  xAE
0147A:  MOVLW  6C
0147C:  MOVWF  xAF
0147E:  MOVLW  20
01480:  MOVWF  xB0
01482:  MOVLW  48
01484:  MOVWF  xB1
01486:  MOVLW  6F
01488:  MOVWF  xB2
0148A:  MOVLW  6C
0148C:  MOVWF  xB3
0148E:  MOVLW  6F
01490:  MOVWF  xB4
01492:  MOVLW  77
01494:  MOVWF  xB5
01496:  MOVLW  6B
01498:  MOVWF  xB6
0149A:  MOVLW  6F
0149C:  MOVWF  xB7
0149E:  MOVLW  2D
014A0:  MOVWF  xB8
014A2:  MOVLW  54
014A4:  MOVWF  xB9
014A6:  MOVLW  69
014A8:  MOVWF  xBA
014AA:  MOVLW  74
014AC:  MOVWF  xBB
014AE:  MOVLW  75
014B0:  MOVWF  xBC
014B2:  MOVLW  6C
014B4:  MOVWF  xBD
014B6:  MOVLW  61
014B8:  MOVWF  xBE
014BA:  MOVLW  72
014BC:  MOVWF  xBF
....................     writeString(0, 0, teststr1); 
014BE:  CLRF   xC0
014C0:  CLRF   xC1
014C2:  MOVLW  07
014C4:  MOVWF  xC3
014C6:  MOVLW  84
014C8:  MOVWF  xC2
014CA:  MOVLB  0
014CC:  RCALL  1338
....................     writeString(0, 1, teststr2); 
014CE:  MOVLB  7
014D0:  CLRF   xC0
014D2:  MOVLW  01
014D4:  MOVWF  xC1
014D6:  MOVLW  07
014D8:  MOVWF  xC3
014DA:  MOVLW  98
014DC:  MOVWF  xC2
014DE:  MOVLB  0
014E0:  RCALL  1338
....................     writeString(0, 2, teststr3); 
014E2:  MOVLB  7
014E4:  CLRF   xC0
014E6:  MOVLW  02
014E8:  MOVWF  xC1
014EA:  MOVLW  07
014EC:  MOVWF  xC3
014EE:  MOVLW  AC
014F0:  MOVWF  xC2
014F2:  MOVLB  0
014F4:  RCALL  1338
....................     writeString(0, 3, teststr4); 
014F6:  MOVLB  7
014F8:  CLRF   xC0
014FA:  MOVLW  03
014FC:  MOVWF  xC1
014FE:  MOVLW  07
01500:  MOVWF  xC3
01502:  MOVLW  70
01504:  MOVWF  xC2
01506:  MOVLB  0
01508:  RCALL  1338
....................     delay_ms(2500); 
0150A:  MOVLW  0A
0150C:  MOVLB  7
0150E:  MOVWF  xC0
01510:  MOVLW  FA
01512:  MOVWF  xC1
01514:  MOVLB  0
01516:  RCALL  11F0
01518:  MOVLB  7
0151A:  DECFSZ xC0,F
0151C:  BRA    1510
....................     clearDisplay(); 
0151E:  MOVLB  0
01520:  RCALL  130C
01522:  GOTO   8FC4 (RETURN)
.................... } 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... // Created May 13, 2013 
.................... // This routine returns the determinent for a given 3X3 mastrix passed through the funtion stack as a pointer to address. 
.................... // The Deteminete is returned at the end of the funtion call. 
.................... // This method for solving equations is called Cramer's rule 
.................... //****************************************************************************** 
....................  
.................... float FindTheDetermint(void) { 
....................     float det, part1, part2; //Define the determint as float. 
....................  
....................     part1 = matx[0][0] * matx[1][1] * matx[2][2]; 
....................  
....................     det = (part1 + matx[1][0] * matx[2][1] * matx[0][2] + matx[2][0] * matx[0][1] * matx[1][2]); 
....................     part2 = (matx[0][2] * matx[1][1] * matx[2][0] + matx[1][2] * matx[2][1] * matx[0][0] + matx[2][2] * matx[0][1] * matx[1][0]); 
....................     det = det - (matx[0][2] * matx[1][1] * matx[2][0] + matx[1][2] * matx[2][1] * matx[0][0] + matx[2][2] * matx[0][1] * matx[1][0]); 
....................  
....................     return (det); 
.................... } 
....................  
.................... int16 GetADCValue(int selection) { 
....................     int16 ReturnedADC, Summer; 
....................     int f; 
....................     //setup_adc(ADC_CLOCK_INTERNAL);  //Setup the ADC to run.. 
....................     set_adc_channel(selection); 
*
01C84:  MOVLB  7
01C86:  RLCF   xAF,W
01C88:  MOVWF  00
01C8A:  RLCF   00,F
01C8C:  MOVLW  FC
01C8E:  ANDWF  00,F
01C90:  MOVF   FC2,W
01C92:  ANDLW  83
01C94:  IORWF  00,W
01C96:  MOVWF  FC2
....................     //		delay_ms(10); 
....................     Summer = 0; 
01C98:  CLRF   xB3
01C9A:  CLRF   xB2
....................     for (f = 0; f < 32; f++) { 
01C9C:  CLRF   xB4
01C9E:  MOVF   xB4,W
01CA0:  SUBLW  1F
01CA2:  BNC   1CB6
....................         //delay_us(10); 
....................         Summer = Summer + read_adc(); // Read adc channel 10  
01CA4:  BSF    FC2.1
01CA6:  BTFSC  FC2.1
01CA8:  BRA    1CA6
01CAA:  MOVF   FC3,W
01CAC:  ADDWF  xB2,F
01CAE:  MOVF   FC4,W
01CB0:  ADDWFC xB3,F
01CB2:  INCF   xB4,F
01CB4:  BRA    1C9E
....................     } 
....................     ReturnedADC = Summer >> 5; 
01CB6:  RRCF   xB3,W
01CB8:  MOVWF  xB1
01CBA:  RRCF   xB2,W
01CBC:  MOVWF  xB0
01CBE:  RRCF   xB1,F
01CC0:  RRCF   xB0,F
01CC2:  RRCF   xB1,F
01CC4:  RRCF   xB0,F
01CC6:  RRCF   xB1,F
01CC8:  RRCF   xB0,F
01CCA:  RRCF   xB1,F
01CCC:  RRCF   xB0,F
01CCE:  MOVLW  07
01CD0:  ANDWF  xB1,F
....................     return (ReturnedADC); 
01CD2:  MOVFF  7B0,01
01CD6:  MOVFF  7B1,02
01CDA:  MOVLB  0
01CDC:  GOTO   3A86 (RETURN)
.................... } 
....................  
....................  
....................  
.................... //***************************************************************** 
.................... // Created May 19, 2016 
.................... // This takes a sampling of the pHBulb and averages them all together. 
.................... // The result is the raw data from the ADC.  In this case it is connected to AD7 
.................... // It returns a float 
.................... //**************************************************************** 
....................  
.................... float ConvertADCTophBulb(void) { 
....................     int16 ReturnedADC; 
....................     int x; 
....................     float tempfloater, tempsummer; 
....................     tempsummer = 0.0; 
....................     for (x = 0; x < 10; x++) { 
....................  
....................         ReturnedADC = GetADCValue(0); //This gets the current ADC conversion for the channel number. 
....................  
....................         tempfloater = (float) ReturnedADC; 
....................         tempsummer = tempsummer + tempfloater; 
....................  
....................     } 
....................     tempfloater = tempsummer / 10.0; 
....................     return (tempfloater); 
.................... } 
....................  
.................... //************************************************************* 
.................... // Created May 15, 2015 
.................... // This routine solves for the coefficents for thermisters ai 
.................... // This routine reads the EEPROM (when completed) and calculates the curve and temperature from four thermal points. 
.................... //************************************************************* 
....................  
.................... void DetermineTempCoef(void) { 
....................     //This has been removed and placed in TaosLightSensor.h  May 21, 2015 
....................     //float temp1,reading1,temp2,reading2,temp3,reading3; 
....................     float temp1in, temp2in, temp3in; 
....................     float reading1in, reading2in, reading3in; 
....................     float det, det1, det2, det3; //These are the other dets for each solution 
....................     // This is the raw data.  Added May 15, 2015 
....................  
....................     //temp1 = 40;     
....................     //temp2 = 21; 
....................     //temp3 = 6; 
....................  
....................     //*************************************************************************** 
....................     //Added January 13, 2015 
....................     // These are the values used for the 10K reistor stolen from Animatics 
....................     //*************************************************************************** 
....................     //reading1 = 5140; 
....................     //reading2 = 13037; 
....................     //reading3 = 27594; 
....................     //*************************************************************************** 
....................     //Added January 13, 2015 
....................     // These are the values used for the ?K reistor supplied by Rick 
....................     //*************************************************************************** 
....................  
....................     //reading1 = 12000;   //this one is measured at 45 degrees C   // these numbers are for the 30K reistor 
....................     //reading2 = 40000;   //this is measured at 22 C  Checked on May 14, 2015 
....................     //reading3 = 72000;   // this tempature is measured at 12 degrees C 
....................  
....................  
....................     temp1in = 1.0 / (temp1 + 273.0); 
....................     temp2in = 1.0 / (temp2 + 273.0); 
....................     temp3in = 1.0 / (temp3 + 273.0); 
....................  
....................  
....................     reading1in = log(reading1); 
....................     reading2in = log(reading2); 
....................     reading3in = log(reading3); 
....................  
....................  
....................     //  This part solves for tempa1, tempa2, tempa3 4 
....................     // Find the divistion determinent 
....................  
....................     matx[0][0] = 1.0; 
....................     matx[1][0] = 1.0; 
....................     matx[2][0] = 1.0; 
....................     matx[0][1] = reading1in; 
....................     matx[1][1] = reading2in; 
....................     matx[2][1] = reading3in; 
....................     matx[0][2] = reading1in*reading1in; 
....................     matx[1][2] = reading2in*reading2in; 
....................     matx[2][2] = reading3in*reading3in; 
....................  
....................     det = FindTheDetermint(); 
....................  
....................     //Find the det for tempa1 
....................  
....................     matx[0][0] = temp1in; 
....................     matx[1][0] = temp2in; 
....................     matx[2][0] = temp3in; 
....................     matx[0][1] = reading1in; 
....................     matx[1][1] = reading2in; 
....................     matx[2][1] = reading3in; 
....................     matx[0][2] = reading1in*reading1in; 
....................     matx[1][2] = reading2in*reading2in; 
....................     matx[2][2] = reading3in*reading3in; 
....................  
....................     det1 = FindTheDetermint(); 
....................     tempa1 = det1 / det; //  This finds the value for the first a1 
....................  
....................     matx[0][0] = 1.0; 
....................     matx[1][0] = 1.0; 
....................     matx[2][0] = 1.0; 
....................     matx[0][1] = temp1in; 
....................     matx[1][1] = temp2in; 
....................     matx[2][1] = temp3in; 
....................     matx[0][2] = reading1in*reading1in; 
....................     matx[1][2] = reading2in*reading2in; 
....................     matx[2][2] = reading3in*reading3in; 
....................  
....................  
....................     det2 = FindTheDetermint(); 
....................     tempa2 = det2 / det; //  This finds the value for the first a2 
....................  
....................  
....................  
....................     matx[0][0] = 1.0; 
....................     matx[1][0] = 1.0; 
....................     matx[2][0] = 1.0; 
....................     matx[0][1] = reading1in; 
....................     matx[1][1] = reading2in; 
....................     matx[2][1] = reading3in; 
....................     matx[0][2] = temp1in; 
....................     matx[1][2] = temp2in; 
....................     matx[2][2] = temp3in; 
....................  
....................     det3 = FindTheDetermint(); 
....................     tempa3 = det3 / det; //  This finds the value for the first a2 
....................  
....................  
.................... } 
....................  
....................  
.................... //***************************************************************** 
.................... // Created Nov. 6, 2012 
.................... // Converts the ADC number on a scale of 5 volts minus some for Op-amp issues 
.................... // The numerical convertion is conveted into degrees C. 
.................... // The returned value in C degrees. 
.................... //  Ths interm convertion is to Kalvin and will later be switched over to Kalvin scale. 
.................... //***************************************************************** 
....................  
.................... float ConvertADCToKalvin(int ADCInputNumber) { 
....................     int16 ReturnedADC; 
....................     float32 ADCVoltageIn, Kelvin, tempfloater; 
....................     ReturnedADC = GetADCValue(ADCInputNumber); //This gets the current ADC convertion for the channel number. 
....................     //    ADCVoltageIn = ReturnedADC * 5.0 / 1024.0;  //Recycled the same float variable.  This is for the 5 volts version. 
....................     tempfloater = (float) ReturnedADC; 
....................     // ADCVoltageIn = (float) ReturnedADC * 3.3 / 1024.0;  //Recycled the same float variable.  This converts the input into scaling 
....................     ADCVoltageIn = (float) ReturnedADC * 5.0 / 1024.0; //Recycled the same float variable.  This converts the input into scaling 
....................  
....................     //Added May 18, 2015  - The current/last thermister is RL0503-7.56K-96-MS  it's a 30K thermister. 
....................  
....................     //	ADCVoltageIn = 5100.0*ADCVoltageIn/(3.3 - ADCVoltageIn);  // Calulate the thermister reistance over a voltage divider.  It's at the bottom of a 0 to 5 volts divider.  The resistance is 4.999K 
....................  
....................     //ADCVoltageIn = 4999.0*ADCVoltageIn/(3.3 - ADCVoltageIn);  // Calculate the thermister reistance over a voltage divider.  It's at the bottom of a 0 to 5 volts divider.  The resistance is 4.999K 
....................     ADCVoltageIn = 5100.0 * ADCVoltageIn / (5.0 - ADCVoltageIn); // Calculate the thermister reistance over a voltage divider.  It's at the bottom of a 0 to 5 volts divider.  The resistance is 4.999K 
....................  
....................  
....................  
....................     DetermineTempCoef(); 
....................  
....................     //Kelvin = (1/(tempa1 + tempa2*(log(ADCVoltageIn)) + tempa3*(log(ADCVoltageIn)*log(ADCVoltageIn))))-273.15;   //This is the old line of code used to find the thermister temperature 
....................     Kelvin = (1 / (tempa1 + tempa2 * (log(ADCVoltageIn)) + tempa3 * (log(ADCVoltageIn) * log(ADCVoltageIn)))) - 273.15; 
....................     return (Kelvin); 
.................... } 
....................  
....................  
....................  
.................... //********************************************************************* 
.................... // Created June 25, 2015 
.................... // This routine calls the water temperature program and averages together twenty points.  Twenty two points are 
.................... // collected and the high and low reading is thrown out.   
.................... // There is no input needed in this routine.  The result is returned as a float. 
.................... //********************************************************************* 
....................  
.................... float WaterTemperature(void) { 
....................     float temparray[42], tempval; 
....................  
....................     int switchflag, x; //This is used in the ordering routine to indicate if two numbers have been switched.  If not, then the array is in numerical order. 
....................  
....................     for (x = 0; x < 42; x++) // Get all of the readings and save them in an array. 
....................     { 
....................         temparray[x] = ConvertADCToKalvin(1); //This called current thermisting reading routine. It returns a temperature reading in C. 
....................     } 
....................  
....................     //  Place the numbers in order in the array from the lowest reading at the high numbers indexs and the hightest readings at the low indexes. 
....................  
....................     do { 
....................         switchflag = 0; //Set it to zero indicating everything is in order. 
....................         for (x = 0; x < 41; x++) { 
....................             if (temparray[x] < temparray[x + 1]) { 
....................                 tempval = temparray[x]; 
....................                 temparray[x] = temparray[x + 1]; 
....................                 temparray[x + 1] = tempval; 
....................                 // Since this case is true, then switch the numbers in the array and set the not completed flag to 1. 
....................                 switchflag = 1; //  Indicate are reversal needed to be done. 
....................             } 
....................         } 
....................     } while (switchflag == 1); //If the value is zero, the array is in order. 
....................  
....................  
....................     //  Average the numbers between 1 and 21.  This will kick out the hightest and lowest readings. 
....................     tempval = 0; //recycled the varaible used for averaging the readings together. 
....................     for (x = 1; x < 41; x++) { 
....................         tempval = tempval + temparray[x]; 
....................     } 
....................     tempval = tempval / 40.0; //Divide the added number by 20 which is the number of values added together. 
....................  
....................  
....................     return (tempval); 
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created October 17, 2016 
.................... // This is a check sum for the data sent through the I2C back to the master.  The numbers are split and put into the 
.................... // last two locations of the upload send_buffer[]. 
.................... //  Returns a 0 if there is no problem, It returns a 1 if there is a problem 
.................... //****************************************************************************** 
....................  
.................... int CalculateCRC(void) { 
....................     unsigned int16 checksum; 
....................     unsigned int8 checksumhigh, checksumlow, x; 
....................     for (x = 0; x < 98; x++) { 
....................         checksum = checksum + rec_buffer[x]; 
....................     } 
....................     //seperate the numbers into high and low 
....................     checksumlow = 0x00FF & checksum; 
....................     //  place the numbers in the array 
....................     checksumhigh = (0xFF00 & checksum) >> 8; 
....................     if ((checksumlow == rec_buffer[98]) && (checksumlow == rec_buffer[99])) { 
....................         return (0); // no problem and the checksum matches 
....................     } else { 
....................         return (1); // someplace has an error and the checksum does not match. 
....................     } 
.................... } 
....................  
....................  
....................  
.................... #INT_RDA 
....................  
.................... void RDA_isr() { 
....................     int8 tbt; 
....................  
....................     BTbuffer[BTnext_in] = fgetc(BT); 
*
00FB2:  MOVLW  26
00FB4:  MOVLB  6
00FB6:  ADDWF  x22,W
00FB8:  MOVWF  FE9
00FBA:  MOVLW  06
00FBC:  ADDWFC x23,W
00FBE:  MOVWF  FEA
00FC0:  BTFSS  F9E.5
00FC2:  BRA    0FC0
00FC4:  MOVFF  FAE,FEF
....................     tbt = BTnext_in; 
00FC8:  MOVFF  622,7F3
....................     // putc(tbt,BT); 
....................     //writeChar(tbt); 
....................     BTnext_in = (BTnext_in + 1) % sizeof (BTbuffer); 
00FCC:  MOVLW  01
00FCE:  ADDWF  x22,W
00FD0:  MOVLB  7
00FD2:  MOVWF  xF4
00FD4:  MOVLW  00
00FD6:  MOVLB  6
00FD8:  ADDWFC x23,W
00FDA:  MOVLB  7
00FDC:  MOVF   xF4,W
00FDE:  ANDLW  3F
00FE0:  MOVLB  6
00FE2:  MOVWF  x22
00FE4:  CLRF   x23
....................     if (BTnext_in == BTnext_out) { 
00FE6:  MOVF   x24,W
00FE8:  SUBWF  x22,W
00FEA:  BNZ   0FF8
00FEC:  MOVF   x25,W
00FEE:  SUBWF  x23,W
00FF0:  BNZ   0FF8
....................         BTnext_in = tbt; // Buffer full !! 
00FF2:  CLRF   x23
00FF4:  MOVFF  7F3,622
....................     } 
....................     //ADDED Crap 
....................     if (BTnext_in == BT_BUFF_SIZE) { 
00FF8:  MOVF   x22,W
00FFA:  SUBLW  40
00FFC:  BNZ   1006
00FFE:  MOVF   x23,F
01000:  BNZ   1006
....................         BTnext_in = 0; 
01002:  CLRF   x23
01004:  CLRF   x22
....................     } 
....................     //ADDED Crap 
....................     if (BTnext_out == BT_BUFF_SIZE) { 
01006:  MOVF   x24,W
01008:  SUBLW  40
0100A:  BNZ   1014
0100C:  MOVF   x25,F
0100E:  BNZ   1014
....................         BTnext_out = 0; 
01010:  CLRF   x25
01012:  CLRF   x24
....................     } 
....................  
01014:  BCF    F9E.5
01016:  MOVLB  0
01018:  GOTO   0060
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Febuary 12, 2017 
.................... // Get the version of the device.  This is used for checking if the device is plugged into the unit 
.................... // Command 0x40   It has been changed from 0x66 because of memory buffer size 
.................... // The correct returned value is 0xA9 
.................... int GetAnalogDONHFourVersion(int lightsensor) 
.................... 	{ 
.................... int version,returned,x; 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
*
038B4:  MOVFF  7AF,7B4
038B8:  RCALL  35F6
....................  
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
.................... 	i2c_start(PH_LIGHT); 
038BA:  BSF    F93.0
038BC:  MOVLW  50
038BE:  MOVWF  00
038C0:  DECFSZ 00,F
038C2:  BRA    38C0
038C4:  BSF    F93.1
038C6:  MOVLW  51
038C8:  MOVWF  00
038CA:  DECFSZ 00,F
038CC:  BRA    38CA
038CE:  BCF    F8A.0
038D0:  BCF    F93.0
038D2:  MOVLW  50
038D4:  MOVWF  00
038D6:  DECFSZ 00,F
038D8:  BRA    38D6
038DA:  BCF    F8A.1
038DC:  BCF    F93.1
....................  //       delay_ms(10); 
....................     returned=i2c_write(PH_LIGHT,0xa0);  //Move the address number left on and add a zero. 
038DE:  MOVLW  A0
038E0:  MOVLB  7
038E2:  MOVWF  xB4
038E4:  MOVLB  0
038E6:  RCALL  363A
038E8:  MOVFF  01,7B1
....................     if (returned == 0x01) 
038EC:  MOVLB  7
038EE:  DECFSZ xB1,W
038F0:  BRA    3918
....................     { 
....................     i2c_stop(PH_LIGHT);   // perhaps a delay here 
038F2:  BCF    F93.0
038F4:  NOP   
038F6:  BSF    F93.1
038F8:  BTFSS  F81.1
038FA:  BRA    38F8
038FC:  MOVLW  50
038FE:  MOVWF  00
03900:  DECFSZ 00,F
03902:  BRA    3900
03904:  BRA    3906
03906:  NOP   
03908:  BSF    F93.0
0390A:  MOVLW  50
0390C:  MOVWF  00
0390E:  DECFSZ 00,F
03910:  BRA    390E
....................     return(0x1A); 
03912:  MOVLW  1A
03914:  MOVWF  01
03916:  BRA    3A3C
....................     }  
....................  //   delay_ms(10); 
....................     returned=i2c_write(PH_LIGHT,0x40);  //Send the command for reading the version 
03918:  MOVLW  40
0391A:  MOVWF  xB4
0391C:  MOVLB  0
0391E:  RCALL  363A
03920:  MOVFF  01,7B1
.................... if (returned == 0x01) 
03924:  MOVLB  7
03926:  DECFSZ xB1,W
03928:  BRA    3950
....................     { 
....................     i2c_stop(PH_LIGHT);   // perhaps a delay here 
0392A:  BCF    F93.0
0392C:  NOP   
0392E:  BSF    F93.1
03930:  BTFSS  F81.1
03932:  BRA    3930
03934:  MOVLW  50
03936:  MOVWF  00
03938:  DECFSZ 00,F
0393A:  BRA    3938
0393C:  BRA    393E
0393E:  NOP   
03940:  BSF    F93.0
03942:  MOVLW  50
03944:  MOVWF  00
03946:  DECFSZ 00,F
03948:  BRA    3946
....................     return(0x1B); 
0394A:  MOVLW  1B
0394C:  MOVWF  01
0394E:  BRA    3A3C
....................     }  
....................    
....................  
.................... returned=i2c_write(PH_LIGHT,0x01);  //Set the register to one to ask for the version number. 
03950:  MOVLW  01
03952:  MOVWF  xB4
03954:  MOVLB  0
03956:  RCALL  363A
03958:  MOVFF  01,7B1
.................... if (returned == 0x01)  
0395C:  MOVLB  7
0395E:  DECFSZ xB1,W
03960:  BRA    3988
....................     { 
....................     i2c_stop(PH_LIGHT);   // perhaps a delay here 
03962:  BCF    F93.0
03964:  NOP   
03966:  BSF    F93.1
03968:  BTFSS  F81.1
0396A:  BRA    3968
0396C:  MOVLW  50
0396E:  MOVWF  00
03970:  DECFSZ 00,F
03972:  BRA    3970
03974:  BRA    3976
03976:  NOP   
03978:  BSF    F93.0
0397A:  MOVLW  50
0397C:  MOVWF  00
0397E:  DECFSZ 00,F
03980:  BRA    397E
....................     return(0x1C); 
03982:  MOVLW  1C
03984:  MOVWF  01
03986:  BRA    3A3C
....................     } 
.................... //delay_ms(15); 
.................... 	i2c_stop(PH_LIGHT);   // perhaps a delay here 
03988:  BCF    F93.0
0398A:  NOP   
0398C:  BSF    F93.1
0398E:  BTFSS  F81.1
03990:  BRA    398E
03992:  MOVLW  50
03994:  MOVWF  00
03996:  DECFSZ 00,F
03998:  BRA    3996
0399A:  BRA    399C
0399C:  NOP   
0399E:  BSF    F93.0
039A0:  MOVLW  50
039A2:  MOVWF  00
039A4:  DECFSZ 00,F
039A6:  BRA    39A4
....................  
....................     i2c_start(PH_LIGHT); 
039A8:  BSF    F93.0
039AA:  MOVLW  50
039AC:  MOVWF  00
039AE:  DECFSZ 00,F
039B0:  BRA    39AE
039B2:  BSF    F93.1
039B4:  MOVLW  51
039B6:  MOVWF  00
039B8:  DECFSZ 00,F
039BA:  BRA    39B8
039BC:  BCF    F8A.0
039BE:  BCF    F93.0
039C0:  MOVLW  50
039C2:  MOVWF  00
039C4:  DECFSZ 00,F
039C6:  BRA    39C4
039C8:  BCF    F8A.1
039CA:  BCF    F93.1
....................  
....................  
.................... returned=i2c_write(PH_LIGHT,0xa1);  //Move the address number left on and add a one to make is a read command. 
039CC:  MOVLW  A1
039CE:  MOVWF  xB4
039D0:  MOVLB  0
039D2:  RCALL  363A
039D4:  MOVFF  01,7B1
.................... if (returned == 0x01)  
039D8:  MOVLB  7
039DA:  DECFSZ xB1,W
039DC:  BRA    3A04
....................     { 
....................     i2c_stop(PH_LIGHT);   // perhaps a delay here 
039DE:  BCF    F93.0
039E0:  NOP   
039E2:  BSF    F93.1
039E4:  BTFSS  F81.1
039E6:  BRA    39E4
039E8:  MOVLW  50
039EA:  MOVWF  00
039EC:  DECFSZ 00,F
039EE:  BRA    39EC
039F0:  BRA    39F2
039F2:  NOP   
039F4:  BSF    F93.0
039F6:  MOVLW  50
039F8:  MOVWF  00
039FA:  DECFSZ 00,F
039FC:  BRA    39FA
....................     return(0x1D); 
039FE:  MOVLW  1D
03A00:  MOVWF  01
03A02:  BRA    3A3C
....................     } 
....................   
....................     delay_ms(75); 
03A04:  MOVLW  4B
03A06:  MOVWF  xC1
03A08:  MOVLB  0
03A0A:  CALL   11F0
.................... 	version = i2c_read(PH_LIGHT,FALSE); 
03A0E:  CLRF   00
03A10:  RCALL  36B0
03A12:  MOVFF  01,7B0
....................   
.................... i2c_stop(PH_LIGHT);   // perhaps a delay here 
03A16:  BCF    F93.0
03A18:  NOP   
03A1A:  BSF    F93.1
03A1C:  BTFSS  F81.1
03A1E:  BRA    3A1C
03A20:  MOVLW  50
03A22:  MOVWF  00
03A24:  DECFSZ 00,F
03A26:  BRA    3A24
03A28:  BRA    3A2A
03A2A:  NOP   
03A2C:  BSF    F93.0
03A2E:  MOVLW  50
03A30:  MOVWF  00
03A32:  DECFSZ 00,F
03A34:  BRA    3A32
.................... //return(0x88); 
.................... 	return(version); 
03A36:  MOVLB  7
03A38:  MOVFF  7B0,01
03A3C:  MOVLB  0
03A3E:  RETURN 0
.................... 	} 
....................  
....................  
....................  
.................... //******************************************************************** 
.................... // Created March 19, 2013 
.................... // Added to this routine Jan 24, 2017 
.................... // Get the version of the device.  This  routine is used for testing I2C. 
.................... // Command 0x04 
.................... // This routine returns the version of the light chip.  
.................... //********************************************************************* 
.................... int getTAOSVersion(int lightsensor) 
.................... 	{ 
.................... int version; 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
*
037F6:  MOVFF  7AF,7B4
037FA:  RCALL  35F6
....................  
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
....................  
.................... 	i2c_start(PH_LIGHT); 
037FC:  BSF    F93.0
037FE:  MOVLW  50
03800:  MOVWF  00
03802:  DECFSZ 00,F
03804:  BRA    3802
03806:  BSF    F93.1
03808:  MOVLW  51
0380A:  MOVWF  00
0380C:  DECFSZ 00,F
0380E:  BRA    380C
03810:  BCF    F8A.0
03812:  BCF    F93.0
03814:  MOVLW  50
03816:  MOVWF  00
03818:  DECFSZ 00,F
0381A:  BRA    3818
0381C:  BCF    F8A.1
0381E:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
03820:  MOVLW  72
03822:  MOVLB  7
03824:  MOVWF  xB4
03826:  MOVLB  0
03828:  RCALL  363A
.................... 	i2c_write(PH_LIGHT,0x84);  //Send the command for reading the version 
0382A:  MOVLW  84
0382C:  MOVLB  7
0382E:  MOVWF  xB4
03830:  MOVLB  0
03832:  RCALL  363A
.................... 	i2c_stop(PH_LIGHT); 
03834:  BCF    F93.0
03836:  NOP   
03838:  BSF    F93.1
0383A:  BTFSS  F81.1
0383C:  BRA    383A
0383E:  MOVLW  50
03840:  MOVWF  00
03842:  DECFSZ 00,F
03844:  BRA    3842
03846:  BRA    3848
03848:  NOP   
0384A:  BSF    F93.0
0384C:  MOVLW  50
0384E:  MOVWF  00
03850:  DECFSZ 00,F
03852:  BRA    3850
....................     i2c_start(PH_LIGHT,0); 
03854:  BSF    F93.0
03856:  MOVLW  50
03858:  MOVWF  00
0385A:  DECFSZ 00,F
0385C:  BRA    385A
0385E:  BSF    F93.1
03860:  MOVLW  51
03862:  MOVWF  00
03864:  DECFSZ 00,F
03866:  BRA    3864
03868:  BCF    F8A.0
0386A:  BCF    F93.0
0386C:  MOVLW  50
0386E:  MOVWF  00
03870:  DECFSZ 00,F
03872:  BRA    3870
03874:  BCF    F8A.1
03876:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
03878:  MOVLW  73
0387A:  MOVLB  7
0387C:  MOVWF  xB4
0387E:  MOVLB  0
03880:  RCALL  363A
.................... 	version = i2c_read(PH_LIGHT,0); 
03882:  CLRF   00
03884:  RCALL  36B0
03886:  MOVFF  01,7B0
.................... 	i2c_stop(PH_LIGHT); 
0388A:  BCF    F93.0
0388C:  NOP   
0388E:  BSF    F93.1
03890:  BTFSS  F81.1
03892:  BRA    3890
03894:  MOVLW  50
03896:  MOVWF  00
03898:  DECFSZ 00,F
0389A:  BRA    3898
0389C:  BRA    389E
0389E:  NOP   
038A0:  BSF    F93.0
038A2:  MOVLW  50
038A4:  MOVWF  00
038A6:  DECFSZ 00,F
038A8:  BRA    38A6
....................  
.................... 	return(version); 
038AA:  MOVLB  7
038AC:  MOVFF  7B0,01
038B0:  MOVLB  0
038B2:  RETURN 0
.................... 	} 
....................  
....................  
.................... //********************************************************************** 
.................... // Created March 19, 2013 
.................... // Power up light chip 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the room 
.................... //  Updated December 8, 2015 
.................... //  StartupATOS is used for all six sensors.  The number of the sensor needs to be provided. 
.................... //********************************************************************** 
.................... void StartUpTAOS(int lightsensor) 
.................... 	{ 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
*
0469C:  MOVFF  791,7B4
046A0:  CALL   35F6
....................  
.................... // then send the command down to the sensor.  All of the communication is done through the I2C on PH_LIGHT. 
....................  
.................... 	i2c_start(PH_LIGHT); 
046A4:  BSF    F93.0
046A6:  MOVLW  50
046A8:  MOVWF  00
046AA:  DECFSZ 00,F
046AC:  BRA    46AA
046AE:  BSF    F93.1
046B0:  MOVLW  51
046B2:  MOVWF  00
046B4:  DECFSZ 00,F
046B6:  BRA    46B4
046B8:  BCF    F8A.0
046BA:  BCF    F93.0
046BC:  MOVLW  50
046BE:  MOVWF  00
046C0:  DECFSZ 00,F
046C2:  BRA    46C0
046C4:  BCF    F8A.1
046C6:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
046C8:  MOVLW  72
046CA:  MOVLB  7
046CC:  MOVWF  xB4
046CE:  MOVLB  0
046D0:  CALL   363A
.................... 	i2c_write(PH_LIGHT,0x80);  //Send the command for reading the version 
046D4:  MOVLW  80
046D6:  MOVLB  7
046D8:  MOVWF  xB4
046DA:  MOVLB  0
046DC:  CALL   363A
.................... 	i2c_write(PH_LIGHT,0x03);  //Send the command for reading the version 
046E0:  MOVLW  03
046E2:  MOVLB  7
046E4:  MOVWF  xB4
046E6:  MOVLB  0
046E8:  CALL   363A
.................... 	i2c_stop(PH_LIGHT); 
046EC:  BCF    F93.0
046EE:  NOP   
046F0:  BSF    F93.1
046F2:  BTFSS  F81.1
046F4:  BRA    46F2
046F6:  MOVLW  50
046F8:  MOVWF  00
046FA:  DECFSZ 00,F
046FC:  BRA    46FA
046FE:  BRA    4700
04700:  NOP   
04702:  BSF    F93.0
04704:  MOVLW  50
04706:  MOVWF  00
04708:  DECFSZ 00,F
0470A:  BRA    4708
0470C:  GOTO   4D68 (RETURN)
.................... 	 
....................  
.................... 	} 
....................  
....................  
.................... //*********************************************************************** 
.................... // Created March 20, 2013 
.................... // This routine changes the exposure time for each sample. 
.................... //  There are three modes of intigration or exposure time per sample. 
.................... // 0 for 12ms 
.................... // 1 for 100 ms 
.................... // 2 for 400 ms 
.................... //*********************************************************************** 
.................... void ExposureTimeTAOS(byte integration, byte lightsensor) 
.................... 	{ 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
*
0462C:  MOVFF  792,7B4
04630:  CALL   35F6
....................  
.................... // then send the command down to the sensor.  All of the communication is done through the I2C on PH_LIGHT. 
....................  
....................  
.................... 	i2c_start(PH_LIGHT); 
04634:  BSF    F93.0
04636:  MOVLW  50
04638:  MOVWF  00
0463A:  DECFSZ 00,F
0463C:  BRA    463A
0463E:  BSF    F93.1
04640:  MOVLW  51
04642:  MOVWF  00
04644:  DECFSZ 00,F
04646:  BRA    4644
04648:  BCF    F8A.0
0464A:  BCF    F93.0
0464C:  MOVLW  50
0464E:  MOVWF  00
04650:  DECFSZ 00,F
04652:  BRA    4650
04654:  BCF    F8A.1
04656:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04658:  MOVLW  72
0465A:  MOVLB  7
0465C:  MOVWF  xB4
0465E:  MOVLB  0
04660:  CALL   363A
.................... 	i2c_write(PH_LIGHT,0x81);  //Send the command for reading the Timing Register 
04664:  MOVLW  81
04666:  MOVLB  7
04668:  MOVWF  xB4
0466A:  MOVLB  0
0466C:  CALL   363A
.................... 	i2c_write(PH_LIGHT,integration);  //Send the command for reading the version 
04670:  MOVFF  791,7B4
04674:  CALL   363A
.................... 	i2c_stop(PH_LIGHT); 
04678:  BCF    F93.0
0467A:  NOP   
0467C:  BSF    F93.1
0467E:  BTFSS  F81.1
04680:  BRA    467E
04682:  MOVLW  50
04684:  MOVWF  00
04686:  DECFSZ 00,F
04688:  BRA    4686
0468A:  BRA    468C
0468C:  NOP   
0468E:  BSF    F93.0
04690:  MOVLW  50
04692:  MOVWF  00
04694:  DECFSZ 00,F
04696:  BRA    4694
04698:  GOTO   4D5E (RETURN)
....................  
.................... 	}  
....................  
....................  
....................  
.................... //****************************************************************** 
.................... //Created March 17, 2013 
.................... // This routine reads the all four inputs and returns the 16 bit value for that color. 
.................... // The value for color is as follows: 
.................... // 1:red 
.................... // 2:greem 
.................... // 3:blue 
.................... // 4:clear 
.................... // The retuened value is measured value. 
.................... //  This measurement is influnenced by the scalling factor for each ADC. 
.................... //  The two numbers are returned through tow global varibles. 
.................... //  The variables are colorlow and colorhigh. 
.................... // Added Oct 20, 2014 - Multi I2C lines can be used for each light sensor 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the room 
.................... //****************************************************************** 
.................... void ReadColorTAOS(int selectedcolor, int lightsensor) 
.................... 	{ 
....................  
.................... 	switch(selectedcolor) 
*
04710:  MOVLB  7
04712:  MOVF   x91,W
04714:  XORLW  02
04716:  MOVLB  0
04718:  BZ    472E
0471A:  XORLW  03
0471C:  BTFSC  FD8.2
0471E:  BRA    489C
04720:  XORLW  02
04722:  BTFSC  FD8.2
04724:  BRA    4A0A
04726:  XORLW  07
04728:  BTFSC  FD8.2
0472A:  BRA    4B78
0472C:  BRA    4CE6
.................... 		{ 
.................... 		case 2:   //green 
.................... 			i2c_start(PH_LIGHT); 
0472E:  BSF    F93.0
04730:  MOVLW  50
04732:  MOVWF  00
04734:  DECFSZ 00,F
04736:  BRA    4734
04738:  BSF    F93.1
0473A:  MOVLW  51
0473C:  MOVWF  00
0473E:  DECFSZ 00,F
04740:  BRA    473E
04742:  BCF    F8A.0
04744:  BCF    F93.0
04746:  MOVLW  50
04748:  MOVWF  00
0474A:  DECFSZ 00,F
0474C:  BRA    474A
0474E:  BCF    F8A.1
04750:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04752:  MOVLW  72
04754:  MOVLB  7
04756:  MOVWF  xB4
04758:  MOVLB  0
0475A:  CALL   363A
.................... 			i2c_write(PH_LIGHT,0x90);  //Send the command for reading the version 
0475E:  MOVLW  90
04760:  MOVLB  7
04762:  MOVWF  xB4
04764:  MOVLB  0
04766:  CALL   363A
.................... 			i2c_stop(PH_LIGHT); 
0476A:  BCF    F93.0
0476C:  NOP   
0476E:  BSF    F93.1
04770:  BTFSS  F81.1
04772:  BRA    4770
04774:  MOVLW  50
04776:  MOVWF  00
04778:  DECFSZ 00,F
0477A:  BRA    4778
0477C:  BRA    477E
0477E:  NOP   
04780:  BSF    F93.0
04782:  MOVLW  50
04784:  MOVWF  00
04786:  DECFSZ 00,F
04788:  BRA    4786
....................  
....................     		i2c_start(PH_LIGHT); 
0478A:  BSF    F93.0
0478C:  MOVLW  50
0478E:  MOVWF  00
04790:  DECFSZ 00,F
04792:  BRA    4790
04794:  BSF    F93.1
04796:  MOVLW  51
04798:  MOVWF  00
0479A:  DECFSZ 00,F
0479C:  BRA    479A
0479E:  BCF    F8A.0
047A0:  BCF    F93.0
047A2:  MOVLW  50
047A4:  MOVWF  00
047A6:  DECFSZ 00,F
047A8:  BRA    47A6
047AA:  BCF    F8A.1
047AC:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
047AE:  MOVLW  73
047B0:  MOVLB  7
047B2:  MOVWF  xB4
047B4:  MOVLB  0
047B6:  CALL   363A
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
047BA:  CLRF   00
047BC:  CALL   36B0
047C0:  MOVFF  01,727
.................... 			i2c_stop(PH_LIGHT); 
047C4:  BCF    F93.0
047C6:  NOP   
047C8:  BSF    F93.1
047CA:  BTFSS  F81.1
047CC:  BRA    47CA
047CE:  MOVLW  50
047D0:  MOVWF  00
047D2:  DECFSZ 00,F
047D4:  BRA    47D2
047D6:  BRA    47D8
047D8:  NOP   
047DA:  BSF    F93.0
047DC:  MOVLW  50
047DE:  MOVWF  00
047E0:  DECFSZ 00,F
047E2:  BRA    47E0
....................  
.................... 			i2c_start(PH_LIGHT); 
047E4:  BSF    F93.0
047E6:  MOVLW  50
047E8:  MOVWF  00
047EA:  DECFSZ 00,F
047EC:  BRA    47EA
047EE:  BSF    F93.1
047F0:  MOVLW  51
047F2:  MOVWF  00
047F4:  DECFSZ 00,F
047F6:  BRA    47F4
047F8:  BCF    F8A.0
047FA:  BCF    F93.0
047FC:  MOVLW  50
047FE:  MOVWF  00
04800:  DECFSZ 00,F
04802:  BRA    4800
04804:  BCF    F8A.1
04806:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04808:  MOVLW  72
0480A:  MOVLB  7
0480C:  MOVWF  xB4
0480E:  MOVLB  0
04810:  CALL   363A
.................... 			i2c_write(PH_LIGHT,0x91);  //Send the command for reading the version 
04814:  MOVLW  91
04816:  MOVLB  7
04818:  MOVWF  xB4
0481A:  MOVLB  0
0481C:  CALL   363A
.................... 			i2c_stop(PH_LIGHT); 
04820:  BCF    F93.0
04822:  NOP   
04824:  BSF    F93.1
04826:  BTFSS  F81.1
04828:  BRA    4826
0482A:  MOVLW  50
0482C:  MOVWF  00
0482E:  DECFSZ 00,F
04830:  BRA    482E
04832:  BRA    4834
04834:  NOP   
04836:  BSF    F93.0
04838:  MOVLW  50
0483A:  MOVWF  00
0483C:  DECFSZ 00,F
0483E:  BRA    483C
....................  
....................     		i2c_start(PH_LIGHT); 
04840:  BSF    F93.0
04842:  MOVLW  50
04844:  MOVWF  00
04846:  DECFSZ 00,F
04848:  BRA    4846
0484A:  BSF    F93.1
0484C:  MOVLW  51
0484E:  MOVWF  00
04850:  DECFSZ 00,F
04852:  BRA    4850
04854:  BCF    F8A.0
04856:  BCF    F93.0
04858:  MOVLW  50
0485A:  MOVWF  00
0485C:  DECFSZ 00,F
0485E:  BRA    485C
04860:  BCF    F8A.1
04862:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
04864:  MOVLW  73
04866:  MOVLB  7
04868:  MOVWF  xB4
0486A:  MOVLB  0
0486C:  CALL   363A
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
04870:  CLRF   00
04872:  CALL   36B0
04876:  MOVFF  01,728
.................... 			i2c_stop(PH_LIGHT); 
0487A:  BCF    F93.0
0487C:  NOP   
0487E:  BSF    F93.1
04880:  BTFSS  F81.1
04882:  BRA    4880
04884:  MOVLW  50
04886:  MOVWF  00
04888:  DECFSZ 00,F
0488A:  BRA    4888
0488C:  BRA    488E
0488E:  NOP   
04890:  BSF    F93.0
04892:  MOVLW  50
04894:  MOVWF  00
04896:  DECFSZ 00,F
04898:  BRA    4896
.................... 			break; 
0489A:  BRA    4CE6
....................  
....................  
.................... 		case 1:   //red 
.................... 			i2c_start(PH_LIGHT); 
0489C:  BSF    F93.0
0489E:  MOVLW  50
048A0:  MOVWF  00
048A2:  DECFSZ 00,F
048A4:  BRA    48A2
048A6:  BSF    F93.1
048A8:  MOVLW  51
048AA:  MOVWF  00
048AC:  DECFSZ 00,F
048AE:  BRA    48AC
048B0:  BCF    F8A.0
048B2:  BCF    F93.0
048B4:  MOVLW  50
048B6:  MOVWF  00
048B8:  DECFSZ 00,F
048BA:  BRA    48B8
048BC:  BCF    F8A.1
048BE:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
048C0:  MOVLW  72
048C2:  MOVLB  7
048C4:  MOVWF  xB4
048C6:  MOVLB  0
048C8:  CALL   363A
.................... 			i2c_write(PH_LIGHT,0x92);  //Send the command for reading the version 
048CC:  MOVLW  92
048CE:  MOVLB  7
048D0:  MOVWF  xB4
048D2:  MOVLB  0
048D4:  CALL   363A
.................... 			i2c_stop(PH_LIGHT); 
048D8:  BCF    F93.0
048DA:  NOP   
048DC:  BSF    F93.1
048DE:  BTFSS  F81.1
048E0:  BRA    48DE
048E2:  MOVLW  50
048E4:  MOVWF  00
048E6:  DECFSZ 00,F
048E8:  BRA    48E6
048EA:  BRA    48EC
048EC:  NOP   
048EE:  BSF    F93.0
048F0:  MOVLW  50
048F2:  MOVWF  00
048F4:  DECFSZ 00,F
048F6:  BRA    48F4
....................  
....................     		i2c_start(PH_LIGHT); 
048F8:  BSF    F93.0
048FA:  MOVLW  50
048FC:  MOVWF  00
048FE:  DECFSZ 00,F
04900:  BRA    48FE
04902:  BSF    F93.1
04904:  MOVLW  51
04906:  MOVWF  00
04908:  DECFSZ 00,F
0490A:  BRA    4908
0490C:  BCF    F8A.0
0490E:  BCF    F93.0
04910:  MOVLW  50
04912:  MOVWF  00
04914:  DECFSZ 00,F
04916:  BRA    4914
04918:  BCF    F8A.1
0491A:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
0491C:  MOVLW  73
0491E:  MOVLB  7
04920:  MOVWF  xB4
04922:  MOVLB  0
04924:  CALL   363A
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
04928:  CLRF   00
0492A:  CALL   36B0
0492E:  MOVFF  01,727
.................... 			i2c_stop(PH_LIGHT); 
04932:  BCF    F93.0
04934:  NOP   
04936:  BSF    F93.1
04938:  BTFSS  F81.1
0493A:  BRA    4938
0493C:  MOVLW  50
0493E:  MOVWF  00
04940:  DECFSZ 00,F
04942:  BRA    4940
04944:  BRA    4946
04946:  NOP   
04948:  BSF    F93.0
0494A:  MOVLW  50
0494C:  MOVWF  00
0494E:  DECFSZ 00,F
04950:  BRA    494E
....................  
.................... 			i2c_start(PH_LIGHT); 
04952:  BSF    F93.0
04954:  MOVLW  50
04956:  MOVWF  00
04958:  DECFSZ 00,F
0495A:  BRA    4958
0495C:  BSF    F93.1
0495E:  MOVLW  51
04960:  MOVWF  00
04962:  DECFSZ 00,F
04964:  BRA    4962
04966:  BCF    F8A.0
04968:  BCF    F93.0
0496A:  MOVLW  50
0496C:  MOVWF  00
0496E:  DECFSZ 00,F
04970:  BRA    496E
04972:  BCF    F8A.1
04974:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04976:  MOVLW  72
04978:  MOVLB  7
0497A:  MOVWF  xB4
0497C:  MOVLB  0
0497E:  CALL   363A
.................... 			i2c_write(PH_LIGHT,0x93);  //Send the command for reading the version 
04982:  MOVLW  93
04984:  MOVLB  7
04986:  MOVWF  xB4
04988:  MOVLB  0
0498A:  CALL   363A
.................... 			i2c_stop(PH_LIGHT); 
0498E:  BCF    F93.0
04990:  NOP   
04992:  BSF    F93.1
04994:  BTFSS  F81.1
04996:  BRA    4994
04998:  MOVLW  50
0499A:  MOVWF  00
0499C:  DECFSZ 00,F
0499E:  BRA    499C
049A0:  BRA    49A2
049A2:  NOP   
049A4:  BSF    F93.0
049A6:  MOVLW  50
049A8:  MOVWF  00
049AA:  DECFSZ 00,F
049AC:  BRA    49AA
....................  
....................     		i2c_start(PH_LIGHT); 
049AE:  BSF    F93.0
049B0:  MOVLW  50
049B2:  MOVWF  00
049B4:  DECFSZ 00,F
049B6:  BRA    49B4
049B8:  BSF    F93.1
049BA:  MOVLW  51
049BC:  MOVWF  00
049BE:  DECFSZ 00,F
049C0:  BRA    49BE
049C2:  BCF    F8A.0
049C4:  BCF    F93.0
049C6:  MOVLW  50
049C8:  MOVWF  00
049CA:  DECFSZ 00,F
049CC:  BRA    49CA
049CE:  BCF    F8A.1
049D0:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
049D2:  MOVLW  73
049D4:  MOVLB  7
049D6:  MOVWF  xB4
049D8:  MOVLB  0
049DA:  CALL   363A
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
049DE:  CLRF   00
049E0:  CALL   36B0
049E4:  MOVFF  01,728
.................... 			i2c_stop(PH_LIGHT); 
049E8:  BCF    F93.0
049EA:  NOP   
049EC:  BSF    F93.1
049EE:  BTFSS  F81.1
049F0:  BRA    49EE
049F2:  MOVLW  50
049F4:  MOVWF  00
049F6:  DECFSZ 00,F
049F8:  BRA    49F6
049FA:  BRA    49FC
049FC:  NOP   
049FE:  BSF    F93.0
04A00:  MOVLW  50
04A02:  MOVWF  00
04A04:  DECFSZ 00,F
04A06:  BRA    4A04
.................... 			break; 
04A08:  BRA    4CE6
....................  
.................... 		case 3:   //blue 
.................... 			i2c_start(PH_LIGHT); 
04A0A:  BSF    F93.0
04A0C:  MOVLW  50
04A0E:  MOVWF  00
04A10:  DECFSZ 00,F
04A12:  BRA    4A10
04A14:  BSF    F93.1
04A16:  MOVLW  51
04A18:  MOVWF  00
04A1A:  DECFSZ 00,F
04A1C:  BRA    4A1A
04A1E:  BCF    F8A.0
04A20:  BCF    F93.0
04A22:  MOVLW  50
04A24:  MOVWF  00
04A26:  DECFSZ 00,F
04A28:  BRA    4A26
04A2A:  BCF    F8A.1
04A2C:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04A2E:  MOVLW  72
04A30:  MOVLB  7
04A32:  MOVWF  xB4
04A34:  MOVLB  0
04A36:  CALL   363A
.................... 			i2c_write(PH_LIGHT,0x94);  //Send the command for reading the version 
04A3A:  MOVLW  94
04A3C:  MOVLB  7
04A3E:  MOVWF  xB4
04A40:  MOVLB  0
04A42:  CALL   363A
.................... 			i2c_stop(PH_LIGHT); 
04A46:  BCF    F93.0
04A48:  NOP   
04A4A:  BSF    F93.1
04A4C:  BTFSS  F81.1
04A4E:  BRA    4A4C
04A50:  MOVLW  50
04A52:  MOVWF  00
04A54:  DECFSZ 00,F
04A56:  BRA    4A54
04A58:  BRA    4A5A
04A5A:  NOP   
04A5C:  BSF    F93.0
04A5E:  MOVLW  50
04A60:  MOVWF  00
04A62:  DECFSZ 00,F
04A64:  BRA    4A62
....................  
....................     		i2c_start(PH_LIGHT); 
04A66:  BSF    F93.0
04A68:  MOVLW  50
04A6A:  MOVWF  00
04A6C:  DECFSZ 00,F
04A6E:  BRA    4A6C
04A70:  BSF    F93.1
04A72:  MOVLW  51
04A74:  MOVWF  00
04A76:  DECFSZ 00,F
04A78:  BRA    4A76
04A7A:  BCF    F8A.0
04A7C:  BCF    F93.0
04A7E:  MOVLW  50
04A80:  MOVWF  00
04A82:  DECFSZ 00,F
04A84:  BRA    4A82
04A86:  BCF    F8A.1
04A88:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
04A8A:  MOVLW  73
04A8C:  MOVLB  7
04A8E:  MOVWF  xB4
04A90:  MOVLB  0
04A92:  CALL   363A
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
04A96:  CLRF   00
04A98:  CALL   36B0
04A9C:  MOVFF  01,727
.................... 			i2c_stop(PH_LIGHT); 
04AA0:  BCF    F93.0
04AA2:  NOP   
04AA4:  BSF    F93.1
04AA6:  BTFSS  F81.1
04AA8:  BRA    4AA6
04AAA:  MOVLW  50
04AAC:  MOVWF  00
04AAE:  DECFSZ 00,F
04AB0:  BRA    4AAE
04AB2:  BRA    4AB4
04AB4:  NOP   
04AB6:  BSF    F93.0
04AB8:  MOVLW  50
04ABA:  MOVWF  00
04ABC:  DECFSZ 00,F
04ABE:  BRA    4ABC
....................  
.................... 			i2c_start(PH_LIGHT); 
04AC0:  BSF    F93.0
04AC2:  MOVLW  50
04AC4:  MOVWF  00
04AC6:  DECFSZ 00,F
04AC8:  BRA    4AC6
04ACA:  BSF    F93.1
04ACC:  MOVLW  51
04ACE:  MOVWF  00
04AD0:  DECFSZ 00,F
04AD2:  BRA    4AD0
04AD4:  BCF    F8A.0
04AD6:  BCF    F93.0
04AD8:  MOVLW  50
04ADA:  MOVWF  00
04ADC:  DECFSZ 00,F
04ADE:  BRA    4ADC
04AE0:  BCF    F8A.1
04AE2:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04AE4:  MOVLW  72
04AE6:  MOVLB  7
04AE8:  MOVWF  xB4
04AEA:  MOVLB  0
04AEC:  CALL   363A
.................... 			i2c_write(PH_LIGHT,0x95);  //Send the command for reading the version 
04AF0:  MOVLW  95
04AF2:  MOVLB  7
04AF4:  MOVWF  xB4
04AF6:  MOVLB  0
04AF8:  CALL   363A
.................... 			i2c_stop(PH_LIGHT); 
04AFC:  BCF    F93.0
04AFE:  NOP   
04B00:  BSF    F93.1
04B02:  BTFSS  F81.1
04B04:  BRA    4B02
04B06:  MOVLW  50
04B08:  MOVWF  00
04B0A:  DECFSZ 00,F
04B0C:  BRA    4B0A
04B0E:  BRA    4B10
04B10:  NOP   
04B12:  BSF    F93.0
04B14:  MOVLW  50
04B16:  MOVWF  00
04B18:  DECFSZ 00,F
04B1A:  BRA    4B18
....................  
....................     		i2c_start(PH_LIGHT); 
04B1C:  BSF    F93.0
04B1E:  MOVLW  50
04B20:  MOVWF  00
04B22:  DECFSZ 00,F
04B24:  BRA    4B22
04B26:  BSF    F93.1
04B28:  MOVLW  51
04B2A:  MOVWF  00
04B2C:  DECFSZ 00,F
04B2E:  BRA    4B2C
04B30:  BCF    F8A.0
04B32:  BCF    F93.0
04B34:  MOVLW  50
04B36:  MOVWF  00
04B38:  DECFSZ 00,F
04B3A:  BRA    4B38
04B3C:  BCF    F8A.1
04B3E:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
04B40:  MOVLW  73
04B42:  MOVLB  7
04B44:  MOVWF  xB4
04B46:  MOVLB  0
04B48:  CALL   363A
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
04B4C:  CLRF   00
04B4E:  CALL   36B0
04B52:  MOVFF  01,728
.................... 			i2c_stop(PH_LIGHT); 
04B56:  BCF    F93.0
04B58:  NOP   
04B5A:  BSF    F93.1
04B5C:  BTFSS  F81.1
04B5E:  BRA    4B5C
04B60:  MOVLW  50
04B62:  MOVWF  00
04B64:  DECFSZ 00,F
04B66:  BRA    4B64
04B68:  BRA    4B6A
04B6A:  NOP   
04B6C:  BSF    F93.0
04B6E:  MOVLW  50
04B70:  MOVWF  00
04B72:  DECFSZ 00,F
04B74:  BRA    4B72
.................... 			break; 
04B76:  BRA    4CE6
....................  
.................... 		case 4:   //clear 
.................... 			i2c_start(PH_LIGHT); 
04B78:  BSF    F93.0
04B7A:  MOVLW  50
04B7C:  MOVWF  00
04B7E:  DECFSZ 00,F
04B80:  BRA    4B7E
04B82:  BSF    F93.1
04B84:  MOVLW  51
04B86:  MOVWF  00
04B88:  DECFSZ 00,F
04B8A:  BRA    4B88
04B8C:  BCF    F8A.0
04B8E:  BCF    F93.0
04B90:  MOVLW  50
04B92:  MOVWF  00
04B94:  DECFSZ 00,F
04B96:  BRA    4B94
04B98:  BCF    F8A.1
04B9A:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04B9C:  MOVLW  72
04B9E:  MOVLB  7
04BA0:  MOVWF  xB4
04BA2:  MOVLB  0
04BA4:  CALL   363A
.................... 			i2c_write(PH_LIGHT,0x96);  //Send the command for reading the version 
04BA8:  MOVLW  96
04BAA:  MOVLB  7
04BAC:  MOVWF  xB4
04BAE:  MOVLB  0
04BB0:  CALL   363A
.................... 			i2c_stop(PH_LIGHT); 
04BB4:  BCF    F93.0
04BB6:  NOP   
04BB8:  BSF    F93.1
04BBA:  BTFSS  F81.1
04BBC:  BRA    4BBA
04BBE:  MOVLW  50
04BC0:  MOVWF  00
04BC2:  DECFSZ 00,F
04BC4:  BRA    4BC2
04BC6:  BRA    4BC8
04BC8:  NOP   
04BCA:  BSF    F93.0
04BCC:  MOVLW  50
04BCE:  MOVWF  00
04BD0:  DECFSZ 00,F
04BD2:  BRA    4BD0
....................  
....................     		i2c_start(PH_LIGHT); 
04BD4:  BSF    F93.0
04BD6:  MOVLW  50
04BD8:  MOVWF  00
04BDA:  DECFSZ 00,F
04BDC:  BRA    4BDA
04BDE:  BSF    F93.1
04BE0:  MOVLW  51
04BE2:  MOVWF  00
04BE4:  DECFSZ 00,F
04BE6:  BRA    4BE4
04BE8:  BCF    F8A.0
04BEA:  BCF    F93.0
04BEC:  MOVLW  50
04BEE:  MOVWF  00
04BF0:  DECFSZ 00,F
04BF2:  BRA    4BF0
04BF4:  BCF    F8A.1
04BF6:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
04BF8:  MOVLW  73
04BFA:  MOVLB  7
04BFC:  MOVWF  xB4
04BFE:  MOVLB  0
04C00:  CALL   363A
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
04C04:  CLRF   00
04C06:  CALL   36B0
04C0A:  MOVFF  01,727
.................... 			i2c_stop(PH_LIGHT); 
04C0E:  BCF    F93.0
04C10:  NOP   
04C12:  BSF    F93.1
04C14:  BTFSS  F81.1
04C16:  BRA    4C14
04C18:  MOVLW  50
04C1A:  MOVWF  00
04C1C:  DECFSZ 00,F
04C1E:  BRA    4C1C
04C20:  BRA    4C22
04C22:  NOP   
04C24:  BSF    F93.0
04C26:  MOVLW  50
04C28:  MOVWF  00
04C2A:  DECFSZ 00,F
04C2C:  BRA    4C2A
....................  
.................... 			i2c_start(PH_LIGHT); 
04C2E:  BSF    F93.0
04C30:  MOVLW  50
04C32:  MOVWF  00
04C34:  DECFSZ 00,F
04C36:  BRA    4C34
04C38:  BSF    F93.1
04C3A:  MOVLW  51
04C3C:  MOVWF  00
04C3E:  DECFSZ 00,F
04C40:  BRA    4C3E
04C42:  BCF    F8A.0
04C44:  BCF    F93.0
04C46:  MOVLW  50
04C48:  MOVWF  00
04C4A:  DECFSZ 00,F
04C4C:  BRA    4C4A
04C4E:  BCF    F8A.1
04C50:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04C52:  MOVLW  72
04C54:  MOVLB  7
04C56:  MOVWF  xB4
04C58:  MOVLB  0
04C5A:  CALL   363A
.................... 			i2c_write(PH_LIGHT,0x97);  //Send the command for reading the version 
04C5E:  MOVLW  97
04C60:  MOVLB  7
04C62:  MOVWF  xB4
04C64:  MOVLB  0
04C66:  CALL   363A
.................... 			i2c_stop(PH_LIGHT); 
04C6A:  BCF    F93.0
04C6C:  NOP   
04C6E:  BSF    F93.1
04C70:  BTFSS  F81.1
04C72:  BRA    4C70
04C74:  MOVLW  50
04C76:  MOVWF  00
04C78:  DECFSZ 00,F
04C7A:  BRA    4C78
04C7C:  BRA    4C7E
04C7E:  NOP   
04C80:  BSF    F93.0
04C82:  MOVLW  50
04C84:  MOVWF  00
04C86:  DECFSZ 00,F
04C88:  BRA    4C86
....................  
....................     		i2c_start(PH_LIGHT); 
04C8A:  BSF    F93.0
04C8C:  MOVLW  50
04C8E:  MOVWF  00
04C90:  DECFSZ 00,F
04C92:  BRA    4C90
04C94:  BSF    F93.1
04C96:  MOVLW  51
04C98:  MOVWF  00
04C9A:  DECFSZ 00,F
04C9C:  BRA    4C9A
04C9E:  BCF    F8A.0
04CA0:  BCF    F93.0
04CA2:  MOVLW  50
04CA4:  MOVWF  00
04CA6:  DECFSZ 00,F
04CA8:  BRA    4CA6
04CAA:  BCF    F8A.1
04CAC:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
04CAE:  MOVLW  73
04CB0:  MOVLB  7
04CB2:  MOVWF  xB4
04CB4:  MOVLB  0
04CB6:  CALL   363A
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
04CBA:  CLRF   00
04CBC:  CALL   36B0
04CC0:  MOVFF  01,728
.................... 			i2c_stop(PH_LIGHT); 
04CC4:  BCF    F93.0
04CC6:  NOP   
04CC8:  BSF    F93.1
04CCA:  BTFSS  F81.1
04CCC:  BRA    4CCA
04CCE:  MOVLW  50
04CD0:  MOVWF  00
04CD2:  DECFSZ 00,F
04CD4:  BRA    4CD2
04CD6:  BRA    4CD8
04CD8:  NOP   
04CDA:  BSF    F93.0
04CDC:  MOVLW  50
04CDE:  MOVWF  00
04CE0:  DECFSZ 00,F
04CE2:  BRA    4CE0
.................... 			break; 
04CE4:  BRA    4CE6
....................  
.................... 		default:	 
.................... 			break; 
.................... 	} 
04CE6:  RETURN 0
....................  
.................... } 
....................  
.................... #include <FindConnectedDevice.c> 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Febuary 20, 2017 
.................... // This table shows the returned results for board used to IDing through the I2C 
.................... // Board Name            Returned ID 
.................... // Digital Board             0x39 
.................... // RH/Temp                   0x1050 
.................... // Light Chip                0x22 
.................... // Analog DO & NH4           0xa9 
.................... // CO2                       0xd9 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Jan 23, 2017 
.................... // This routine searches for a plugged in device for any port.  It is a general purpose used for osmobot for finding whih i2c is plugged in. 
.................... // The returned value is the device ID number used by osmobot.  
.................... // The the returned value is a 1, that means nothing is plugged in or it's not working. (communicating) 
.................... //****************************************************************************** 
.................... int FindRJ45Device(int portnumber,int deviceid) 
.................... { 
....................      
....................      
....................  
....................     int16 returnedvalue;  // this is the dummy returned value from checking I2C connections 
....................     int struuu; 
....................     float nhthree,NHCalHigh,NHCalLow,NHReadingLow,NHReadingHigh,wtemper,b,phtemper,nhslope; 
....................     int16 ReturnedADC;  // this is the returned value from the Vernier Sensor 
....................     char teststr4[20]; 
....................     if (deviceid==0x02) 
*
03A40:  MOVLB  7
03A42:  MOVF   x71,W
03A44:  SUBLW  02
03A46:  BNZ   3A7C
....................     { 
....................     clearDisplay(); 
03A48:  MOVLB  0
03A4A:  CALL   130C
....................     sprintf(teststr4,"Identifying"); 
03A4E:  MOVLW  07
03A50:  MOVLB  2
03A52:  MOVWF  x32
03A54:  MOVLW  9B
03A56:  MOVWF  x31
03A58:  MOVLW  1C
03A5A:  MOVWF  FF6
03A5C:  MOVLW  10
03A5E:  MOVWF  FF7
03A60:  MOVLB  0
03A62:  CALL   1C64
....................      writeString(0, 0, teststr4); 
03A66:  MOVLB  7
03A68:  CLRF   xC0
03A6A:  CLRF   xC1
03A6C:  MOVLW  07
03A6E:  MOVWF  xC3
03A70:  MOVLW  9B
03A72:  MOVWF  xC2
03A74:  MOVLB  0
03A76:  CALL   1338
03A7A:  MOVLB  7
....................     } 
....................  
....................  
....................     //************************************************************************* 
....................     // Created March 14, 2017 
....................     // This sections reads the Vernier Sensor and displays it on the bottom. 
....................     // The sensor is connected to the back of the used using the British RJ45 connection (right handed) 
....................     //*************************************************************************) 
....................      
....................     // read the sensor  ADC sAN3 off pin 5. 
....................     ReturnedADC = GetADCValue(3); //This gets the current ADC convertion for the channel number. 
03A7C:  MOVLW  03
03A7E:  MOVWF  xAF
03A80:  MOVLB  0
03A82:  GOTO   1C84
03A86:  MOVFF  02,79A
03A8A:  MOVFF  01,799
....................     // show the result all the time a devices is not being accessed. 
....................      
....................     //************************************************************************** 
....................     // Created March 14, 2017 
....................     // This is the first attempt at seperating the NH3 and NH4 from the reading. 
....................     //  Neede varaibles 
....................     //  Total (NH3+NH4)-Nitrogen Concentration (mg/L)    (NitConcentration) 
....................     // pH                     sysOutput.pH 
....................     // temperature in C       sysOutput.wTemp 
....................     //  Free NH3 in (mg/L) 
....................     //  form.product.value = Number(form.one.value)/(1+Math.pow(10,(0.0902-Number(form.two.value)+(2730/(273.2+Number(form.three.value)))))); 
.................... //  (mg/L NH3) = NitConcentration/(1 + 10^(0.0902-sysOutput.pH +(2730/(273.2+sysOutput.wTemp))) 
....................      
....................      
....................     NHCalHigh = 100.0; 
03A8E:  MOVLB  7
03A90:  CLRF   x7C
03A92:  CLRF   x7B
03A94:  MOVLW  48
03A96:  MOVWF  x7A
03A98:  MOVLW  85
03A9A:  MOVWF  x79
....................     NHCalLow = 1.0; 
03A9C:  CLRF   x80
03A9E:  CLRF   x7F
03AA0:  CLRF   x7E
03AA2:  MOVLW  7F
03AA4:  MOVWF  x7D
....................     NHReadingHigh = 25.0; 
03AA6:  CLRF   x88
03AA8:  CLRF   x87
03AAA:  MOVLW  48
03AAC:  MOVWF  x86
03AAE:  MOVLW  83
03AB0:  MOVWF  x85
....................     NHReadingLow = 6.0; 
03AB2:  CLRF   x84
03AB4:  CLRF   x83
03AB6:  MOVLW  40
03AB8:  MOVWF  x82
03ABA:  MOVLW  81
03ABC:  MOVWF  x81
....................     wtemper = 19.0; 
03ABE:  CLRF   x8C
03AC0:  CLRF   x8B
03AC2:  MOVLW  18
03AC4:  MOVWF  x8A
03AC6:  MOVLW  83
03AC8:  MOVWF  x89
....................     phtemper= 7.0; 
03ACA:  CLRF   x94
03ACC:  CLRF   x93
03ACE:  MOVLW  60
03AD0:  MOVWF  x92
03AD2:  MOVLW  81
03AD4:  MOVWF  x91
....................      
....................     nhslope = ((NHCalHigh - NHCalLow)/(NHReadingHigh-NHReadingLow)); 
03AD6:  BSF    FD8.1
03AD8:  MOVFF  77C,7E6
03ADC:  MOVFF  77B,7E5
03AE0:  MOVFF  77A,7E4
03AE4:  MOVFF  779,7E3
03AE8:  MOVFF  780,7EA
03AEC:  MOVFF  77F,7E9
03AF0:  MOVFF  77E,7E8
03AF4:  MOVFF  77D,7E7
03AF8:  MOVLB  0
03AFA:  CALL   1CE0
03AFE:  MOVFF  03,7B2
03B02:  MOVFF  02,7B1
03B06:  MOVFF  01,7B0
03B0A:  MOVFF  00,7AF
03B0E:  BSF    FD8.1
03B10:  MOVFF  788,7E6
03B14:  MOVFF  787,7E5
03B18:  MOVFF  786,7E4
03B1C:  MOVFF  785,7E3
03B20:  MOVFF  784,7EA
03B24:  MOVFF  783,7E9
03B28:  MOVFF  782,7E8
03B2C:  MOVFF  781,7E7
03B30:  CALL   1CE0
03B34:  MOVFF  7B2,7DB
03B38:  MOVFF  7B1,7DA
03B3C:  MOVFF  7B0,7D9
03B40:  MOVFF  7AF,7D8
03B44:  MOVFF  03,7DF
03B48:  MOVFF  02,7DE
03B4C:  MOVFF  01,7DD
03B50:  MOVFF  00,7DC
03B54:  CALL   1F58
03B58:  MOVFF  03,798
03B5C:  MOVFF  02,797
03B60:  MOVFF  01,796
03B64:  MOVFF  00,795
....................     b = NHCalHigh - nhslope * NHReadingHigh; 
03B68:  MOVFF  798,7E2
03B6C:  MOVFF  797,7E1
03B70:  MOVFF  796,7E0
03B74:  MOVFF  795,7DF
03B78:  MOVFF  788,7E6
03B7C:  MOVFF  787,7E5
03B80:  MOVFF  786,7E4
03B84:  MOVFF  785,7E3
03B88:  CALL   20B6
03B8C:  BSF    FD8.1
03B8E:  MOVFF  77C,7E6
03B92:  MOVFF  77B,7E5
03B96:  MOVFF  77A,7E4
03B9A:  MOVFF  779,7E3
03B9E:  MOVFF  03,7EA
03BA2:  MOVFF  02,7E9
03BA6:  MOVFF  01,7E8
03BAA:  MOVFF  00,7E7
03BAE:  CALL   1CE0
03BB2:  MOVFF  03,790
03BB6:  MOVFF  02,78F
03BBA:  MOVFF  01,78E
03BBE:  MOVFF  00,78D
....................     nhthree = (float) ReturnedADC; 
03BC2:  MOVFF  79A,7E4
03BC6:  MOVFF  799,7E3
03BCA:  CALL   21AC
03BCE:  MOVFF  03,778
03BD2:  MOVFF  02,777
03BD6:  MOVFF  01,776
03BDA:  MOVFF  00,775
....................      
....................     // find the number from the slope equation 
....................     nhthree = nhslope*nhthree + b;  // this is the calculated NH4 and NH3 
03BDE:  MOVFF  798,7E2
03BE2:  MOVFF  797,7E1
03BE6:  MOVFF  796,7E0
03BEA:  MOVFF  795,7DF
03BEE:  MOVFF  778,7E6
03BF2:  MOVFF  777,7E5
03BF6:  MOVFF  776,7E4
03BFA:  MOVFF  775,7E3
03BFE:  CALL   20B6
03C02:  MOVFF  03,7B2
03C06:  MOVFF  02,7B1
03C0A:  MOVFF  01,7B0
03C0E:  MOVFF  00,7AF
03C12:  BCF    FD8.1
03C14:  MOVFF  03,7E6
03C18:  MOVFF  02,7E5
03C1C:  MOVFF  01,7E4
03C20:  MOVFF  00,7E3
03C24:  MOVFF  790,7EA
03C28:  MOVFF  78F,7E9
03C2C:  MOVFF  78E,7E8
03C30:  MOVFF  78D,7E7
03C34:  CALL   1CE0
03C38:  MOVFF  03,778
03C3C:  MOVFF  02,777
03C40:  MOVFF  01,776
03C44:  MOVFF  00,775
....................      
....................      
....................     nhthree = nhthree/(1 + pow(10,(0.0902-phtemper +(2730/(273.2+wtemper))))); 
03C48:  BSF    FD8.1
03C4A:  MOVLW  C7
03C4C:  MOVLB  7
03C4E:  MOVWF  xE6
03C50:  MOVLW  BA
03C52:  MOVWF  xE5
03C54:  MOVLW  38
03C56:  MOVWF  xE4
03C58:  MOVLW  7B
03C5A:  MOVWF  xE3
03C5C:  MOVFF  794,7EA
03C60:  MOVFF  793,7E9
03C64:  MOVFF  792,7E8
03C68:  MOVFF  791,7E7
03C6C:  MOVLB  0
03C6E:  CALL   1CE0
03C72:  MOVFF  03,7B2
03C76:  MOVFF  02,7B1
03C7A:  MOVFF  01,7B0
03C7E:  MOVFF  00,7AF
03C82:  BCF    FD8.1
03C84:  MOVLW  9A
03C86:  MOVLB  7
03C88:  MOVWF  xE6
03C8A:  MOVLW  99
03C8C:  MOVWF  xE5
03C8E:  MOVLW  08
03C90:  MOVWF  xE4
03C92:  MOVLW  87
03C94:  MOVWF  xE3
03C96:  MOVFF  78C,7EA
03C9A:  MOVFF  78B,7E9
03C9E:  MOVFF  78A,7E8
03CA2:  MOVFF  789,7E7
03CA6:  MOVLB  0
03CA8:  CALL   1CE0
03CAC:  MOVLB  7
03CAE:  CLRF   xDB
03CB0:  MOVLW  A0
03CB2:  MOVWF  xDA
03CB4:  MOVLW  2A
03CB6:  MOVWF  xD9
03CB8:  MOVLW  8A
03CBA:  MOVWF  xD8
03CBC:  MOVFF  03,7DF
03CC0:  MOVFF  02,7DE
03CC4:  MOVFF  01,7DD
03CC8:  MOVFF  00,7DC
03CCC:  MOVLB  0
03CCE:  CALL   1F58
03CD2:  BCF    FD8.1
03CD4:  MOVFF  7B2,7E6
03CD8:  MOVFF  7B1,7E5
03CDC:  MOVFF  7B0,7E4
03CE0:  MOVFF  7AF,7E3
03CE4:  MOVFF  03,7EA
03CE8:  MOVFF  02,7E9
03CEC:  MOVFF  01,7E8
03CF0:  MOVFF  00,7E7
03CF4:  CALL   1CE0
03CF8:  MOVFF  03,7B2
03CFC:  MOVFF  02,7B1
03D00:  MOVFF  01,7B0
03D04:  MOVFF  00,7AF
03D08:  MOVLB  7
03D0A:  CLRF   xB6
03D0C:  CLRF   xB5
03D0E:  MOVLW  20
03D10:  MOVWF  xB4
03D12:  MOVLW  82
03D14:  MOVWF  xB3
03D16:  MOVFF  03,7BA
03D1A:  MOVFF  02,7B9
03D1E:  MOVFF  01,7B8
03D22:  MOVFF  00,7B7
03D26:  MOVLB  0
03D28:  GOTO   2F66
03D2C:  MOVFF  FEA,7B0
03D30:  MOVFF  FE9,7AF
03D34:  BCF    FD8.1
03D36:  MOVLB  7
03D38:  CLRF   xE6
03D3A:  CLRF   xE5
03D3C:  CLRF   xE4
03D3E:  MOVLW  7F
03D40:  MOVWF  xE3
03D42:  MOVFF  03,7EA
03D46:  MOVFF  02,7E9
03D4A:  MOVFF  01,7E8
03D4E:  MOVFF  00,7E7
03D52:  MOVLB  0
03D54:  CALL   1CE0
03D58:  MOVFF  7B0,FEA
03D5C:  MOVFF  7AF,FE9
03D60:  MOVFF  778,7DB
03D64:  MOVFF  777,7DA
03D68:  MOVFF  776,7D9
03D6C:  MOVFF  775,7D8
03D70:  MOVFF  03,7DF
03D74:  MOVFF  02,7DE
03D78:  MOVFF  01,7DD
03D7C:  MOVFF  00,7DC
03D80:  CALL   1F58
03D84:  MOVFF  03,778
03D88:  MOVFF  02,777
03D8C:  MOVFF  01,776
03D90:  MOVFF  00,775
....................      
....................     sprintf(teststr4,"Vernier %Lu NH3 %f  ",ReturnedADC,nhthree); 
03D94:  MOVLW  07
03D96:  MOVLB  2
03D98:  MOVWF  x32
03D9A:  MOVLW  9B
03D9C:  MOVWF  x31
03D9E:  MOVLW  28
03DA0:  MOVWF  FF6
03DA2:  MOVLW  10
03DA4:  MOVWF  FF7
03DA6:  MOVLW  08
03DA8:  MOVLB  7
03DAA:  MOVWF  xAF
03DAC:  MOVLB  0
03DAE:  CALL   327E
03DB2:  MOVLW  10
03DB4:  MOVWF  FE9
03DB6:  MOVFF  79A,7B0
03DBA:  MOVFF  799,7AF
03DBE:  CALL   32A8
03DC2:  MOVLW  33
03DC4:  MOVWF  FF6
03DC6:  MOVLW  10
03DC8:  MOVWF  FF7
03DCA:  MOVLW  05
03DCC:  MOVLB  7
03DCE:  MOVWF  xAF
03DD0:  MOVLB  0
03DD2:  CALL   327E
03DD6:  MOVLW  89
03DD8:  MOVWF  FE9
03DDA:  MOVFF  778,7B2
03DDE:  MOVFF  777,7B1
03DE2:  MOVFF  776,7B0
03DE6:  MOVFF  775,7AF
03DEA:  MOVLW  02
03DEC:  MOVLB  7
03DEE:  MOVWF  xB3
03DF0:  MOVLB  0
03DF2:  CALL   3446
03DF6:  MOVLW  20
03DF8:  MOVLB  7
03DFA:  MOVWF  xBC
03DFC:  MOVLB  0
03DFE:  CALL   1C42
03E02:  MOVLW  20
03E04:  MOVLB  7
03E06:  MOVWF  xBC
03E08:  MOVLB  0
03E0A:  CALL   1C42
....................      writeString(0, 3, teststr4); 
03E0E:  MOVLB  7
03E10:  CLRF   xC0
03E12:  MOVLW  03
03E14:  MOVWF  xC1
03E16:  MOVLW  07
03E18:  MOVWF  xC3
03E1A:  MOVLW  9B
03E1C:  MOVWF  xC2
03E1E:  MOVLB  0
03E20:  CALL   1338
....................       
....................    // selectsensor(portnumber);  // this sets the SCL to the right I2C device. 
....................      
....................  
....................          
....................         // check for 1050 
....................         returnedvalue = GetHDC1080Version(0x01); 
03E24:  MOVLW  01
03E26:  MOVLB  7
03E28:  MOVWF  xAF
03E2A:  MOVLB  0
03E2C:  RCALL  371A
03E2E:  MOVFF  02,773
03E32:  MOVFF  01,772
....................         if (returnedvalue == 0x1050) 
03E36:  MOVLB  7
03E38:  MOVF   x72,W
03E3A:  SUBLW  50
03E3C:  BNZ   3E4A
03E3E:  MOVF   x73,W
03E40:  SUBLW  10
03E42:  BNZ   3E4A
....................         { 
....................               // this is the TO rH and temp sensor 
....................             return(0x22); 
03E44:  MOVLW  22
03E46:  MOVWF  01
03E48:  BRA    3E9A
....................         } 
....................          
....................         // this finds the light sensor version and then tests the device. 
....................         struuu = getTAOSVersion(0x01); 
03E4A:  MOVLW  01
03E4C:  MOVWF  xAF
03E4E:  MOVLB  0
03E50:  RCALL  37F6
03E52:  MOVFF  01,774
....................         if (struuu == 0x11) 
03E56:  MOVLB  7
03E58:  MOVF   x74,W
03E5A:  SUBLW  11
03E5C:  BNZ   3E64
....................         { 
....................               // this is the number for the light sensor/PAR, 
....................             return(0x23);  // returns a 23 for the light sensor test. 
03E5E:  MOVLW  23
03E60:  MOVWF  01
03E62:  BRA    3E9A
....................         }         
....................          
....................         struuu = GetAnalogDONHFourVersion(0x01); 
03E64:  MOVLW  01
03E66:  MOVWF  xAF
03E68:  MOVLB  0
03E6A:  RCALL  38B4
03E6C:  MOVFF  01,774
....................         if (struuu == 0xA9)  //  this is the code for the Analog DO and NH4 sensor 
03E70:  MOVLB  7
03E72:  MOVF   x74,W
03E74:  SUBLW  A9
03E76:  BNZ   3E7E
....................         { 
....................               // this is the Analog DO, Temperature and NH4 sensor 
....................             return(0x24); 
03E78:  MOVLW  24
03E7A:  MOVWF  01
03E7C:  BRA    3E9A
....................         }       
....................         if (struuu == 0x39)  //  this is the code for the Digital DO and NH4 sensor 
03E7E:  MOVF   x74,W
03E80:  SUBLW  39
03E82:  BNZ   3E8A
....................         { 
....................               // this is the Digital DO, Temperature and NH4 sensor 
....................             return(0x25); 
03E84:  MOVLW  25
03E86:  MOVWF  01
03E88:  BRA    3E9A
....................         }          
....................          if (struuu == 0xd9)  //  this is the code for the CO2, RH and Temp sensor 
03E8A:  MOVF   x74,W
03E8C:  SUBLW  D9
03E8E:  BNZ   3E96
....................         { 
....................               // this is the CO2, RH and Temp sensor 
....................             return(0x26); 
03E90:  MOVLW  26
03E92:  MOVWF  01
03E94:  BRA    3E9A
....................         }          
....................     //clear display and put up display searching for plugged in device. 
....................      
....................     // loop through all of version and device IDs that are provided by the manufacturer. 
....................     
....................     // If a result is one of the known devices, return the device index number.  
....................      
....................     //  The device is then tested by another routine. 
....................      
....................     return(0x01); 
03E96:  MOVLW  01
03E98:  MOVWF  01
03E9A:  MOVLB  0
03E9C:  GOTO   9028 (RETURN)
.................... } 
....................  
....................  
.................... //***************************************************************************** 
.................... // Create January 23, 2017 
.................... // This routine is used to test the TI 1050 chip on the optical board. 
.................... // It clears the display and sends the raw and calculated data to the display in real time. 
.................... // when the cable is pulled out, there is an error with the version number and then it releases back 
.................... // to the operating system to check for the next connection. 
.................... //  Returns nothing. 
.................... //***************************************************************************** 
.................... int TestRHTemp(void) 
.................... { 
....................      
....................     int16 returnedvalue,returnedresult; 
....................     float returnedresultit,titemp; 
....................      
....................     clearDisplay(); 
*
0436C:  CALL   130C
....................     char teststr4[20]; 
....................     sprintf(teststr4,"TI 1015 RH/Temp"); 
04370:  MOVLW  07
04372:  MOVLB  2
04374:  MOVWF  x32
04376:  MOVLW  7C
04378:  MOVWF  x31
0437A:  MOVLW  3E
0437C:  MOVWF  FF6
0437E:  MOVLW  10
04380:  MOVWF  FF7
04382:  MOVLB  0
04384:  CALL   1C64
....................     writeString(0, 0, teststr4); 
04388:  MOVLB  7
0438A:  CLRF   xC0
0438C:  CLRF   xC1
0438E:  MOVLW  07
04390:  MOVWF  xC3
04392:  MOVLW  7C
04394:  MOVWF  xC2
04396:  MOVLB  0
04398:  CALL   1338
....................     while(1) 
....................     { 
....................         returnedvalue = GetHDC1080Version(0x01); 
0439C:  MOVLW  01
0439E:  MOVLB  7
043A0:  MOVWF  xAF
043A2:  MOVLB  0
043A4:  CALL   371A
043A8:  MOVFF  02,771
043AC:  MOVFF  01,770
....................         if (returnedvalue == 0x1050) 
043B0:  MOVLB  7
043B2:  MOVF   x70,W
043B4:  SUBLW  50
043B6:  BTFSS  FD8.2
043B8:  BRA    461A
043BA:  MOVF   x71,W
043BC:  SUBLW  10
043BE:  BTFSS  FD8.2
043C0:  BRA    461A
....................         { 
.................... // this means the device is still plugged in.  Get the real-time temp and RH. 
....................     //    returnedvalue = GetHDC1080RHTemp(0x01); 
....................              
....................    returnedresultit = GetHDC1080RHTemp(0x01); 
043C2:  MOVLW  01
043C4:  MOVWF  x90
043C6:  MOVLB  0
043C8:  BRA    3F28
043CA:  MOVFF  03,777
043CE:  MOVFF  02,776
043D2:  MOVFF  01,775
043D6:  MOVFF  00,774
....................     
....................    readlineararray(); 
043DA:  BRA    41FE
....................    returnedresult = th; 
043DC:  MOVFF  22A,773
043E0:  MOVFF  229,772
....................    returnedresult = tl; 
043E4:  MOVFF  22C,773
043E8:  MOVFF  22B,772
....................    titemp = (float) (th << 8 | tl);     
043EC:  MOVFF  229,792
043F0:  MOVLB  7
043F2:  CLRF   x91
043F4:  MOVF   x91,W
043F6:  MOVLB  2
043F8:  IORWF  x2B,W
043FA:  MOVWF  00
043FC:  MOVLB  7
043FE:  MOVF   x92,W
04400:  MOVLB  2
04402:  IORWF  x2C,W
04404:  MOVWF  03
04406:  MOVFF  00,7E3
0440A:  MOVLB  7
0440C:  MOVWF  xE4
0440E:  MOVLB  0
04410:  CALL   21AC
04414:  MOVFF  03,77B
04418:  MOVFF  02,77A
0441C:  MOVFF  01,779
04420:  MOVFF  00,778
....................     titemp = titemp * 165.0 / 65536.0 - 40.0; 
04424:  MOVFF  77B,7E2
04428:  MOVFF  77A,7E1
0442C:  MOVFF  779,7E0
04430:  MOVFF  778,7DF
04434:  MOVLB  7
04436:  CLRF   xE6
04438:  CLRF   xE5
0443A:  MOVLW  25
0443C:  MOVWF  xE4
0443E:  MOVLW  86
04440:  MOVWF  xE3
04442:  MOVLB  0
04444:  CALL   20B6
04448:  MOVFF  03,793
0444C:  MOVFF  02,792
04450:  MOVFF  01,791
04454:  MOVFF  00,790
04458:  MOVFF  03,7DB
0445C:  MOVFF  02,7DA
04460:  MOVFF  01,7D9
04464:  MOVFF  00,7D8
04468:  MOVLB  7
0446A:  CLRF   xDF
0446C:  CLRF   xDE
0446E:  CLRF   xDD
04470:  MOVLW  8F
04472:  MOVWF  xDC
04474:  MOVLB  0
04476:  CALL   1F58
0447A:  MOVFF  03,793
0447E:  MOVFF  02,792
04482:  MOVFF  01,791
04486:  MOVFF  00,790
0448A:  BSF    FD8.1
0448C:  MOVFF  03,7E6
04490:  MOVFF  02,7E5
04494:  MOVFF  01,7E4
04498:  MOVFF  00,7E3
0449C:  MOVLB  7
0449E:  CLRF   xEA
044A0:  CLRF   xE9
044A2:  MOVLW  20
044A4:  MOVWF  xE8
044A6:  MOVLW  84
044A8:  MOVWF  xE7
044AA:  MOVLB  0
044AC:  CALL   1CE0
044B0:  MOVFF  03,77B
044B4:  MOVFF  02,77A
044B8:  MOVFF  01,779
044BC:  MOVFF  00,778
....................      sprintf(teststr4,"Temp %f",titemp);    
044C0:  MOVLW  07
044C2:  MOVLB  2
044C4:  MOVWF  x32
044C6:  MOVLW  7C
044C8:  MOVWF  x31
044CA:  MOVLW  4E
044CC:  MOVWF  FF6
044CE:  MOVLW  10
044D0:  MOVWF  FF7
044D2:  MOVLW  05
044D4:  MOVLB  7
044D6:  MOVWF  xAF
044D8:  MOVLB  0
044DA:  CALL   327E
044DE:  MOVLW  89
044E0:  MOVWF  FE9
044E2:  MOVFF  77B,7B2
044E6:  MOVFF  77A,7B1
044EA:  MOVFF  779,7B0
044EE:  MOVFF  778,7AF
044F2:  MOVLW  02
044F4:  MOVLB  7
044F6:  MOVWF  xB3
044F8:  MOVLB  0
044FA:  CALL   3446
....................     writeString(0, 3, teststr4); 
044FE:  MOVLB  7
04500:  CLRF   xC0
04502:  MOVLW  03
04504:  MOVWF  xC1
04506:  MOVLW  07
04508:  MOVWF  xC3
0450A:  MOVLW  7C
0450C:  MOVWF  xC2
0450E:  MOVLB  0
04510:  CALL   1338
....................  
....................     returnedresult = hh; 
04514:  MOVFF  22E,773
04518:  MOVFF  22D,772
....................    returnedresult = hl; 
0451C:  MOVFF  230,773
04520:  MOVFF  22F,772
....................    titemp = (float) (hh << 8 | hl);     
04524:  MOVFF  22D,792
04528:  MOVLB  7
0452A:  CLRF   x91
0452C:  MOVF   x91,W
0452E:  MOVLB  2
04530:  IORWF  x2F,W
04532:  MOVWF  00
04534:  MOVLB  7
04536:  MOVF   x92,W
04538:  MOVLB  2
0453A:  IORWF  x30,W
0453C:  MOVWF  03
0453E:  MOVFF  00,7E3
04542:  MOVLB  7
04544:  MOVWF  xE4
04546:  MOVLB  0
04548:  CALL   21AC
0454C:  MOVFF  03,77B
04550:  MOVFF  02,77A
04554:  MOVFF  01,779
04558:  MOVFF  00,778
....................    titemp = titemp * 100.0 / 65536.0; 
0455C:  MOVFF  77B,7E2
04560:  MOVFF  77A,7E1
04564:  MOVFF  779,7E0
04568:  MOVFF  778,7DF
0456C:  MOVLB  7
0456E:  CLRF   xE6
04570:  CLRF   xE5
04572:  MOVLW  48
04574:  MOVWF  xE4
04576:  MOVLW  85
04578:  MOVWF  xE3
0457A:  MOVLB  0
0457C:  CALL   20B6
04580:  MOVFF  03,793
04584:  MOVFF  02,792
04588:  MOVFF  01,791
0458C:  MOVFF  00,790
04590:  MOVFF  03,7DB
04594:  MOVFF  02,7DA
04598:  MOVFF  01,7D9
0459C:  MOVFF  00,7D8
045A0:  MOVLB  7
045A2:  CLRF   xDF
045A4:  CLRF   xDE
045A6:  CLRF   xDD
045A8:  MOVLW  8F
045AA:  MOVWF  xDC
045AC:  MOVLB  0
045AE:  CALL   1F58
045B2:  MOVFF  03,77B
045B6:  MOVFF  02,77A
045BA:  MOVFF  01,779
045BE:  MOVFF  00,778
....................   //    titemp = titemp * 100.0 / 32768.0; 
....................      sprintf(teststr4,"RH %f",titemp);  
045C2:  MOVLW  07
045C4:  MOVLB  2
045C6:  MOVWF  x32
045C8:  MOVLW  7C
045CA:  MOVWF  x31
045CC:  MOVLW  56
045CE:  MOVWF  FF6
045D0:  MOVLW  10
045D2:  MOVWF  FF7
045D4:  MOVLW  03
045D6:  MOVLB  7
045D8:  MOVWF  xAF
045DA:  MOVLB  0
045DC:  CALL   327E
045E0:  MOVLW  89
045E2:  MOVWF  FE9
045E4:  MOVFF  77B,7B2
045E8:  MOVFF  77A,7B1
045EC:  MOVFF  779,7B0
045F0:  MOVFF  778,7AF
045F4:  MOVLW  02
045F6:  MOVLB  7
045F8:  MOVWF  xB3
045FA:  MOVLB  0
045FC:  CALL   3446
....................         writeString(0, 2, teststr4);         
04600:  MOVLB  7
04602:  CLRF   xC0
04604:  MOVLW  02
04606:  MOVWF  xC1
04608:  MOVLW  07
0460A:  MOVWF  xC3
0460C:  MOVLW  7C
0460E:  MOVWF  xC2
04610:  MOVLB  0
04612:  CALL   1338
....................         } 
04616:  BRA    4622
04618:  MOVLB  7
....................         else 
....................         { 
....................         return(0x02);    // exit the routine when the chip is not installed. 
0461A:  MOVLW  02
0461C:  MOVWF  01
0461E:  BRA    4626
04620:  MOVLB  0
....................         } 
04622:  BRA    439C
04624:  MOVLB  7
....................     }    
04626:  MOVLB  0
04628:  GOTO   903E (RETURN)
.................... } 
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Create January 24, 2017 
.................... // This routine is used to test the PAR chip on the optical board. 
.................... // It clears the display and sends the raw and calculated data to the display in real time. 
.................... // when the cable is pulled out, there is an error with the version number and then it releases back 
.................... // to the operating system to check for the next connection. 
.................... //  Returns nothing. 
.................... //***************************************************************************** 
.................... int TestPARchip(void) 
.................... { 
....................      
....................     int16 returnedvalue,returnedresult; 
....................     float returnedresultit,titemp; 
....................     int struuu; 
....................      
....................     clearDisplay(); 
*
04D0A:  CALL   130C
....................     char teststr4[20]; 
....................     sprintf(teststr4,"       TAOS 3414"); 
04D0E:  MOVLW  07
04D10:  MOVLB  2
04D12:  MOVWF  x32
04D14:  MOVLW  7D
04D16:  MOVWF  x31
04D18:  MOVLW  5C
04D1A:  MOVWF  FF6
04D1C:  MOVLW  10
04D1E:  MOVWF  FF7
04D20:  MOVLB  0
04D22:  CALL   1C64
....................     writeString(0, 0, teststr4); 
04D26:  MOVLB  7
04D28:  CLRF   xC0
04D2A:  CLRF   xC1
04D2C:  MOVLW  07
04D2E:  MOVWF  xC3
04D30:  MOVLW  7D
04D32:  MOVWF  xC2
04D34:  MOVLB  0
04D36:  CALL   1338
....................     while(1) 
....................     { 
....................         struuu = getTAOSVersion(0x01); 
04D3A:  MOVLW  01
04D3C:  MOVLB  7
04D3E:  MOVWF  xAF
04D40:  MOVLB  0
04D42:  CALL   37F6
04D46:  MOVFF  01,77C
....................         if (struuu == 0x11) 
04D4A:  MOVLB  7
04D4C:  MOVF   x7C,W
04D4E:  SUBLW  11
04D50:  BTFSS  FD8.2
04D52:  BRA    4EE8
....................         { 
.................... // this means the device is still plugged in.  Get the real-time temp and RH. 
....................       ExposureTimeTAOS(0x00, 0x01); 
04D54:  CLRF   x91
04D56:  MOVLW  01
04D58:  MOVWF  x92
04D5A:  MOVLB  0
04D5C:  BRA    462C
....................       StartUpTAOS(0x01); 
04D5E:  MOVLW  01
04D60:  MOVLB  7
04D62:  MOVWF  x91
04D64:  MOVLB  0
04D66:  BRA    469C
....................        
.................... 		ReadColorTAOS(2,0x01);  //green 
04D68:  MOVLW  02
04D6A:  MOVLB  7
04D6C:  MOVWF  x91
04D6E:  MOVLW  01
04D70:  MOVWF  x92
04D72:  MOVLB  0
04D74:  RCALL  4710
.................... 		green = colorlow + colorhigh * 256; 
04D76:  MOVLB  7
04D78:  CLRF   xB5
04D7A:  MOVFF  728,7B4
04D7E:  MOVLW  01
04D80:  MOVWF  xB7
04D82:  CLRF   xB6
04D84:  MOVLB  0
04D86:  RCALL  4CE8
04D88:  MOVF   01,W
04D8A:  MOVLB  7
04D8C:  ADDWF  x27,W
04D8E:  MOVWF  x2B
04D90:  MOVLW  00
04D92:  ADDWFC 02,W
04D94:  MOVWF  x2C
....................  
.................... 		ReadColorTAOS(1,0x01);  //red 
04D96:  MOVLW  01
04D98:  MOVWF  x91
04D9A:  MOVWF  x92
04D9C:  MOVLB  0
04D9E:  RCALL  4710
.................... 		red = colorlow + colorhigh * 256; 
04DA0:  MOVLB  7
04DA2:  CLRF   xB5
04DA4:  MOVFF  728,7B4
04DA8:  MOVLW  01
04DAA:  MOVWF  xB7
04DAC:  CLRF   xB6
04DAE:  MOVLB  0
04DB0:  RCALL  4CE8
04DB2:  MOVF   01,W
04DB4:  MOVLB  7
04DB6:  ADDWF  x27,W
04DB8:  MOVWF  x29
04DBA:  MOVLW  00
04DBC:  ADDWFC 02,W
04DBE:  MOVWF  x2A
....................  
.................... 		ReadColorTAOS(4,0x01);  //clear 
04DC0:  MOVLW  04
04DC2:  MOVWF  x91
04DC4:  MOVLW  01
04DC6:  MOVWF  x92
04DC8:  MOVLB  0
04DCA:  RCALL  4710
.................... 		clear = colorlow + colorhigh * 256; 
04DCC:  MOVLB  7
04DCE:  CLRF   xB5
04DD0:  MOVFF  728,7B4
04DD4:  MOVLW  01
04DD6:  MOVWF  xB7
04DD8:  CLRF   xB6
04DDA:  MOVLB  0
04DDC:  RCALL  4CE8
04DDE:  MOVF   01,W
04DE0:  MOVLB  7
04DE2:  ADDWF  x27,W
04DE4:  MOVWF  x2F
04DE6:  MOVLW  00
04DE8:  ADDWFC 02,W
04DEA:  MOVWF  x30
....................  
.................... 		ReadColorTAOS(3,0x01);  //blue 
04DEC:  MOVLW  03
04DEE:  MOVWF  x91
04DF0:  MOVLW  01
04DF2:  MOVWF  x92
04DF4:  MOVLB  0
04DF6:  RCALL  4710
.................... 		blue = colorlow + colorhigh * 256; 
04DF8:  MOVLB  7
04DFA:  CLRF   xB5
04DFC:  MOVFF  728,7B4
04E00:  MOVLW  01
04E02:  MOVWF  xB7
04E04:  CLRF   xB6
04E06:  MOVLB  0
04E08:  RCALL  4CE8
04E0A:  MOVF   01,W
04E0C:  MOVLB  7
04E0E:  ADDWF  x27,W
04E10:  MOVWF  x2D
04E12:  MOVLW  00
04E14:  ADDWFC 02,W
04E16:  MOVWF  x2E
....................        
....................        
....................        
....................      sprintf(teststr4,"red %Lu",red);    
04E18:  MOVLW  07
04E1A:  MOVLB  2
04E1C:  MOVWF  x32
04E1E:  MOVLW  7D
04E20:  MOVWF  x31
04E22:  MOVLW  6E
04E24:  MOVWF  FF6
04E26:  MOVLW  10
04E28:  MOVWF  FF7
04E2A:  MOVLW  04
04E2C:  MOVLB  7
04E2E:  MOVWF  xAF
04E30:  MOVLB  0
04E32:  CALL   327E
04E36:  MOVLW  10
04E38:  MOVWF  FE9
04E3A:  MOVFF  72A,7B0
04E3E:  MOVFF  729,7AF
04E42:  CALL   32A8
....................     writeString(0, 1, teststr4); 
04E46:  MOVLB  7
04E48:  CLRF   xC0
04E4A:  MOVLW  01
04E4C:  MOVWF  xC1
04E4E:  MOVLW  07
04E50:  MOVWF  xC3
04E52:  MOVLW  7D
04E54:  MOVWF  xC2
04E56:  MOVLB  0
04E58:  CALL   1338
....................      sprintf(teststr4,"green %Lu",green);    
04E5C:  MOVLW  07
04E5E:  MOVLB  2
04E60:  MOVWF  x32
04E62:  MOVLW  7D
04E64:  MOVWF  x31
04E66:  MOVLW  76
04E68:  MOVWF  FF6
04E6A:  MOVLW  10
04E6C:  MOVWF  FF7
04E6E:  MOVLW  06
04E70:  MOVLB  7
04E72:  MOVWF  xAF
04E74:  MOVLB  0
04E76:  CALL   327E
04E7A:  MOVLW  10
04E7C:  MOVWF  FE9
04E7E:  MOVFF  72C,7B0
04E82:  MOVFF  72B,7AF
04E86:  CALL   32A8
....................     writeString(0, 2, teststr4); 
04E8A:  MOVLB  7
04E8C:  CLRF   xC0
04E8E:  MOVLW  02
04E90:  MOVWF  xC1
04E92:  MOVLW  07
04E94:  MOVWF  xC3
04E96:  MOVLW  7D
04E98:  MOVWF  xC2
04E9A:  MOVLB  0
04E9C:  CALL   1338
....................       sprintf(teststr4,"blue %Lu",blue);    
04EA0:  MOVLW  07
04EA2:  MOVLB  2
04EA4:  MOVWF  x32
04EA6:  MOVLW  7D
04EA8:  MOVWF  x31
04EAA:  MOVLW  80
04EAC:  MOVWF  FF6
04EAE:  MOVLW  10
04EB0:  MOVWF  FF7
04EB2:  MOVLW  05
04EB4:  MOVLB  7
04EB6:  MOVWF  xAF
04EB8:  MOVLB  0
04EBA:  CALL   327E
04EBE:  MOVLW  10
04EC0:  MOVWF  FE9
04EC2:  MOVFF  72E,7B0
04EC6:  MOVFF  72D,7AF
04ECA:  CALL   32A8
....................     writeString(0, 3, teststr4);       
04ECE:  MOVLB  7
04ED0:  CLRF   xC0
04ED2:  MOVLW  03
04ED4:  MOVWF  xC1
04ED6:  MOVLW  07
04ED8:  MOVWF  xC3
04EDA:  MOVLW  7D
04EDC:  MOVWF  xC2
04EDE:  MOVLB  0
04EE0:  CALL   1338
....................         } 
04EE4:  BRA    4EF0
04EE6:  MOVLB  7
....................         else 
....................         { 
....................         return(0x02);    // exit the routine when the chip is not installed. 
04EE8:  MOVLW  02
04EEA:  MOVWF  01
04EEC:  BRA    4EF4
04EEE:  MOVLB  0
....................         } 
04EF0:  BRA    4D3A
04EF2:  MOVLB  7
....................     }    
04EF4:  MOVLB  0
04EF6:  GOTO   9054 (RETURN)
.................... } 
....................  
....................  
.................... //***************************************************************************** 
.................... // Create Fabuary 12, 2017 
.................... // This routine is used to test the AnalogDO and NH4 board. 
.................... // It clears the display and sends the raw and calculated data to the display in real time. 
.................... // when the cable is pulled out, there is an error with the version number and then it releases back 
.................... // to the operating system to check for the next connection. 
.................... //  Returns no data other than the flag if nothing is connected 
.................... //***************************************************************************** 
.................... int TestAnalogDONHFourBoard(void) 
.................... { 
....................      
....................     int16 returnedvalue,returnedresult; 
....................     float returnedresultit,titemp; 
....................     int struuu; 
....................      
....................     clearDisplay(); 
*
07EF2:  CALL   130C
....................     char teststr4[20]; 
....................     sprintf(teststr4," Analog DO and NH4  "); 
07EF6:  MOVLW  07
07EF8:  MOVLB  2
07EFA:  MOVWF  x32
07EFC:  MOVLW  7D
07EFE:  MOVWF  x31
07F00:  MOVLW  8A
07F02:  MOVWF  FF6
07F04:  MOVLW  10
07F06:  MOVWF  FF7
07F08:  MOVLB  0
07F0A:  CALL   1C64
....................     writeString(0, 0, teststr4); 
07F0E:  MOVLB  7
07F10:  CLRF   xC0
07F12:  CLRF   xC1
07F14:  MOVLW  07
07F16:  MOVWF  xC3
07F18:  MOVLW  7D
07F1A:  MOVWF  xC2
07F1C:  MOVLB  0
07F1E:  CALL   1338
....................     while(1) 
....................     { 
....................         struuu = GetAnalogDONHFourVersion(0x01); 
07F22:  MOVLW  01
07F24:  MOVLB  7
07F26:  MOVWF  xAF
07F28:  MOVLB  0
07F2A:  CALL   38B4
07F2E:  MOVFF  01,77C
....................         if (struuu == 0xa9) 
07F32:  MOVLB  7
07F34:  MOVF   x7C,W
07F36:  SUBLW  A9
07F38:  BTFSS  FD8.2
07F3A:  BRA    8090
....................         { 
.................... // this means the device is still plugged in.  Get the real-time temp and RH. 
....................              
....................         ReadRemoteDevice(0x01); // this selects the Top connector RJ45 device 
07F3C:  MOVLW  01
07F3E:  MOVWF  x91
07F40:  MOVLB  0
07F42:  RCALL  783C
....................         moveReceivedData(0x00); 
07F44:  MOVLB  7
07F46:  CLRF   x91
07F48:  MOVLB  0
07F4A:  RCALL  7956
....................          
....................      sprintf(teststr4,"WT %f  Raw %Lu  ",sysOutput.wTemp,WTraw);    
07F4C:  MOVLW  07
07F4E:  MOVLB  2
07F50:  MOVWF  x32
07F52:  MOVLW  7D
07F54:  MOVWF  x31
07F56:  MOVLW  A0
07F58:  MOVWF  FF6
07F5A:  MOVLW  10
07F5C:  MOVWF  FF7
07F5E:  MOVLW  03
07F60:  MOVLB  7
07F62:  MOVWF  xAF
07F64:  MOVLB  0
07F66:  CALL   327E
07F6A:  MOVLW  89
07F6C:  MOVWF  FE9
07F6E:  MOVFF  1D2,7B2
07F72:  MOVFF  1D1,7B1
07F76:  MOVFF  1D0,7B0
07F7A:  MOVFF  1CF,7AF
07F7E:  MOVLW  02
07F80:  MOVLB  7
07F82:  MOVWF  xB3
07F84:  MOVLB  0
07F86:  CALL   3446
07F8A:  MOVLW  A5
07F8C:  MOVWF  FF6
07F8E:  MOVLW  10
07F90:  MOVWF  FF7
07F92:  MOVLW  06
07F94:  MOVLB  7
07F96:  MOVWF  xAF
07F98:  MOVLB  0
07F9A:  CALL   327E
07F9E:  MOVLW  10
07FA0:  MOVWF  FE9
07FA2:  MOVFF  1B0,7B0
07FA6:  MOVFF  1AF,7AF
07FAA:  CALL   32A8
07FAE:  MOVLW  20
07FB0:  MOVLB  7
07FB2:  MOVWF  xBC
07FB4:  MOVLB  0
07FB6:  CALL   1C42
07FBA:  MOVLW  20
07FBC:  MOVLB  7
07FBE:  MOVWF  xBC
07FC0:  MOVLB  0
07FC2:  CALL   1C42
....................     writeString(0, 1, teststr4); 
07FC6:  MOVLB  7
07FC8:  CLRF   xC0
07FCA:  MOVLW  01
07FCC:  MOVWF  xC1
07FCE:  MOVLW  07
07FD0:  MOVWF  xC3
07FD2:  MOVLW  7D
07FD4:  MOVWF  xC2
07FD6:  MOVLB  0
07FD8:  CALL   1338
....................      sprintf(teststr4,"NH4 %Lu   ",NH4Raw);    
07FDC:  MOVLW  07
07FDE:  MOVLB  2
07FE0:  MOVWF  x32
07FE2:  MOVLW  7D
07FE4:  MOVWF  x31
07FE6:  MOVLW  B2
07FE8:  MOVWF  FF6
07FEA:  MOVLW  10
07FEC:  MOVWF  FF7
07FEE:  MOVLW  04
07FF0:  MOVLB  7
07FF2:  MOVWF  xAF
07FF4:  MOVLB  0
07FF6:  CALL   327E
07FFA:  MOVLW  10
07FFC:  MOVWF  FE9
07FFE:  MOVFF  1B2,7B0
08002:  MOVFF  1B1,7AF
08006:  CALL   32A8
0800A:  MOVLW  B9
0800C:  MOVWF  FF6
0800E:  MOVLW  10
08010:  MOVWF  FF7
08012:  MOVLW  03
08014:  MOVLB  7
08016:  MOVWF  xAF
08018:  MOVLB  0
0801A:  CALL   327E
....................     writeString(0, 2, teststr4); 
0801E:  MOVLB  7
08020:  CLRF   xC0
08022:  MOVLW  02
08024:  MOVWF  xC1
08026:  MOVLW  07
08028:  MOVWF  xC3
0802A:  MOVLW  7D
0802C:  MOVWF  xC2
0802E:  MOVLB  0
08030:  CALL   1338
....................       sprintf(teststr4,"DO %Lu   ",DOraw);    
08034:  MOVLW  07
08036:  MOVLB  2
08038:  MOVWF  x32
0803A:  MOVLW  7D
0803C:  MOVWF  x31
0803E:  MOVLW  BE
08040:  MOVWF  FF6
08042:  MOVLW  10
08044:  MOVWF  FF7
08046:  MOVLW  03
08048:  MOVLB  7
0804A:  MOVWF  xAF
0804C:  MOVLB  0
0804E:  CALL   327E
08052:  MOVLW  10
08054:  MOVWF  FE9
08056:  MOVFF  1AE,7B0
0805A:  MOVFF  1AD,7AF
0805E:  CALL   32A8
08062:  MOVLW  C4
08064:  MOVWF  FF6
08066:  MOVLW  10
08068:  MOVWF  FF7
0806A:  MOVLW  03
0806C:  MOVLB  7
0806E:  MOVWF  xAF
08070:  MOVLB  0
08072:  CALL   327E
....................     writeString(0, 3, teststr4);       
08076:  MOVLB  7
08078:  CLRF   xC0
0807A:  MOVLW  03
0807C:  MOVWF  xC1
0807E:  MOVLW  07
08080:  MOVWF  xC3
08082:  MOVLW  7D
08084:  MOVWF  xC2
08086:  MOVLB  0
08088:  CALL   1338
....................         } 
0808C:  BRA    8098
0808E:  MOVLB  7
....................         else 
....................         { 
....................         return(0x02);    // exit the routine when the chip is not installed. 
08090:  MOVLW  02
08092:  MOVWF  01
08094:  BRA    809C
08096:  MOVLB  0
....................         } 
08098:  BRA    7F22
0809A:  MOVLB  7
....................     }    
0809C:  MOVLB  0
0809E:  GOTO   906A (RETURN)
.................... } 
....................  
.................... //***************************************************************************** 
.................... // Create Fabuary 16, 2017 
.................... // This routine is used to test the  Digital DO and NH4 board. 
.................... // It clears the display and sends the raw and calculated data to the display in real time. 
.................... // when the cable is pulled out, there is an error with the version number and then it releases back 
.................... // to the operating system to check for the next connection. 
.................... //  Returns no data other than the flag if nothing is connected 
.................... //***************************************************************************** 
.................... int TestDigitalDONHFourBoard(void) 
.................... { 
....................      
....................     int16 returnedvalue,returnedresult; 
....................     float returnedresultit,titemp; 
....................     int struuu; 
....................      
....................     clearDisplay(); 
080A2:  CALL   130C
....................     char teststr4[20]; 
....................  //   sprintf(teststr4,"Digital DO and NH4   "); 
....................  //   writeString(0, 0, teststr4); 
....................     while(1) 
....................     { 
....................         struuu = GetAnalogDONHFourVersion(0x01); 
080A6:  MOVLW  01
080A8:  MOVLB  7
080AA:  MOVWF  xAF
080AC:  MOVLB  0
080AE:  CALL   38B4
080B2:  MOVFF  01,77C
....................         if ((struuu == 0x39) && (!startupdate)) 
080B6:  MOVLB  7
080B8:  MOVF   x7C,W
080BA:  SUBLW  39
080BC:  BTFSS  FD8.2
080BE:  BRA    845E
080C0:  MOVLB  2
080C2:  MOVF   x28,F
080C4:  BTFSC  FD8.2
080C6:  BRA    80CC
080C8:  MOVLB  7
080CA:  BRA    845E
....................         { 
.................... // this means the device is still plugged in.  Get the real-time temp and RH. 
....................            //DpHredRaw,DpHGreenRaw,DpHBlueRaw,DpHWhiteRaw  
....................         ReadRemoteDevice(0x01); // this selects the Top connector RJ45 device 
080CC:  MOVLW  01
080CE:  MOVLB  7
080D0:  MOVWF  x91
080D2:  MOVLB  0
080D4:  CALL   783C
....................         moveReceivedData(0x00); 
080D8:  MOVLB  7
080DA:  CLRF   x91
080DC:  MOVLB  0
080DE:  RCALL  7956
....................          
....................      sprintf(teststr4,"WT %f  Raw %Lu  ",sysOutput.wTemp,WTraw);    
080E0:  MOVLW  07
080E2:  MOVLB  2
080E4:  MOVWF  x32
080E6:  MOVLW  7D
080E8:  MOVWF  x31
080EA:  MOVLW  C8
080EC:  MOVWF  FF6
080EE:  MOVLW  10
080F0:  MOVWF  FF7
080F2:  MOVLW  03
080F4:  MOVLB  7
080F6:  MOVWF  xAF
080F8:  MOVLB  0
080FA:  CALL   327E
080FE:  MOVLW  89
08100:  MOVWF  FE9
08102:  MOVFF  1D2,7B2
08106:  MOVFF  1D1,7B1
0810A:  MOVFF  1D0,7B0
0810E:  MOVFF  1CF,7AF
08112:  MOVLW  02
08114:  MOVLB  7
08116:  MOVWF  xB3
08118:  MOVLB  0
0811A:  CALL   3446
0811E:  MOVLW  CD
08120:  MOVWF  FF6
08122:  MOVLW  10
08124:  MOVWF  FF7
08126:  MOVLW  06
08128:  MOVLB  7
0812A:  MOVWF  xAF
0812C:  MOVLB  0
0812E:  CALL   327E
08132:  MOVLW  10
08134:  MOVWF  FE9
08136:  MOVFF  1B0,7B0
0813A:  MOVFF  1AF,7AF
0813E:  CALL   32A8
08142:  MOVLW  20
08144:  MOVLB  7
08146:  MOVWF  xBC
08148:  MOVLB  0
0814A:  CALL   1C42
0814E:  MOVLW  20
08150:  MOVLB  7
08152:  MOVWF  xBC
08154:  MOVLB  0
08156:  CALL   1C42
....................     writeString(0, 0, teststr4); 
0815A:  MOVLB  7
0815C:  CLRF   xC0
0815E:  CLRF   xC1
08160:  MOVLW  07
08162:  MOVWF  xC3
08164:  MOVLW  7D
08166:  MOVWF  xC2
08168:  MOVLB  0
0816A:  CALL   1338
....................      sprintf(teststr4,"%Lu  %Lu  %Lu  %Lu  ",NHRedRaw,NHGreenRaw,NHBlueRaw,NHWhiteRaw);    
0816E:  MOVLW  07
08170:  MOVLB  2
08172:  MOVWF  x32
08174:  MOVLW  7D
08176:  MOVWF  x31
08178:  MOVLW  10
0817A:  MOVWF  FE9
0817C:  MOVFF  2B7,7B0
08180:  MOVFF  2B6,7AF
08184:  MOVLB  0
08186:  CALL   32A8
0818A:  MOVLW  20
0818C:  MOVLB  7
0818E:  MOVWF  xBC
08190:  MOVLB  0
08192:  CALL   1C42
08196:  MOVLW  20
08198:  MOVLB  7
0819A:  MOVWF  xBC
0819C:  MOVLB  0
0819E:  CALL   1C42
081A2:  MOVLW  10
081A4:  MOVWF  FE9
081A6:  MOVFF  2B9,7B0
081AA:  MOVFF  2B8,7AF
081AE:  CALL   32A8
081B2:  MOVLW  20
081B4:  MOVLB  7
081B6:  MOVWF  xBC
081B8:  MOVLB  0
081BA:  CALL   1C42
081BE:  MOVLW  20
081C0:  MOVLB  7
081C2:  MOVWF  xBC
081C4:  MOVLB  0
081C6:  CALL   1C42
081CA:  MOVLW  10
081CC:  MOVWF  FE9
081CE:  MOVFF  2BB,7B0
081D2:  MOVFF  2BA,7AF
081D6:  CALL   32A8
081DA:  MOVLW  20
081DC:  MOVLB  7
081DE:  MOVWF  xBC
081E0:  MOVLB  0
081E2:  CALL   1C42
081E6:  MOVLW  20
081E8:  MOVLB  7
081EA:  MOVWF  xBC
081EC:  MOVLB  0
081EE:  CALL   1C42
081F2:  MOVLW  10
081F4:  MOVWF  FE9
081F6:  MOVFF  2BD,7B0
081FA:  MOVFF  2BC,7AF
081FE:  CALL   32A8
08202:  MOVLW  20
08204:  MOVLB  7
08206:  MOVWF  xBC
08208:  MOVLB  0
0820A:  CALL   1C42
0820E:  MOVLW  20
08210:  MOVLB  7
08212:  MOVWF  xBC
08214:  MOVLB  0
08216:  CALL   1C42
....................     writeString(0, 1, teststr4); 
0821A:  MOVLB  7
0821C:  CLRF   xC0
0821E:  MOVLW  01
08220:  MOVWF  xC1
08222:  MOVLW  07
08224:  MOVWF  xC3
08226:  MOVLW  7D
08228:  MOVWF  xC2
0822A:  MOVLB  0
0822C:  CALL   1338
....................       sprintf(teststr4,"DO Raw %Lu    ",DOraw);    
08230:  MOVLW  07
08232:  MOVLB  2
08234:  MOVWF  x32
08236:  MOVLW  7D
08238:  MOVWF  x31
0823A:  MOVLW  DA
0823C:  MOVWF  FF6
0823E:  MOVLW  10
08240:  MOVWF  FF7
08242:  MOVLW  07
08244:  MOVLB  7
08246:  MOVWF  xAF
08248:  MOVLB  0
0824A:  CALL   327E
0824E:  MOVLW  10
08250:  MOVWF  FE9
08252:  MOVFF  1AE,7B0
08256:  MOVFF  1AD,7AF
0825A:  CALL   32A8
0825E:  MOVLW  E4
08260:  MOVWF  FF6
08262:  MOVLW  10
08264:  MOVWF  FF7
08266:  MOVLW  04
08268:  MOVLB  7
0826A:  MOVWF  xAF
0826C:  MOVLB  0
0826E:  CALL   327E
....................     writeString(0, 2, teststr4);  
08272:  MOVLB  7
08274:  CLRF   xC0
08276:  MOVLW  02
08278:  MOVWF  xC1
0827A:  MOVLW  07
0827C:  MOVWF  xC3
0827E:  MOVLW  7D
08280:  MOVWF  xC2
08282:  MOVLB  0
08284:  CALL   1338
....................     sprintf(teststr4,"%Lu  %Lu  %Lu  %Lu  ",DpHRedRaw,DpHGreenRaw,DpHBlueRaw,DpHWhiteRaw);     
08288:  MOVLW  07
0828A:  MOVLB  2
0828C:  MOVWF  x32
0828E:  MOVLW  7D
08290:  MOVWF  x31
08292:  MOVLW  10
08294:  MOVWF  FE9
08296:  MOVFF  2BF,7B0
0829A:  MOVFF  2BE,7AF
0829E:  MOVLB  0
082A0:  CALL   32A8
082A4:  MOVLW  20
082A6:  MOVLB  7
082A8:  MOVWF  xBC
082AA:  MOVLB  0
082AC:  CALL   1C42
082B0:  MOVLW  20
082B2:  MOVLB  7
082B4:  MOVWF  xBC
082B6:  MOVLB  0
082B8:  CALL   1C42
082BC:  MOVLW  10
082BE:  MOVWF  FE9
082C0:  MOVFF  2C1,7B0
082C4:  MOVFF  2C0,7AF
082C8:  CALL   32A8
082CC:  MOVLW  20
082CE:  MOVLB  7
082D0:  MOVWF  xBC
082D2:  MOVLB  0
082D4:  CALL   1C42
082D8:  MOVLW  20
082DA:  MOVLB  7
082DC:  MOVWF  xBC
082DE:  MOVLB  0
082E0:  CALL   1C42
082E4:  MOVLW  10
082E6:  MOVWF  FE9
082E8:  MOVFF  2C3,7B0
082EC:  MOVFF  2C2,7AF
082F0:  CALL   32A8
082F4:  MOVLW  20
082F6:  MOVLB  7
082F8:  MOVWF  xBC
082FA:  MOVLB  0
082FC:  CALL   1C42
08300:  MOVLW  20
08302:  MOVLB  7
08304:  MOVWF  xBC
08306:  MOVLB  0
08308:  CALL   1C42
0830C:  MOVLW  10
0830E:  MOVWF  FE9
08310:  MOVFF  2C5,7B0
08314:  MOVFF  2C4,7AF
08318:  CALL   32A8
0831C:  MOVLW  20
0831E:  MOVLB  7
08320:  MOVWF  xBC
08322:  MOVLB  0
08324:  CALL   1C42
08328:  MOVLW  20
0832A:  MOVLB  7
0832C:  MOVWF  xBC
0832E:  MOVLB  0
08330:  CALL   1C42
....................     writeString(0, 3, teststr4);     
08334:  MOVLB  7
08336:  CLRF   xC0
08338:  MOVLW  03
0833A:  MOVWF  xC1
0833C:  MOVLW  07
0833E:  MOVWF  xC3
08340:  MOVLW  7D
08342:  MOVWF  xC2
08344:  MOVLB  0
08346:  CALL   1338
....................     fprintf(BT,"NH4-DO RGBW %Lu  %Lu  %Lu  %Lu  DO Red  %Lu  WT %f  Raw %Lu\n\r",NHRedRaw,NHGreenRaw,NHBlueRaw,NHWhiteRaw,DOraw,sysOutput.wTemp,WTraw); 
0834A:  MOVLW  EA
0834C:  MOVWF  FF6
0834E:  MOVLW  10
08350:  MOVWF  FF7
08352:  MOVLW  0C
08354:  MOVLB  7
08356:  MOVWF  xA8
08358:  MOVLB  0
0835A:  CALL   5642
0835E:  MOVLW  10
08360:  MOVWF  FE9
08362:  MOVFF  2B7,7A9
08366:  MOVFF  2B6,7A8
0836A:  CALL   5A4C
0836E:  MOVLW  20
08370:  BTFSS  F9E.4
08372:  BRA    8370
08374:  MOVWF  FAD
08376:  MOVLW  20
08378:  BTFSS  F9E.4
0837A:  BRA    8378
0837C:  MOVWF  FAD
0837E:  MOVLW  10
08380:  MOVWF  FE9
08382:  MOVFF  2B9,7A9
08386:  MOVFF  2B8,7A8
0838A:  CALL   5A4C
0838E:  MOVLW  20
08390:  BTFSS  F9E.4
08392:  BRA    8390
08394:  MOVWF  FAD
08396:  MOVLW  20
08398:  BTFSS  F9E.4
0839A:  BRA    8398
0839C:  MOVWF  FAD
0839E:  MOVLW  10
083A0:  MOVWF  FE9
083A2:  MOVFF  2BB,7A9
083A6:  MOVFF  2BA,7A8
083AA:  CALL   5A4C
083AE:  MOVLW  20
083B0:  BTFSS  F9E.4
083B2:  BRA    83B0
083B4:  MOVWF  FAD
083B6:  MOVLW  20
083B8:  BTFSS  F9E.4
083BA:  BRA    83B8
083BC:  MOVWF  FAD
083BE:  MOVLW  10
083C0:  MOVWF  FE9
083C2:  MOVFF  2BD,7A9
083C6:  MOVFF  2BC,7A8
083CA:  CALL   5A4C
083CE:  MOVLW  08
083D0:  MOVWF  FF6
083D2:  MOVLW  11
083D4:  MOVWF  FF7
083D6:  MOVLW  0A
083D8:  MOVLB  7
083DA:  MOVWF  xA8
083DC:  MOVLB  0
083DE:  CALL   5642
083E2:  MOVLW  10
083E4:  MOVWF  FE9
083E6:  MOVFF  1AE,7A9
083EA:  MOVFF  1AD,7A8
083EE:  CALL   5A4C
083F2:  MOVLW  15
083F4:  MOVWF  FF6
083F6:  MOVLW  11
083F8:  MOVWF  FF7
083FA:  MOVLW  05
083FC:  MOVLB  7
083FE:  MOVWF  xA8
08400:  MOVLB  0
08402:  CALL   5642
08406:  MOVLW  89
08408:  MOVWF  FE9
0840A:  MOVFF  1D2,7AB
0840E:  MOVFF  1D1,7AA
08412:  MOVFF  1D0,7A9
08416:  MOVFF  1CF,7A8
0841A:  MOVLW  02
0841C:  MOVLB  7
0841E:  MOVWF  xAC
08420:  MOVLB  0
08422:  CALL   566C
08426:  MOVLW  1C
08428:  MOVWF  FF6
0842A:  MOVLW  11
0842C:  MOVWF  FF7
0842E:  MOVLW  06
08430:  MOVLB  7
08432:  MOVWF  xA8
08434:  MOVLB  0
08436:  CALL   5642
0843A:  MOVLW  10
0843C:  MOVWF  FE9
0843E:  MOVFF  1B0,7A9
08442:  MOVFF  1AF,7A8
08446:  CALL   5A4C
0844A:  MOVLW  0A
0844C:  BTFSS  F9E.4
0844E:  BRA    844C
08450:  MOVWF  FAD
08452:  MOVLW  0D
08454:  BTFSS  F9E.4
08456:  BRA    8454
08458:  MOVWF  FAD
....................         } 
0845A:  BRA    8466
0845C:  MOVLB  7
....................         else 
....................         { 
....................         return(0x02);    // exit the routine when the chip is not installed. 
0845E:  MOVLW  02
08460:  MOVWF  01
08462:  BRA    846A
08464:  MOVLB  0
....................         } 
08466:  BRA    80A6
08468:  MOVLB  7
....................     }    
0846A:  MOVLB  0
0846C:  GOTO   9080 (RETURN)
.................... } 
....................  
....................  
.................... //***************************************************************************** 
.................... // Create Fabuary 20, 2017 
.................... // This routine is used to test the CO2 board. 
.................... // It clears the display and sends the raw and calculated data to the display in real time. 
.................... // when the cable is pulled out, there is an error with the version number and then it releases back 
.................... // to the operating system to check for the next connection. 
.................... //  Returns no data other than the flag if nothing is connected 
.................... //***************************************************************************** 
.................... int TestCO2Board(void) 
.................... { 
....................      
....................     int16 returnedvalue,returnedresult; 
....................     float returnedresultit,titemp; 
....................     int struuu; 
....................      
....................     clearDisplay(); 
08470:  CALL   130C
....................     char teststr4[20]; 
....................     sprintf(teststr4,"  CO2/RH/Temp   "); 
08474:  MOVLW  07
08476:  MOVLB  2
08478:  MOVWF  x32
0847A:  MOVLW  7D
0847C:  MOVWF  x31
0847E:  MOVLW  28
08480:  MOVWF  FF6
08482:  MOVLW  11
08484:  MOVWF  FF7
08486:  MOVLB  0
08488:  CALL   1C64
....................     writeString(0, 0, teststr4); 
0848C:  MOVLB  7
0848E:  CLRF   xC0
08490:  CLRF   xC1
08492:  MOVLW  07
08494:  MOVWF  xC3
08496:  MOVLW  7D
08498:  MOVWF  xC2
0849A:  MOVLB  0
0849C:  CALL   1338
....................     while(1) 
....................     { 
....................         struuu = GetAnalogDONHFourVersion(0x01);   // this same routine is used for finding the ID code for all of the made boards.  The returned number is what makes it different. 
084A0:  MOVLW  01
084A2:  MOVLB  7
084A4:  MOVWF  xAF
084A6:  MOVLB  0
084A8:  CALL   38B4
084AC:  MOVFF  01,77C
....................         if (struuu == 0xd9) 
084B0:  MOVLB  7
084B2:  MOVF   x7C,W
084B4:  SUBLW  D9
084B6:  BTFSS  FD8.2
084B8:  BRA    85CA
....................         { 
.................... // this means the device is still plugged in.  Get the real-time temp and RH. 
....................              
....................         ReadRemoteDevice(0x01); // this selects the Top connector RJ45 device 
084BA:  MOVLW  01
084BC:  MOVWF  x91
084BE:  MOVLB  0
084C0:  CALL   783C
....................         moveReceivedData(0x00); 
084C4:  MOVLB  7
084C6:  CLRF   x91
084C8:  MOVLB  0
084CA:  CALL   7956
....................          
....................      sprintf(teststr4,"AT %f  RH  %f  ",sysOutput.aTemp,sysOutput.rH);    
084CE:  MOVLW  07
084D0:  MOVLB  2
084D2:  MOVWF  x32
084D4:  MOVLW  7D
084D6:  MOVWF  x31
084D8:  MOVLW  3A
084DA:  MOVWF  FF6
084DC:  MOVLW  11
084DE:  MOVWF  FF7
084E0:  MOVLW  03
084E2:  MOVLB  7
084E4:  MOVWF  xAF
084E6:  MOVLB  0
084E8:  CALL   327E
084EC:  MOVLW  89
084EE:  MOVWF  FE9
084F0:  MOVFF  211,7B2
084F4:  MOVFF  210,7B1
084F8:  MOVFF  20F,7B0
084FC:  MOVFF  20E,7AF
08500:  MOVLW  02
08502:  MOVLB  7
08504:  MOVWF  xB3
08506:  MOVLB  0
08508:  CALL   3446
0850C:  MOVLW  3F
0850E:  MOVWF  FF6
08510:  MOVLW  11
08512:  MOVWF  FF7
08514:  MOVLW  06
08516:  MOVLB  7
08518:  MOVWF  xAF
0851A:  MOVLB  0
0851C:  CALL   327E
08520:  MOVLW  89
08522:  MOVWF  FE9
08524:  MOVFF  209,7B2
08528:  MOVFF  208,7B1
0852C:  MOVFF  207,7B0
08530:  MOVFF  206,7AF
08534:  MOVLW  02
08536:  MOVLB  7
08538:  MOVWF  xB3
0853A:  MOVLB  0
0853C:  CALL   3446
08540:  MOVLW  20
08542:  MOVLB  7
08544:  MOVWF  xBC
08546:  MOVLB  0
08548:  CALL   1C42
0854C:  MOVLW  20
0854E:  MOVLB  7
08550:  MOVWF  xBC
08552:  MOVLB  0
08554:  CALL   1C42
....................     writeString(0, 1, teststr4); 
08558:  MOVLB  7
0855A:  CLRF   xC0
0855C:  MOVLW  01
0855E:  MOVWF  xC1
08560:  MOVLW  07
08562:  MOVWF  xC3
08564:  MOVLW  7D
08566:  MOVWF  xC2
08568:  MOVLB  0
0856A:  CALL   1338
....................       sprintf(teststr4,"CO2 %Lu    ",sysOutput.cO2);    
0856E:  MOVLW  07
08570:  MOVLB  2
08572:  MOVWF  x32
08574:  MOVLW  7D
08576:  MOVWF  x31
08578:  MOVLW  4A
0857A:  MOVWF  FF6
0857C:  MOVLW  11
0857E:  MOVWF  FF7
08580:  MOVLW  04
08582:  MOVLB  7
08584:  MOVWF  xAF
08586:  MOVLB  0
08588:  CALL   327E
0858C:  MOVLW  10
0858E:  MOVWF  FE9
08590:  MOVFF  213,7B0
08594:  MOVFF  212,7AF
08598:  CALL   32A8
0859C:  MOVLW  51
0859E:  MOVWF  FF6
085A0:  MOVLW  11
085A2:  MOVWF  FF7
085A4:  MOVLW  04
085A6:  MOVLB  7
085A8:  MOVWF  xAF
085AA:  MOVLB  0
085AC:  CALL   327E
....................     writeString(0, 3, teststr4);       
085B0:  MOVLB  7
085B2:  CLRF   xC0
085B4:  MOVLW  03
085B6:  MOVWF  xC1
085B8:  MOVLW  07
085BA:  MOVWF  xC3
085BC:  MOVLW  7D
085BE:  MOVWF  xC2
085C0:  MOVLB  0
085C2:  CALL   1338
....................         } 
085C6:  BRA    85D2
085C8:  MOVLB  7
....................         else 
....................         { 
....................         return(0x02);    // exit the routine when the chip is not installed. 
085CA:  MOVLW  02
085CC:  MOVWF  01
085CE:  BRA    85D6
085D0:  MOVLB  0
....................         } 
085D2:  BRA    84A0
085D4:  MOVLB  7
....................     }    
085D6:  MOVLB  0
085D8:  GOTO   9096 (RETURN)
.................... } 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Feb 18, 2017 
.................... // This routine inits all of the levels for the linear array chip to measure the mercury theomoeter 
.................... // Returns nothing 
.................... //****************************************************************************** 
.................... void linearinit(void) 
.................... { 
....................      
....................     //  Set up the output for the controls Si and CLK 
....................     output_low(PIN_A4); 
*
011D0:  BCF    F92.4
011D2:  BCF    F89.4
....................     // set up the output for the clock 
....................     output_low(PIN_A5); 
011D4:  BCF    F92.5
011D6:  BCF    F89.5
011D8:  GOTO   8FA0 (RETURN)
....................      
....................      
....................      
.................... } 
....................  
.................... //****************************************************************************** 
.................... // Created Feb 18, 2017 
.................... // this routine makes the exposure for the linear array and then places a reading in  
.................... // an array for comparing to the scaling.  It also does level detention and scaling for high 
.................... // and low levels. 
.................... // It returns 0 if there is no problem 
.................... // A 1 is returned if there is a fault 
.................... //***************************************************************************** 
.................... int readlineararray(void) 
*
041FE:  MOVLB  7
04200:  CLRF   x92
04202:  CLRF   x91
04204:  MOVLW  04
04206:  MOVWF  x94
04208:  CLRF   x93
.................... { 
....................     int x; 
....................     unsigned int16 maxvalue = 0; 
....................     unsigned int16 minvalue = 1024; 
....................     char teststr2[20]; 
....................     
....................     set_adc_channel(0x01); 
0420A:  MOVWF  01
0420C:  MOVF   FC2,W
0420E:  ANDLW  83
04210:  IORWF  01,W
04212:  MOVWF  FC2
....................         delay_us(10); 
04214:  MOVLW  10
04216:  MOVWF  00
04218:  DECFSZ 00,F
0421A:  BRA    4218
0421C:  NOP   
....................         output_high(PIN_A4);  // SI 
0421E:  BCF    F92.4
04220:  BSF    F89.4
....................         output_high(PIN_A5);  // clock 
04222:  BCF    F92.5
04224:  BSF    F89.5
....................         delay_us(10);//delay 
04226:  MOVLW  10
04228:  MOVWF  00
0422A:  DECFSZ 00,F
0422C:  BRA    422A
0422E:  NOP   
....................         output_low(PIN_A4);  // SI 
04230:  BCF    F92.4
04232:  BCF    F89.4
....................     for (x=0; x < 128; x++)  // loop through all of the clock cycles and recored the ADV from AN1 value 
04234:  CLRF   x90
04236:  MOVF   x90,W
04238:  SUBLW  7F
0423A:  BNC   4266
....................     { 
....................         output_low(PIN_A5); 
0423C:  BCF    F92.5
0423E:  BCF    F89.5
....................          reading[x]= read_adc(); // Read adc channel 1   
04240:  BCF    FD8.0
04242:  RLCF   x90,W
04244:  CLRF   03
04246:  ADDLW  A6
04248:  MOVWF  FE9
0424A:  MOVLW  00
0424C:  ADDWFC 03,W
0424E:  MOVWF  FEA
04250:  BSF    FC2.1
04252:  BTFSC  FC2.1
04254:  BRA    4252
04256:  MOVFF  FC3,FEF
0425A:  MOVFF  FC4,FEC
....................         //delay_us(5);  // delay for exposure? 
....................         output_high(PIN_A5); 
0425E:  BCF    F92.5
04260:  BSF    F89.5
04262:  INCF   x90,F
04264:  BRA    4236
....................     } 
....................         output_low(PIN_A4);  // when done, set low 
04266:  BCF    F92.4
04268:  BCF    F89.4
....................         output_low(PIN_A5);    // when done, set low     
0426A:  BCF    F92.5
0426C:  BCF    F89.5
....................      
....................          
.................... // Find the min and max value in the array. 
....................         for (x=0; x < 128; x++) 
0426E:  CLRF   x90
04270:  MOVF   x90,W
04272:  SUBLW  7F
04274:  BNC   42FE
....................         { 
....................             if (reading[x] < minvalue) 
04276:  BCF    FD8.0
04278:  RLCF   x90,W
0427A:  CLRF   03
0427C:  ADDLW  A6
0427E:  MOVWF  FE9
04280:  MOVLW  00
04282:  ADDWFC 03,W
04284:  MOVWF  FEA
04286:  MOVFF  FEC,7AA
0428A:  MOVF   FED,F
0428C:  MOVFF  FEF,7A9
04290:  MOVF   xAA,W
04292:  SUBWF  x94,W
04294:  BNC   42B8
04296:  BNZ   429E
04298:  MOVF   x93,W
0429A:  SUBWF  xA9,W
0429C:  BC    42B8
....................                 minvalue = reading[x];  // then new min value is set 
0429E:  BCF    FD8.0
042A0:  RLCF   x90,W
042A2:  CLRF   03
042A4:  ADDLW  A6
042A6:  MOVWF  FE9
042A8:  MOVLW  00
042AA:  ADDWFC 03,W
042AC:  MOVWF  FEA
042AE:  MOVFF  FEC,794
042B2:  MOVF   FED,F
042B4:  MOVFF  FEF,793
....................               if (reading[x] > maxvalue) 
042B8:  BCF    FD8.0
042BA:  RLCF   x90,W
042BC:  CLRF   03
042BE:  ADDLW  A6
042C0:  MOVWF  FE9
042C2:  MOVLW  00
042C4:  ADDWFC 03,W
042C6:  MOVWF  FEA
042C8:  MOVFF  FEC,7AA
042CC:  MOVF   FED,F
042CE:  MOVFF  FEF,7A9
042D2:  MOVF   x92,W
042D4:  SUBWF  xAA,W
042D6:  BNC   42FA
042D8:  BNZ   42E0
042DA:  MOVF   xA9,W
042DC:  SUBWF  x91,W
042DE:  BC    42FA
....................                 maxvalue = reading[x];  // then new min value is set           
042E0:  BCF    FD8.0
042E2:  RLCF   x90,W
042E4:  CLRF   03
042E6:  ADDLW  A6
042E8:  MOVWF  FE9
042EA:  MOVLW  00
042EC:  ADDWFC 03,W
042EE:  MOVWF  FEA
042F0:  MOVFF  FEC,792
042F4:  MOVF   FED,F
042F6:  MOVFF  FEF,791
042FA:  INCF   x90,F
042FC:  BRA    4270
....................         } 
....................   //     sprintf(teststr2,"%Lu   %Lu    ",maxvalue,minvalue); 
....................  //      writeString(0, 3, teststr2);         
....................         //remove the minvalue from the whole array 
....................         for (x=0; x < 128; x++) 
042FE:  CLRF   x90
04300:  MOVF   x90,W
04302:  SUBLW  7F
04304:  BNC   4350
....................         { 
....................             reading[x] = reading[x] - minvalue; 
04306:  BCF    FD8.0
04308:  RLCF   x90,W
0430A:  CLRF   03
0430C:  ADDLW  A6
0430E:  MOVWF  01
04310:  MOVLW  00
04312:  ADDWFC 03,F
04314:  MOVFF  03,7AA
04318:  BCF    FD8.0
0431A:  RLCF   x90,W
0431C:  CLRF   03
0431E:  ADDLW  A6
04320:  MOVWF  FE9
04322:  MOVLW  00
04324:  ADDWFC 03,W
04326:  MOVWF  FEA
04328:  MOVFF  FEC,7AC
0432C:  MOVF   FED,F
0432E:  MOVFF  FEF,7AB
04332:  MOVF   x93,W
04334:  SUBWF  xAB,W
04336:  MOVWF  00
04338:  MOVF   x94,W
0433A:  SUBWFB xAC,W
0433C:  MOVFF  7AA,FEA
04340:  MOVFF  01,FE9
04344:  MOVWF  FEC
04346:  MOVF   FED,F
04348:  MOVFF  00,FEF
0434C:  INCF   x90,F
0434E:  BRA    4300
....................         }     
....................         maxvalue = (maxvalue - minvalue); 
04350:  MOVF   x93,W
04352:  SUBWF  x91,F
04354:  MOVF   x94,W
04356:  SUBWFB x92,F
....................          
....................  //      sprintf(teststr2,"%Lu   ",maxvalue); 
....................  //      writeString(0, 2, teststr2);  
....................         
....................         
....................         displaybar(maxvalue, 2); 
04358:  MOVFF  791,7A9
0435C:  MOVLW  02
0435E:  MOVWF  xAA
04360:  MOVLB  0
04362:  BRA    4180
....................          
....................      
....................          
....................     return(0); 
04364:  MOVLW  00
04366:  MOVWF  01
04368:  GOTO   43DC (RETURN)
.................... } 
....................  
.................... void main(void) { 
*
08C9A:  CLRF   FF8
08C9C:  BCF    FD0.7
08C9E:  BSF    07.7
08CA0:  MOVLB  1
08CA2:  CLRF   xA6
08CA4:  CLRF   xA7
08CA6:  BCF    xA8.0
08CA8:  CLRF   xA9
08CAA:  CLRF   xAA
08CAC:  BSF    FB8.3
08CAE:  MOVLW  08
08CB0:  MOVWF  FAF
08CB2:  MOVLW  02
08CB4:  MOVWF  FB0
08CB6:  MOVLW  A6
08CB8:  MOVWF  FAC
08CBA:  MOVLW  90
08CBC:  MOVWF  FAB
08CBE:  MOVLB  2
08CC0:  CLRF   x28
08CC2:  CLRF   x32
08CC4:  CLRF   x31
08CC6:  CLRF   xC6
08CC8:  MOVLB  4
08CCA:  CLRF   x52
08CCC:  CLRF   x53
08CCE:  MOVLB  6
08CD0:  CLRF   x23
08CD2:  CLRF   x22
08CD4:  CLRF   x25
08CD6:  CLRF   x24
08CD8:  CLRF   x72
08CDA:  CLRF   x71
08CDC:  MOVLW  20
08CDE:  MOVWF  x70
08CE0:  MOVLW  84
08CE2:  MOVWF  x6F
08CE4:  CLRF   x76
08CE6:  MOVLW  A0
08CE8:  MOVWF  x75
08CEA:  MOVLW  20
08CEC:  MOVWF  x74
08CEE:  MOVLW  8B
08CF0:  MOVWF  x73
08CF2:  CLRF   x7A
08CF4:  CLRF   x79
08CF6:  MOVLW  20
08CF8:  MOVWF  x78
08CFA:  MOVLW  83
08CFC:  MOVWF  x77
08CFE:  CLRF   x7E
08D00:  MOVLW  D0
08D02:  MOVWF  x7D
08D04:  MOVLW  36
08D06:  MOVWF  x7C
08D08:  MOVLW  8C
08D0A:  MOVWF  x7B
08D0C:  CLRF   x82
08D0E:  CLRF   x81
08D10:  MOVLW  40
08D12:  MOVWF  x80
08D14:  MOVLW  81
08D16:  MOVWF  x7F
08D18:  CLRF   x86
08D1A:  MOVLW  B4
08D1C:  MOVWF  x85
08D1E:  MOVLW  28
08D20:  MOVWF  x84
08D22:  MOVLW  8D
08D24:  MOVWF  x83
08D26:  MOVLB  F
08D28:  CLRF   x38
08D2A:  CLRF   x39
08D2C:  CLRF   x3A
08D2E:  CLRF   x3B
08D30:  CLRF   x3C
08D32:  MOVLB  1
08D34:  CLRF   x88
08D36:  CLRF   F77
08D38:  CLRF   F78
08D3A:  CLRF   F79
08D3C:  BRA    8EDE
08D3E:  DATA 02,00
08D40:  DATA 19,00
08D42:  DATA 00,01
08D44:  DATA 04,54
08D46:  DATA 3F,0A
08D48:  DATA C0,00
08D4A:  DATA 07,80
08D4C:  DATA 64,69
08D4E:  DATA 73,70
08D50:  DATA 6C,61
08D52:  DATA 79,04
08D54:  DATA C0,00
08D56:  DATA 03,80
08D58:  DATA 73,65
08D5A:  DATA 74,08
08D5C:  DATA C0,00
08D5E:  DATA 07,80
08D60:  DATA 64,65
08D62:  DATA 66,61
08D64:  DATA 75,6C
08D66:  DATA 74,04
08D68:  DATA C0,00
08D6A:  DATA 1C,80
08D6C:  DATA 73,68
08D6E:  DATA 6F,77
08D70:  DATA 63,6F
08D72:  DATA 6E,66
08D74:  DATA 69,67
08D76:  DATA 00,73
08D78:  DATA 61,76
08D7A:  DATA 65,63
08D7C:  DATA 6F,6E
08D7E:  DATA 66,69
08D80:  DATA 67,00
08D82:  DATA 75,70
08D84:  DATA 64,61
08D86:  DATA 74,65
08D88:  DATA 05,C0
08D8A:  DATA 00,04
08D8C:  DATA 80,72
08D8E:  DATA 73,74
08D90:  DATA 00,03
08D92:  DATA 04,AC
08D94:  DATA 70,70
08D96:  DATA 68,08
08D98:  DATA C0,00
08D9A:  DATA 02,80
08D9C:  DATA 61,74
08D9E:  DATA 09,C0
08DA0:  DATA 00,02
08DA2:  DATA 80,64
08DA4:  DATA 6F,09
08DA6:  DATA C0,00
08DA8:  DATA 02,80
08DAA:  DATA 70,68
08DAC:  DATA 09,C0
08DAE:  DATA 00,02
08DB0:  DATA 80,77
08DB2:  DATA 64,09
08DB4:  DATA C0,00
08DB6:  DATA 06,80
08DB8:  DATA 70,68
08DBA:  DATA 62,75
08DBC:  DATA 6C,62
08DBE:  DATA 05,C0
08DC0:  DATA 00,05
08DC2:  DATA 80,63
08DC4:  DATA 6C,65
08DC6:  DATA 61,72
08DC8:  DATA 06,C0
08DCA:  DATA 00,03
08DCC:  DATA 80,6C
08DCE:  DATA 75,78
08DD0:  DATA 08,C0
08DD2:  DATA 00,02
08DD4:  DATA 80,65
08DD6:  DATA 63,09
08DD8:  DATA C0,00
08DDA:  DATA 03,80
08DDC:  DATA 63,6F
08DDE:  DATA 32,08
08DE0:  DATA C0,00
08DE2:  DATA 02,80
08DE4:  DATA 77,74
08DE6:  DATA 09,C0
08DE8:  DATA 00,03
08DEA:  DATA 80,70
08DEC:  DATA 61,72
08DEE:  DATA 08,C0
08DF0:  DATA 00,03
08DF2:  DATA 80,6E
08DF4:  DATA 68,34
08DF6:  DATA 08,C0
08DF8:  DATA 00,07
08DFA:  DATA 80,72
08DFC:  DATA 65,74
08DFE:  DATA 6E,68
08E00:  DATA 34,31
08E02:  DATA 04,C0
08E04:  DATA 00,07
08E06:  DATA 80,72
08E08:  DATA 65,74
08E0A:  DATA 6E,68
08E0C:  DATA 34,32
08E0E:  DATA 04,C0
08E10:  DATA 00,07
08E12:  DATA 80,72
08E14:  DATA 65,74
08E16:  DATA 6E,68
08E18:  DATA 34,33
08E1A:  DATA 04,C0
08E1C:  DATA 00,06
08E1E:  DATA 80,6E
08E20:  DATA 68,34
08E22:  DATA 70,74
08E24:  DATA 31,05
08E26:  DATA C0,00
08E28:  DATA 06,80
08E2A:  DATA 6E,68
08E2C:  DATA 34,70
08E2E:  DATA 74,32
08E30:  DATA 05,C0
08E32:  DATA 00,06
08E34:  DATA 80,6E
08E36:  DATA 68,34
08E38:  DATA 70,74
08E3A:  DATA 33,05
08E3C:  DATA C0,00
08E3E:  DATA 06,80
08E40:  DATA 6E,68
08E42:  DATA 34,70
08E44:  DATA 74,34
08E46:  DATA 05,C0
08E48:  DATA 00,06
08E4A:  DATA 80,6E
08E4C:  DATA 68,34
08E4E:  DATA 70,74
08E50:  DATA 35,05
08E52:  DATA C0,00
08E54:  DATA 06,80
08E56:  DATA 6E,68
08E58:  DATA 34,70
08E5A:  DATA 74,36
08E5C:  DATA 05,C0
08E5E:  DATA 00,06
08E60:  DATA 80,6E
08E62:  DATA 68,34
08E64:  DATA 70,74
08E66:  DATA 37,05
08E68:  DATA C0,00
08E6A:  DATA 06,80
08E6C:  DATA 6E,68
08E6E:  DATA 34,70
08E70:  DATA 74,38
08E72:  DATA 05,C0
08E74:  DATA 00,06
08E76:  DATA 80,6E
08E78:  DATA 68,34
08E7A:  DATA 70,74
08E7C:  DATA 39,05
08E7E:  DATA C0,00
08E80:  DATA 05,80
08E82:  DATA 44,4F
08E84:  DATA 70,74
08E86:  DATA 31,06
08E88:  DATA C0,00
08E8A:  DATA 05,80
08E8C:  DATA 44,4F
08E8E:  DATA 70,74
08E90:  DATA 32,06
08E92:  DATA C0,00
08E94:  DATA 05,80
08E96:  DATA 44,4F
08E98:  DATA 70,74
08E9A:  DATA 33,06
08E9C:  DATA C0,00
08E9E:  DATA 05,80
08EA0:  DATA 44,4F
08EA2:  DATA 70,74
08EA4:  DATA 34,06
08EA6:  DATA C0,00
08EA8:  DATA 05,80
08EAA:  DATA 44,4F
08EAC:  DATA 70,74
08EAE:  DATA 35,06
08EB0:  DATA C0,00
08EB2:  DATA 05,80
08EB4:  DATA 44,4F
08EB6:  DATA 70,74
08EB8:  DATA 36,06
08EBA:  DATA C0,00
08EBC:  DATA 05,80
08EBE:  DATA 44,4F
08EC0:  DATA 70,74
08EC2:  DATA 37,06
08EC4:  DATA C0,00
08EC6:  DATA 05,80
08EC8:  DATA 44,4F
08ECA:  DATA 70,74
08ECC:  DATA 38,06
08ECE:  DATA C0,00
08ED0:  DATA 06,80
08ED2:  DATA 44,4F
08ED4:  DATA 70,74
08ED6:  DATA 39,00
08ED8:  DATA 01,06
08EDA:  DATA 66,00
08EDC:  DATA 00,00
08EDE:  MOVLW  00
08EE0:  MOVWF  FF8
08EE2:  MOVLW  8D
08EE4:  MOVWF  FF7
08EE6:  MOVLW  3E
08EE8:  MOVWF  FF6
08EEA:  TBLRD*+
08EEC:  MOVF   FF5,W
08EEE:  MOVWF  00
08EF0:  XORLW  00
08EF2:  BZ    8F1A
08EF4:  TBLRD*+
08EF6:  MOVF   FF5,W
08EF8:  MOVWF  01
08EFA:  BTFSC  FE8.7
08EFC:  BRA    8F08
08EFE:  ANDLW  0F
08F00:  MOVWF  FEA
08F02:  TBLRD*+
08F04:  MOVFF  FF5,FE9
08F08:  BTFSC  01.6
08F0A:  TBLRD*+
08F0C:  BTFSS  01.6
08F0E:  TBLRD*+
08F10:  MOVFF  FF5,FEE
08F14:  DCFSNZ 00,F
08F16:  BRA    8EEA
08F18:  BRA    8F0C
08F1A:  CLRF   FF8
....................     //i2c_init(TRUE); 
....................  
....................     int8 adcStrCntr; 
....................     char teststr2[10]; 
....................     int8 deviceid,deviceidreturn;  // this is device ID that indicates what's plugged in.  A 1 means no device is plugged in. 
....................     float tempvar; 
....................     int16 tempvarint; 
....................     BTnext_in = 0; 
08F1C:  MOVLB  6
08F1E:  CLRF   x23
08F20:  CLRF   x22
....................     BTnext_out = 0; 
08F22:  CLRF   x25
08F24:  CLRF   x24
....................  
....................  
....................     sysInput.eccal1x = 4000.0; //  This the EC data point  Added July 18, 2016 
08F26:  MOVLB  2
08F28:  CLRF   x90
08F2A:  CLRF   x8F
08F2C:  MOVLW  7A
08F2E:  MOVWF  x8E
08F30:  MOVLW  8A
08F32:  MOVWF  x8D
....................     sysInput.eccal2x = 1100.0; //  This the EC data point  Added July 18, 2016 
08F34:  CLRF   x94
08F36:  MOVLW  80
08F38:  MOVWF  x93
08F3A:  MOVLW  09
08F3C:  MOVWF  x92
08F3E:  MOVLW  89
08F40:  MOVWF  x91
....................     sysInput.eccal3x = 200.0; //  This the EC data point  Added July 18, 2016 
08F42:  CLRF   x98
08F44:  CLRF   x97
08F46:  MOVLW  48
08F48:  MOVWF  x96
08F4A:  MOVLW  86
08F4C:  MOVWF  x95
....................     sysInput.eccal1y = 150.0; //  This the EC data point  Added July 18, 2016 
08F4E:  CLRF   x9C
08F50:  CLRF   x9B
08F52:  MOVLW  16
08F54:  MOVWF  x9A
08F56:  MOVLW  86
08F58:  MOVWF  x99
....................     sysInput.eccal2y = 603.0; //  This the EC data point  Added July 18, 2016 
08F5A:  CLRF   xA0
08F5C:  MOVLW  C0
08F5E:  MOVWF  x9F
08F60:  MOVLW  16
08F62:  MOVWF  x9E
08F64:  MOVLW  88
08F66:  MOVWF  x9D
....................     sysInput.eccal3y = 10000.0; //  This the EC data point  Added July 18, 2016 
08F68:  CLRF   xA4
08F6A:  MOVLW  40
08F6C:  MOVWF  xA3
08F6E:  MOVLW  1C
08F70:  MOVWF  xA2
08F72:  MOVLW  8C
08F74:  MOVWF  xA1
....................  
....................     sysInput.phcallow = 250; 
08F76:  CLRF   x36
08F78:  CLRF   x35
08F7A:  MOVLW  7A
08F7C:  MOVWF  x34
08F7E:  MOVLW  86
08F80:  MOVWF  x33
....................     sysInput.phcalhigh = 500; 
08F82:  CLRF   x3A
08F84:  CLRF   x39
08F86:  MOVLW  7A
08F88:  MOVWF  x38
08F8A:  MOVLW  87
08F8C:  MOVWF  x37
....................     sysInput.phnumberupper = 10; 
08F8E:  CLRF   x3E
08F90:  CLRF   x3D
08F92:  MOVLW  20
08F94:  MOVWF  x3C
08F96:  MOVLW  82
08F98:  MOVWF  x3B
....................  
....................     linearinit(); 
08F9A:  MOVLB  0
08F9C:  GOTO   11D0
....................     initDispIO(); 
08FA0:  GOTO   11DC
....................     delay_ms(2000);    /// delay the display from coming up or the CPU will not stay booted. 
08FA4:  MOVLW  08
08FA6:  MOVLB  7
08FA8:  MOVWF  x70
08FAA:  MOVLW  FA
08FAC:  MOVWF  xC1
08FAE:  MOVLB  0
08FB0:  CALL   11F0
08FB4:  MOVLB  7
08FB6:  DECFSZ x70,F
08FB8:  BRA    8FAA
....................     initDisplay();     
08FBA:  MOVLB  0
08FBC:  GOTO   12AE
....................     splash(); 
08FC0:  GOTO   13A8
....................  
....................     //************************************************** 
....................     // Created Nov 22, 2106 
....................     // Get the saved configurations from the EEPROM and put them in local variables. 
....................     //************************************************** 
....................     selectitem = getlocalconfigurations(); // this gets the items for local configuration 
08FC4:  GOTO   1526
08FC8:  MOVFF  02,225
08FCC:  MOVFF  01,224
....................     LoadConfigurations(); 
08FD0:  GOTO   15E0
....................     fprintf(BT, "Command Line Processor\r\n>"); 
08FD4:  MOVLW  56
08FD6:  MOVWF  FF6
08FD8:  MOVLW  11
08FDA:  MOVWF  FF7
08FDC:  CALL   1C20
....................     fprintf(BT, "Press ? and CR for a list of commands\r\n>"); 
08FE0:  MOVLW  70
08FE2:  MOVWF  FF6
08FE4:  MOVLW  11
08FE6:  MOVWF  FF7
08FE8:  CALL   1C20
....................       
....................     setup_adc_ports(sAN0|sAN1|sAN2|sAN3|VSS_VDD);   // AN1 is the linear array 
08FEC:  MOVF   FC1,W
08FEE:  ANDLW  F0
08FF0:  MOVWF  FC1
08FF2:  MOVLW  0F
08FF4:  MOVLB  F
08FF6:  MOVWF  x38
08FF8:  MOVLW  00
08FFA:  MOVWF  x3C
08FFC:  MOVWF  x39
08FFE:  MOVWF  x3A
09000:  MOVWF  x3B
....................     setup_adc(ADC_CLOCK_INTERNAL); 
09002:  MOVF   FC0,W
09004:  ANDLW  C0
09006:  IORLW  07
09008:  MOVWF  FC0
0900A:  BSF    FC0.7
0900C:  BSF    FC2.0
....................     enable_interrupts(GLOBAL); 
0900E:  MOVLW  C0
09010:  IORWF  FF2,F
....................     enable_interrupts(INT_RDA); //This starts up s the Blue tooth module enterupt for taking in charters.  Added July 8, 2015 
09012:  BSF    F9D.5
....................  
....................      
....................    //************************************************************************ 
....................    // Added Jan 23, 2017 
....................    // This routine cycles through all of the possible i2c devices to determine which one is plugged in. 
....................    //************************************************************************ 
....................    deviceidreturn=0x02; 
09014:  MOVLW  02
09016:  MOVLB  7
09018:  MOVWF  x69
....................     
....................   // this is used for debugging and building new routines 
....................  //  while(1) 
....................  //  { 
....................  //       readlineararray(); 
....................        // sprintf(teststr2,"%x",deviceid); 
....................        // writeString(0, 0, teststr2); 
....................      //   delay_ms(100); 
....................          
....................  //  } 
....................    
....................     
....................    while(1)    
....................    { 
....................     deviceid = FindRJ45Device(0x01,deviceidreturn); 
0901A:  MOVLW  01
0901C:  MOVWF  x70
0901E:  MOVFF  769,771
09022:  MOVLB  0
09024:  GOTO   3A40
09028:  MOVFF  01,768
....................     deviceidreturn = deviceid; 
0902C:  MOVFF  768,769
....................     if (deviceid==0x22) 
09030:  MOVLB  7
09032:  MOVF   x68,W
09034:  SUBLW  22
09036:  BNZ   9048
....................     {  
....................        deviceid = TestRHTemp(); 
09038:  MOVLB  0
0903A:  GOTO   436C
0903E:  MOVFF  01,768
....................        deviceidreturn = deviceid; 
09042:  MOVFF  768,769
09046:  MOVLB  7
....................     } 
....................      
....................     if (deviceid==0x23) 
09048:  MOVF   x68,W
0904A:  SUBLW  23
0904C:  BNZ   905E
....................     { 
....................        deviceid = TestPARchip(); 
0904E:  MOVLB  0
09050:  GOTO   4D0A
09054:  MOVFF  01,768
....................        deviceidreturn = deviceid; 
09058:  MOVFF  768,769
0905C:  MOVLB  7
....................     } 
....................      
....................     if (deviceid==0x24)  // this is for Analog DO and NH4 
0905E:  MOVF   x68,W
09060:  SUBLW  24
09062:  BNZ   9074
....................     { 
....................        deviceid = TestAnalogDONHFourBoard(); 
09064:  MOVLB  0
09066:  GOTO   7EF2
0906A:  MOVFF  01,768
....................        deviceidreturn = deviceid; 
0906E:  MOVFF  768,769
09072:  MOVLB  7
....................     } 
....................     if (deviceid==0x25)  // this is for Analog DO and NH4 
09074:  MOVF   x68,W
09076:  SUBLW  25
09078:  BNZ   908A
....................     { 
....................        deviceid = TestDigitalDONHFourBoard(); 
0907A:  MOVLB  0
0907C:  GOTO   80A2
09080:  MOVFF  01,768
....................        deviceidreturn = deviceid; 
09084:  MOVFF  768,769
09088:  MOVLB  7
....................     } 
....................     if (deviceid==0x26)  // this is for Analog DO and NH4 
0908A:  MOVF   x68,W
0908C:  SUBLW  26
0908E:  BNZ   90A0
....................     { 
....................        deviceid = TestCO2Board(); 
09090:  MOVLB  0
09092:  GOTO   8470
09096:  MOVFF  01,768
....................        deviceidreturn = deviceid; 
0909A:  MOVFF  768,769
0909E:  MOVLB  7
....................     } 
....................     BTTestEvent(); // check for the data coming back to display    
090A0:  MOVLB  0
090A2:  CALL   77A2
....................     BTTestEvent(); // check for the data coming back to display  
090A6:  CALL   77A2
....................     BTTestEvent(); // check for the data coming back to display    
090AA:  CALL   77A2
....................     BTTestEvent(); // check for the data coming back to display  
090AE:  CALL   77A2
....................     BTTestEvent(); // check for the data coming back to display    
090B2:  CALL   77A2
....................     BTTestEvent(); // check for the data coming back to display  
090B6:  CALL   77A2
....................      
....................      
....................     //************************************************************************** 
....................     // Update Feb 11, 2017 
....................     // This section takes the global flag for startupdate and sends the lateset varaibel configuration to the remote devie. 
....................     // There needs to be an added check the remote device is attached. 
....................     //  It needs to be read back and confirmed after sending it to the remote device, saving it in EEPROM, re-read from EEPROM and sent back to this host. 
....................     //  1  Send data to remote device 
....................     //  2  Save varaible data in remote EEPROM device 
....................     //  3  re-read the data from the EEPROM in the remote device 
....................     //  4  send it back to this host 
....................     //  5  Compare it with the orginal data 
....................     //  6  Send an error if there is a difference. 
....................     //************************************************************************** 
....................         if (startupdate) 
090BA:  MOVLB  2
090BC:  MOVF   x28,F
090BE:  BZ    90F4
....................         { 
....................           //  while(1) 
....................          //   { 
....................                 stuffit = 1069; 
090C0:  MOVLW  04
090C2:  MOVWF  x27
090C4:  MOVLW  2D
090C6:  MOVWF  x26
....................                 startupdate = 0;  // this sets the flag to do an update to the remote unit when all data polling is completed. 
090C8:  CLRF   x28
....................                 fprintf(BT,"Sending Updated Configurations\n\r"); 
090CA:  MOVLW  9A
090CC:  MOVWF  FF6
090CE:  MOVLW  11
090D0:  MOVWF  FF7
090D2:  MOVLB  0
090D4:  CALL   1C20
....................                 sendConfigData(0x01, 0x03);   //device 1 or the top connector 
090D8:  MOVLW  01
090DA:  MOVLB  7
090DC:  MOVWF  x70
090DE:  MOVLW  03
090E0:  MOVWF  x71
090E2:  MOVLB  0
090E4:  GOTO   85DC
....................                 fprintf(BT,"Update Completed\r\n"); 
090E8:  MOVLW  BC
090EA:  MOVWF  FF6
090EC:  MOVLW  11
090EE:  MOVWF  FF7
090F0:  CALL   1C20
....................          //   } 
....................         } 
090F4:  MOVLB  7
090F6:  BRA    901A
....................      
....................    } 
....................      
....................      
....................      
....................     /* 
....................     while (1) { 
....................  
....................         //unsigned int16 adcVal=read_adc(); 
....................     //    float adcVal = ConvertADCTophBulb(); 
....................     //    float voltage = (5 * (float) adcVal / ADCREZ); 
....................  
....................         BTTestEvent(); // check for the data coming back to display 
....................         BTTestEvent(); // check for the data coming back to display 
....................         BTTestEvent(); // check for the data coming back to display 
....................       //  sysOutput.pH = CalculatepH(adcVal); // enter the adc and make a ph value 
....................  
....................      //   ReadRemoteDevice(0x00); // this selects the internal digital DO and NH4 sensor board 
....................      //   moveReceivedData(0x00); 
....................         //CalculateCRC(); 
....................         ReadRemoteDevice(0x01); // this selects the Top connector RJ45 device 
....................         moveReceivedData(0x00); 
....................         //if (!CalculateCRC()) 
....................         //   { 
....................  
....................  
....................         //  tempvarint = rec_buffer[7]; 
....................         //   tempvarint = tempvarint*256 + rec_buffer[8]; 
....................         //  if (tempvarint >= 0.0) 
....................         //       sysOutput.cO2 = tempvarint; 
....................  
....................         //  tempvar = (float) rec_buffer[9]; 
....................         //  sysOutput.aTemp = tempvar  + ((float) rec_buffer[10])/100; 
....................         //   tempvar = (float) rec_buffer[11]; 
....................         //   sysOutput.rh = tempvar  + ((float) rec_buffer[12])/100;   
....................  
....................  
....................         //*********************************************************** 
....................         // Created Nov 22, 2016 
....................         // This area displays the requested latest varaibles on the VFD.   
....................         //*********************************************************** 
....................         displayselecteddata(selectitem); 
....................  
....................         //} 
....................  
....................  
....................      
....................     } */ 
.................... } 
090F8:  BRA    90F8

Configuration Fuses:
   Word  1: E200   HSH NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 3C19   NOPUT NOBROWNOUT BORV19 NOWDT WDT32768
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0000   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
