CCS PCH C Compiler, Version 5.045, 35992               06-Apr-17 14:57

               Filename:   C:\Aquarium Software\Debug Monitor\OsmobotTester.X\build\default\production\_ext\1472\main.lst

               ROM used:   37140 bytes (57%)
                           Largest free fragment is 28392
               RAM used:   1905 (49%) at main() level
                           2038 (52%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 30

*
00000:  GOTO   8CB8
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  F9D.5
00056:  GOTO   0060
0005A:  BTFSC  F9E.5
0005C:  GOTO   0FB2
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVFF  15,FF5
0009A:  MOVFF  16,FF6
0009E:  MOVFF  17,FF7
000A2:  MOVF   04,W
000A4:  MOVFF  06,FE0
000A8:  MOVFF  05,FD8
000AC:  RETFIE 0
.................... // Debug Display Sensor Main.c file 
.................... #include <18F46k22.h> 
.................... //////////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F46K22 
000AE:  DATA 44,4F
000B0:  DATA 20,25
000B2:  DATA 4C,75
000B4:  DATA 20,25
000B6:  DATA 66,20
000B8:  DATA 20,00
000BA:  DATA 57,54
000BC:  DATA 20,25
000BE:  DATA 4C,75
000C0:  DATA 20,20
000C2:  DATA 25,66
000C4:  DATA 20,20
000C6:  DATA 20,00
000C8:  DATA 4E,48
000CA:  DATA 34,20
000CC:  DATA 25,4C
000CE:  DATA 75,20
000D0:  DATA 20,25
000D2:  DATA 66,00
000D4:  DATA 43,4F
000D6:  DATA 32,20
000D8:  DATA 25,4C
000DA:  DATA 75,20
000DC:  DATA 70,70
000DE:  DATA 6D,00
000E0:  DATA 41,54
000E2:  DATA 2B,52
000E4:  DATA 48,20
000E6:  DATA 25,66
000E8:  DATA 43,20
000EA:  DATA 25,66
000EC:  DATA 25,25
000EE:  DATA 00,00
000F0:  DATA 4F,73
000F2:  DATA 6D,6F
000F4:  DATA 62,6F
000F6:  DATA 74,20
000F8:  DATA 54,65
000FA:  DATA 73,74
000FC:  DATA 69,6E
000FE:  DATA 67,20
00100:  DATA 61,6E
00102:  DATA 64,20
00104:  DATA 43,6F
00106:  DATA 6E,66
00108:  DATA 69,67
0010A:  DATA 75,72
0010C:  DATA 61,74
0010E:  DATA 69,6F
00110:  DATA 6E,20
00112:  DATA 48,65
00114:  DATA 6C,70
00116:  DATA 0A,0D
00118:  DATA 00,00
0011A:  DATA 42,65
0011C:  DATA 6C,6F
0011E:  DATA 77,20
00120:  DATA 69,73
00122:  DATA 20,61
00124:  DATA 20,6C
00126:  DATA 69,73
00128:  DATA 74,20
0012A:  DATA 6F,66
0012C:  DATA 20,61
0012E:  DATA 6C,6C
00130:  DATA 20,74
00132:  DATA 68,65
00134:  DATA 20,63
00136:  DATA 6F,6D
00138:  DATA 6D,61
0013A:  DATA 6E,64
0013C:  DATA 73,20
0013E:  DATA 74,68
00140:  DATA 69,73
00142:  DATA 20,75
00144:  DATA 6E,69
00146:  DATA 74,20
00148:  DATA 63,61
0014A:  DATA 6E,20
0014C:  DATA 64,6F
0014E:  DATA 2E,20
00150:  DATA 20,46
00152:  DATA 61,62
00154:  DATA 75,61
00156:  DATA 72,79
00158:  DATA 20,31
0015A:  DATA 31,2C
0015C:  DATA 20,32
0015E:  DATA 30,31
00160:  DATA 37,0A
00162:  DATA 0D,00
00164:  DATA 73,68
00166:  DATA 6F,77
00168:  DATA 63,6F
0016A:  DATA 6E,66
0016C:  DATA 69,67
0016E:  DATA 20,20
00170:  DATA 20,20
00172:  DATA 20,20
00174:  DATA 20,20
00176:  DATA 20,20
00178:  DATA 44,75
0017A:  DATA 6D,70
0017C:  DATA 73,20
0017E:  DATA 61,6C
00180:  DATA 6C,20
00182:  DATA 6F,66
00184:  DATA 20,74
00186:  DATA 68,65
00188:  DATA 20,63
0018A:  DATA 75,72
0018C:  DATA 72,65
0018E:  DATA 6E,74
00190:  DATA 20,63
00192:  DATA 61,6C
00194:  DATA 69,62
00196:  DATA 72,61
00198:  DATA 74,69
0019A:  DATA 6F,6E
0019C:  DATA 73,20
0019E:  DATA 66,6F
001A0:  DATA 72,20
001A2:  DATA 61,6C
001A4:  DATA 6C,20
001A6:  DATA 73,65
001A8:  DATA 6E,73
001AA:  DATA 6F,72
001AC:  DATA 73,20
001AE:  DATA 74,6F
001B0:  DATA 20,64
001B2:  DATA 61,74
001B4:  DATA 65,20
001B6:  DATA 74,6F
001B8:  DATA 20,74
001BA:  DATA 68,65
001BC:  DATA 20,64
001BE:  DATA 69,73
001C0:  DATA 70,6C
001C2:  DATA 61,79
001C4:  DATA 2E,0A
001C6:  DATA 0D,00
001C8:  DATA 73,61
001CA:  DATA 76,65
001CC:  DATA 63,6F
001CE:  DATA 6E,66
001D0:  DATA 69,67
001D2:  DATA 20,20
001D4:  DATA 20,20
001D6:  DATA 20,20
001D8:  DATA 20,20
001DA:  DATA 20,20
001DC:  DATA 53,61
001DE:  DATA 76,65
001E0:  DATA 73,20
001E2:  DATA 61,6C
001E4:  DATA 6C,20
001E6:  DATA 6F,66
001E8:  DATA 20,74
001EA:  DATA 68,65
001EC:  DATA 20,63
001EE:  DATA 75,72
001F0:  DATA 72,65
001F2:  DATA 6E,74
001F4:  DATA 20,63
001F6:  DATA 61,6C
001F8:  DATA 69,62
001FA:  DATA 72,61
001FC:  DATA 74,69
001FE:  DATA 6F,6E
00200:  DATA 20,69
00202:  DATA 6E,20
00204:  DATA 45,45
00206:  DATA 50,52
00208:  DATA 4F,4D
0020A:  DATA 20,6F
0020C:  DATA 6E,20
0020E:  DATA 74,68
00210:  DATA 69,73
00212:  DATA 20,64
00214:  DATA 65,76
00216:  DATA 69,63
00218:  DATA 65,2E
0021A:  DATA 20,20
0021C:  DATA 49,74
0021E:  DATA 27,73
00220:  DATA 20,75
00222:  DATA 73,65
00224:  DATA 64,20
00226:  DATA 61,73
00228:  DATA 20,64
0022A:  DATA 65,66
0022C:  DATA 61,75
0022E:  DATA 6C,74
00230:  DATA 20,66
00232:  DATA 6F,72
00234:  DATA 20,69
00236:  DATA 6E,69
00238:  DATA 74,61
0023A:  DATA 6C,69
0023C:  DATA 7A,69
0023E:  DATA 6E,67
00240:  DATA 20,6E
00242:  DATA 65,77
00244:  DATA 20,75
00246:  DATA 6E,69
00248:  DATA 74,73
0024A:  DATA 2E,0A
0024C:  DATA 0D,00
0024E:  DATA 64,69
00250:  DATA 73,70
00252:  DATA 6C,61
00254:  DATA 79,20
00256:  DATA 20,20
00258:  DATA 20,20
0025A:  DATA 20,20
0025C:  DATA 20,20
0025E:  DATA 20,20
00260:  DATA 20,20
00262:  DATA 43,6F
00264:  DATA 6D,6D
00266:  DATA 61,6E
00268:  DATA 64,20
0026A:  DATA 74,6F
0026C:  DATA 20,73
0026E:  DATA 65,74
00270:  DATA 20,6F
00272:  DATA 72,20
00274:  DATA 72,65
00276:  DATA 73,65
00278:  DATA 74,20
0027A:  DATA 69,74
0027C:  DATA 65,6D
0027E:  DATA 73,20
00280:  DATA 74,6F
00282:  DATA 20,74
00284:  DATA 68,65
00286:  DATA 20,56
00288:  DATA 46,44
0028A:  DATA 20,20
0028C:  DATA 64,69
0028E:  DATA 73,70
00290:  DATA 6C,61
00292:  DATA 79,2E
00294:  DATA 20,4F
00296:  DATA 6E,6C
00298:  DATA 79,20
0029A:  DATA 34,20
0029C:  DATA 69,74
0029E:  DATA 65,6D
002A0:  DATA 73,20
002A2:  DATA 63,61
002A4:  DATA 6E,20
002A6:  DATA 62,65
002A8:  DATA 20,73
002AA:  DATA 68,6F
002AC:  DATA 77,6E
002AE:  DATA 20,61
002B0:  DATA 74,20
002B2:  DATA 74,68
002B4:  DATA 65,20
002B6:  DATA 73,61
002B8:  DATA 6D,65
002BA:  DATA 20,74
002BC:  DATA 69,6D
002BE:  DATA 65,2E
002C0:  DATA 20,20
002C2:  DATA 41,6C
002C4:  DATA 6C,20
002C6:  DATA 65,6C
002C8:  DATA 73,65
002CA:  DATA 20,77
002CC:  DATA 69,6C
002CE:  DATA 6C,20
002D0:  DATA 62,65
002D2:  DATA 20,74
002D4:  DATA 72,75
002D6:  DATA 6E,63
002D8:  DATA 61,74
002DA:  DATA 65,64
002DC:  DATA 2E,0A
002DE:  DATA 0D,00
002E0:  DATA 20,20
002E2:  DATA 20,20
002E4:  DATA 20,20
002E6:  DATA 20,20
002E8:  DATA 20,20
002EA:  DATA 20,20
002EC:  DATA 20,20
002EE:  DATA 20,20
002F0:  DATA 20,20
002F2:  DATA 20,20
002F4:  DATA 48,65
002F6:  DATA 72,65
002F8:  DATA 20,61
002FA:  DATA 72,65
002FC:  DATA 20,74
002FE:  DATA 68,65
00300:  DATA 20,6F
00302:  DATA 70,74
00304:  DATA 69,6F
00306:  DATA 6E,73
00308:  DATA 2E,0A
0030A:  DATA 0D,00
0030C:  DATA 20,20
0030E:  DATA 20,20
00310:  DATA 20,20
00312:  DATA 20,20
00314:  DATA 20,20
00316:  DATA 20,20
00318:  DATA 20,20
0031A:  DATA 20,20
0031C:  DATA 20,20
0031E:  DATA 20,20
00320:  DATA 70,70
00322:  DATA 68,20
00324:  DATA 64,6F
00326:  DATA 20,20
00328:  DATA 70,68
0032A:  DATA 20,20
0032C:  DATA 77,64
0032E:  DATA 20,20
00330:  DATA 70,68
00332:  DATA 62,75
00334:  DATA 6C,62
00336:  DATA 20,20
00338:  DATA 63,6C
0033A:  DATA 65,61
0033C:  DATA 72,20
0033E:  DATA 6C,75
00340:  DATA 78,20
00342:  DATA 20,65
00344:  DATA 63,20
00346:  DATA 20,20
00348:  DATA 77,74
0034A:  DATA 20,20
0034C:  DATA 70,61
0034E:  DATA 72,20
00350:  DATA 20,6E
00352:  DATA 68,34
00354:  DATA 20,0A
00356:  DATA 0D,00
00358:  DATA 64,65
0035A:  DATA 66,61
0035C:  DATA 75,6C
0035E:  DATA 74,20
00360:  DATA 20,20
00362:  DATA 20,20
00364:  DATA 20,20
00366:  DATA 20,20
00368:  DATA 20,20
0036A:  DATA 20,20
0036C:  DATA 54,68
0036E:  DATA 69,73
00370:  DATA 20,73
00372:  DATA 65,74
00374:  DATA 73,20
00376:  DATA 61,6C
00378:  DATA 6C,20
0037A:  DATA 6F,66
0037C:  DATA 20,74
0037E:  DATA 68,65
00380:  DATA 20,63
00382:  DATA 61,6C
00384:  DATA 69,62
00386:  DATA 72,61
00388:  DATA 74,69
0038A:  DATA 6F,6E
0038C:  DATA 20,74
0038E:  DATA 6F,20
00390:  DATA 64,65
00392:  DATA 66,61
00394:  DATA 75,6C
00396:  DATA 74,20
00398:  DATA 76,61
0039A:  DATA 6C,75
0039C:  DATA 65,73
0039E:  DATA 2E,0A
003A0:  DATA 0D,00
003A2:  DATA 75,70
003A4:  DATA 64,61
003A6:  DATA 74,65
003A8:  DATA 20,20
003AA:  DATA 20,20
003AC:  DATA 20,20
003AE:  DATA 20,20
003B0:  DATA 20,20
003B2:  DATA 20,20
003B4:  DATA 20,20
003B6:  DATA 49,74
003B8:  DATA 20,73
003BA:  DATA 68,6F
003BC:  DATA 6F,74
003BE:  DATA 73,20
003C0:  DATA 74,68
003C2:  DATA 65,20
003C4:  DATA 63,75
003C6:  DATA 72,72
003C8:  DATA 65,6E
003CA:  DATA 74,20
003CC:  DATA 63,61
003CE:  DATA 6C,69
003D0:  DATA 62,72
003D2:  DATA 61,74
003D4:  DATA 69,6F
003D6:  DATA 6E,20
003D8:  DATA 76,61
003DA:  DATA 6C,75
003DC:  DATA 65,73
003DE:  DATA 20,74
003E0:  DATA 6F,20
003E2:  DATA 74,68
003E4:  DATA 65,20
003E6:  DATA 72,65
003E8:  DATA 6D,6F
003EA:  DATA 74,65
003EC:  DATA 20,64
003EE:  DATA 65,76
003F0:  DATA 69,63
003F2:  DATA 65,2E
003F4:  DATA 0A,0D
003F6:  DATA 00,00
003F8:  DATA 73,65
003FA:  DATA 74,20
003FC:  DATA 20,20
003FE:  DATA 20,20
00400:  DATA 20,20
00402:  DATA 20,20
00404:  DATA 20,20
00406:  DATA 20,20
00408:  DATA 20,20
0040A:  DATA 20,20
0040C:  DATA 53,65
0040E:  DATA 74,73
00410:  DATA 20,74
00412:  DATA 68,65
00414:  DATA 20,63
00416:  DATA 61,6C
00418:  DATA 69,62
0041A:  DATA 72,61
0041C:  DATA 74,69
0041E:  DATA 6F,6E
00420:  DATA 20,76
00422:  DATA 61,72
00424:  DATA 2E,20
00426:  DATA 20,54
00428:  DATA 68,65
0042A:  DATA 20,66
0042C:  DATA 6F,72
0042E:  DATA 6D,61
00430:  DATA 74,20
00432:  DATA 69,73
00434:  DATA 20,3E
00436:  DATA 73,65
00438:  DATA 74,20
0043A:  DATA 76,61
0043C:  DATA 72,6E
0043E:  DATA 61,6D
00440:  DATA 65,20
00442:  DATA 76,61
00444:  DATA 6C,75
00446:  DATA 65,2E
00448:  DATA 20,20
0044A:  DATA 4F,6E
0044C:  DATA 65,20
0044E:  DATA 73,70
00450:  DATA 61,63
00452:  DATA 65,20
00454:  DATA 69,6E
00456:  DATA 20,62
00458:  DATA 65,74
0045A:  DATA 77,65
0045C:  DATA 65,6E
0045E:  DATA 2E,0A
00460:  DATA 0D,00
00462:  DATA 20,20
00464:  DATA 20,20
00466:  DATA 20,20
00468:  DATA 20,20
0046A:  DATA 20,20
0046C:  DATA 20,20
0046E:  DATA 20,20
00470:  DATA 20,20
00472:  DATA 20,20
00474:  DATA 20,20
00476:  DATA 20,20
00478:  DATA 20,20
0047A:  DATA 20,20
0047C:  DATA 20,20
0047E:  DATA 55,73
00480:  DATA 65,20
00482:  DATA 74,68
00484:  DATA 65,20
00486:  DATA 73,68
00488:  DATA 6F,77
0048A:  DATA 63,6F
0048C:  DATA 6E,66
0048E:  DATA 69,67
00490:  DATA 20,63
00492:  DATA 6F,6D
00494:  DATA 6D,61
00496:  DATA 6E,64
00498:  DATA 20,74
0049A:  DATA 6F,20
0049C:  DATA 64,69
0049E:  DATA 73,70
004A0:  DATA 6C,61
004A2:  DATA 79,20
004A4:  DATA 74,68
004A6:  DATA 65,20
004A8:  DATA 76,61
004AA:  DATA 72,20
004AC:  DATA 6E,61
004AE:  DATA 6D,65
004B0:  DATA 73,20
004B2:  DATA 69,6E
004B4:  DATA 20,28
004B6:  DATA 29,2E
004B8:  DATA 0A,0D
004BA:  DATA 00,00
004BC:  DATA 72,73
004BE:  DATA 74,20
004C0:  DATA 20,20
004C2:  DATA 20,20
004C4:  DATA 20,20
004C6:  DATA 20,20
004C8:  DATA 20,20
004CA:  DATA 20,20
004CC:  DATA 20,20
004CE:  DATA 20,20
004D0:  DATA 72,65
004D2:  DATA 62,6F
004D4:  DATA 6F,74
004D6:  DATA 20,74
004D8:  DATA 68,69
004DA:  DATA 73,20
004DC:  DATA 75,6E
004DE:  DATA 69,74
004E0:  DATA 2E,0A
004E2:  DATA 0D,00
004E4:  DATA 65,6E
004E6:  DATA 64,20
004E8:  DATA 6F,66
004EA:  DATA 20,6C
004EC:  DATA 69,6E
004EE:  DATA 65,0A
004F0:  DATA 0D,00
004F2:  DATA 45,72
004F4:  DATA 72,6F
004F6:  DATA 72,20
004F8:  DATA 53,61
004FA:  DATA 76,69
004FC:  DATA 6E,67
004FE:  DATA 20,4C
00500:  DATA 6F,63
00502:  DATA 61,6C
00504:  DATA 20,43
00506:  DATA 6F,6E
00508:  DATA 66,69
0050A:  DATA 67,75
0050C:  DATA 72,61
0050E:  DATA 74,69
00510:  DATA 6F,6E
00512:  DATA 0A,0D
00514:  DATA 00,00
00516:  DATA 4C,6F
00518:  DATA 63,61
0051A:  DATA 6C,20
0051C:  DATA 43,6F
0051E:  DATA 6E,66
00520:  DATA 69,67
00522:  DATA 75,72
00524:  DATA 61,74
00526:  DATA 69,6F
00528:  DATA 6E,73
0052A:  DATA 20,43
0052C:  DATA 6C,65
0052E:  DATA 61,72
00530:  DATA 65,64
00532:  DATA 0A,0D
00534:  DATA 00,00
00536:  DATA 45,72
00538:  DATA 72,6F
0053A:  DATA 72,20
0053C:  DATA 53,61
0053E:  DATA 76,69
00540:  DATA 6E,67
00542:  DATA 20,4C
00544:  DATA 6F,63
00546:  DATA 61,6C
00548:  DATA 20,43
0054A:  DATA 6F,6E
0054C:  DATA 66,69
0054E:  DATA 67,75
00550:  DATA 72,61
00552:  DATA 74,69
00554:  DATA 6F,6E
00556:  DATA 0A,0D
00558:  DATA 00,00
0055A:  DATA 4C,6F
0055C:  DATA 63,61
0055E:  DATA 6C,20
00560:  DATA 43,6F
00562:  DATA 6E,66
00564:  DATA 69,67
00566:  DATA 75,72
00568:  DATA 61,74
0056A:  DATA 69,6F
0056C:  DATA 6E,73
0056E:  DATA 20,53
00570:  DATA 61,76
00572:  DATA 65,64
00574:  DATA 0A,0D
00576:  DATA 00,00
00578:  DATA 28,72
0057A:  DATA 65,74
0057C:  DATA 6E,68
0057E:  DATA 34,31
00580:  DATA 29,20
00582:  DATA 20,6E
00584:  DATA 68,34
00586:  DATA 70,74
00588:  DATA 31,72
0058A:  DATA 65,74
0058C:  DATA 75,72
0058E:  DATA 6E,65
00590:  DATA 64,6E
00592:  DATA 75,6D
00594:  DATA 62,65
00596:  DATA 72,20
00598:  DATA 73,65
0059A:  DATA 74,20
0059C:  DATA 74,6F
0059E:  DATA 20,25
005A0:  DATA 66,0A
005A2:  DATA 0D,00
005A4:  DATA 41,6C
005A6:  DATA 73,6F
005A8:  DATA 20,75
005AA:  DATA 73,65
005AC:  DATA 64,20
005AE:  DATA 61,73
005B0:  DATA 20,41
005B2:  DATA 6E,61
005B4:  DATA 6C,6F
005B6:  DATA 67,20
005B8:  DATA 4E,48
005BA:  DATA 34,20
005BC:  DATA 70,72
005BE:  DATA 6F,62
005C0:  DATA 65,20
005C2:  DATA 6F,75
005C4:  DATA 74,70
005C6:  DATA 75,74
005C8:  DATA 20,6C
005CA:  DATA 6F,77
005CC:  DATA 20,6E
005CE:  DATA 75,6D
005D0:  DATA 62,65
005D2:  DATA 72,2E
005D4:  DATA 0A,0D
005D6:  DATA 00,00
005D8:  DATA 28,72
005DA:  DATA 65,74
005DC:  DATA 6E,68
005DE:  DATA 34,32
005E0:  DATA 29,20
005E2:  DATA 20,6E
005E4:  DATA 68,34
005E6:  DATA 70,74
005E8:  DATA 32,72
005EA:  DATA 65,74
005EC:  DATA 75,72
005EE:  DATA 6E,65
005F0:  DATA 64,6E
005F2:  DATA 75,6D
005F4:  DATA 62,65
005F6:  DATA 72,20
005F8:  DATA 73,65
005FA:  DATA 74,20
005FC:  DATA 74,6F
005FE:  DATA 20,25
00600:  DATA 66,0A
00602:  DATA 0D,00
00604:  DATA 28,72
00606:  DATA 65,74
00608:  DATA 6E,68
0060A:  DATA 34,33
0060C:  DATA 29,20
0060E:  DATA 20,6E
00610:  DATA 68,34
00612:  DATA 70,74
00614:  DATA 33,72
00616:  DATA 65,74
00618:  DATA 75,72
0061A:  DATA 6E,65
0061C:  DATA 64,6E
0061E:  DATA 75,6D
00620:  DATA 62,65
00622:  DATA 72,20
00624:  DATA 73,65
00626:  DATA 74,20
00628:  DATA 74,6F
0062A:  DATA 20,25
0062C:  DATA 66,0A
0062E:  DATA 0D,00
00630:  DATA 41,6C
00632:  DATA 73,6F
00634:  DATA 20,75
00636:  DATA 73,65
00638:  DATA 64,20
0063A:  DATA 61,73
0063C:  DATA 20,41
0063E:  DATA 6E,61
00640:  DATA 6C,6F
00642:  DATA 67,20
00644:  DATA 4E,48
00646:  DATA 34,20
00648:  DATA 70,72
0064A:  DATA 6F,62
0064C:  DATA 65,20
0064E:  DATA 6F,75
00650:  DATA 74,70
00652:  DATA 75,74
00654:  DATA 20,68
00656:  DATA 69,67
00658:  DATA 68,20
0065A:  DATA 6E,75
0065C:  DATA 6D,62
0065E:  DATA 65,72
00660:  DATA 2E,0A
00662:  DATA 0D,00
00664:  DATA 28,6E
00666:  DATA 68,34
00668:  DATA 70,74
0066A:  DATA 31,29
0066C:  DATA 20,20
0066E:  DATA 6E,68
00670:  DATA 34,70
00672:  DATA 74,31
00674:  DATA 63,61
00676:  DATA 6C,31
00678:  DATA 6F,66
0067A:  DATA 33,20
0067C:  DATA 73,65
0067E:  DATA 74,20
00680:  DATA 74,6F
00682:  DATA 20,25
00684:  DATA 4C,75
00686:  DATA 0A,0D
00688:  DATA 00,00
0068A:  DATA 41,6C
0068C:  DATA 73,6F
0068E:  DATA 20,75
00690:  DATA 73,65
00692:  DATA 64,20
00694:  DATA 61,73
00696:  DATA 20,41
00698:  DATA 6E,61
0069A:  DATA 6C,6F
0069C:  DATA 67,20
0069E:  DATA 4E,48
006A0:  DATA 34,20
006A2:  DATA 70,72
006A4:  DATA 6F,62
006A6:  DATA 65,20
006A8:  DATA 69,6E
006AA:  DATA 70,75
006AC:  DATA 74,20
006AE:  DATA 6C,6F
006B0:  DATA 77,20
006B2:  DATA 6E,75
006B4:  DATA 6D,62
006B6:  DATA 65,72
006B8:  DATA 2E,0A
006BA:  DATA 0D,00
006BC:  DATA 28,6E
006BE:  DATA 68,34
006C0:  DATA 70,74
006C2:  DATA 32,29
006C4:  DATA 20,20
006C6:  DATA 6E,68
006C8:  DATA 34,70
006CA:  DATA 74,31
006CC:  DATA 63,61
006CE:  DATA 6C,32
006D0:  DATA 6F,66
006D2:  DATA 33,20
006D4:  DATA 73,65
006D6:  DATA 74,20
006D8:  DATA 74,6F
006DA:  DATA 20,25
006DC:  DATA 4C,75
006DE:  DATA 0A,0D
006E0:  DATA 00,00
006E2:  DATA 28,6E
006E4:  DATA 68,34
006E6:  DATA 70,74
006E8:  DATA 33,29
006EA:  DATA 20,20
006EC:  DATA 6E,68
006EE:  DATA 34,70
006F0:  DATA 74,31
006F2:  DATA 63,61
006F4:  DATA 6C,33
006F6:  DATA 6F,66
006F8:  DATA 33,20
006FA:  DATA 73,65
006FC:  DATA 74,20
006FE:  DATA 74,6F
00700:  DATA 20,25
00702:  DATA 4C,75
00704:  DATA 0A,0D
00706:  DATA 00,00
00708:  DATA 41,6C
0070A:  DATA 73,6F
0070C:  DATA 20,75
0070E:  DATA 73,65
00710:  DATA 64,20
00712:  DATA 61,73
00714:  DATA 20,41
00716:  DATA 6E,61
00718:  DATA 6C,6F
0071A:  DATA 67,20
0071C:  DATA 4E,48
0071E:  DATA 34,20
00720:  DATA 70,72
00722:  DATA 6F,62
00724:  DATA 65,20
00726:  DATA 69,6E
00728:  DATA 70,75
0072A:  DATA 74,20
0072C:  DATA 6C,6F
0072E:  DATA 77,20
00730:  DATA 6E,75
00732:  DATA 6D,62
00734:  DATA 65,72
00736:  DATA 2E,0A
00738:  DATA 0D,00
0073A:  DATA 28,6E
0073C:  DATA 68,34
0073E:  DATA 70,74
00740:  DATA 34,29
00742:  DATA 20,20
00744:  DATA 6E,68
00746:  DATA 34,70
00748:  DATA 74,32
0074A:  DATA 63,61
0074C:  DATA 6C,31
0074E:  DATA 6F,66
00750:  DATA 33,20
00752:  DATA 73,65
00754:  DATA 74,20
00756:  DATA 74,6F
00758:  DATA 20,25
0075A:  DATA 4C,75
0075C:  DATA 0A,0D
0075E:  DATA 00,00
00760:  DATA 41,6C
00762:  DATA 73,6F
00764:  DATA 20,75
00766:  DATA 73,65
00768:  DATA 64,20
0076A:  DATA 61,73
0076C:  DATA 20,41
0076E:  DATA 6E,61
00770:  DATA 6C,6F
00772:  DATA 67,20
00774:  DATA 4E,48
00776:  DATA 34,20
00778:  DATA 70,72
0077A:  DATA 6F,62
0077C:  DATA 65,20
0077E:  DATA 69,6E
00780:  DATA 70,75
00782:  DATA 74,20
00784:  DATA 6C,6F
00786:  DATA 77,20
00788:  DATA 6E,75
0078A:  DATA 6D,62
0078C:  DATA 65,72
0078E:  DATA 2E,0A
00790:  DATA 0D,00
00792:  DATA 28,6E
00794:  DATA 68,34
00796:  DATA 70,74
00798:  DATA 35,29
0079A:  DATA 20,20
0079C:  DATA 6E,68
0079E:  DATA 34,70
007A0:  DATA 74,32
007A2:  DATA 63,61
007A4:  DATA 6C,32
007A6:  DATA 6F,66
007A8:  DATA 33,20
007AA:  DATA 73,65
007AC:  DATA 74,20
007AE:  DATA 74,6F
007B0:  DATA 20,25
007B2:  DATA 4C,75
007B4:  DATA 0A,0D
007B6:  DATA 00,00
007B8:  DATA 41,6C
007BA:  DATA 73,6F
007BC:  DATA 20,75
007BE:  DATA 73,65
007C0:  DATA 64,20
007C2:  DATA 61,73
007C4:  DATA 20,41
007C6:  DATA 6E,61
007C8:  DATA 6C,6F
007CA:  DATA 67,20
007CC:  DATA 4E,48
007CE:  DATA 34,20
007D0:  DATA 70,72
007D2:  DATA 6F,62
007D4:  DATA 65,20
007D6:  DATA 69,6E
007D8:  DATA 70,75
007DA:  DATA 74,20
007DC:  DATA 6C,6F
007DE:  DATA 77,20
007E0:  DATA 6E,75
007E2:  DATA 6D,62
007E4:  DATA 65,72
007E6:  DATA 2E,0A
007E8:  DATA 0D,00
007EA:  DATA 28,6E
007EC:  DATA 68,34
007EE:  DATA 70,74
007F0:  DATA 36,29
007F2:  DATA 20,20
007F4:  DATA 6E,68
007F6:  DATA 34,70
007F8:  DATA 74,32
007FA:  DATA 63,61
007FC:  DATA 6C,33
007FE:  DATA 6F,66
00800:  DATA 33,20
00802:  DATA 73,65
00804:  DATA 74,20
00806:  DATA 74,6F
00808:  DATA 20,25
0080A:  DATA 4C,75
0080C:  DATA 0A,0D
0080E:  DATA 00,00
00810:  DATA 41,6C
00812:  DATA 73,6F
00814:  DATA 20,75
00816:  DATA 73,65
00818:  DATA 64,20
0081A:  DATA 61,73
0081C:  DATA 20,41
0081E:  DATA 6E,61
00820:  DATA 6C,6F
00822:  DATA 67,20
00824:  DATA 4E,48
00826:  DATA 34,20
00828:  DATA 70,72
0082A:  DATA 6F,62
0082C:  DATA 65,20
0082E:  DATA 69,6E
00830:  DATA 70,75
00832:  DATA 74,20
00834:  DATA 6C,6F
00836:  DATA 77,20
00838:  DATA 6E,75
0083A:  DATA 6D,62
0083C:  DATA 65,72
0083E:  DATA 2E,0A
00840:  DATA 0D,00
00842:  DATA 28,6E
00844:  DATA 68,34
00846:  DATA 70,74
00848:  DATA 37,29
0084A:  DATA 20,20
0084C:  DATA 6E,68
0084E:  DATA 34,70
00850:  DATA 74,33
00852:  DATA 63,61
00854:  DATA 6C,31
00856:  DATA 6F,66
00858:  DATA 33,20
0085A:  DATA 73,65
0085C:  DATA 74,20
0085E:  DATA 74,6F
00860:  DATA 20,25
00862:  DATA 4C,75
00864:  DATA 0A,0D
00866:  DATA 00,00
00868:  DATA 41,6C
0086A:  DATA 73,6F
0086C:  DATA 20,75
0086E:  DATA 73,65
00870:  DATA 64,20
00872:  DATA 61,73
00874:  DATA 20,41
00876:  DATA 6E,61
00878:  DATA 6C,6F
0087A:  DATA 67,20
0087C:  DATA 4E,48
0087E:  DATA 34,20
00880:  DATA 70,72
00882:  DATA 6F,62
00884:  DATA 65,20
00886:  DATA 69,6E
00888:  DATA 70,75
0088A:  DATA 74,20
0088C:  DATA 6C,6F
0088E:  DATA 77,20
00890:  DATA 6E,75
00892:  DATA 6D,62
00894:  DATA 65,72
00896:  DATA 2E,0A
00898:  DATA 0D,00
0089A:  DATA 28,6E
0089C:  DATA 68,34
0089E:  DATA 70,74
008A0:  DATA 38,29
008A2:  DATA 20,20
008A4:  DATA 6E,68
008A6:  DATA 34,70
008A8:  DATA 74,33
008AA:  DATA 63,61
008AC:  DATA 6C,32
008AE:  DATA 6F,66
008B0:  DATA 33,20
008B2:  DATA 73,65
008B4:  DATA 74,20
008B6:  DATA 74,6F
008B8:  DATA 20,25
008BA:  DATA 4C,75
008BC:  DATA 0A,0D
008BE:  DATA 00,00
008C0:  DATA 41,6C
008C2:  DATA 73,6F
008C4:  DATA 20,75
008C6:  DATA 73,65
008C8:  DATA 64,20
008CA:  DATA 61,73
008CC:  DATA 20,41
008CE:  DATA 6E,61
008D0:  DATA 6C,6F
008D2:  DATA 67,20
008D4:  DATA 4E,48
008D6:  DATA 34,20
008D8:  DATA 70,72
008DA:  DATA 6F,62
008DC:  DATA 65,20
008DE:  DATA 69,6E
008E0:  DATA 70,75
008E2:  DATA 74,20
008E4:  DATA 6C,6F
008E6:  DATA 77,20
008E8:  DATA 6E,75
008EA:  DATA 6D,62
008EC:  DATA 65,72
008EE:  DATA 2E,0A
008F0:  DATA 0D,00
008F2:  DATA 28,6E
008F4:  DATA 68,34
008F6:  DATA 70,74
008F8:  DATA 39,29
008FA:  DATA 20,20
008FC:  DATA 6E,68
008FE:  DATA 34,70
00900:  DATA 74,33
00902:  DATA 63,61
00904:  DATA 6C,33
00906:  DATA 6F,66
00908:  DATA 33,20
0090A:  DATA 73,65
0090C:  DATA 74,20
0090E:  DATA 74,6F
00910:  DATA 20,25
00912:  DATA 4C,75
00914:  DATA 0A,0D
00916:  DATA 00,00
00918:  DATA 28,44
0091A:  DATA 4F,70
0091C:  DATA 74,31
0091E:  DATA 29,20
00920:  DATA 20,44
00922:  DATA 4F,70
00924:  DATA 74,31
00926:  DATA 63,61
00928:  DATA 6C,31
0092A:  DATA 6F,66
0092C:  DATA 33,20
0092E:  DATA 73,65
00930:  DATA 74,20
00932:  DATA 74,6F
00934:  DATA 20,25
00936:  DATA 4C,75
00938:  DATA 0A,0D
0093A:  DATA 00,00
0093C:  DATA 28,44
0093E:  DATA 4F,70
00940:  DATA 74,32
00942:  DATA 29,20
00944:  DATA 20,44
00946:  DATA 4F,70
00948:  DATA 74,31
0094A:  DATA 63,61
0094C:  DATA 6C,32
0094E:  DATA 6F,66
00950:  DATA 33,20
00952:  DATA 73,65
00954:  DATA 74,20
00956:  DATA 74,6F
00958:  DATA 20,25
0095A:  DATA 4C,75
0095C:  DATA 0A,0D
0095E:  DATA 00,00
00960:  DATA 28,44
00962:  DATA 4F,70
00964:  DATA 74,33
00966:  DATA 29,20
00968:  DATA 20,44
0096A:  DATA 4F,70
0096C:  DATA 74,31
0096E:  DATA 63,61
00970:  DATA 6C,33
00972:  DATA 6F,66
00974:  DATA 33,20
00976:  DATA 73,65
00978:  DATA 74,20
0097A:  DATA 74,6F
0097C:  DATA 20,25
0097E:  DATA 4C,75
00980:  DATA 0A,0D
00982:  DATA 00,00
00984:  DATA 28,44
00986:  DATA 4F,70
00988:  DATA 74,34
0098A:  DATA 29,20
0098C:  DATA 20,44
0098E:  DATA 4F,70
00990:  DATA 74,32
00992:  DATA 63,61
00994:  DATA 6C,31
00996:  DATA 6F,66
00998:  DATA 33,20
0099A:  DATA 73,65
0099C:  DATA 74,20
0099E:  DATA 74,6F
009A0:  DATA 20,25
009A2:  DATA 4C,75
009A4:  DATA 0A,0D
009A6:  DATA 00,00
009A8:  DATA 28,44
009AA:  DATA 4F,70
009AC:  DATA 74,35
009AE:  DATA 29,20
009B0:  DATA 20,44
009B2:  DATA 4F,70
009B4:  DATA 74,32
009B6:  DATA 63,61
009B8:  DATA 6C,32
009BA:  DATA 6F,66
009BC:  DATA 33,20
009BE:  DATA 73,65
009C0:  DATA 74,20
009C2:  DATA 74,6F
009C4:  DATA 20,25
009C6:  DATA 4C,75
009C8:  DATA 0A,0D
009CA:  DATA 00,00
009CC:  DATA 28,44
009CE:  DATA 4F,70
009D0:  DATA 74,36
009D2:  DATA 29,20
009D4:  DATA 20,44
009D6:  DATA 4F,70
009D8:  DATA 74,32
009DA:  DATA 63,61
009DC:  DATA 6C,33
009DE:  DATA 6F,66
009E0:  DATA 33,20
009E2:  DATA 73,65
009E4:  DATA 74,20
009E6:  DATA 74,6F
009E8:  DATA 20,25
009EA:  DATA 4C,75
009EC:  DATA 0A,0D
009EE:  DATA 00,00
009F0:  DATA 28,44
009F2:  DATA 4F,70
009F4:  DATA 74,31
009F6:  DATA 37,20
009F8:  DATA 20,44
009FA:  DATA 4F,70
009FC:  DATA 74,33
009FE:  DATA 63,61
00A00:  DATA 6C,31
00A02:  DATA 6F,66
00A04:  DATA 33,20
00A06:  DATA 73,65
00A08:  DATA 74,20
00A0A:  DATA 74,6F
00A0C:  DATA 20,25
00A0E:  DATA 4C,75
00A10:  DATA 0A,0D
00A12:  DATA 00,00
00A14:  DATA 28,44
00A16:  DATA 4F,70
00A18:  DATA 74,38
00A1A:  DATA 29,20
00A1C:  DATA 20,44
00A1E:  DATA 4F,70
00A20:  DATA 74,33
00A22:  DATA 63,61
00A24:  DATA 6C,32
00A26:  DATA 6F,66
00A28:  DATA 33,20
00A2A:  DATA 73,65
00A2C:  DATA 74,20
00A2E:  DATA 74,6F
00A30:  DATA 20,25
00A32:  DATA 4C,75
00A34:  DATA 0A,0D
00A36:  DATA 00,00
00A38:  DATA 28,44
00A3A:  DATA 4F,70
00A3C:  DATA 74,39
00A3E:  DATA 29,20
00A40:  DATA 20,44
00A42:  DATA 4F,70
00A44:  DATA 74,33
00A46:  DATA 63,61
00A48:  DATA 6C,33
00A4A:  DATA 6F,66
00A4C:  DATA 33,20
00A4E:  DATA 73,65
00A50:  DATA 74,20
00A52:  DATA 74,6F
00A54:  DATA 20,25
00A56:  DATA 4C,75
00A58:  DATA 0A,0D
00A5A:  DATA 00,00
00A5C:  DATA 53,65
00A5E:  DATA 74,74
00A60:  DATA 69,6E
00A62:  DATA 67,20
00A64:  DATA 61,6C
00A66:  DATA 6C,20
00A68:  DATA 63,61
00A6A:  DATA 6C,69
00A6C:  DATA 62,72
00A6E:  DATA 61,74
00A70:  DATA 69,6F
00A72:  DATA 6E,20
00A74:  DATA 76,61
00A76:  DATA 6C,75
00A78:  DATA 65,73
00A7A:  DATA 20,74
00A7C:  DATA 6F,20
00A7E:  DATA 64,65
00A80:  DATA 66,61
00A82:  DATA 75,6C
00A84:  DATA 74,2E
00A86:  DATA 20,20
00A88:  DATA 44,6F
00A8A:  DATA 20,61
00A8C:  DATA 20,73
00A8E:  DATA 61,76
00A90:  DATA 65,63
00A92:  DATA 6F,6E
00A94:  DATA 66,69
00A96:  DATA 67,20
00A98:  DATA 74,6F
00A9A:  DATA 20,73
00A9C:  DATA 61,76
00A9E:  DATA 65,20
00AA0:  DATA 69,74
00AA2:  DATA 20,69
00AA4:  DATA 6E,20
00AA6:  DATA 45,45
00AA8:  DATA 50,52
00AAA:  DATA 4F,4D
00AAC:  DATA 2E,0A
00AAE:  DATA 0D,00
00AB0:  DATA 43,75
00AB2:  DATA 72,72
00AB4:  DATA 65,6E
00AB6:  DATA 74,20
00AB8:  DATA 43,61
00ABA:  DATA 6C,69
00ABC:  DATA 62,72
00ABE:  DATA 61,74
00AC0:  DATA 69,6F
00AC2:  DATA 6E,73
00AC4:  DATA 0A,0D
00AC6:  DATA 00,00
00AC8:  DATA 70,68
00ACA:  DATA 63,61
00ACC:  DATA 6C,6C
00ACE:  DATA 6F,77
00AD0:  DATA 20,3D
00AD2:  DATA 20,25
00AD4:  DATA 66,0A
00AD6:  DATA 0D,00
00AD8:  DATA 70,68
00ADA:  DATA 63,61
00ADC:  DATA 6C,68
00ADE:  DATA 69,67
00AE0:  DATA 68,20
00AE2:  DATA 3D,20
00AE4:  DATA 25,66
00AE6:  DATA 0A,0D
00AE8:  DATA 00,00
00AEA:  DATA 70,68
00AEC:  DATA 6E,75
00AEE:  DATA 6D,62
00AF0:  DATA 65,72
00AF2:  DATA 75,70
00AF4:  DATA 70,65
00AF6:  DATA 72,20
00AF8:  DATA 3D,20
00AFA:  DATA 25,66
00AFC:  DATA 0A,0D
00AFE:  DATA 00,00
00B00:  DATA 28,6E
00B02:  DATA 68,34
00B04:  DATA 70,74
00B06:  DATA 31,29
00B08:  DATA 20,6E
00B0A:  DATA 68,34
00B0C:  DATA 70,74
00B0E:  DATA 31,63
00B10:  DATA 61,6C
00B12:  DATA 31,6F
00B14:  DATA 66,33
00B16:  DATA 20,3D
00B18:  DATA 20,25
00B1A:  DATA 4C,75
00B1C:  DATA 0A,0D
00B1E:  DATA 00,00
00B20:  DATA 28,6E
00B22:  DATA 68,34
00B24:  DATA 70,74
00B26:  DATA 32,29
00B28:  DATA 20,6E
00B2A:  DATA 68,34
00B2C:  DATA 70,74
00B2E:  DATA 31,63
00B30:  DATA 61,6C
00B32:  DATA 32,6F
00B34:  DATA 66,33
00B36:  DATA 20,3D
00B38:  DATA 20,25
00B3A:  DATA 4C,75
00B3C:  DATA 0A,0D
00B3E:  DATA 00,00
00B40:  DATA 28,6E
00B42:  DATA 68,34
00B44:  DATA 70,74
00B46:  DATA 33,29
00B48:  DATA 20,6E
00B4A:  DATA 68,34
00B4C:  DATA 70,74
00B4E:  DATA 31,63
00B50:  DATA 61,6C
00B52:  DATA 33,6F
00B54:  DATA 66,33
00B56:  DATA 20,3D
00B58:  DATA 20,25
00B5A:  DATA 4C,75
00B5C:  DATA 0A,0D
00B5E:  DATA 00,00
00B60:  DATA 28,6E
00B62:  DATA 68,34
00B64:  DATA 70,74
00B66:  DATA 34,29
00B68:  DATA 20,6E
00B6A:  DATA 68,34
00B6C:  DATA 70,74
00B6E:  DATA 32,63
00B70:  DATA 61,6C
00B72:  DATA 31,6F
00B74:  DATA 66,33
00B76:  DATA 20,3D
00B78:  DATA 20,25
00B7A:  DATA 4C,75
00B7C:  DATA 0A,0D
00B7E:  DATA 00,00
00B80:  DATA 28,6E
00B82:  DATA 68,34
00B84:  DATA 70,74
00B86:  DATA 35,29
00B88:  DATA 20,6E
00B8A:  DATA 68,34
00B8C:  DATA 70,74
00B8E:  DATA 32,63
00B90:  DATA 61,6C
00B92:  DATA 32,6F
00B94:  DATA 66,33
00B96:  DATA 20,3D
00B98:  DATA 20,25
00B9A:  DATA 4C,75
00B9C:  DATA 0A,0D
00B9E:  DATA 00,00
00BA0:  DATA 28,6E
00BA2:  DATA 68,34
00BA4:  DATA 70,74
00BA6:  DATA 36,29
00BA8:  DATA 20,6E
00BAA:  DATA 68,34
00BAC:  DATA 70,74
00BAE:  DATA 32,63
00BB0:  DATA 61,6C
00BB2:  DATA 33,6F
00BB4:  DATA 66,33
00BB6:  DATA 20,3D
00BB8:  DATA 20,25
00BBA:  DATA 4C,75
00BBC:  DATA 0A,0D
00BBE:  DATA 00,00
00BC0:  DATA 28,6E
00BC2:  DATA 68,34
00BC4:  DATA 70,74
00BC6:  DATA 37,29
00BC8:  DATA 20,6E
00BCA:  DATA 68,34
00BCC:  DATA 70,74
00BCE:  DATA 33,63
00BD0:  DATA 61,6C
00BD2:  DATA 31,6F
00BD4:  DATA 66,33
00BD6:  DATA 20,3D
00BD8:  DATA 20,25
00BDA:  DATA 4C,75
00BDC:  DATA 0A,0D
00BDE:  DATA 00,00
00BE0:  DATA 28,6E
00BE2:  DATA 68,34
00BE4:  DATA 70,74
00BE6:  DATA 38,29
00BE8:  DATA 20,6E
00BEA:  DATA 68,34
00BEC:  DATA 70,74
00BEE:  DATA 33,63
00BF0:  DATA 61,6C
00BF2:  DATA 32,6F
00BF4:  DATA 66,33
00BF6:  DATA 20,3D
00BF8:  DATA 20,25
00BFA:  DATA 4C,75
00BFC:  DATA 0A,0D
00BFE:  DATA 00,00
00C00:  DATA 28,6E
00C02:  DATA 68,34
00C04:  DATA 70,74
00C06:  DATA 39,29
00C08:  DATA 20,6E
00C0A:  DATA 68,34
00C0C:  DATA 70,74
00C0E:  DATA 33,63
00C10:  DATA 61,6C
00C12:  DATA 33,6F
00C14:  DATA 66,33
00C16:  DATA 20,3D
00C18:  DATA 20,25
00C1A:  DATA 4C,75
00C1C:  DATA 0A,0D
00C1E:  DATA 00,00
00C20:  DATA 28,72
00C22:  DATA 65,74
00C24:  DATA 6E,68
00C26:  DATA 34,31
00C28:  DATA 29,20
00C2A:  DATA 6E,68
00C2C:  DATA 34,70
00C2E:  DATA 74,31
00C30:  DATA 72,65
00C32:  DATA 74,75
00C34:  DATA 72,6E
00C36:  DATA 65,64
00C38:  DATA 6E,75
00C3A:  DATA 6D,62
00C3C:  DATA 65,72
00C3E:  DATA 20,3D
00C40:  DATA 20,25
00C42:  DATA 66,0A
00C44:  DATA 0D,00
00C46:  DATA 28,72
00C48:  DATA 65,74
00C4A:  DATA 6E,68
00C4C:  DATA 34,32
00C4E:  DATA 29,20
00C50:  DATA 6E,68
00C52:  DATA 34,70
00C54:  DATA 74,32
00C56:  DATA 72,65
00C58:  DATA 74,75
00C5A:  DATA 72,6E
00C5C:  DATA 65,64
00C5E:  DATA 6E,75
00C60:  DATA 6D,62
00C62:  DATA 65,72
00C64:  DATA 20,3D
00C66:  DATA 20,25
00C68:  DATA 66,0A
00C6A:  DATA 0D,00
00C6C:  DATA 28,72
00C6E:  DATA 65,74
00C70:  DATA 6E,68
00C72:  DATA 34,33
00C74:  DATA 29,20
00C76:  DATA 6E,68
00C78:  DATA 34,70
00C7A:  DATA 74,33
00C7C:  DATA 72,65
00C7E:  DATA 74,75
00C80:  DATA 72,6E
00C82:  DATA 65,64
00C84:  DATA 6E,75
00C86:  DATA 6D,62
00C88:  DATA 65,72
00C8A:  DATA 20,3D
00C8C:  DATA 20,25
00C8E:  DATA 66,0A
00C90:  DATA 0D,00
00C92:  DATA 28,44
00C94:  DATA 4F,70
00C96:  DATA 74,31
00C98:  DATA 29,20
00C9A:  DATA 44,4F
00C9C:  DATA 70,74
00C9E:  DATA 31,63
00CA0:  DATA 61,6C
00CA2:  DATA 31,6F
00CA4:  DATA 66,33
00CA6:  DATA 20,3D
00CA8:  DATA 20,25
00CAA:  DATA 4C,75
00CAC:  DATA 0A,0D
00CAE:  DATA 00,00
00CB0:  DATA 28,44
00CB2:  DATA 4F,70
00CB4:  DATA 74,32
00CB6:  DATA 29,20
00CB8:  DATA 44,4F
00CBA:  DATA 70,74
00CBC:  DATA 31,63
00CBE:  DATA 61,6C
00CC0:  DATA 32,6F
00CC2:  DATA 66,33
00CC4:  DATA 20,3D
00CC6:  DATA 20,25
00CC8:  DATA 4C,75
00CCA:  DATA 0A,0D
00CCC:  DATA 00,00
00CCE:  DATA 28,44
00CD0:  DATA 4F,70
00CD2:  DATA 74,33
00CD4:  DATA 29,20
00CD6:  DATA 44,4F
00CD8:  DATA 70,74
00CDA:  DATA 31,63
00CDC:  DATA 61,6C
00CDE:  DATA 33,6F
00CE0:  DATA 66,33
00CE2:  DATA 20,3D
00CE4:  DATA 20,25
00CE6:  DATA 4C,75
00CE8:  DATA 0A,0D
00CEA:  DATA 00,00
00CEC:  DATA 28,44
00CEE:  DATA 4F,70
00CF0:  DATA 74,34
00CF2:  DATA 29,20
00CF4:  DATA 44,4F
00CF6:  DATA 70,74
00CF8:  DATA 32,63
00CFA:  DATA 61,6C
00CFC:  DATA 31,6F
00CFE:  DATA 66,33
00D00:  DATA 20,3D
00D02:  DATA 20,25
00D04:  DATA 4C,75
00D06:  DATA 0A,0D
00D08:  DATA 00,00
00D0A:  DATA 28,44
00D0C:  DATA 4F,70
00D0E:  DATA 74,35
00D10:  DATA 29,20
00D12:  DATA 44,4F
00D14:  DATA 70,74
00D16:  DATA 32,63
00D18:  DATA 61,6C
00D1A:  DATA 32,6F
00D1C:  DATA 66,33
00D1E:  DATA 20,3D
00D20:  DATA 20,25
00D22:  DATA 4C,75
00D24:  DATA 0A,0D
00D26:  DATA 00,00
00D28:  DATA 28,44
00D2A:  DATA 4F,70
00D2C:  DATA 74,36
00D2E:  DATA 29,20
00D30:  DATA 44,4F
00D32:  DATA 70,74
00D34:  DATA 32,63
00D36:  DATA 61,6C
00D38:  DATA 33,6F
00D3A:  DATA 66,33
00D3C:  DATA 20,3D
00D3E:  DATA 20,25
00D40:  DATA 4C,75
00D42:  DATA 0A,0D
00D44:  DATA 00,00
00D46:  DATA 28,44
00D48:  DATA 4F,70
00D4A:  DATA 74,37
00D4C:  DATA 29,20
00D4E:  DATA 44,4F
00D50:  DATA 70,74
00D52:  DATA 33,63
00D54:  DATA 61,6C
00D56:  DATA 31,6F
00D58:  DATA 66,33
00D5A:  DATA 20,3D
00D5C:  DATA 20,25
00D5E:  DATA 4C,75
00D60:  DATA 0A,0D
00D62:  DATA 00,00
00D64:  DATA 28,44
00D66:  DATA 4F,70
00D68:  DATA 74,38
00D6A:  DATA 29,20
00D6C:  DATA 44,4F
00D6E:  DATA 70,74
00D70:  DATA 33,63
00D72:  DATA 61,6C
00D74:  DATA 32,6F
00D76:  DATA 66,33
00D78:  DATA 20,3D
00D7A:  DATA 20,25
00D7C:  DATA 4C,75
00D7E:  DATA 0A,0D
00D80:  DATA 00,00
00D82:  DATA 28,44
00D84:  DATA 4F,70
00D86:  DATA 74,39
00D88:  DATA 29,20
00D8A:  DATA 44,4F
00D8C:  DATA 70,74
00D8E:  DATA 33,63
00D90:  DATA 61,6C
00D92:  DATA 33,6F
00D94:  DATA 66,33
00D96:  DATA 20,3D
00D98:  DATA 20,25
00D9A:  DATA 4C,75
00D9C:  DATA 0A,0D
00D9E:  DATA 00,00
00DA0:  DATA 28,44
00DA2:  DATA 4F,72
00DA4:  DATA 65,74
00DA6:  DATA 31,29
00DA8:  DATA 20,44
00DAA:  DATA 4F,70
00DAC:  DATA 74,31
00DAE:  DATA 72,65
00DB0:  DATA 74,75
00DB2:  DATA 72,6E
00DB4:  DATA 65,64
00DB6:  DATA 6E,75
00DB8:  DATA 6D,62
00DBA:  DATA 65,72
00DBC:  DATA 20,3D
00DBE:  DATA 20,25
00DC0:  DATA 66,0A
00DC2:  DATA 0D,00
00DC4:  DATA 28,44
00DC6:  DATA 4F,72
00DC8:  DATA 65,74
00DCA:  DATA 29,20
00DCC:  DATA 44,4F
00DCE:  DATA 70,74
00DD0:  DATA 32,72
00DD2:  DATA 65,74
00DD4:  DATA 75,72
00DD6:  DATA 6E,65
00DD8:  DATA 64,6E
00DDA:  DATA 75,6D
00DDC:  DATA 62,65
00DDE:  DATA 72,20
00DE0:  DATA 3D,20
00DE2:  DATA 25,66
00DE4:  DATA 0A,0D
00DE6:  DATA 00,00
00DE8:  DATA 28,44
00DEA:  DATA 4F,72
00DEC:  DATA 65,74
00DEE:  DATA 33,29
00DF0:  DATA 20,44
00DF2:  DATA 4F,70
00DF4:  DATA 74,33
00DF6:  DATA 72,65
00DF8:  DATA 74,75
00DFA:  DATA 72,6E
00DFC:  DATA 65,64
00DFE:  DATA 6E,75
00E00:  DATA 6D,62
00E02:  DATA 65,72
00E04:  DATA 20,3D
00E06:  DATA 20,25
00E08:  DATA 66,0A
00E0A:  DATA 0D,00
00E0C:  DATA 28,54
00E0E:  DATA 48,70
00E10:  DATA 74,31
00E12:  DATA 29,20
00E14:  DATA 54,68
00E16:  DATA 65,72
00E18:  DATA 6D,69
00E1A:  DATA 73,74
00E1C:  DATA 65,72
00E1E:  DATA 70,74
00E20:  DATA 31,63
00E22:  DATA 61,6C
00E24:  DATA 31,6F
00E26:  DATA 66,33
00E28:  DATA 20,3D
00E2A:  DATA 20,25
00E2C:  DATA 4C,75
00E2E:  DATA 0A,0D
00E30:  DATA 00,00
00E32:  DATA 28,54
00E34:  DATA 48,70
00E36:  DATA 74,32
00E38:  DATA 29,20
00E3A:  DATA 54,68
00E3C:  DATA 65,72
00E3E:  DATA 6D,69
00E40:  DATA 73,74
00E42:  DATA 65,72
00E44:  DATA 70,74
00E46:  DATA 32,63
00E48:  DATA 61,6C
00E4A:  DATA 31,6F
00E4C:  DATA 66,33
00E4E:  DATA 20,3D
00E50:  DATA 20,25
00E52:  DATA 4C,75
00E54:  DATA 0A,0D
00E56:  DATA 00,00
00E58:  DATA 28,54
00E5A:  DATA 48,70
00E5C:  DATA 74,33
00E5E:  DATA 29,20
00E60:  DATA 54,68
00E62:  DATA 65,72
00E64:  DATA 6D,69
00E66:  DATA 73,74
00E68:  DATA 65,72
00E6A:  DATA 70,74
00E6C:  DATA 33,63
00E6E:  DATA 61,6C
00E70:  DATA 31,6F
00E72:  DATA 66,33
00E74:  DATA 20,3D
00E76:  DATA 20,25
00E78:  DATA 4C,75
00E7A:  DATA 0A,0D
00E7C:  DATA 00,00
00E7E:  DATA 28,54
00E80:  DATA 48,72
00E82:  DATA 65,74
00E84:  DATA 31,29
00E86:  DATA 20,54
00E88:  DATA 68,65
00E8A:  DATA 72,6D
00E8C:  DATA 69,73
00E8E:  DATA 74,65
00E90:  DATA 72,70
00E92:  DATA 74,31
00E94:  DATA 72,65
00E96:  DATA 74,75
00E98:  DATA 72,6E
00E9A:  DATA 65,64
00E9C:  DATA 6E,75
00E9E:  DATA 6D,62
00EA0:  DATA 65,72
00EA2:  DATA 20,3D
00EA4:  DATA 20,25
00EA6:  DATA 66,0A
00EA8:  DATA 0D,00
00EAA:  DATA 28,54
00EAC:  DATA 48,72
00EAE:  DATA 65,74
00EB0:  DATA 32,29
00EB2:  DATA 20,54
00EB4:  DATA 68,65
00EB6:  DATA 72,6D
00EB8:  DATA 69,73
00EBA:  DATA 74,65
00EBC:  DATA 72,70
00EBE:  DATA 74,32
00EC0:  DATA 72,65
00EC2:  DATA 74,75
00EC4:  DATA 72,6E
00EC6:  DATA 65,64
00EC8:  DATA 6E,75
00ECA:  DATA 6D,62
00ECC:  DATA 65,72
00ECE:  DATA 20,3D
00ED0:  DATA 20,25
00ED2:  DATA 66,0A
00ED4:  DATA 0D,00
00ED6:  DATA 28,54
00ED8:  DATA 48,72
00EDA:  DATA 65,74
00EDC:  DATA 33,29
00EDE:  DATA 20,54
00EE0:  DATA 68,65
00EE2:  DATA 72,6D
00EE4:  DATA 69,73
00EE6:  DATA 74,65
00EE8:  DATA 72,70
00EEA:  DATA 74,33
00EEC:  DATA 72,65
00EEE:  DATA 74,75
00EF0:  DATA 72,6E
00EF2:  DATA 65,64
00EF4:  DATA 6E,75
00EF6:  DATA 6D,62
00EF8:  DATA 65,72
00EFA:  DATA 20,3D
00EFC:  DATA 20,25
00EFE:  DATA 66,0A
00F00:  DATA 0D,00
00F02:  DATA 65,63
00F04:  DATA 63,61
00F06:  DATA 6C,31
00F08:  DATA 78,20
00F0A:  DATA 3D,20
00F0C:  DATA 25,66
00F0E:  DATA 0A,0D
00F10:  DATA 00,00
00F12:  DATA 65,63
00F14:  DATA 63,61
00F16:  DATA 6C,32
00F18:  DATA 78,20
00F1A:  DATA 3D,20
00F1C:  DATA 25,66
00F1E:  DATA 0A,0D
00F20:  DATA 00,00
00F22:  DATA 65,63
00F24:  DATA 63,61
00F26:  DATA 6C,33
00F28:  DATA 78,20
00F2A:  DATA 3D,20
00F2C:  DATA 25,66
00F2E:  DATA 0A,0D
00F30:  DATA 00,00
00F32:  DATA 65,63
00F34:  DATA 63,61
00F36:  DATA 6C,31
00F38:  DATA 79,20
00F3A:  DATA 3D,20
00F3C:  DATA 25,66
00F3E:  DATA 0A,0D
00F40:  DATA 00,00
00F42:  DATA 65,63
00F44:  DATA 63,61
00F46:  DATA 6C,32
00F48:  DATA 79,20
00F4A:  DATA 3D,20
00F4C:  DATA 25,66
00F4E:  DATA 0A,0D
00F50:  DATA 00,00
00F52:  DATA 65,63
00F54:  DATA 63,61
00F56:  DATA 6C,33
00F58:  DATA 79,20
00F5A:  DATA 3D,20
00F5C:  DATA 25,66
00F5E:  DATA 0A,0D
00F60:  DATA 00,00
00F62:  DATA 53,61
00F64:  DATA 76,69
00F66:  DATA 6E,67
00F68:  DATA 20,43
00F6A:  DATA 61,6C
00F6C:  DATA 69,62
00F6E:  DATA 72,61
00F70:  DATA 74,69
00F72:  DATA 6F,6E
00F74:  DATA 73,20
00F76:  DATA 69,6E
00F78:  DATA 74,6F
00F7A:  DATA 20,45
00F7C:  DATA 45,50
00F7E:  DATA 52,4F
00F80:  DATA 4D,0A
00F82:  DATA 0D,00
00F84:  DATA 43,6F
00F86:  DATA 6D,70
00F88:  DATA 6C,65
00F8A:  DATA 74,69
00F8C:  DATA 6E,67
00F8E:  DATA 20,6C
00F90:  DATA 61,73
00F92:  DATA 74,20
00F94:  DATA 70,6F
00F96:  DATA 6C,6C
00F98:  DATA 69,6E
00F9A:  DATA 67,20
00F9C:  DATA 62,65
00F9E:  DATA 66,6F
00FA0:  DATA 72,65
00FA2:  DATA 20,75
00FA4:  DATA 70,64
00FA6:  DATA 61,74
00FA8:  DATA 69,6E
00FAA:  DATA 67,0A
00FAC:  DATA 0D,00
00FAE:  DATA 0D,0A
00FB0:  DATA 3E,00
*
0101C:  DATA 49,64
0101E:  DATA 65,6E
01020:  DATA 74,69
01022:  DATA 66,79
01024:  DATA 69,6E
01026:  DATA 67,00
01028:  DATA 56,65
0102A:  DATA 72,6E
0102C:  DATA 69,65
0102E:  DATA 72,20
01030:  DATA 25,4C
01032:  DATA 75,20
01034:  DATA 4E,48
01036:  DATA 33,20
01038:  DATA 25,66
0103A:  DATA 20,20
0103C:  DATA 00,00
0103E:  DATA 54,49
01040:  DATA 20,31
01042:  DATA 30,31
01044:  DATA 35,20
01046:  DATA 52,48
01048:  DATA 2F,54
0104A:  DATA 65,6D
0104C:  DATA 70,00
0104E:  DATA 54,65
01050:  DATA 6D,70
01052:  DATA 20,25
01054:  DATA 66,00
01056:  DATA 52,48
01058:  DATA 20,25
0105A:  DATA 66,00
0105C:  DATA 20,20
0105E:  DATA 20,20
01060:  DATA 20,20
01062:  DATA 20,54
01064:  DATA 41,4F
01066:  DATA 53,20
01068:  DATA 33,34
0106A:  DATA 31,34
0106C:  DATA 00,00
0106E:  DATA 72,65
01070:  DATA 64,20
01072:  DATA 25,4C
01074:  DATA 75,00
01076:  DATA 67,72
01078:  DATA 65,65
0107A:  DATA 6E,20
0107C:  DATA 25,4C
0107E:  DATA 75,00
01080:  DATA 62,6C
01082:  DATA 75,65
01084:  DATA 20,25
01086:  DATA 4C,75
01088:  DATA 00,00
0108A:  DATA 20,41
0108C:  DATA 6E,61
0108E:  DATA 6C,6F
01090:  DATA 67,20
01092:  DATA 44,4F
01094:  DATA 20,61
01096:  DATA 6E,64
01098:  DATA 20,4E
0109A:  DATA 48,34
0109C:  DATA 20,20
0109E:  DATA 00,00
010A0:  DATA 57,54
010A2:  DATA 20,25
010A4:  DATA 66,20
010A6:  DATA 20,52
010A8:  DATA 61,77
010AA:  DATA 20,25
010AC:  DATA 4C,75
010AE:  DATA 20,20
010B0:  DATA 00,00
010B2:  DATA 4E,48
010B4:  DATA 34,20
010B6:  DATA 25,4C
010B8:  DATA 75,20
010BA:  DATA 20,20
010BC:  DATA 00,00
010BE:  DATA 44,4F
010C0:  DATA 20,25
010C2:  DATA 4C,75
010C4:  DATA 20,20
010C6:  DATA 20,00
010C8:  DATA 57,54
010CA:  DATA 20,25
010CC:  DATA 66,20
010CE:  DATA 20,52
010D0:  DATA 61,77
010D2:  DATA 20,25
010D4:  DATA 4C,75
010D6:  DATA 20,20
010D8:  DATA 00,00
010DA:  DATA 44,4F
010DC:  DATA 20,52
010DE:  DATA 61,77
010E0:  DATA 20,25
010E2:  DATA 4C,75
010E4:  DATA 20,20
010E6:  DATA 20,20
010E8:  DATA 00,00
010EA:  DATA 4E,48
010EC:  DATA 34,2D
010EE:  DATA 44,4F
010F0:  DATA 20,52
010F2:  DATA 47,42
010F4:  DATA 57,2C
010F6:  DATA 25,4C
010F8:  DATA 75,2C
010FA:  DATA 25,4C
010FC:  DATA 75,2C
010FE:  DATA 25,4C
01100:  DATA 75,2C
01102:  DATA 25,4C
01104:  DATA 75,2C
01106:  DATA 44,4F
01108:  DATA 20,52
0110A:  DATA 65,64
0110C:  DATA 2C,25
0110E:  DATA 4C,75
01110:  DATA 2C,57
01112:  DATA 54,2C
01114:  DATA 25,66
01116:  DATA 2C,52
01118:  DATA 61,77
0111A:  DATA 2C,25
0111C:  DATA 4C,75
0111E:  DATA 2C,44
01120:  DATA 70,68
01122:  DATA 2D,52
01124:  DATA 47,42
01126:  DATA 57,2C
01128:  DATA 25,4C
0112A:  DATA 75,2C
0112C:  DATA 25,4C
0112E:  DATA 75,2C
01130:  DATA 25,4C
01132:  DATA 75,2C
01134:  DATA 25,4C
01136:  DATA 75,0A
01138:  DATA 0D,00
0113A:  DATA 20,20
0113C:  DATA 43,4F
0113E:  DATA 32,2F
01140:  DATA 52,48
01142:  DATA 2F,54
01144:  DATA 65,6D
01146:  DATA 70,20
01148:  DATA 20,20
0114A:  DATA 00,00
0114C:  DATA 41,54
0114E:  DATA 20,25
01150:  DATA 66,20
01152:  DATA 20,52
01154:  DATA 48,20
01156:  DATA 20,25
01158:  DATA 66,20
0115A:  DATA 20,00
0115C:  DATA 43,4F
0115E:  DATA 32,20
01160:  DATA 25,4C
01162:  DATA 75,20
01164:  DATA 20,20
01166:  DATA 20,00
01168:  DATA 43,6F
0116A:  DATA 6D,6D
0116C:  DATA 61,6E
0116E:  DATA 64,20
01170:  DATA 4C,69
01172:  DATA 6E,65
01174:  DATA 20,50
01176:  DATA 72,6F
01178:  DATA 63,65
0117A:  DATA 73,73
0117C:  DATA 6F,72
0117E:  DATA 0D,0A
01180:  DATA 3E,00
01182:  DATA 50,72
01184:  DATA 65,73
01186:  DATA 73,20
01188:  DATA 3F,20
0118A:  DATA 61,6E
0118C:  DATA 64,20
0118E:  DATA 43,52
01190:  DATA 20,66
01192:  DATA 6F,72
01194:  DATA 20,61
01196:  DATA 20,6C
01198:  DATA 69,73
0119A:  DATA 74,20
0119C:  DATA 6F,66
0119E:  DATA 20,63
011A0:  DATA 6F,6D
011A2:  DATA 6D,61
011A4:  DATA 6E,64
011A6:  DATA 73,0D
011A8:  DATA 0A,3E
011AA:  DATA 00,00
011AC:  DATA 53,65
011AE:  DATA 6E,64
011B0:  DATA 69,6E
011B2:  DATA 67,20
011B4:  DATA 55,70
011B6:  DATA 64,61
011B8:  DATA 74,65
011BA:  DATA 64,20
011BC:  DATA 43,6F
011BE:  DATA 6E,66
011C0:  DATA 69,67
011C2:  DATA 75,72
011C4:  DATA 61,74
011C6:  DATA 69,6F
011C8:  DATA 6E,73
011CA:  DATA 0A,0D
011CC:  DATA 00,00
011CE:  DATA 55,70
011D0:  DATA 64,61
011D2:  DATA 74,65
011D4:  DATA 20,43
011D6:  DATA 6F,6D
011D8:  DATA 70,6C
011DA:  DATA 65,74
011DC:  DATA 65,64
011DE:  DATA 0D,0A
011E0:  DATA 00,00
*
01C32:  TBLRD*+
01C34:  MOVF   FF5,F
01C36:  BZ    1C52
01C38:  MOVFF  FF6,7A8
01C3C:  MOVFF  FF7,7A9
01C40:  MOVF   FF5,W
01C42:  BTFSS  F9E.4
01C44:  BRA    1C42
01C46:  MOVWF  FAD
01C48:  MOVFF  7A8,FF6
01C4C:  MOVFF  7A9,FF7
01C50:  BRA    1C32
01C52:  RETURN 0
01C54:  MOVFF  232,FEA
01C58:  MOVFF  231,FE9
01C5C:  MOVLB  7
01C5E:  MOVFF  7BC,FEF
01C62:  INCF   FE9,F
01C64:  BTFSC  FD8.2
01C66:  INCF   FEA,F
01C68:  CLRF   FEF
01C6A:  MOVLB  2
01C6C:  INCF   x31,F
01C6E:  BTFSC  FD8.2
01C70:  INCF   x32,F
01C72:  MOVLB  0
01C74:  RETURN 0
01C76:  TBLRD*+
01C78:  MOVF   FF5,F
01C7A:  BZ    1C94
01C7C:  MOVFF  FF6,7AF
01C80:  MOVFF  FF7,7B0
01C84:  MOVFF  FF5,7BC
01C88:  RCALL  1C54
01C8A:  MOVFF  7AF,FF6
01C8E:  MOVFF  7B0,FF7
01C92:  BRA    1C76
01C94:  RETURN 0
*
01CF2:  MOVLW  80
01CF4:  BTFSS  FD8.1
01CF6:  BRA    1CFC
01CF8:  MOVLB  7
01CFA:  XORWF  xE8,F
01CFC:  MOVLB  7
01CFE:  CLRF   xED
01D00:  CLRF   xEE
01D02:  MOVFF  7E4,7EC
01D06:  MOVF   xE8,W
01D08:  XORWF  xEC,F
01D0A:  MOVF   xE3,W
01D0C:  BTFSC  FD8.2
01D0E:  BRA    1ECE
01D10:  MOVWF  xEB
01D12:  MOVWF  00
01D14:  MOVF   xE7,W
01D16:  BTFSC  FD8.2
01D18:  BRA    1EE0
01D1A:  SUBWF  xEB,F
01D1C:  BTFSC  FD8.2
01D1E:  BRA    1E26
01D20:  BNC   1D9E
01D22:  MOVFF  7E8,7F1
01D26:  BSF    xF1.7
01D28:  MOVFF  7E9,7F0
01D2C:  MOVFF  7EA,7EF
01D30:  CLRF   xEE
01D32:  BCF    FD8.0
01D34:  RRCF   xF1,F
01D36:  RRCF   xF0,F
01D38:  RRCF   xEF,F
01D3A:  RRCF   xEE,F
01D3C:  DECFSZ xEB,F
01D3E:  BRA    1D30
01D40:  BTFSS  xEC.7
01D42:  BRA    1D4A
01D44:  BSF    xED.0
01D46:  BRA    1F08
01D48:  BCF    xED.0
01D4A:  BCF    xEB.0
01D4C:  BSF    xED.4
01D4E:  MOVLW  07
01D50:  MOVWF  FEA
01D52:  MOVLW  E6
01D54:  MOVWF  FE9
01D56:  BRA    1F2E
01D58:  BCF    xED.4
01D5A:  BTFSC  xEC.7
01D5C:  BRA    1D72
01D5E:  BTFSS  xEB.0
01D60:  BRA    1D88
01D62:  RRCF   xF1,F
01D64:  RRCF   xF0,F
01D66:  RRCF   xEF,F
01D68:  RRCF   xEE,F
01D6A:  INCF   00,F
01D6C:  BTFSC  FD8.2
01D6E:  BRA    1EFE
01D70:  BRA    1D88
01D72:  BTFSC  xF1.7
01D74:  BRA    1D8E
01D76:  BCF    FD8.0
01D78:  RLCF   xEE,F
01D7A:  RLCF   xEF,F
01D7C:  RLCF   xF0,F
01D7E:  RLCF   xF1,F
01D80:  DECF   00,F
01D82:  BTFSC  FD8.2
01D84:  BRA    1EFE
01D86:  BRA    1D72
01D88:  BSF    xED.6
01D8A:  BRA    1E66
01D8C:  BCF    xED.6
01D8E:  MOVFF  7E4,7EC
01D92:  BTFSS  xE4.7
01D94:  BRA    1D9A
01D96:  BSF    xF1.7
01D98:  BRA    1EF0
01D9A:  BCF    xF1.7
01D9C:  BRA    1EF0
01D9E:  MOVFF  7E7,7EB
01DA2:  MOVFF  7E7,00
01DA6:  MOVF   xE3,W
01DA8:  SUBWF  xEB,F
01DAA:  MOVFF  7E4,7F1
01DAE:  BSF    xF1.7
01DB0:  MOVFF  7E5,7F0
01DB4:  MOVFF  7E6,7EF
01DB8:  CLRF   xEE
01DBA:  BCF    FD8.0
01DBC:  RRCF   xF1,F
01DBE:  RRCF   xF0,F
01DC0:  RRCF   xEF,F
01DC2:  RRCF   xEE,F
01DC4:  DECFSZ xEB,F
01DC6:  BRA    1DB8
01DC8:  BTFSS  xEC.7
01DCA:  BRA    1DD2
01DCC:  BSF    xED.1
01DCE:  BRA    1F08
01DD0:  BCF    xED.1
01DD2:  BCF    xEB.0
01DD4:  BSF    xED.5
01DD6:  MOVLW  07
01DD8:  MOVWF  FEA
01DDA:  MOVLW  EA
01DDC:  MOVWF  FE9
01DDE:  BRA    1F2E
01DE0:  BCF    xED.5
01DE2:  BTFSC  xEC.7
01DE4:  BRA    1DFA
01DE6:  BTFSS  xEB.0
01DE8:  BRA    1E10
01DEA:  RRCF   xF1,F
01DEC:  RRCF   xF0,F
01DEE:  RRCF   xEF,F
01DF0:  RRCF   xEE,F
01DF2:  INCF   00,F
01DF4:  BTFSC  FD8.2
01DF6:  BRA    1EFE
01DF8:  BRA    1E10
01DFA:  BTFSC  xF1.7
01DFC:  BRA    1E16
01DFE:  BCF    FD8.0
01E00:  RLCF   xEE,F
01E02:  RLCF   xEF,F
01E04:  RLCF   xF0,F
01E06:  RLCF   xF1,F
01E08:  DECF   00,F
01E0A:  BTFSC  FD8.2
01E0C:  BRA    1EFE
01E0E:  BRA    1DFA
01E10:  BSF    xED.7
01E12:  BRA    1E66
01E14:  BCF    xED.7
01E16:  MOVFF  7E8,7EC
01E1A:  BTFSS  xE8.7
01E1C:  BRA    1E22
01E1E:  BSF    xF1.7
01E20:  BRA    1EF0
01E22:  BCF    xF1.7
01E24:  BRA    1EF0
01E26:  MOVFF  7E8,7F1
01E2A:  BSF    xF1.7
01E2C:  MOVFF  7E9,7F0
01E30:  MOVFF  7EA,7EF
01E34:  BTFSS  xEC.7
01E36:  BRA    1E40
01E38:  BCF    xF1.7
01E3A:  BSF    xED.2
01E3C:  BRA    1F08
01E3E:  BCF    xED.2
01E40:  CLRF   xEE
01E42:  BCF    xEB.0
01E44:  MOVLW  07
01E46:  MOVWF  FEA
01E48:  MOVLW  E6
01E4A:  MOVWF  FE9
01E4C:  BRA    1F2E
01E4E:  BTFSC  xEC.7
01E50:  BRA    1E8A
01E52:  MOVFF  7E4,7EC
01E56:  BTFSS  xEB.0
01E58:  BRA    1E66
01E5A:  RRCF   xF1,F
01E5C:  RRCF   xF0,F
01E5E:  RRCF   xEF,F
01E60:  RRCF   xEE,F
01E62:  INCF   00,F
01E64:  BZ    1EFE
01E66:  BTFSS  xEE.7
01E68:  BRA    1E80
01E6A:  INCF   xEF,F
01E6C:  BNZ   1E80
01E6E:  INCF   xF0,F
01E70:  BNZ   1E80
01E72:  INCF   xF1,F
01E74:  BNZ   1E80
01E76:  RRCF   xF1,F
01E78:  RRCF   xF0,F
01E7A:  RRCF   xEF,F
01E7C:  INCF   00,F
01E7E:  BZ    1EFE
01E80:  BTFSC  xED.6
01E82:  BRA    1D8C
01E84:  BTFSC  xED.7
01E86:  BRA    1E14
01E88:  BRA    1EC2
01E8A:  MOVLW  80
01E8C:  XORWF  xF1,F
01E8E:  BTFSS  xF1.7
01E90:  BRA    1E9A
01E92:  BRA    1F08
01E94:  MOVFF  7E8,7EC
01E98:  BRA    1EAE
01E9A:  MOVFF  7E4,7EC
01E9E:  MOVF   xF1,F
01EA0:  BNZ   1EAE
01EA2:  MOVF   xF0,F
01EA4:  BNZ   1EAE
01EA6:  MOVF   xEF,F
01EA8:  BNZ   1EAE
01EAA:  CLRF   00
01EAC:  BRA    1EF0
01EAE:  BTFSC  xF1.7
01EB0:  BRA    1EC2
01EB2:  BCF    FD8.0
01EB4:  RLCF   xEE,F
01EB6:  RLCF   xEF,F
01EB8:  RLCF   xF0,F
01EBA:  RLCF   xF1,F
01EBC:  DECFSZ 00,F
01EBE:  BRA    1EAE
01EC0:  BRA    1EFE
01EC2:  BTFSS  xEC.7
01EC4:  BRA    1ECA
01EC6:  BSF    xF1.7
01EC8:  BRA    1EF0
01ECA:  BCF    xF1.7
01ECC:  BRA    1EF0
01ECE:  MOVFF  7E7,00
01ED2:  MOVFF  7E8,7F1
01ED6:  MOVFF  7E9,7F0
01EDA:  MOVFF  7EA,7EF
01EDE:  BRA    1EF0
01EE0:  MOVFF  7E3,00
01EE4:  MOVFF  7E4,7F1
01EE8:  MOVFF  7E5,7F0
01EEC:  MOVFF  7E6,7EF
01EF0:  MOVFF  7F1,01
01EF4:  MOVFF  7F0,02
01EF8:  MOVFF  7EF,03
01EFC:  BRA    1F66
01EFE:  CLRF   00
01F00:  CLRF   01
01F02:  CLRF   02
01F04:  CLRF   03
01F06:  BRA    1F66
01F08:  CLRF   xEE
01F0A:  COMF   xEF,F
01F0C:  COMF   xF0,F
01F0E:  COMF   xF1,F
01F10:  COMF   xEE,F
01F12:  INCF   xEE,F
01F14:  BNZ   1F20
01F16:  INCF   xEF,F
01F18:  BNZ   1F20
01F1A:  INCF   xF0,F
01F1C:  BNZ   1F20
01F1E:  INCF   xF1,F
01F20:  BTFSC  xED.0
01F22:  BRA    1D48
01F24:  BTFSC  xED.1
01F26:  BRA    1DD0
01F28:  BTFSC  xED.2
01F2A:  BRA    1E3E
01F2C:  BRA    1E94
01F2E:  MOVF   FEF,W
01F30:  ADDWF  xEF,F
01F32:  BNC   1F3E
01F34:  INCF   xF0,F
01F36:  BNZ   1F3E
01F38:  INCF   xF1,F
01F3A:  BTFSC  FD8.2
01F3C:  BSF    xEB.0
01F3E:  MOVF   FED,F
01F40:  MOVF   FEF,W
01F42:  ADDWF  xF0,F
01F44:  BNC   1F4C
01F46:  INCF   xF1,F
01F48:  BTFSC  FD8.2
01F4A:  BSF    xEB.0
01F4C:  MOVF   FED,F
01F4E:  MOVF   FEF,W
01F50:  BTFSC  FEF.7
01F52:  BRA    1F56
01F54:  XORLW  80
01F56:  ADDWF  xF1,F
01F58:  BTFSC  FD8.0
01F5A:  BSF    xEB.0
01F5C:  BTFSC  xED.4
01F5E:  BRA    1D58
01F60:  BTFSC  xED.5
01F62:  BRA    1DE0
01F64:  BRA    1E4E
01F66:  MOVLB  0
01F68:  RETURN 0
01F6A:  MOVLB  7
01F6C:  MOVF   xD8,W
01F6E:  BTFSC  FD8.2
01F70:  BRA    20BC
01F72:  MOVWF  xE4
01F74:  MOVF   xDC,W
01F76:  BTFSC  FD8.2
01F78:  BRA    20BC
01F7A:  SUBWF  xE4,F
01F7C:  BNC   1F88
01F7E:  MOVLW  7F
01F80:  ADDWF  xE4,F
01F82:  BTFSC  FD8.0
01F84:  BRA    20BC
01F86:  BRA    1F94
01F88:  MOVLW  81
01F8A:  SUBWF  xE4,F
01F8C:  BTFSS  FD8.0
01F8E:  BRA    20BC
01F90:  BTFSC  FD8.2
01F92:  BRA    20BC
01F94:  MOVFF  7E4,00
01F98:  CLRF   01
01F9A:  CLRF   02
01F9C:  CLRF   03
01F9E:  CLRF   xE3
01FA0:  MOVFF  7D9,7E2
01FA4:  BSF    xE2.7
01FA6:  MOVFF  7DA,7E1
01FAA:  MOVFF  7DB,7E0
01FAE:  MOVLW  19
01FB0:  MOVWF  xE4
01FB2:  MOVF   xDF,W
01FB4:  SUBWF  xE0,F
01FB6:  BC    1FD2
01FB8:  MOVLW  01
01FBA:  SUBWF  xE1,F
01FBC:  BC    1FD2
01FBE:  SUBWF  xE2,F
01FC0:  BC    1FD2
01FC2:  SUBWF  xE3,F
01FC4:  BC    1FD2
01FC6:  INCF   xE3,F
01FC8:  INCF   xE2,F
01FCA:  INCF   xE1,F
01FCC:  MOVF   xDF,W
01FCE:  ADDWF  xE0,F
01FD0:  BRA    2022
01FD2:  MOVF   xDE,W
01FD4:  SUBWF  xE1,F
01FD6:  BC    1FFC
01FD8:  MOVLW  01
01FDA:  SUBWF  xE2,F
01FDC:  BC    1FFC
01FDE:  SUBWF  xE3,F
01FE0:  BC    1FFC
01FE2:  INCF   xE3,F
01FE4:  INCF   xE2,F
01FE6:  MOVF   xDE,W
01FE8:  ADDWF  xE1,F
01FEA:  MOVF   xDF,W
01FEC:  ADDWF  xE0,F
01FEE:  BNC   2022
01FF0:  INCF   xE1,F
01FF2:  BNZ   2022
01FF4:  INCF   xE2,F
01FF6:  BNZ   2022
01FF8:  INCF   xE3,F
01FFA:  BRA    2022
01FFC:  MOVF   xDD,W
01FFE:  IORLW  80
02000:  SUBWF  xE2,F
02002:  BC    2020
02004:  MOVLW  01
02006:  SUBWF  xE3,F
02008:  BC    2020
0200A:  INCF   xE3,F
0200C:  MOVF   xDD,W
0200E:  IORLW  80
02010:  ADDWF  xE2,F
02012:  MOVF   xDE,W
02014:  ADDWF  xE1,F
02016:  BNC   1FEA
02018:  INCF   xE2,F
0201A:  BNZ   1FEA
0201C:  INCF   xE3,F
0201E:  BRA    1FEA
02020:  BSF    03.0
02022:  DECFSZ xE4,F
02024:  BRA    2028
02026:  BRA    203E
02028:  BCF    FD8.0
0202A:  RLCF   xE0,F
0202C:  RLCF   xE1,F
0202E:  RLCF   xE2,F
02030:  RLCF   xE3,F
02032:  BCF    FD8.0
02034:  RLCF   03,F
02036:  RLCF   02,F
02038:  RLCF   01,F
0203A:  RLCF   xE5,F
0203C:  BRA    1FB2
0203E:  BTFSS  xE5.0
02040:  BRA    204E
02042:  BCF    FD8.0
02044:  RRCF   01,F
02046:  RRCF   02,F
02048:  RRCF   03,F
0204A:  RRCF   xE5,F
0204C:  BRA    2052
0204E:  DECF   00,F
02050:  BZ    20BC
02052:  BTFSC  xE5.7
02054:  BRA    2092
02056:  BCF    FD8.0
02058:  RLCF   xE0,F
0205A:  RLCF   xE1,F
0205C:  RLCF   xE2,F
0205E:  RLCF   xE3,F
02060:  MOVF   xDF,W
02062:  SUBWF  xE0,F
02064:  BC    2074
02066:  MOVLW  01
02068:  SUBWF  xE1,F
0206A:  BC    2074
0206C:  SUBWF  xE2,F
0206E:  BC    2074
02070:  SUBWF  xE3,F
02072:  BNC   20A8
02074:  MOVF   xDE,W
02076:  SUBWF  xE1,F
02078:  BC    2084
0207A:  MOVLW  01
0207C:  SUBWF  xE2,F
0207E:  BC    2084
02080:  SUBWF  xE3,F
02082:  BNC   20A8
02084:  MOVF   xDD,W
02086:  IORLW  80
02088:  SUBWF  xE2,F
0208A:  BC    2092
0208C:  MOVLW  01
0208E:  SUBWF  xE3,F
02090:  BNC   20A8
02092:  INCF   03,F
02094:  BNZ   20A8
02096:  INCF   02,F
02098:  BNZ   20A8
0209A:  INCF   01,F
0209C:  BNZ   20A8
0209E:  INCF   00,F
020A0:  BZ    20BC
020A2:  RRCF   01,F
020A4:  RRCF   02,F
020A6:  RRCF   03,F
020A8:  MOVFF  7D9,7E4
020AC:  MOVF   xDD,W
020AE:  XORWF  xE4,F
020B0:  BTFSS  xE4.7
020B2:  BRA    20B8
020B4:  BSF    01.7
020B6:  BRA    20C4
020B8:  BCF    01.7
020BA:  BRA    20C4
020BC:  CLRF   00
020BE:  CLRF   01
020C0:  CLRF   02
020C2:  CLRF   03
020C4:  MOVLB  0
020C6:  RETURN 0
020C8:  MOVLB  7
020CA:  MOVF   xDF,W
020CC:  BTFSC  FD8.2
020CE:  BRA    21B2
020D0:  MOVWF  00
020D2:  MOVF   xE3,W
020D4:  BTFSC  FD8.2
020D6:  BRA    21B2
020D8:  ADDWF  00,F
020DA:  BNC   20E4
020DC:  MOVLW  81
020DE:  ADDWF  00,F
020E0:  BC    21B2
020E2:  BRA    20EC
020E4:  MOVLW  7F
020E6:  SUBWF  00,F
020E8:  BNC   21B2
020EA:  BZ    21B2
020EC:  MOVFF  7E0,7E7
020F0:  MOVF   xE4,W
020F2:  XORWF  xE7,F
020F4:  BSF    xE0.7
020F6:  BSF    xE4.7
020F8:  MOVF   xE2,W
020FA:  MULWF  xE6
020FC:  MOVFF  FF4,7E9
02100:  MOVF   xE1,W
02102:  MULWF  xE5
02104:  MOVFF  FF4,03
02108:  MOVFF  FF3,7E8
0210C:  MULWF  xE6
0210E:  MOVF   FF3,W
02110:  ADDWF  xE9,F
02112:  MOVF   FF4,W
02114:  ADDWFC xE8,F
02116:  MOVLW  00
02118:  ADDWFC 03,F
0211A:  MOVF   xE2,W
0211C:  MULWF  xE5
0211E:  MOVF   FF3,W
02120:  ADDWF  xE9,F
02122:  MOVF   FF4,W
02124:  ADDWFC xE8,F
02126:  MOVLW  00
02128:  CLRF   02
0212A:  ADDWFC 03,F
0212C:  ADDWFC 02,F
0212E:  MOVF   xE0,W
02130:  MULWF  xE6
02132:  MOVF   FF3,W
02134:  ADDWF  xE8,F
02136:  MOVF   FF4,W
02138:  ADDWFC 03,F
0213A:  MOVLW  00
0213C:  ADDWFC 02,F
0213E:  MOVF   xE0,W
02140:  MULWF  xE5
02142:  MOVF   FF3,W
02144:  ADDWF  03,F
02146:  MOVF   FF4,W
02148:  ADDWFC 02,F
0214A:  MOVLW  00
0214C:  CLRF   01
0214E:  ADDWFC 01,F
02150:  MOVF   xE2,W
02152:  MULWF  xE4
02154:  MOVF   FF3,W
02156:  ADDWF  xE8,F
02158:  MOVF   FF4,W
0215A:  ADDWFC 03,F
0215C:  MOVLW  00
0215E:  ADDWFC 02,F
02160:  ADDWFC 01,F
02162:  MOVF   xE1,W
02164:  MULWF  xE4
02166:  MOVF   FF3,W
02168:  ADDWF  03,F
0216A:  MOVF   FF4,W
0216C:  ADDWFC 02,F
0216E:  MOVLW  00
02170:  ADDWFC 01,F
02172:  MOVF   xE0,W
02174:  MULWF  xE4
02176:  MOVF   FF3,W
02178:  ADDWF  02,F
0217A:  MOVF   FF4,W
0217C:  ADDWFC 01,F
0217E:  INCF   00,F
02180:  BTFSC  01.7
02182:  BRA    218E
02184:  RLCF   xE8,F
02186:  RLCF   03,F
02188:  RLCF   02,F
0218A:  RLCF   01,F
0218C:  DECF   00,F
0218E:  MOVLW  00
02190:  BTFSS  xE8.7
02192:  BRA    21A8
02194:  INCF   03,F
02196:  ADDWFC 02,F
02198:  ADDWFC 01,F
0219A:  MOVF   01,W
0219C:  BNZ   21A8
0219E:  MOVF   02,W
021A0:  BNZ   21A8
021A2:  MOVF   03,W
021A4:  BNZ   21A8
021A6:  INCF   00,F
021A8:  BTFSC  xE7.7
021AA:  BSF    01.7
021AC:  BTFSS  xE7.7
021AE:  BCF    01.7
021B0:  BRA    21BA
021B2:  CLRF   00
021B4:  CLRF   01
021B6:  CLRF   02
021B8:  CLRF   03
021BA:  MOVLB  0
021BC:  RETURN 0
021BE:  MOVLW  8E
021C0:  MOVWF  00
021C2:  MOVFF  7E4,01
021C6:  MOVFF  7E3,02
021CA:  CLRF   03
021CC:  MOVF   01,F
021CE:  BNZ   21E2
021D0:  MOVFF  02,01
021D4:  CLRF   02
021D6:  MOVLW  08
021D8:  SUBWF  00,F
021DA:  MOVF   01,F
021DC:  BNZ   21E2
021DE:  CLRF   00
021E0:  BRA    21F2
021E2:  BCF    FD8.0
021E4:  BTFSC  01.7
021E6:  BRA    21F0
021E8:  RLCF   02,F
021EA:  RLCF   01,F
021EC:  DECF   00,F
021EE:  BRA    21E2
021F0:  BCF    01.7
021F2:  RETURN 0
021F4:  MOVFF  7E0,7E7
021F8:  MOVLB  7
021FA:  MOVF   xE4,W
021FC:  XORWF  xE7,F
021FE:  BTFSS  xE7.7
02200:  BRA    220C
02202:  BCF    FD8.2
02204:  BCF    FD8.0
02206:  BTFSC  xE0.7
02208:  BSF    FD8.0
0220A:  BRA    226A
0220C:  MOVFF  7E0,7E7
02210:  MOVFF  7E3,7E8
02214:  MOVF   xDF,W
02216:  SUBWF  xE8,F
02218:  BZ    2226
0221A:  BTFSS  xE7.7
0221C:  BRA    226A
0221E:  MOVF   FD8,W
02220:  XORLW  01
02222:  MOVWF  FD8
02224:  BRA    226A
02226:  MOVFF  7E4,7E8
0222A:  MOVF   xE0,W
0222C:  SUBWF  xE8,F
0222E:  BZ    223C
02230:  BTFSS  xE7.7
02232:  BRA    226A
02234:  MOVF   FD8,W
02236:  XORLW  01
02238:  MOVWF  FD8
0223A:  BRA    226A
0223C:  MOVFF  7E5,7E8
02240:  MOVF   xE1,W
02242:  SUBWF  xE8,F
02244:  BZ    2252
02246:  BTFSS  xE7.7
02248:  BRA    226A
0224A:  MOVF   FD8,W
0224C:  XORLW  01
0224E:  MOVWF  FD8
02250:  BRA    226A
02252:  MOVFF  7E6,7E8
02256:  MOVF   xE2,W
02258:  SUBWF  xE8,F
0225A:  BZ    2268
0225C:  BTFSS  xE7.7
0225E:  BRA    226A
02260:  MOVF   FD8,W
02262:  XORLW  01
02264:  MOVWF  FD8
02266:  BRA    226A
02268:  BCF    FD8.0
0226A:  MOVLB  0
0226C:  RETURN 0
0226E:  MOVLW  8E
02270:  MOVWF  00
02272:  MOVLB  7
02274:  MOVF   xDF,W
02276:  SUBWF  00,F
02278:  MOVFF  7E0,02
0227C:  MOVFF  7E1,01
02280:  BSF    02.7
02282:  MOVF   00,F
02284:  BZ    2298
02286:  BCF    FD8.0
02288:  MOVF   02,F
0228A:  BNZ   2290
0228C:  MOVF   01,F
0228E:  BZ    2298
02290:  RRCF   02,F
02292:  RRCF   01,F
02294:  DECFSZ 00,F
02296:  BRA    2286
02298:  BTFSS  xE0.7
0229A:  BRA    22A6
0229C:  COMF   01,F
0229E:  COMF   02,F
022A0:  INCF   01,F
022A2:  BTFSC  FD8.2
022A4:  INCF   02,F
022A6:  MOVLB  0
022A8:  RETURN 0
*
0278E:  MOVLW  8E
02790:  MOVWF  00
02792:  MOVFF  7D6,01
02796:  MOVFF  7D5,02
0279A:  CLRF   03
0279C:  BTFSS  01.7
0279E:  BRA    27AA
027A0:  COMF   01,F
027A2:  COMF   02,F
027A4:  INCF   02,F
027A6:  BNZ   27AA
027A8:  INCF   01,F
027AA:  MOVF   01,F
027AC:  BNZ   27C0
027AE:  MOVFF  02,01
027B2:  CLRF   02
027B4:  MOVLW  08
027B6:  SUBWF  00,F
027B8:  MOVF   01,F
027BA:  BNZ   27C0
027BC:  CLRF   00
027BE:  BRA    27DC
027C0:  BCF    FD8.0
027C2:  BTFSC  01.7
027C4:  BRA    27CE
027C6:  RLCF   02,F
027C8:  RLCF   01,F
027CA:  DECF   00,F
027CC:  BRA    27C0
027CE:  MOVLB  7
027D0:  BTFSS  xD6.7
027D2:  BRA    27D8
027D4:  MOVLB  0
027D6:  BRA    27DC
027D8:  BCF    01.7
027DA:  MOVLB  0
027DC:  RETURN 0
*
03290:  TBLRD*+
03292:  MOVFF  FF6,7B0
03296:  MOVFF  FF7,7B1
0329A:  MOVFF  FF5,7BC
0329E:  CALL   1C54
032A2:  MOVFF  7B0,FF6
032A6:  MOVFF  7B1,FF7
032AA:  MOVLB  7
032AC:  DECFSZ xAF,F
032AE:  BRA    32B2
032B0:  BRA    32B6
032B2:  MOVLB  0
032B4:  BRA    3290
032B6:  MOVLB  0
032B8:  RETURN 0
032BA:  MOVFF  FEA,7B7
032BE:  MOVFF  FE9,7B6
032C2:  MOVLB  7
032C4:  SWAPF  xB0,W
032C6:  IORLW  F0
032C8:  MOVWF  xB2
032CA:  ADDWF  xB2,F
032CC:  ADDLW  E2
032CE:  MOVWF  xB3
032D0:  ADDLW  32
032D2:  MOVWF  xB5
032D4:  MOVF   xB0,W
032D6:  ANDLW  0F
032D8:  ADDWF  xB3,F
032DA:  ADDWF  xB3,F
032DC:  ADDWF  xB5,F
032DE:  ADDLW  E9
032E0:  MOVWF  xB4
032E2:  ADDWF  xB4,F
032E4:  ADDWF  xB4,F
032E6:  SWAPF  xAF,W
032E8:  ANDLW  0F
032EA:  ADDWF  xB4,F
032EC:  ADDWF  xB5,F
032EE:  RLCF   xB4,F
032F0:  RLCF   xB5,F
032F2:  COMF   xB5,F
032F4:  RLCF   xB5,F
032F6:  MOVF   xAF,W
032F8:  ANDLW  0F
032FA:  ADDWF  xB5,F
032FC:  RLCF   xB2,F
032FE:  MOVLW  07
03300:  MOVWF  xB1
03302:  MOVLW  0A
03304:  DECF   xB4,F
03306:  ADDWF  xB5,F
03308:  BNC   3304
0330A:  DECF   xB3,F
0330C:  ADDWF  xB4,F
0330E:  BNC   330A
03310:  DECF   xB2,F
03312:  ADDWF  xB3,F
03314:  BNC   3310
03316:  DECF   xB1,F
03318:  ADDWF  xB2,F
0331A:  BNC   3316
0331C:  MOVLW  07
0331E:  MOVWF  FEA
03320:  MOVLW  B1
03322:  MOVWF  FE9
03324:  MOVLW  07
03326:  ANDWF  xB6,W
03328:  BCF    xB6.6
0332A:  ADDWF  FE9,F
0332C:  MOVLW  00
0332E:  ADDWFC FEA,F
03330:  MOVF   FE9,W
03332:  SUBLW  B5
03334:  BNZ   333E
03336:  MOVF   FEA,W
03338:  SUBLW  07
0333A:  BNZ   333E
0333C:  BSF    xB6.6
0333E:  MOVF   FEF,W
03340:  MOVWF  00
03342:  BNZ   3354
03344:  BTFSC  xB6.6
03346:  BRA    3354
03348:  BTFSC  xB6.4
0334A:  BRA    3378
0334C:  BTFSC  xB6.3
0334E:  BRA    3354
03350:  MOVLW  20
03352:  BRA    335A
03354:  BSF    xB6.3
03356:  BCF    xB6.4
03358:  MOVLW  30
0335A:  ADDWF  00,F
0335C:  MOVFF  FEA,7B0
03360:  MOVFF  FE9,7AF
03364:  MOVFF  00,7BC
03368:  MOVLB  0
0336A:  CALL   1C54
0336E:  MOVFF  7B0,FEA
03372:  MOVFF  7AF,FE9
03376:  MOVLB  7
03378:  MOVF   FEE,W
0337A:  BTFSS  xB6.6
0337C:  BRA    3330
0337E:  MOVLB  0
03380:  RETURN 0
03382:  MOVLB  7
03384:  MOVF   xBC,W
03386:  SUBLW  B6
03388:  MOVWF  xBC
0338A:  CLRF   03
0338C:  MOVFF  7BD,7C0
03390:  BSF    xBD.7
03392:  BCF    FD8.0
03394:  RRCF   xBD,F
03396:  RRCF   xBE,F
03398:  RRCF   xBF,F
0339A:  RRCF   03,F
0339C:  RRCF   02,F
0339E:  RRCF   01,F
033A0:  RRCF   00,F
033A2:  DECFSZ xBC,F
033A4:  BRA    3392
033A6:  BTFSS  xC0.7
033A8:  BRA    33C0
033AA:  COMF   00,F
033AC:  COMF   01,F
033AE:  COMF   02,F
033B0:  COMF   03,F
033B2:  INCF   00,F
033B4:  BTFSC  FD8.2
033B6:  INCF   01,F
033B8:  BTFSC  FD8.2
033BA:  INCF   02,F
033BC:  BTFSC  FD8.2
033BE:  INCF   03,F
033C0:  MOVLB  0
033C2:  RETURN 0
033C4:  BTFSC  FD8.1
033C6:  BRA    33D0
033C8:  MOVLW  07
033CA:  MOVWF  FEA
033CC:  MOVLW  C4
033CE:  MOVWF  FE9
033D0:  CLRF   00
033D2:  CLRF   01
033D4:  CLRF   02
033D6:  CLRF   03
033D8:  MOVLB  7
033DA:  CLRF   xC4
033DC:  CLRF   xC5
033DE:  CLRF   xC6
033E0:  CLRF   xC7
033E2:  MOVF   xC3,W
033E4:  IORWF  xC2,W
033E6:  IORWF  xC1,W
033E8:  IORWF  xC0,W
033EA:  BZ    3444
033EC:  MOVLW  20
033EE:  MOVWF  xC8
033F0:  BCF    FD8.0
033F2:  RLCF   xBC,F
033F4:  RLCF   xBD,F
033F6:  RLCF   xBE,F
033F8:  RLCF   xBF,F
033FA:  RLCF   xC4,F
033FC:  RLCF   xC5,F
033FE:  RLCF   xC6,F
03400:  RLCF   xC7,F
03402:  MOVF   xC3,W
03404:  SUBWF  xC7,W
03406:  BNZ   3418
03408:  MOVF   xC2,W
0340A:  SUBWF  xC6,W
0340C:  BNZ   3418
0340E:  MOVF   xC1,W
03410:  SUBWF  xC5,W
03412:  BNZ   3418
03414:  MOVF   xC0,W
03416:  SUBWF  xC4,W
03418:  BNC   3438
0341A:  MOVF   xC0,W
0341C:  SUBWF  xC4,F
0341E:  MOVF   xC1,W
03420:  BTFSS  FD8.0
03422:  INCFSZ xC1,W
03424:  SUBWF  xC5,F
03426:  MOVF   xC2,W
03428:  BTFSS  FD8.0
0342A:  INCFSZ xC2,W
0342C:  SUBWF  xC6,F
0342E:  MOVF   xC3,W
03430:  BTFSS  FD8.0
03432:  INCFSZ xC3,W
03434:  SUBWF  xC7,F
03436:  BSF    FD8.0
03438:  RLCF   00,F
0343A:  RLCF   01,F
0343C:  RLCF   02,F
0343E:  RLCF   03,F
03440:  DECFSZ xC8,F
03442:  BRA    33F0
03444:  MOVFF  7C4,FEF
03448:  MOVFF  7C5,FEC
0344C:  MOVFF  7C6,FEC
03450:  MOVFF  7C7,FEC
03454:  MOVLB  0
03456:  RETURN 0
03458:  MOVF   FE9,W
0345A:  MOVLB  7
0345C:  MOVWF  xB4
0345E:  MOVF   xB3,W
03460:  MOVWF  xB6
03462:  BZ    349C
03464:  MOVFF  7B2,7E2
03468:  MOVFF  7B1,7E1
0346C:  MOVFF  7B0,7E0
03470:  MOVFF  7AF,7DF
03474:  CLRF   xE6
03476:  CLRF   xE5
03478:  MOVLW  20
0347A:  MOVWF  xE4
0347C:  MOVLW  82
0347E:  MOVWF  xE3
03480:  MOVLB  0
03482:  CALL   20C8
03486:  MOVFF  03,7B2
0348A:  MOVFF  02,7B1
0348E:  MOVFF  01,7B0
03492:  MOVFF  00,7AF
03496:  MOVLB  7
03498:  DECFSZ xB6,F
0349A:  BRA    3464
0349C:  MOVFF  7B2,7BF
034A0:  MOVFF  7B1,7BE
034A4:  MOVFF  7B0,7BD
034A8:  MOVFF  7AF,7BC
034AC:  MOVLB  0
034AE:  RCALL  3382
034B0:  MOVFF  03,7B2
034B4:  MOVFF  02,7B1
034B8:  MOVFF  01,7B0
034BC:  MOVFF  00,7AF
034C0:  MOVLB  7
034C2:  BTFSS  xB2.7
034C4:  BRA    34E0
034C6:  DECF   xB4,F
034C8:  BSF    xB4.5
034CA:  COMF   xAF,F
034CC:  COMF   xB0,F
034CE:  COMF   xB1,F
034D0:  COMF   xB2,F
034D2:  INCF   xAF,F
034D4:  BTFSC  FD8.2
034D6:  INCF   xB0,F
034D8:  BTFSC  FD8.2
034DA:  INCF   xB1,F
034DC:  BTFSC  FD8.2
034DE:  INCF   xB2,F
034E0:  MOVLW  3B
034E2:  MOVWF  xBB
034E4:  MOVLW  9A
034E6:  MOVWF  xBA
034E8:  MOVLW  CA
034EA:  MOVWF  xB9
034EC:  CLRF   xB8
034EE:  MOVLW  0A
034F0:  MOVWF  xB6
034F2:  MOVF   xB3,W
034F4:  BTFSC  FD8.2
034F6:  INCF   xB4,F
034F8:  BSF    FD8.1
034FA:  MOVLW  07
034FC:  MOVWF  FEA
034FE:  MOVLW  AF
03500:  MOVWF  FE9
03502:  MOVFF  7B2,7BF
03506:  MOVFF  7B1,7BE
0350A:  MOVFF  7B0,7BD
0350E:  MOVFF  7AF,7BC
03512:  MOVFF  7BB,7C3
03516:  MOVFF  7BA,7C2
0351A:  MOVFF  7B9,7C1
0351E:  MOVFF  7B8,7C0
03522:  MOVLB  0
03524:  RCALL  33C4
03526:  MOVF   01,W
03528:  MOVF   00,F
0352A:  BNZ   3552
0352C:  MOVLB  7
0352E:  INCF   xB3,W
03530:  SUBWF  xB6,W
03532:  BTFSS  FD8.2
03534:  BRA    353A
03536:  MOVLB  0
03538:  BRA    3552
0353A:  MOVF   xB4,W
0353C:  BZ    3558
0353E:  ANDLW  0F
03540:  SUBWF  xB6,W
03542:  BZ    3546
03544:  BC    35CE
03546:  BTFSC  xB4.7
03548:  BRA    35CE
0354A:  BTFSC  xB4.6
0354C:  BRA    3558
0354E:  MOVLW  20
03550:  BRA    35C0
03552:  MOVLW  20
03554:  MOVLB  7
03556:  ANDWF  xB4,F
03558:  BTFSS  xB4.5
0355A:  BRA    357A
0355C:  BCF    xB4.5
0355E:  MOVF   xB3,W
03560:  BTFSS  FD8.2
03562:  DECF   xB4,F
03564:  MOVF   00,W
03566:  MOVWF  xB4
03568:  MOVLW  2D
0356A:  MOVWF  xBC
0356C:  MOVLB  0
0356E:  CALL   1C54
03572:  MOVLB  7
03574:  MOVF   xB4,W
03576:  MOVWF  00
03578:  CLRF   xB4
0357A:  MOVF   xB3,W
0357C:  SUBWF  xB6,W
0357E:  BNZ   359A
03580:  MOVF   00,W
03582:  MOVWF  xB4
03584:  MOVLW  2E
03586:  MOVWF  xBC
03588:  MOVLB  0
0358A:  CALL   1C54
0358E:  MOVLB  7
03590:  MOVF   xB4,W
03592:  MOVWF  00
03594:  MOVLW  20
03596:  ANDWF  xB4,F
03598:  MOVLW  00
0359A:  MOVLW  30
0359C:  BTFSS  xB4.5
0359E:  BRA    35C0
035A0:  BCF    xB4.5
035A2:  MOVF   xB3,W
035A4:  BTFSS  FD8.2
035A6:  DECF   xB4,F
035A8:  MOVF   00,W
035AA:  MOVWF  xB4
035AC:  MOVLW  2D
035AE:  MOVWF  xBC
035B0:  MOVLB  0
035B2:  CALL   1C54
035B6:  MOVLB  7
035B8:  MOVF   xB4,W
035BA:  MOVWF  00
035BC:  CLRF   xB4
035BE:  MOVLW  30
035C0:  ADDWF  00,F
035C2:  MOVFF  00,7BC
035C6:  MOVLB  0
035C8:  CALL   1C54
035CC:  MOVLB  7
035CE:  BCF    FD8.1
035D0:  MOVFF  7BB,7BF
035D4:  MOVFF  7BA,7BE
035D8:  MOVFF  7B9,7BD
035DC:  MOVFF  7B8,7BC
035E0:  CLRF   xC3
035E2:  CLRF   xC2
035E4:  CLRF   xC1
035E6:  MOVLW  0A
035E8:  MOVWF  xC0
035EA:  MOVLB  0
035EC:  RCALL  33C4
035EE:  MOVFF  03,7BB
035F2:  MOVFF  02,7BA
035F6:  MOVFF  01,7B9
035FA:  MOVFF  00,7B8
035FE:  MOVLB  7
03600:  DECFSZ xB6,F
03602:  BRA    34F8
03604:  MOVLB  0
03606:  RETURN 0
*
04162:  ADDWF  FE8,W
04164:  CLRF   FF7
04166:  RLCF   FF7,F
04168:  ADDLW  7D
0416A:  MOVWF  FF6
0416C:  MOVLW  41
0416E:  ADDWFC FF7,F
04170:  TBLRD*-
04172:  MOVF   FF5,W
04174:  MOVWF  FFA
04176:  TBLRD*
04178:  MOVF   FF5,W
0417A:  MOVWF  FF9
0417C:  DATA 22,41
0417E:  DATA 2A,41
04180:  DATA 32,41
04182:  DATA 3A,41
*
04CFA:  MOVLB  7
04CFC:  MOVF   xB4,W
04CFE:  MULWF  xB6
04D00:  MOVFF  FF3,01
04D04:  MOVFF  FF4,00
04D08:  MULWF  xB7
04D0A:  MOVF   FF3,W
04D0C:  ADDWF  00,F
04D0E:  MOVF   xB5,W
04D10:  MULWF  xB6
04D12:  MOVF   FF3,W
04D14:  ADDWFC 00,W
04D16:  MOVWF  02
04D18:  MOVLB  0
04D1A:  RETURN 0
*
0509E:  MOVF   FEF,F
050A0:  BZ    50C2
050A2:  MOVFF  FEA,7A9
050A6:  MOVFF  FE9,7A8
050AA:  MOVF   FEF,W
050AC:  BTFSS  F9E.4
050AE:  BRA    50AC
050B0:  MOVWF  FAD
050B2:  MOVFF  7A9,FEA
050B6:  MOVFF  7A8,FE9
050BA:  INCF   FE9,F
050BC:  BTFSC  FD8.2
050BE:  INCF   FEA,F
050C0:  BRA    509E
050C2:  GOTO   641E (RETURN)
*
05654:  TBLRD*+
05656:  MOVFF  FF6,7A9
0565A:  MOVFF  FF7,7AA
0565E:  MOVF   FF5,W
05660:  BTFSS  F9E.4
05662:  BRA    5660
05664:  MOVWF  FAD
05666:  MOVFF  7A9,FF6
0566A:  MOVFF  7AA,FF7
0566E:  MOVLB  7
05670:  DECFSZ xA8,F
05672:  BRA    5676
05674:  BRA    567A
05676:  MOVLB  0
05678:  BRA    5654
0567A:  MOVLB  0
0567C:  RETURN 0
0567E:  MOVF   FE9,W
05680:  MOVLB  7
05682:  MOVWF  xAD
05684:  MOVF   xAC,W
05686:  MOVWF  xAF
05688:  BZ    56C2
0568A:  MOVFF  7AB,7E2
0568E:  MOVFF  7AA,7E1
05692:  MOVFF  7A9,7E0
05696:  MOVFF  7A8,7DF
0569A:  CLRF   xE6
0569C:  CLRF   xE5
0569E:  MOVLW  20
056A0:  MOVWF  xE4
056A2:  MOVLW  82
056A4:  MOVWF  xE3
056A6:  MOVLB  0
056A8:  CALL   20C8
056AC:  MOVFF  03,7AB
056B0:  MOVFF  02,7AA
056B4:  MOVFF  01,7A9
056B8:  MOVFF  00,7A8
056BC:  MOVLB  7
056BE:  DECFSZ xAF,F
056C0:  BRA    568A
056C2:  MOVFF  7AB,7BF
056C6:  MOVFF  7AA,7BE
056CA:  MOVFF  7A9,7BD
056CE:  MOVFF  7A8,7BC
056D2:  MOVLB  0
056D4:  CALL   3382
056D8:  MOVFF  03,7AB
056DC:  MOVFF  02,7AA
056E0:  MOVFF  01,7A9
056E4:  MOVFF  00,7A8
056E8:  MOVLB  7
056EA:  BTFSS  xAB.7
056EC:  BRA    5708
056EE:  DECF   xAD,F
056F0:  BSF    xAD.5
056F2:  COMF   xA8,F
056F4:  COMF   xA9,F
056F6:  COMF   xAA,F
056F8:  COMF   xAB,F
056FA:  INCF   xA8,F
056FC:  BTFSC  FD8.2
056FE:  INCF   xA9,F
05700:  BTFSC  FD8.2
05702:  INCF   xAA,F
05704:  BTFSC  FD8.2
05706:  INCF   xAB,F
05708:  MOVLW  3B
0570A:  MOVWF  xB4
0570C:  MOVLW  9A
0570E:  MOVWF  xB3
05710:  MOVLW  CA
05712:  MOVWF  xB2
05714:  CLRF   xB1
05716:  MOVLW  0A
05718:  MOVWF  xAF
0571A:  MOVF   xAC,W
0571C:  BTFSC  FD8.2
0571E:  INCF   xAD,F
05720:  BSF    FD8.1
05722:  MOVLW  07
05724:  MOVWF  FEA
05726:  MOVLW  A8
05728:  MOVWF  FE9
0572A:  MOVFF  7AB,7BF
0572E:  MOVFF  7AA,7BE
05732:  MOVFF  7A9,7BD
05736:  MOVFF  7A8,7BC
0573A:  MOVFF  7B4,7C3
0573E:  MOVFF  7B3,7C2
05742:  MOVFF  7B2,7C1
05746:  MOVFF  7B1,7C0
0574A:  MOVLB  0
0574C:  CALL   33C4
05750:  MOVF   01,W
05752:  MOVF   00,F
05754:  BNZ   577C
05756:  MOVLB  7
05758:  INCF   xAC,W
0575A:  SUBWF  xAF,W
0575C:  BTFSS  FD8.2
0575E:  BRA    5764
05760:  MOVLB  0
05762:  BRA    577C
05764:  MOVF   xAD,W
05766:  BZ    5782
05768:  ANDLW  0F
0576A:  SUBWF  xAF,W
0576C:  BZ    5770
0576E:  BC    57E8
05770:  BTFSC  xAD.7
05772:  BRA    57E8
05774:  BTFSC  xAD.6
05776:  BRA    5782
05778:  MOVLW  20
0577A:  BRA    57DE
0577C:  MOVLW  20
0577E:  MOVLB  7
05780:  ANDWF  xAD,F
05782:  BTFSS  xAD.5
05784:  BRA    57A0
05786:  BCF    xAD.5
05788:  MOVF   xAC,W
0578A:  BTFSS  FD8.2
0578C:  DECF   xAD,F
0578E:  MOVF   00,W
05790:  MOVWF  xAD
05792:  MOVLW  2D
05794:  BTFSS  F9E.4
05796:  BRA    5794
05798:  MOVWF  FAD
0579A:  MOVF   xAD,W
0579C:  MOVWF  00
0579E:  CLRF   xAD
057A0:  MOVF   xAC,W
057A2:  SUBWF  xAF,W
057A4:  BNZ   57BC
057A6:  MOVF   00,W
057A8:  MOVWF  xAD
057AA:  MOVLW  2E
057AC:  BTFSS  F9E.4
057AE:  BRA    57AC
057B0:  MOVWF  FAD
057B2:  MOVF   xAD,W
057B4:  MOVWF  00
057B6:  MOVLW  20
057B8:  ANDWF  xAD,F
057BA:  MOVLW  00
057BC:  MOVLW  30
057BE:  BTFSS  xAD.5
057C0:  BRA    57DE
057C2:  BCF    xAD.5
057C4:  MOVF   xAC,W
057C6:  BTFSS  FD8.2
057C8:  DECF   xAD,F
057CA:  MOVF   00,W
057CC:  MOVWF  xAD
057CE:  MOVLW  2D
057D0:  BTFSS  F9E.4
057D2:  BRA    57D0
057D4:  MOVWF  FAD
057D6:  MOVF   xAD,W
057D8:  MOVWF  00
057DA:  CLRF   xAD
057DC:  MOVLW  30
057DE:  ADDWF  00,F
057E0:  MOVF   00,W
057E2:  BTFSS  F9E.4
057E4:  BRA    57E2
057E6:  MOVWF  FAD
057E8:  BCF    FD8.1
057EA:  MOVFF  7B4,7BF
057EE:  MOVFF  7B3,7BE
057F2:  MOVFF  7B2,7BD
057F6:  MOVFF  7B1,7BC
057FA:  CLRF   xC3
057FC:  CLRF   xC2
057FE:  CLRF   xC1
05800:  MOVLW  0A
05802:  MOVWF  xC0
05804:  MOVLB  0
05806:  CALL   33C4
0580A:  MOVFF  03,7B4
0580E:  MOVFF  02,7B3
05812:  MOVFF  01,7B2
05816:  MOVFF  00,7B1
0581A:  MOVLB  7
0581C:  DECFSZ xAF,F
0581E:  BRA    5720
05820:  MOVLB  0
05822:  RETURN 0
05824:  MOVLB  7
05826:  MOVF   xB1,W
05828:  XORWF  xB3,W
0582A:  ANDLW  80
0582C:  MOVWF  xB5
0582E:  BTFSS  xB1.7
05830:  BRA    583C
05832:  COMF   xB0,F
05834:  COMF   xB1,F
05836:  INCF   xB0,F
05838:  BTFSC  FD8.2
0583A:  INCF   xB1,F
0583C:  BTFSS  xB3.7
0583E:  BRA    584A
05840:  COMF   xB2,F
05842:  COMF   xB3,F
05844:  INCF   xB2,F
05846:  BTFSC  FD8.2
05848:  INCF   xB3,F
0584A:  MOVF   xB0,W
0584C:  MULWF  xB2
0584E:  MOVFF  FF3,01
05852:  MOVFF  FF4,00
05856:  MULWF  xB3
05858:  MOVF   FF3,W
0585A:  ADDWF  00,F
0585C:  MOVF   xB1,W
0585E:  MULWF  xB2
05860:  MOVF   FF3,W
05862:  ADDWFC 00,W
05864:  MOVWF  02
05866:  BTFSS  xB5.7
05868:  BRA    5874
0586A:  COMF   01,F
0586C:  COMF   02,F
0586E:  INCF   01,F
05870:  BTFSC  FD8.2
05872:  INCF   02,F
05874:  MOVLB  0
05876:  GOTO   5954 (RETURN)
*
05A5E:  MOVFF  FEA,7B0
05A62:  MOVFF  FE9,7AF
05A66:  MOVLB  7
05A68:  SWAPF  xA9,W
05A6A:  IORLW  F0
05A6C:  MOVWF  xAB
05A6E:  ADDWF  xAB,F
05A70:  ADDLW  E2
05A72:  MOVWF  xAC
05A74:  ADDLW  32
05A76:  MOVWF  xAE
05A78:  MOVF   xA9,W
05A7A:  ANDLW  0F
05A7C:  ADDWF  xAC,F
05A7E:  ADDWF  xAC,F
05A80:  ADDWF  xAE,F
05A82:  ADDLW  E9
05A84:  MOVWF  xAD
05A86:  ADDWF  xAD,F
05A88:  ADDWF  xAD,F
05A8A:  SWAPF  xA8,W
05A8C:  ANDLW  0F
05A8E:  ADDWF  xAD,F
05A90:  ADDWF  xAE,F
05A92:  RLCF   xAD,F
05A94:  RLCF   xAE,F
05A96:  COMF   xAE,F
05A98:  RLCF   xAE,F
05A9A:  MOVF   xA8,W
05A9C:  ANDLW  0F
05A9E:  ADDWF  xAE,F
05AA0:  RLCF   xAB,F
05AA2:  MOVLW  07
05AA4:  MOVWF  xAA
05AA6:  MOVLW  0A
05AA8:  DECF   xAD,F
05AAA:  ADDWF  xAE,F
05AAC:  BNC   5AA8
05AAE:  DECF   xAC,F
05AB0:  ADDWF  xAD,F
05AB2:  BNC   5AAE
05AB4:  DECF   xAB,F
05AB6:  ADDWF  xAC,F
05AB8:  BNC   5AB4
05ABA:  DECF   xAA,F
05ABC:  ADDWF  xAB,F
05ABE:  BNC   5ABA
05AC0:  MOVLW  07
05AC2:  MOVWF  FEA
05AC4:  MOVLW  AA
05AC6:  MOVWF  FE9
05AC8:  MOVLW  07
05ACA:  ANDWF  xAF,W
05ACC:  BCF    xAF.6
05ACE:  ADDWF  FE9,F
05AD0:  MOVLW  00
05AD2:  ADDWFC FEA,F
05AD4:  MOVF   FE9,W
05AD6:  SUBLW  AE
05AD8:  BNZ   5AE2
05ADA:  MOVF   FEA,W
05ADC:  SUBLW  07
05ADE:  BNZ   5AE2
05AE0:  BSF    xAF.6
05AE2:  MOVF   FEF,W
05AE4:  MOVWF  00
05AE6:  BNZ   5AF8
05AE8:  BTFSC  xAF.6
05AEA:  BRA    5AF8
05AEC:  BTFSC  xAF.4
05AEE:  BRA    5B08
05AF0:  BTFSC  xAF.3
05AF2:  BRA    5AF8
05AF4:  MOVLW  20
05AF6:  BRA    5AFE
05AF8:  BSF    xAF.3
05AFA:  BCF    xAF.4
05AFC:  MOVLW  30
05AFE:  ADDWF  00,F
05B00:  MOVF   00,W
05B02:  BTFSS  F9E.4
05B04:  BRA    5B02
05B06:  MOVWF  FAD
05B08:  MOVF   FEE,W
05B0A:  BTFSS  xAF.6
05B0C:  BRA    5AD4
05B0E:  MOVLB  0
05B10:  RETURN 0
....................  
.................... #list 
....................  
.................... #DEVICE ICD=TRUE 
.................... #device ADC=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
050C6:  MOVLB  7
050C8:  MOVFF  7B5,FE9
050CC:  MOVFF  7B6,FEA
050D0:  MOVFF  FEF,7B9
050D4:  MOVFF  7B8,03
050D8:  MOVFF  7B7,FE9
050DC:  MOVFF  7B8,FEA
050E0:  MOVF   FEF,W
050E2:  SUBWF  xB9,W
050E4:  BZ    5176
050E6:  MOVFF  7B6,03
050EA:  MOVFF  7B5,FE9
050EE:  MOVFF  7B6,FEA
050F2:  MOVFF  FEF,7B9
050F6:  MOVF   xB9,W
050F8:  SUBLW  40
050FA:  BC    5102
050FC:  MOVF   xB9,W
050FE:  SUBLW  5A
05100:  BC    510E
05102:  MOVF   xB9,W
05104:  SUBLW  60
05106:  BC    51A0
05108:  MOVF   xB9,W
0510A:  SUBLW  7A
0510C:  BNC   51A0
0510E:  MOVFF  7B8,03
05112:  MOVFF  7B7,FE9
05116:  MOVFF  7B8,FEA
0511A:  MOVFF  FEF,7B9
0511E:  MOVF   xB9,W
05120:  SUBLW  40
05122:  BC    512A
05124:  MOVF   xB9,W
05126:  SUBLW  5A
05128:  BC    5136
0512A:  MOVF   xB9,W
0512C:  SUBLW  60
0512E:  BC    51A0
05130:  MOVF   xB9,W
05132:  SUBLW  7A
05134:  BNC   51A0
05136:  MOVFF  7B5,FE9
0513A:  MOVFF  7B6,FEA
0513E:  MOVFF  FEF,7B9
05142:  MOVFF  7B8,03
05146:  MOVFF  7B7,FE9
0514A:  MOVFF  7B8,FEA
0514E:  MOVLW  20
05150:  ADDWF  FEF,W
05152:  SUBWF  xB9,W
05154:  BZ    5176
05156:  MOVFF  7B7,FE9
0515A:  MOVFF  7B8,FEA
0515E:  MOVFF  FEF,7B9
05162:  MOVFF  7B6,03
05166:  MOVFF  7B5,FE9
0516A:  MOVFF  7B6,FEA
0516E:  MOVLW  20
05170:  ADDWF  FEF,W
05172:  SUBWF  xB9,W
05174:  BNZ   51A0
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
05176:  MOVFF  7B6,03
0517A:  MOVFF  7B5,FE9
0517E:  MOVFF  7B6,FEA
05182:  MOVF   FEF,F
05184:  BNZ   518C
....................        return(0); 
05186:  MOVLW  00
05188:  MOVWF  01
0518A:  BRA    51CA
0518C:  MOVFF  7B6,03
05190:  MOVF   xB5,W
05192:  INCF   xB5,F
05194:  BTFSC  FD8.2
05196:  INCF   xB6,F
05198:  INCF   xB7,F
0519A:  BTFSC  FD8.2
0519C:  INCF   xB8,F
0519E:  BRA    50C8
....................  return((*s1 < *s2) ? -1: 1); 
051A0:  MOVFF  7B6,03
051A4:  MOVFF  7B5,FE9
051A8:  MOVFF  7B6,FEA
051AC:  MOVFF  FEF,7B9
051B0:  MOVFF  7B8,03
051B4:  MOVFF  7B7,FE9
051B8:  MOVFF  7B8,FEA
051BC:  MOVF   FEF,W
051BE:  SUBWF  xB9,W
051C0:  BC    51C6
051C2:  MOVLW  FF
051C4:  BRA    51C8
051C6:  MOVLW  01
051C8:  MOVWF  01
051CA:  MOVLB  0
051CC:  RETURN 0
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0587A:  MOVLB  7
0587C:  CLRF   xAE
....................    sign = 0; 
0587E:  CLRF   xAC
....................    base = 10; 
05880:  MOVLW  0A
05882:  MOVWF  xAD
....................    result = 0; 
05884:  CLRF   xAB
05886:  CLRF   xAA
....................  
....................    if (!s) 
05888:  MOVF   xA8,W
0588A:  IORWF  xA9,W
0588C:  BNZ   5896
....................       return 0; 
0588E:  MOVLW  00
05890:  MOVWF  01
05892:  MOVWF  02
05894:  BRA    5A5A
....................    c = s[index++]; 
05896:  MOVF   xAE,W
05898:  INCF   xAE,F
0589A:  ADDWF  xA8,W
0589C:  MOVWF  FE9
0589E:  MOVLW  00
058A0:  ADDWFC xA9,W
058A2:  MOVWF  FEA
058A4:  MOVFF  FEF,7AF
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
058A8:  MOVF   xAF,W
058AA:  SUBLW  2D
058AC:  BNZ   58C6
....................    { 
....................       sign = 1;         // Set the sign to negative 
058AE:  MOVLW  01
058B0:  MOVWF  xAC
....................       c = s[index++]; 
058B2:  MOVF   xAE,W
058B4:  INCF   xAE,F
058B6:  ADDWF  xA8,W
058B8:  MOVWF  FE9
058BA:  MOVLW  00
058BC:  ADDWFC xA9,W
058BE:  MOVWF  FEA
058C0:  MOVFF  FEF,7AF
....................    } 
058C4:  BRA    58DE
....................    else if (c == '+') 
058C6:  MOVF   xAF,W
058C8:  SUBLW  2B
058CA:  BNZ   58DE
....................    { 
....................       c = s[index++]; 
058CC:  MOVF   xAE,W
058CE:  INCF   xAE,F
058D0:  ADDWF  xA8,W
058D2:  MOVWF  FE9
058D4:  MOVLW  00
058D6:  ADDWFC xA9,W
058D8:  MOVWF  FEA
058DA:  MOVFF  FEF,7AF
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
058DE:  MOVF   xAF,W
058E0:  SUBLW  2F
058E2:  BTFSC  FD8.0
058E4:  BRA    5A3E
058E6:  MOVF   xAF,W
058E8:  SUBLW  39
058EA:  BTFSS  FD8.0
058EC:  BRA    5A3E
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
058EE:  MOVF   xAF,W
058F0:  SUBLW  30
058F2:  BNZ   5930
058F4:  MOVF   xAE,W
058F6:  ADDWF  xA8,W
058F8:  MOVWF  FE9
058FA:  MOVLW  00
058FC:  ADDWFC xA9,W
058FE:  MOVWF  FEA
05900:  MOVF   FEF,W
05902:  SUBLW  78
05904:  BZ    5918
05906:  MOVF   xAE,W
05908:  ADDWF  xA8,W
0590A:  MOVWF  FE9
0590C:  MOVLW  00
0590E:  ADDWFC xA9,W
05910:  MOVWF  FEA
05912:  MOVF   FEF,W
05914:  SUBLW  58
05916:  BNZ   5930
....................       { 
....................          base = 16; 
05918:  MOVLW  10
0591A:  MOVWF  xAD
....................          index++; 
0591C:  INCF   xAE,F
....................          c = s[index++]; 
0591E:  MOVF   xAE,W
05920:  INCF   xAE,F
05922:  ADDWF  xA8,W
05924:  MOVWF  FE9
05926:  MOVLW  00
05928:  ADDWFC xA9,W
0592A:  MOVWF  FEA
0592C:  MOVFF  FEF,7AF
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
05930:  MOVF   xAD,W
05932:  SUBLW  0A
05934:  BNZ   597A
....................       { 
....................          while (c >= '0' && c <= '9') 
05936:  MOVF   xAF,W
05938:  SUBLW  2F
0593A:  BC    5978
0593C:  MOVF   xAF,W
0593E:  SUBLW  39
05940:  BNC   5978
....................          { 
....................             result = 10*result + (c - '0'); 
05942:  CLRF   xB1
05944:  MOVLW  0A
05946:  MOVWF  xB0
05948:  MOVFF  7AB,7B3
0594C:  MOVFF  7AA,7B2
05950:  MOVLB  0
05952:  BRA    5824
05954:  MOVLW  30
05956:  MOVLB  7
05958:  SUBWF  xAF,W
0595A:  ADDWF  01,W
0595C:  MOVWF  xAA
0595E:  MOVLW  00
05960:  ADDWFC 02,W
05962:  MOVWF  xAB
....................             c = s[index++]; 
05964:  MOVF   xAE,W
05966:  INCF   xAE,F
05968:  ADDWF  xA8,W
0596A:  MOVWF  FE9
0596C:  MOVLW  00
0596E:  ADDWFC xA9,W
05970:  MOVWF  FEA
05972:  MOVFF  FEF,7AF
05976:  BRA    5936
....................          } 
....................       } 
05978:  BRA    5A3E
....................       else if (base == 16)    // The number is a hexa number 
0597A:  MOVF   xAD,W
0597C:  SUBLW  10
0597E:  BNZ   5A3E
....................       { 
....................          c = toupper(c); 
05980:  MOVF   xAF,W
05982:  SUBLW  60
05984:  BC    5992
05986:  MOVF   xAF,W
05988:  SUBLW  7A
0598A:  BNC   5992
0598C:  MOVF   xAF,W
0598E:  ANDLW  DF
05990:  BRA    5994
05992:  MOVF   xAF,W
05994:  MOVWF  xAF
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
05996:  MOVF   xAF,W
05998:  SUBLW  2F
0599A:  BC    59A2
0599C:  MOVF   xAF,W
0599E:  SUBLW  39
059A0:  BC    59AE
059A2:  MOVF   xAF,W
059A4:  SUBLW  40
059A6:  BC    5A3E
059A8:  MOVF   xAF,W
059AA:  SUBLW  46
059AC:  BNC   5A3E
....................          { 
....................             if (c >= '0' && c <= '9') 
059AE:  MOVF   xAF,W
059B0:  SUBLW  2F
059B2:  BC    59E8
059B4:  MOVF   xAF,W
059B6:  SUBLW  39
059B8:  BNC   59E8
....................                result = (result << 4) + (c - '0'); 
059BA:  RLCF   xAA,W
059BC:  MOVWF  xB0
059BE:  RLCF   xAB,W
059C0:  MOVWF  xB1
059C2:  RLCF   xB0,F
059C4:  RLCF   xB1,F
059C6:  RLCF   xB0,F
059C8:  RLCF   xB1,F
059CA:  RLCF   xB0,F
059CC:  RLCF   xB1,F
059CE:  MOVLW  F0
059D0:  ANDWF  xB0,F
059D2:  MOVLW  30
059D4:  SUBWF  xAF,W
059D6:  ADDWF  xB0,W
059D8:  MOVWF  01
059DA:  MOVLW  00
059DC:  ADDWFC xB1,W
059DE:  MOVWF  03
059E0:  MOVFF  01,7AA
059E4:  MOVWF  xAB
059E6:  BRA    5A14
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
059E8:  RLCF   xAA,W
059EA:  MOVWF  xB0
059EC:  RLCF   xAB,W
059EE:  MOVWF  xB1
059F0:  RLCF   xB0,F
059F2:  RLCF   xB1,F
059F4:  RLCF   xB0,F
059F6:  RLCF   xB1,F
059F8:  RLCF   xB0,F
059FA:  RLCF   xB1,F
059FC:  MOVLW  F0
059FE:  ANDWF  xB0,F
05A00:  MOVLW  41
05A02:  SUBWF  xAF,W
05A04:  ADDLW  0A
05A06:  ADDWF  xB0,W
05A08:  MOVWF  01
05A0A:  MOVLW  00
05A0C:  ADDWFC xB1,W
05A0E:  MOVFF  01,7AA
05A12:  MOVWF  xAB
....................  
....................             c = s[index++];c = toupper(c); 
05A14:  MOVF   xAE,W
05A16:  INCF   xAE,F
05A18:  ADDWF  xA8,W
05A1A:  MOVWF  FE9
05A1C:  MOVLW  00
05A1E:  ADDWFC xA9,W
05A20:  MOVWF  FEA
05A22:  MOVFF  FEF,7AF
05A26:  MOVF   xAF,W
05A28:  SUBLW  60
05A2A:  BC    5A38
05A2C:  MOVF   xAF,W
05A2E:  SUBLW  7A
05A30:  BNC   5A38
05A32:  MOVF   xAF,W
05A34:  ANDLW  DF
05A36:  BRA    5A3A
05A38:  MOVF   xAF,W
05A3A:  MOVWF  xAF
05A3C:  BRA    5996
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
05A3E:  MOVF   xAD,W
05A40:  SUBLW  0A
05A42:  BNZ   5A52
05A44:  DECFSZ xAC,W
05A46:  BRA    5A52
....................       result = -result; 
05A48:  COMF   xAA,F
05A4A:  COMF   xAB,F
05A4C:  INCF   xAA,F
05A4E:  BTFSC  FD8.2
05A50:  INCF   xAB,F
....................  
....................    return(result); 
05A52:  MOVFF  7AA,01
05A56:  MOVFF  7AB,02
05A5A:  MOVLB  0
05A5C:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
053FA:  MOVLB  7
053FC:  CLRF   xAF
053FE:  CLRF   xAE
05400:  CLRF   xAD
05402:  MOVLW  7F
05404:  MOVWF  xAC
05406:  CLRF   xB3
05408:  CLRF   xB2
0540A:  CLRF   xB1
0540C:  CLRF   xB0
0540E:  BSF    xB4.0
05410:  BCF    xB4.1
05412:  BCF    xB4.2
05414:  CLRF   xB6
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
05416:  MOVF   xA8,W
05418:  IORWF  xA9,W
0541A:  BNZ   5426
....................       return 0; 
0541C:  CLRF   00
0541E:  CLRF   01
05420:  CLRF   02
05422:  CLRF   03
05424:  BRA    5650
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
05426:  MOVF   xB6,W
05428:  INCF   xB6,F
0542A:  ADDWF  xA8,W
0542C:  MOVWF  FE9
0542E:  MOVLW  00
05430:  ADDWFC xA9,W
05432:  MOVWF  FEA
05434:  MOVFF  FEF,7B5
05438:  MOVF   xB5,F
0543A:  BTFSC  FD8.2
0543C:  BRA    55D4
....................    { 
....................       if (skip && !isspace(c)) 
0543E:  BTFSS  xB4.0
05440:  BRA    5460
05442:  MOVF   xB5,W
05444:  SUBLW  20
05446:  BZ    5460
....................       { 
....................          skip = 0; 
05448:  BCF    xB4.0
....................          if (c == '+') 
0544A:  MOVF   xB5,W
0544C:  SUBLW  2B
0544E:  BNZ   5456
....................          { 
....................             sign = 0; 
05450:  BCF    xB4.1
....................             continue; 
05452:  BRA    55BC
....................          }             
05454:  BRA    5460
....................          else if (c == '-') 
05456:  MOVF   xB5,W
05458:  SUBLW  2D
0545A:  BNZ   5460
....................          { 
....................             sign = 1; 
0545C:  BSF    xB4.1
....................             continue; 
0545E:  BRA    55BC
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
05460:  BTFSC  xB4.0
05462:  BRA    5472
05464:  MOVF   xB5,W
05466:  SUBLW  2E
05468:  BNZ   5472
0546A:  BTFSC  xB4.2
0546C:  BRA    5472
....................          point = 1; 
0546E:  BSF    xB4.2
05470:  BRA    55BC
....................       else if (!skip && isdigit(c)) 
05472:  BTFSC  xB4.0
05474:  BRA    55B6
05476:  MOVF   xB5,W
05478:  SUBLW  2F
0547A:  BTFSC  FD8.0
0547C:  BRA    55B6
0547E:  MOVF   xB5,W
05480:  SUBLW  39
05482:  BTFSS  FD8.0
05484:  BRA    55B6
....................       { 
....................          c -= '0'; 
05486:  MOVLW  30
05488:  SUBWF  xB5,F
....................          if (point) 
0548A:  BTFSS  xB4.2
0548C:  BRA    553C
....................          { 
....................             pow10 = pow10 * 10.0; 
0548E:  MOVFF  7AF,7E2
05492:  MOVFF  7AE,7E1
05496:  MOVFF  7AD,7E0
0549A:  MOVFF  7AC,7DF
0549E:  CLRF   xE6
054A0:  CLRF   xE5
054A2:  MOVLW  20
054A4:  MOVWF  xE4
054A6:  MOVLW  82
054A8:  MOVWF  xE3
054AA:  MOVLB  0
054AC:  CALL   20C8
054B0:  MOVFF  03,7AF
054B4:  MOVFF  02,7AE
054B8:  MOVFF  01,7AD
054BC:  MOVFF  00,7AC
....................             result += (float)c / pow10;    
054C0:  MOVLB  7
054C2:  CLRF   xE4
054C4:  MOVFF  7B5,7E3
054C8:  MOVLB  0
054CA:  CALL   21BE
054CE:  MOVFF  03,7BA
054D2:  MOVFF  02,7B9
054D6:  MOVFF  01,7B8
054DA:  MOVFF  00,7B7
054DE:  MOVFF  03,7DB
054E2:  MOVFF  02,7DA
054E6:  MOVFF  01,7D9
054EA:  MOVFF  00,7D8
054EE:  MOVFF  7AF,7DF
054F2:  MOVFF  7AE,7DE
054F6:  MOVFF  7AD,7DD
054FA:  MOVFF  7AC,7DC
054FE:  CALL   1F6A
05502:  BCF    FD8.1
05504:  MOVFF  7B3,7E6
05508:  MOVFF  7B2,7E5
0550C:  MOVFF  7B1,7E4
05510:  MOVFF  7B0,7E3
05514:  MOVFF  03,7EA
05518:  MOVFF  02,7E9
0551C:  MOVFF  01,7E8
05520:  MOVFF  00,7E7
05524:  CALL   1CF2
05528:  MOVFF  03,7B3
0552C:  MOVFF  02,7B2
05530:  MOVFF  01,7B1
05534:  MOVFF  00,7B0
....................          } 
05538:  BRA    55B2
0553A:  MOVLB  7
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0553C:  CLRF   xE2
0553E:  CLRF   xE1
05540:  MOVLW  20
05542:  MOVWF  xE0
05544:  MOVLW  82
05546:  MOVWF  xDF
05548:  MOVFF  7B3,7E6
0554C:  MOVFF  7B2,7E5
05550:  MOVFF  7B1,7E4
05554:  MOVFF  7B0,7E3
05558:  MOVLB  0
0555A:  CALL   20C8
0555E:  MOVFF  03,7BA
05562:  MOVFF  02,7B9
05566:  MOVFF  01,7B8
0556A:  MOVFF  00,7B7
0556E:  MOVLB  7
05570:  CLRF   xE4
05572:  MOVFF  7B5,7E3
05576:  MOVLB  0
05578:  CALL   21BE
0557C:  BCF    FD8.1
0557E:  MOVFF  7BA,7E6
05582:  MOVFF  7B9,7E5
05586:  MOVFF  7B8,7E4
0558A:  MOVFF  7B7,7E3
0558E:  MOVFF  03,7EA
05592:  MOVFF  02,7E9
05596:  MOVFF  01,7E8
0559A:  MOVFF  00,7E7
0559E:  CALL   1CF2
055A2:  MOVFF  03,7B3
055A6:  MOVFF  02,7B2
055AA:  MOVFF  01,7B1
055AE:  MOVFF  00,7B0
....................          } 
....................       } 
055B2:  BRA    55BE
055B4:  MOVLB  7
....................       else if (!skip) 
055B6:  BTFSC  xB4.0
055B8:  BRA    55BC
....................          break; 
055BA:  BRA    55D4
055BC:  MOVLB  0
055BE:  MOVLB  7
055C0:  MOVF   xB6,W
055C2:  INCF   xB6,F
055C4:  ADDWF  xA8,W
055C6:  MOVWF  FE9
055C8:  MOVLW  00
055CA:  ADDWFC xA9,W
055CC:  MOVWF  FEA
055CE:  MOVFF  FEF,7B5
055D2:  BRA    5438
....................    } 
....................  
....................    if (sign) 
055D4:  BTFSS  xB4.1
055D6:  BRA    560C
....................       result = -1*result; 
055D8:  CLRF   xE2
055DA:  CLRF   xE1
055DC:  MOVLW  80
055DE:  MOVWF  xE0
055E0:  MOVLW  7F
055E2:  MOVWF  xDF
055E4:  MOVFF  7B3,7E6
055E8:  MOVFF  7B2,7E5
055EC:  MOVFF  7B1,7E4
055F0:  MOVFF  7B0,7E3
055F4:  MOVLB  0
055F6:  CALL   20C8
055FA:  MOVFF  03,7B3
055FE:  MOVFF  02,7B2
05602:  MOVFF  01,7B1
05606:  MOVFF  00,7B0
0560A:  MOVLB  7
....................        
....................    if(endptr) 
0560C:  MOVF   xAA,W
0560E:  IORWF  xAB,W
05610:  BZ    5640
....................    { 
....................       if (ptr) { 
05612:  MOVF   xB6,F
05614:  BZ    562E
....................          ptr--; 
05616:  DECF   xB6,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
05618:  MOVFF  7AA,FE9
0561C:  MOVFF  7AB,FEA
05620:  MOVF   xB6,W
05622:  ADDWF  xA8,W
05624:  MOVWF  FEF
05626:  MOVLW  00
05628:  ADDWFC xA9,W
0562A:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0562C:  BRA    5640
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0562E:  MOVFF  7AA,FE9
05632:  MOVFF  7AB,FEA
05636:  MOVFF  7A9,FEC
0563A:  MOVF   FED,F
0563C:  MOVFF  7A8,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
05640:  MOVFF  7B0,00
05644:  MOVFF  7B1,01
05648:  MOVFF  7B2,02
0564C:  MOVFF  7B3,03
05650:  MOVLB  0
05652:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
022AA:  MOVLB  7
022AC:  BCF    xDE.0
....................    y = x; 
022AE:  MOVFF  7D2,7D7
022B2:  MOVFF  7D1,7D6
022B6:  MOVFF  7D0,7D5
022BA:  MOVFF  7CF,7D4
....................  
....................    if (x < 0) 
022BE:  MOVFF  7D2,7E2
022C2:  MOVFF  7D1,7E1
022C6:  MOVFF  7D0,7E0
022CA:  MOVFF  7CF,7DF
022CE:  CLRF   xE6
022D0:  CLRF   xE5
022D2:  CLRF   xE4
022D4:  CLRF   xE3
022D6:  MOVLB  0
022D8:  RCALL  21F4
022DA:  BNC   22E8
....................    { 
....................       s = 1; 
022DC:  MOVLB  7
022DE:  BSF    xDE.0
....................       y = -y; 
022E0:  MOVF   xD5,W
022E2:  XORLW  80
022E4:  MOVWF  xD5
022E6:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
022E8:  MOVFF  7D7,7E2
022EC:  MOVFF  7D6,7E1
022F0:  MOVFF  7D5,7E0
022F4:  MOVFF  7D4,7DF
022F8:  MOVLB  7
022FA:  CLRF   xE6
022FC:  CLRF   xE5
022FE:  CLRF   xE4
02300:  MOVLW  8E
02302:  MOVWF  xE3
02304:  MOVLB  0
02306:  RCALL  21F4
02308:  BC    230C
0230A:  BNZ   233A
....................       res = (float32)(unsigned int16)y; 
0230C:  MOVFF  7D7,7E2
02310:  MOVFF  7D6,7E1
02314:  MOVFF  7D5,7E0
02318:  MOVFF  7D4,7DF
0231C:  RCALL  226E
0231E:  MOVFF  02,7E4
02322:  MOVFF  01,7E3
02326:  RCALL  21BE
02328:  MOVFF  03,7DB
0232C:  MOVFF  02,7DA
02330:  MOVFF  01,7D9
02334:  MOVFF  00,7D8
02338:  BRA    24C8
....................  
....................  else if (y < 10000000.0) 
0233A:  MOVFF  7D7,7E2
0233E:  MOVFF  7D6,7E1
02342:  MOVFF  7D5,7E0
02346:  MOVFF  7D4,7DF
0234A:  MOVLW  80
0234C:  MOVLB  7
0234E:  MOVWF  xE6
02350:  MOVLW  96
02352:  MOVWF  xE5
02354:  MOVLW  18
02356:  MOVWF  xE4
02358:  MOVLW  96
0235A:  MOVWF  xE3
0235C:  MOVLB  0
0235E:  RCALL  21F4
02360:  BTFSS  FD8.0
02362:  BRA    24B8
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
02364:  MOVFF  7D7,7E2
02368:  MOVFF  7D6,7E1
0236C:  MOVFF  7D5,7E0
02370:  MOVFF  7D4,7DF
02374:  MOVLB  7
02376:  CLRF   xE6
02378:  CLRF   xE5
0237A:  CLRF   xE4
0237C:  MOVLW  70
0237E:  MOVWF  xE3
02380:  MOVLB  0
02382:  RCALL  20C8
02384:  MOVFF  03,7E2
02388:  MOVFF  02,7E1
0238C:  MOVFF  01,7E0
02390:  MOVFF  00,7DF
02394:  RCALL  226E
02396:  MOVFF  02,7DD
0239A:  MOVFF  01,7DC
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0239E:  MOVFF  7D7,7E2
023A2:  MOVFF  7D6,7E1
023A6:  MOVFF  7D5,7E0
023AA:  MOVFF  7D4,7DF
023AE:  MOVLB  7
023B0:  CLRF   xE6
023B2:  CLRF   xE5
023B4:  CLRF   xE4
023B6:  MOVLW  70
023B8:  MOVWF  xE3
023BA:  MOVLB  0
023BC:  RCALL  20C8
023BE:  MOVFF  03,7E2
023C2:  MOVFF  02,7E1
023C6:  MOVFF  01,7E0
023CA:  MOVFF  00,7DF
023CE:  MOVFF  7DD,7E4
023D2:  MOVFF  7DC,7E3
023D6:  RCALL  21BE
023D8:  BSF    FD8.1
023DA:  MOVFF  7E2,7E6
023DE:  MOVFF  7E1,7E5
023E2:  MOVFF  7E0,7E4
023E6:  MOVFF  7DF,7E3
023EA:  MOVFF  03,7EA
023EE:  MOVFF  02,7E9
023F2:  MOVFF  01,7E8
023F6:  MOVFF  00,7E7
023FA:  RCALL  1CF2
023FC:  MOVLB  7
023FE:  CLRF   xE2
02400:  CLRF   xE1
02402:  CLRF   xE0
02404:  MOVLW  8E
02406:  MOVWF  xDF
02408:  MOVFF  03,7E6
0240C:  MOVFF  02,7E5
02410:  MOVFF  01,7E4
02414:  MOVFF  00,7E3
02418:  MOVLB  0
0241A:  RCALL  20C8
0241C:  MOVFF  03,7D7
02420:  MOVFF  02,7D6
02424:  MOVFF  01,7D5
02428:  MOVFF  00,7D4
....................       res = 32768.0*(float32)l; 
0242C:  MOVFF  7DD,7E4
02430:  MOVFF  7DC,7E3
02434:  RCALL  21BE
02436:  MOVLB  7
02438:  CLRF   xE2
0243A:  CLRF   xE1
0243C:  CLRF   xE0
0243E:  MOVLW  8E
02440:  MOVWF  xDF
02442:  MOVFF  03,7E6
02446:  MOVFF  02,7E5
0244A:  MOVFF  01,7E4
0244E:  MOVFF  00,7E3
02452:  MOVLB  0
02454:  RCALL  20C8
02456:  MOVFF  03,7DB
0245A:  MOVFF  02,7DA
0245E:  MOVFF  01,7D9
02462:  MOVFF  00,7D8
....................       res += (float32)(unsigned int16)y; 
02466:  MOVFF  7D7,7E2
0246A:  MOVFF  7D6,7E1
0246E:  MOVFF  7D5,7E0
02472:  MOVFF  7D4,7DF
02476:  RCALL  226E
02478:  MOVFF  02,7E4
0247C:  MOVFF  01,7E3
02480:  RCALL  21BE
02482:  BCF    FD8.1
02484:  MOVFF  7DB,7E6
02488:  MOVFF  7DA,7E5
0248C:  MOVFF  7D9,7E4
02490:  MOVFF  7D8,7E3
02494:  MOVFF  03,7EA
02498:  MOVFF  02,7E9
0249C:  MOVFF  01,7E8
024A0:  MOVFF  00,7E7
024A4:  RCALL  1CF2
024A6:  MOVFF  03,7DB
024AA:  MOVFF  02,7DA
024AE:  MOVFF  01,7D9
024B2:  MOVFF  00,7D8
....................    } 
024B6:  BRA    24C8
....................  
....................  else 
....................   res = y; 
024B8:  MOVFF  7D7,7DB
024BC:  MOVFF  7D6,7DA
024C0:  MOVFF  7D5,7D9
024C4:  MOVFF  7D4,7D8
....................  
....................  y = y - (float32)(unsigned int16)y; 
024C8:  MOVFF  7D7,7E2
024CC:  MOVFF  7D6,7E1
024D0:  MOVFF  7D5,7E0
024D4:  MOVFF  7D4,7DF
024D8:  RCALL  226E
024DA:  MOVFF  02,7E4
024DE:  MOVFF  01,7E3
024E2:  RCALL  21BE
024E4:  BSF    FD8.1
024E6:  MOVFF  7D7,7E6
024EA:  MOVFF  7D6,7E5
024EE:  MOVFF  7D5,7E4
024F2:  MOVFF  7D4,7E3
024F6:  MOVFF  03,7EA
024FA:  MOVFF  02,7E9
024FE:  MOVFF  01,7E8
02502:  MOVFF  00,7E7
02506:  CALL   1CF2
0250A:  MOVFF  03,7D7
0250E:  MOVFF  02,7D6
02512:  MOVFF  01,7D5
02516:  MOVFF  00,7D4
....................  
....................  if (s) 
0251A:  MOVLB  7
0251C:  BTFSS  xDE.0
0251E:  BRA    2526
....................   res = -res; 
02520:  MOVF   xD9,W
02522:  XORLW  80
02524:  MOVWF  xD9
....................  
....................  if (y != 0) 
02526:  MOVFF  7D7,7E2
0252A:  MOVFF  7D6,7E1
0252E:  MOVFF  7D5,7E0
02532:  MOVFF  7D4,7DF
02536:  CLRF   xE6
02538:  CLRF   xE5
0253A:  CLRF   xE4
0253C:  CLRF   xE3
0253E:  MOVLB  0
02540:  RCALL  21F4
02542:  BZ    25BC
....................  { 
....................   if (s == 1 && n == 0) 
02544:  MOVLB  7
02546:  BTFSS  xDE.0
02548:  BRA    2582
0254A:  MOVF   xD3,F
0254C:  BNZ   2582
....................    res -= 1.0; 
0254E:  BSF    FD8.1
02550:  MOVFF  7DB,7E6
02554:  MOVFF  7DA,7E5
02558:  MOVFF  7D9,7E4
0255C:  MOVFF  7D8,7E3
02560:  CLRF   xEA
02562:  CLRF   xE9
02564:  CLRF   xE8
02566:  MOVLW  7F
02568:  MOVWF  xE7
0256A:  MOVLB  0
0256C:  CALL   1CF2
02570:  MOVFF  03,7DB
02574:  MOVFF  02,7DA
02578:  MOVFF  01,7D9
0257C:  MOVFF  00,7D8
02580:  MOVLB  7
....................  
....................   if (s == 0 && n == 1) 
02582:  BTFSC  xDE.0
02584:  BRA    25BE
02586:  DECFSZ xD3,W
02588:  BRA    25BE
....................    res += 1.0; 
0258A:  BCF    FD8.1
0258C:  MOVFF  7DB,7E6
02590:  MOVFF  7DA,7E5
02594:  MOVFF  7D9,7E4
02598:  MOVFF  7D8,7E3
0259C:  CLRF   xEA
0259E:  CLRF   xE9
025A0:  CLRF   xE8
025A2:  MOVLW  7F
025A4:  MOVWF  xE7
025A6:  MOVLB  0
025A8:  CALL   1CF2
025AC:  MOVFF  03,7DB
025B0:  MOVFF  02,7DA
025B4:  MOVFF  01,7D9
025B8:  MOVFF  00,7D8
025BC:  MOVLB  7
....................  } 
....................  if (x == 0) 
025BE:  MOVFF  7D2,7E2
025C2:  MOVFF  7D1,7E1
025C6:  MOVFF  7D0,7E0
025CA:  MOVFF  7CF,7DF
025CE:  CLRF   xE6
025D0:  CLRF   xE5
025D2:  CLRF   xE4
025D4:  CLRF   xE3
025D6:  MOVLB  0
025D8:  RCALL  21F4
025DA:  BNZ   25E8
....................     res = 0; 
025DC:  MOVLB  7
025DE:  CLRF   xDB
025E0:  CLRF   xDA
025E2:  CLRF   xD9
025E4:  CLRF   xD8
025E6:  MOVLB  0
....................  
....................  return (res); 
025E8:  MOVFF  7D8,00
025EC:  MOVFF  7D9,01
025F0:  MOVFF  7DA,02
025F4:  MOVFF  7DB,03
025F8:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
02618:  MOVFF  7CE,7D2
0261C:  MOVFF  7CD,7D1
02620:  MOVFF  7CC,7D0
02624:  MOVFF  7CB,7CF
02628:  MOVLB  7
0262A:  CLRF   xD3
0262C:  MOVLB  0
0262E:  RCALL  22AA
02630:  GOTO   2732 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
025FA:  MOVFF  7CE,7D2
025FE:  MOVFF  7CD,7D1
02602:  MOVFF  7CC,7D0
02606:  MOVFF  7CB,7CF
0260A:  MOVLW  01
0260C:  MOVLB  7
0260E:  MOVWF  xD3
02610:  MOVLB  0
02612:  RCALL  22AA
02614:  GOTO   26EC (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
02634:  MOVFF  7C2,7E2
02638:  MOVFF  7C1,7E1
0263C:  MOVFF  7C0,7E0
02640:  MOVFF  7BF,7DF
02644:  MOVLB  7
02646:  CLRF   xE6
02648:  CLRF   xE5
0264A:  CLRF   xE4
0264C:  CLRF   xE3
0264E:  MOVLB  0
02650:  RCALL  21F4
02652:  BTFSC  FD8.2
02654:  BRA    278C
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
02656:  MOVFF  7BE,7DB
0265A:  MOVFF  7BD,7DA
0265E:  MOVFF  7BC,7D9
02662:  MOVFF  7BB,7D8
02666:  MOVFF  7C2,7DF
0266A:  MOVFF  7C1,7DE
0266E:  MOVFF  7C0,7DD
02672:  MOVFF  7BF,7DC
02676:  RCALL  1F6A
02678:  MOVFF  03,7CA
0267C:  MOVFF  02,7C9
02680:  MOVFF  01,7C8
02684:  MOVFF  00,7C7
02688:  MOVFF  03,7E2
0268C:  MOVFF  02,7E1
02690:  MOVFF  01,7E0
02694:  MOVFF  00,7DF
02698:  MOVLB  7
0269A:  CLRF   xE6
0269C:  CLRF   xE5
0269E:  CLRF   xE4
026A0:  CLRF   xE3
026A2:  MOVLB  0
026A4:  RCALL  21F4
026A6:  BNC   26EE
026A8:  MOVFF  7BE,7DB
026AC:  MOVFF  7BD,7DA
026B0:  MOVFF  7BC,7D9
026B4:  MOVFF  7BB,7D8
026B8:  MOVFF  7C2,7DF
026BC:  MOVFF  7C1,7DE
026C0:  MOVFF  7C0,7DD
026C4:  MOVFF  7BF,7DC
026C8:  RCALL  1F6A
026CA:  MOVFF  03,7CA
026CE:  MOVFF  02,7C9
026D2:  MOVFF  01,7C8
026D6:  MOVFF  00,7C7
026DA:  MOVFF  03,7CE
026DE:  MOVFF  02,7CD
026E2:  MOVFF  01,7CC
026E6:  MOVFF  00,7CB
026EA:  BRA    25FA
026EC:  BRA    2732
026EE:  MOVFF  7BE,7DB
026F2:  MOVFF  7BD,7DA
026F6:  MOVFF  7BC,7D9
026FA:  MOVFF  7BB,7D8
026FE:  MOVFF  7C2,7DF
02702:  MOVFF  7C1,7DE
02706:  MOVFF  7C0,7DD
0270A:  MOVFF  7BF,7DC
0270E:  RCALL  1F6A
02710:  MOVFF  03,7CA
02714:  MOVFF  02,7C9
02718:  MOVFF  01,7C8
0271C:  MOVFF  00,7C7
02720:  MOVFF  03,7CE
02724:  MOVFF  02,7CD
02728:  MOVFF  01,7CC
0272C:  MOVFF  00,7CB
02730:  BRA    2618
02732:  MOVFF  03,7C6
02736:  MOVFF  02,7C5
0273A:  MOVFF  01,7C4
0273E:  MOVFF  00,7C3
....................       return(x-(i*y)); 
02742:  MOVFF  7C6,7E2
02746:  MOVFF  7C5,7E1
0274A:  MOVFF  7C4,7E0
0274E:  MOVFF  7C3,7DF
02752:  MOVFF  7C2,7E6
02756:  MOVFF  7C1,7E5
0275A:  MOVFF  7C0,7E4
0275E:  MOVFF  7BF,7E3
02762:  RCALL  20C8
02764:  BSF    FD8.1
02766:  MOVFF  7BE,7E6
0276A:  MOVFF  7BD,7E5
0276E:  MOVFF  7BC,7E4
02772:  MOVFF  7BB,7E3
02776:  MOVFF  03,7EA
0277A:  MOVFF  02,7E9
0277E:  MOVFF  01,7E8
02782:  MOVFF  00,7E7
02786:  CALL   1CF2
0278A:  BRA    278C
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0278C:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
*
02B6C:  MOVFF  7C2,7E2
02B70:  MOVFF  7C1,7E1
02B74:  MOVFF  7C0,7E0
02B78:  MOVFF  7BF,7DF
02B7C:  MOVLW  3B
02B7E:  MOVLB  7
02B80:  MOVWF  xE6
02B82:  MOVLW  AA
02B84:  MOVWF  xE5
02B86:  MOVLW  38
02B88:  MOVWF  xE4
02B8A:  MOVLW  7F
02B8C:  MOVWF  xE3
02B8E:  MOVLB  0
02B90:  CALL   20C8
02B94:  MOVFF  03,7E2
02B98:  MOVFF  02,7E1
02B9C:  MOVFF  01,7E0
02BA0:  MOVFF  00,7DF
02BA4:  CALL   226E
02BA8:  MOVFF  01,7CF
....................    s = 0; 
02BAC:  MOVLB  7
02BAE:  BCF    xD0.0
....................    y = x; 
02BB0:  MOVFF  7C2,7C6
02BB4:  MOVFF  7C1,7C5
02BB8:  MOVFF  7C0,7C4
02BBC:  MOVFF  7BF,7C3
....................  
....................    if (x < 0) 
02BC0:  MOVFF  7C2,7E2
02BC4:  MOVFF  7C1,7E1
02BC8:  MOVFF  7C0,7E0
02BCC:  MOVFF  7BF,7DF
02BD0:  CLRF   xE6
02BD2:  CLRF   xE5
02BD4:  CLRF   xE4
02BD6:  CLRF   xE3
02BD8:  MOVLB  0
02BDA:  CALL   21F4
02BDE:  BNC   2BEE
....................    { 
....................       s = 1; 
02BE0:  MOVLB  7
02BE2:  BSF    xD0.0
....................       n = -n; 
02BE4:  NEGF   xCF
....................       y = -y; 
02BE6:  MOVF   xC4,W
02BE8:  XORLW  80
02BEA:  MOVWF  xC4
02BEC:  MOVLB  0
....................    } 
....................  
....................    res = 0.0; 
02BEE:  MOVLB  7
02BF0:  CLRF   xCA
02BF2:  CLRF   xC9
02BF4:  CLRF   xC8
02BF6:  CLRF   xC7
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
02BF8:  MOVLW  07
02BFA:  MOVWF  xD2
02BFC:  MOVLW  C7
02BFE:  MOVWF  FE9
02C00:  MOVFF  7D2,FEA
02C04:  MOVLW  7F
02C06:  ADDWF  xCF,W
02C08:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
02C0A:  MOVFF  7C6,7E2
02C0E:  MOVFF  7C5,7E1
02C12:  MOVFF  7C4,7E0
02C16:  MOVFF  7C3,7DF
02C1A:  MOVLW  3B
02C1C:  MOVWF  xE6
02C1E:  MOVLW  AA
02C20:  MOVWF  xE5
02C22:  MOVLW  38
02C24:  MOVWF  xE4
02C26:  MOVLW  7F
02C28:  MOVWF  xE3
02C2A:  MOVLB  0
02C2C:  CALL   20C8
02C30:  MOVFF  03,7D4
02C34:  MOVFF  02,7D3
02C38:  MOVFF  01,7D2
02C3C:  MOVFF  00,7D1
02C40:  MOVLB  7
02C42:  CLRF   xD6
02C44:  MOVFF  7CF,7D5
02C48:  BTFSC  xD5.7
02C4A:  DECF   xD6,F
02C4C:  MOVLB  0
02C4E:  RCALL  278E
02C50:  BSF    FD8.1
02C52:  MOVFF  7D4,7E6
02C56:  MOVFF  7D3,7E5
02C5A:  MOVFF  7D2,7E4
02C5E:  MOVFF  7D1,7E3
02C62:  MOVFF  03,7EA
02C66:  MOVFF  02,7E9
02C6A:  MOVFF  01,7E8
02C6E:  MOVFF  00,7E7
02C72:  CALL   1CF2
02C76:  MOVFF  03,7C6
02C7A:  MOVFF  02,7C5
02C7E:  MOVFF  01,7C4
02C82:  MOVFF  00,7C3
....................  
....................    r = pe[0]*y + pe[1]; 
02C86:  MOVLW  7C
02C88:  MOVLB  7
02C8A:  MOVWF  xE2
02C8C:  MOVLW  88
02C8E:  MOVWF  xE1
02C90:  MOVLW  59
02C92:  MOVWF  xE0
02C94:  MOVLW  72
02C96:  MOVWF  xDF
02C98:  MOVFF  7C6,7E6
02C9C:  MOVFF  7C5,7E5
02CA0:  MOVFF  7C4,7E4
02CA4:  MOVFF  7C3,7E3
02CA8:  MOVLB  0
02CAA:  CALL   20C8
02CAE:  MOVFF  03,7D4
02CB2:  MOVFF  02,7D3
02CB6:  MOVFF  01,7D2
02CBA:  MOVFF  00,7D1
02CBE:  BCF    FD8.1
02CC0:  MOVFF  03,7E6
02CC4:  MOVFF  02,7E5
02CC8:  MOVFF  01,7E4
02CCC:  MOVFF  00,7E3
02CD0:  MOVLW  E0
02CD2:  MOVLB  7
02CD4:  MOVWF  xEA
02CD6:  MOVLW  97
02CD8:  MOVWF  xE9
02CDA:  MOVLW  26
02CDC:  MOVWF  xE8
02CDE:  MOVLW  75
02CE0:  MOVWF  xE7
02CE2:  MOVLB  0
02CE4:  CALL   1CF2
02CE8:  MOVFF  03,7CE
02CEC:  MOVFF  02,7CD
02CF0:  MOVFF  01,7CC
02CF4:  MOVFF  00,7CB
....................    r = r*y + pe[2]; 
02CF8:  MOVFF  7CE,7E2
02CFC:  MOVFF  7CD,7E1
02D00:  MOVFF  7CC,7E0
02D04:  MOVFF  7CB,7DF
02D08:  MOVFF  7C6,7E6
02D0C:  MOVFF  7C5,7E5
02D10:  MOVFF  7C4,7E4
02D14:  MOVFF  7C3,7E3
02D18:  CALL   20C8
02D1C:  MOVFF  03,7D4
02D20:  MOVFF  02,7D3
02D24:  MOVFF  01,7D2
02D28:  MOVFF  00,7D1
02D2C:  BCF    FD8.1
02D2E:  MOVFF  03,7E6
02D32:  MOVFF  02,7E5
02D36:  MOVFF  01,7E4
02D3A:  MOVFF  00,7E3
02D3E:  MOVLW  C4
02D40:  MOVLB  7
02D42:  MOVWF  xEA
02D44:  MOVLW  1D
02D46:  MOVWF  xE9
02D48:  MOVLW  1E
02D4A:  MOVWF  xE8
02D4C:  MOVLW  78
02D4E:  MOVWF  xE7
02D50:  MOVLB  0
02D52:  CALL   1CF2
02D56:  MOVFF  03,7CE
02D5A:  MOVFF  02,7CD
02D5E:  MOVFF  01,7CC
02D62:  MOVFF  00,7CB
....................    r = r*y + pe[3]; 
02D66:  MOVFF  7CE,7E2
02D6A:  MOVFF  7CD,7E1
02D6E:  MOVFF  7CC,7E0
02D72:  MOVFF  7CB,7DF
02D76:  MOVFF  7C6,7E6
02D7A:  MOVFF  7C5,7E5
02D7E:  MOVFF  7C4,7E4
02D82:  MOVFF  7C3,7E3
02D86:  CALL   20C8
02D8A:  MOVFF  03,7D4
02D8E:  MOVFF  02,7D3
02D92:  MOVFF  01,7D2
02D96:  MOVFF  00,7D1
02D9A:  BCF    FD8.1
02D9C:  MOVFF  03,7E6
02DA0:  MOVFF  02,7E5
02DA4:  MOVFF  01,7E4
02DA8:  MOVFF  00,7E3
02DAC:  MOVLW  5E
02DAE:  MOVLB  7
02DB0:  MOVWF  xEA
02DB2:  MOVLW  50
02DB4:  MOVWF  xE9
02DB6:  MOVLW  63
02DB8:  MOVWF  xE8
02DBA:  MOVLW  7A
02DBC:  MOVWF  xE7
02DBE:  MOVLB  0
02DC0:  CALL   1CF2
02DC4:  MOVFF  03,7CE
02DC8:  MOVFF  02,7CD
02DCC:  MOVFF  01,7CC
02DD0:  MOVFF  00,7CB
....................    r = r*y + pe[4]; 
02DD4:  MOVFF  7CE,7E2
02DD8:  MOVFF  7CD,7E1
02DDC:  MOVFF  7CC,7E0
02DE0:  MOVFF  7CB,7DF
02DE4:  MOVFF  7C6,7E6
02DE8:  MOVFF  7C5,7E5
02DEC:  MOVFF  7C4,7E4
02DF0:  MOVFF  7C3,7E3
02DF4:  CALL   20C8
02DF8:  MOVFF  03,7D4
02DFC:  MOVFF  02,7D3
02E00:  MOVFF  01,7D2
02E04:  MOVFF  00,7D1
02E08:  BCF    FD8.1
02E0A:  MOVFF  03,7E6
02E0E:  MOVFF  02,7E5
02E12:  MOVFF  01,7E4
02E16:  MOVFF  00,7E3
02E1A:  MOVLW  1A
02E1C:  MOVLB  7
02E1E:  MOVWF  xEA
02E20:  MOVLW  FE
02E22:  MOVWF  xE9
02E24:  MOVLW  75
02E26:  MOVWF  xE8
02E28:  MOVLW  7C
02E2A:  MOVWF  xE7
02E2C:  MOVLB  0
02E2E:  CALL   1CF2
02E32:  MOVFF  03,7CE
02E36:  MOVFF  02,7CD
02E3A:  MOVFF  01,7CC
02E3E:  MOVFF  00,7CB
....................    r = r*y + pe[5]; 
02E42:  MOVFF  7CE,7E2
02E46:  MOVFF  7CD,7E1
02E4A:  MOVFF  7CC,7E0
02E4E:  MOVFF  7CB,7DF
02E52:  MOVFF  7C6,7E6
02E56:  MOVFF  7C5,7E5
02E5A:  MOVFF  7C4,7E4
02E5E:  MOVFF  7C3,7E3
02E62:  CALL   20C8
02E66:  MOVFF  03,7D4
02E6A:  MOVFF  02,7D3
02E6E:  MOVFF  01,7D2
02E72:  MOVFF  00,7D1
02E76:  BCF    FD8.1
02E78:  MOVFF  03,7E6
02E7C:  MOVFF  02,7E5
02E80:  MOVFF  01,7E4
02E84:  MOVFF  00,7E3
02E88:  MOVLW  18
02E8A:  MOVLB  7
02E8C:  MOVWF  xEA
02E8E:  MOVLW  72
02E90:  MOVWF  xE9
02E92:  MOVLW  31
02E94:  MOVWF  xE8
02E96:  MOVLW  7E
02E98:  MOVWF  xE7
02E9A:  MOVLB  0
02E9C:  CALL   1CF2
02EA0:  MOVFF  03,7CE
02EA4:  MOVFF  02,7CD
02EA8:  MOVFF  01,7CC
02EAC:  MOVFF  00,7CB
....................  
....................    res = res*(1.0 + y*r); 
02EB0:  MOVFF  7C6,7E2
02EB4:  MOVFF  7C5,7E1
02EB8:  MOVFF  7C4,7E0
02EBC:  MOVFF  7C3,7DF
02EC0:  MOVFF  7CE,7E6
02EC4:  MOVFF  7CD,7E5
02EC8:  MOVFF  7CC,7E4
02ECC:  MOVFF  7CB,7E3
02ED0:  CALL   20C8
02ED4:  BCF    FD8.1
02ED6:  MOVLB  7
02ED8:  CLRF   xE6
02EDA:  CLRF   xE5
02EDC:  CLRF   xE4
02EDE:  MOVLW  7F
02EE0:  MOVWF  xE3
02EE2:  MOVFF  03,7EA
02EE6:  MOVFF  02,7E9
02EEA:  MOVFF  01,7E8
02EEE:  MOVFF  00,7E7
02EF2:  MOVLB  0
02EF4:  CALL   1CF2
02EF8:  MOVFF  7CA,7E2
02EFC:  MOVFF  7C9,7E1
02F00:  MOVFF  7C8,7E0
02F04:  MOVFF  7C7,7DF
02F08:  MOVFF  03,7E6
02F0C:  MOVFF  02,7E5
02F10:  MOVFF  01,7E4
02F14:  MOVFF  00,7E3
02F18:  CALL   20C8
02F1C:  MOVFF  03,7CA
02F20:  MOVFF  02,7C9
02F24:  MOVFF  01,7C8
02F28:  MOVFF  00,7C7
....................  
....................    if (s) 
02F2C:  MOVLB  7
02F2E:  BTFSS  xD0.0
02F30:  BRA    2F64
....................       res = 1.0/res; 
02F32:  CLRF   xDB
02F34:  CLRF   xDA
02F36:  CLRF   xD9
02F38:  MOVLW  7F
02F3A:  MOVWF  xD8
02F3C:  MOVFF  7CA,7DF
02F40:  MOVFF  7C9,7DE
02F44:  MOVFF  7C8,7DD
02F48:  MOVFF  7C7,7DC
02F4C:  MOVLB  0
02F4E:  CALL   1F6A
02F52:  MOVFF  03,7CA
02F56:  MOVFF  02,7C9
02F5A:  MOVFF  01,7C8
02F5E:  MOVFF  00,7C7
02F62:  MOVLB  7
....................    return(res); 
02F64:  MOVFF  7C7,00
02F68:  MOVFF  7C8,01
02F6C:  MOVFF  7C9,02
02F70:  MOVFF  7CA,03
02F74:  MOVLB  0
02F76:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
027DE:  MOVFF  7C2,7C6
027E2:  MOVFF  7C1,7C5
027E6:  MOVFF  7C0,7C4
027EA:  MOVFF  7BF,7C3
....................  
....................    if (y != 1.0) 
027EE:  MOVFF  7C6,7E2
027F2:  MOVFF  7C5,7E1
027F6:  MOVFF  7C4,7E0
027FA:  MOVFF  7C3,7DF
027FE:  MOVLB  7
02800:  CLRF   xE6
02802:  CLRF   xE5
02804:  CLRF   xE4
02806:  MOVLW  7F
02808:  MOVWF  xE3
0280A:  MOVLB  0
0280C:  RCALL  21F4
0280E:  BTFSC  FD8.2
02810:  BRA    2B4E
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
02812:  MOVLW  07
02814:  MOVLB  7
02816:  MOVWF  xD5
02818:  MOVLW  C3
0281A:  MOVWF  FE9
0281C:  MOVFF  7D5,FEA
02820:  MOVLW  7E
02822:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
02824:  BSF    FD8.1
02826:  MOVFF  7C6,7E6
0282A:  MOVFF  7C5,7E5
0282E:  MOVFF  7C4,7E4
02832:  MOVFF  7C3,7E3
02836:  CLRF   xEA
02838:  CLRF   xE9
0283A:  CLRF   xE8
0283C:  MOVLW  7F
0283E:  MOVWF  xE7
02840:  MOVLB  0
02842:  CALL   1CF2
02846:  MOVFF  03,7D7
0284A:  MOVFF  02,7D6
0284E:  MOVFF  01,7D5
02852:  MOVFF  00,7D4
02856:  BCF    FD8.1
02858:  MOVFF  7C6,7E6
0285C:  MOVFF  7C5,7E5
02860:  MOVFF  7C4,7E4
02864:  MOVFF  7C3,7E3
02868:  MOVLB  7
0286A:  CLRF   xEA
0286C:  CLRF   xE9
0286E:  CLRF   xE8
02870:  MOVLW  7F
02872:  MOVWF  xE7
02874:  MOVLB  0
02876:  CALL   1CF2
0287A:  MOVFF  7D7,7DB
0287E:  MOVFF  7D6,7DA
02882:  MOVFF  7D5,7D9
02886:  MOVFF  7D4,7D8
0288A:  MOVFF  03,7DF
0288E:  MOVFF  02,7DE
02892:  MOVFF  01,7DD
02896:  MOVFF  00,7DC
0289A:  CALL   1F6A
0289E:  MOVFF  03,7C6
028A2:  MOVFF  02,7C5
028A6:  MOVFF  01,7C4
028AA:  MOVFF  00,7C3
....................  
....................       y2=y*y; 
028AE:  MOVFF  7C6,7E2
028B2:  MOVFF  7C5,7E1
028B6:  MOVFF  7C4,7E0
028BA:  MOVFF  7C3,7DF
028BE:  MOVFF  7C6,7E6
028C2:  MOVFF  7C5,7E5
028C6:  MOVFF  7C4,7E4
028CA:  MOVFF  7C3,7E3
028CE:  CALL   20C8
028D2:  MOVFF  03,7D2
028D6:  MOVFF  02,7D1
028DA:  MOVFF  01,7D0
028DE:  MOVFF  00,7CF
....................  
....................       res = pl[0]*y2 + pl[1]; 
028E2:  MOVLW  99
028E4:  MOVLB  7
028E6:  MOVWF  xE2
028E8:  MOVLW  47
028EA:  MOVWF  xE1
028EC:  MOVLW  8A
028EE:  MOVWF  xE0
028F0:  MOVLW  7F
028F2:  MOVWF  xDF
028F4:  MOVFF  7D2,7E6
028F8:  MOVFF  7D1,7E5
028FC:  MOVFF  7D0,7E4
02900:  MOVFF  7CF,7E3
02904:  MOVLB  0
02906:  CALL   20C8
0290A:  MOVFF  03,7D7
0290E:  MOVFF  02,7D6
02912:  MOVFF  01,7D5
02916:  MOVFF  00,7D4
0291A:  BCF    FD8.1
0291C:  MOVFF  03,7E6
02920:  MOVFF  02,7E5
02924:  MOVFF  01,7E4
02928:  MOVFF  00,7E3
0292C:  MOVLB  7
0292E:  CLRF   xEA
02930:  CLRF   xE9
02932:  CLRF   xE8
02934:  MOVLW  80
02936:  MOVWF  xE7
02938:  MOVLB  0
0293A:  CALL   1CF2
0293E:  MOVFF  03,7CA
02942:  MOVFF  02,7C9
02946:  MOVFF  01,7C8
0294A:  MOVFF  00,7C7
....................  
....................       r = ql[0]*y2 + ql[1]; 
0294E:  MOVLW  4C
02950:  MOVLB  7
02952:  MOVWF  xE2
02954:  MOVLW  F3
02956:  MOVWF  xE1
02958:  MOVLW  3A
0295A:  MOVWF  xE0
0295C:  MOVLW  7B
0295E:  MOVWF  xDF
02960:  MOVFF  7D2,7E6
02964:  MOVFF  7D1,7E5
02968:  MOVFF  7D0,7E4
0296C:  MOVFF  7CF,7E3
02970:  MOVLB  0
02972:  CALL   20C8
02976:  MOVFF  03,7D7
0297A:  MOVFF  02,7D6
0297E:  MOVFF  01,7D5
02982:  MOVFF  00,7D4
02986:  BCF    FD8.1
02988:  MOVFF  03,7E6
0298C:  MOVFF  02,7E5
02990:  MOVFF  01,7E4
02994:  MOVFF  00,7E3
02998:  MOVLW  2B
0299A:  MOVLB  7
0299C:  MOVWF  xEA
0299E:  MOVLW  9D
029A0:  MOVWF  xE9
029A2:  MOVLW  DF
029A4:  MOVWF  xE8
029A6:  MOVLW  7E
029A8:  MOVWF  xE7
029AA:  MOVLB  0
029AC:  CALL   1CF2
029B0:  MOVFF  03,7CE
029B4:  MOVFF  02,7CD
029B8:  MOVFF  01,7CC
029BC:  MOVFF  00,7CB
....................       r = r*y2 + 1.0; 
029C0:  MOVFF  7CE,7E2
029C4:  MOVFF  7CD,7E1
029C8:  MOVFF  7CC,7E0
029CC:  MOVFF  7CB,7DF
029D0:  MOVFF  7D2,7E6
029D4:  MOVFF  7D1,7E5
029D8:  MOVFF  7D0,7E4
029DC:  MOVFF  7CF,7E3
029E0:  CALL   20C8
029E4:  MOVFF  03,7D7
029E8:  MOVFF  02,7D6
029EC:  MOVFF  01,7D5
029F0:  MOVFF  00,7D4
029F4:  BCF    FD8.1
029F6:  MOVFF  03,7E6
029FA:  MOVFF  02,7E5
029FE:  MOVFF  01,7E4
02A02:  MOVFF  00,7E3
02A06:  MOVLB  7
02A08:  CLRF   xEA
02A0A:  CLRF   xE9
02A0C:  CLRF   xE8
02A0E:  MOVLW  7F
02A10:  MOVWF  xE7
02A12:  MOVLB  0
02A14:  CALL   1CF2
02A18:  MOVFF  03,7CE
02A1C:  MOVFF  02,7CD
02A20:  MOVFF  01,7CC
02A24:  MOVFF  00,7CB
....................  
....................       res = y*res/r; 
02A28:  MOVFF  7C6,7E2
02A2C:  MOVFF  7C5,7E1
02A30:  MOVFF  7C4,7E0
02A34:  MOVFF  7C3,7DF
02A38:  MOVFF  7CA,7E6
02A3C:  MOVFF  7C9,7E5
02A40:  MOVFF  7C8,7E4
02A44:  MOVFF  7C7,7E3
02A48:  CALL   20C8
02A4C:  MOVFF  03,7D7
02A50:  MOVFF  02,7D6
02A54:  MOVFF  01,7D5
02A58:  MOVFF  00,7D4
02A5C:  MOVFF  03,7DB
02A60:  MOVFF  02,7DA
02A64:  MOVFF  01,7D9
02A68:  MOVFF  00,7D8
02A6C:  MOVFF  7CE,7DF
02A70:  MOVFF  7CD,7DE
02A74:  MOVFF  7CC,7DD
02A78:  MOVFF  7CB,7DC
02A7C:  CALL   1F6A
02A80:  MOVFF  03,7CA
02A84:  MOVFF  02,7C9
02A88:  MOVFF  01,7C8
02A8C:  MOVFF  00,7C7
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
02A90:  MOVLW  07
02A92:  MOVLB  7
02A94:  MOVWF  xD5
02A96:  MOVLW  BF
02A98:  MOVWF  FE9
02A9A:  MOVFF  7D5,FEA
02A9E:  MOVLW  7E
02AA0:  SUBWF  FEF,W
02AA2:  MOVWF  xD3
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
02AA4:  BTFSS  xD3.7
02AA6:  BRA    2AD0
....................          r = -(float32)-n; 
02AA8:  MOVLW  00
02AAA:  BSF    FD8.0
02AAC:  SUBFWB xD3,W
02AAE:  CLRF   xD6
02AB0:  MOVWF  xD5
02AB2:  BTFSC  xD5.7
02AB4:  DECF   xD6,F
02AB6:  MOVLB  0
02AB8:  RCALL  278E
02ABA:  MOVFF  00,7CB
02ABE:  MOVF   01,W
02AC0:  XORLW  80
02AC2:  MOVLB  7
02AC4:  MOVWF  xCC
02AC6:  MOVFF  02,7CD
02ACA:  MOVFF  03,7CE
02ACE:  BRA    2AF0
....................       else 
....................          r = (float32)n; 
02AD0:  CLRF   xD6
02AD2:  MOVFF  7D3,7D5
02AD6:  BTFSC  xD5.7
02AD8:  DECF   xD6,F
02ADA:  MOVLB  0
02ADC:  RCALL  278E
02ADE:  MOVFF  03,7CE
02AE2:  MOVFF  02,7CD
02AE6:  MOVFF  01,7CC
02AEA:  MOVFF  00,7CB
02AEE:  MOVLB  7
....................  
....................       res += r*LN2; 
02AF0:  MOVFF  7CE,7E2
02AF4:  MOVFF  7CD,7E1
02AF8:  MOVFF  7CC,7E0
02AFC:  MOVFF  7CB,7DF
02B00:  MOVLW  18
02B02:  MOVWF  xE6
02B04:  MOVLW  72
02B06:  MOVWF  xE5
02B08:  MOVLW  31
02B0A:  MOVWF  xE4
02B0C:  MOVLW  7E
02B0E:  MOVWF  xE3
02B10:  MOVLB  0
02B12:  CALL   20C8
02B16:  BCF    FD8.1
02B18:  MOVFF  7CA,7E6
02B1C:  MOVFF  7C9,7E5
02B20:  MOVFF  7C8,7E4
02B24:  MOVFF  7C7,7E3
02B28:  MOVFF  03,7EA
02B2C:  MOVFF  02,7E9
02B30:  MOVFF  01,7E8
02B34:  MOVFF  00,7E7
02B38:  CALL   1CF2
02B3C:  MOVFF  03,7CA
02B40:  MOVFF  02,7C9
02B44:  MOVFF  01,7C8
02B48:  MOVFF  00,7C7
....................    } 
02B4C:  BRA    2B5A
....................  
....................    else 
....................       res = 0.0; 
02B4E:  MOVLB  7
02B50:  CLRF   xCA
02B52:  CLRF   xC9
02B54:  CLRF   xC8
02B56:  CLRF   xC7
02B58:  MOVLB  0
....................  
....................    return(res); 
02B5A:  MOVFF  7C7,00
02B5E:  MOVFF  7C8,01
02B62:  MOVFF  7C9,02
02B66:  MOVFF  7CA,03
02B6A:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
02F78:  MOVFF  7B6,7E2
02F7C:  MOVFF  7B5,7E1
02F80:  MOVFF  7B4,7E0
02F84:  MOVFF  7B3,7DF
02F88:  MOVLB  7
02F8A:  CLRF   xE6
02F8C:  CLRF   xE5
02F8E:  CLRF   xE4
02F90:  CLRF   xE3
02F92:  MOVLB  0
02F94:  CALL   21F4
02F98:  BTFSS  FD8.0
02F9A:  BRA    314E
02F9C:  MOVFF  7BA,7BE
02FA0:  MOVFF  7B9,7BD
02FA4:  MOVFF  7B8,7BC
02FA8:  MOVFF  7B7,7BB
02FAC:  MOVLB  7
02FAE:  CLRF   xC2
02FB0:  CLRF   xC1
02FB2:  CLRF   xC0
02FB4:  MOVLW  7F
02FB6:  MOVWF  xBF
02FB8:  MOVLB  0
02FBA:  CALL   2634
02FBE:  MOVFF  03,7BE
02FC2:  MOVFF  02,7BD
02FC6:  MOVFF  01,7BC
02FCA:  MOVFF  00,7BB
02FCE:  MOVFF  03,7E2
02FD2:  MOVFF  02,7E1
02FD6:  MOVFF  01,7E0
02FDA:  MOVFF  00,7DF
02FDE:  MOVLB  7
02FE0:  CLRF   xE6
02FE2:  CLRF   xE5
02FE4:  CLRF   xE4
02FE6:  CLRF   xE3
02FE8:  MOVLB  0
02FEA:  CALL   21F4
02FEE:  BTFSS  FD8.2
02FF0:  BRA    314E
....................       if(fmod(y, 2) == 0) { 
02FF2:  MOVFF  7BA,7BE
02FF6:  MOVFF  7B9,7BD
02FFA:  MOVFF  7B8,7BC
02FFE:  MOVFF  7B7,7BB
03002:  MOVLB  7
03004:  CLRF   xC2
03006:  CLRF   xC1
03008:  CLRF   xC0
0300A:  MOVLW  80
0300C:  MOVWF  xBF
0300E:  MOVLB  0
03010:  CALL   2634
03014:  MOVFF  03,7BE
03018:  MOVFF  02,7BD
0301C:  MOVFF  01,7BC
03020:  MOVFF  00,7BB
03024:  MOVFF  03,7E2
03028:  MOVFF  02,7E1
0302C:  MOVFF  01,7E0
03030:  MOVFF  00,7DF
03034:  MOVLB  7
03036:  CLRF   xE6
03038:  CLRF   xE5
0303A:  CLRF   xE4
0303C:  CLRF   xE3
0303E:  MOVLB  0
03040:  CALL   21F4
03044:  BNZ   30C8
....................          return (exp(log(-x) * y)); 
03046:  MOVFF  7B3,7BB
0304A:  MOVLB  7
0304C:  MOVF   xB4,W
0304E:  XORLW  80
03050:  MOVWF  xBC
03052:  MOVFF  7B5,7BD
03056:  MOVFF  7B6,7BE
0305A:  MOVFF  7B6,7C2
0305E:  MOVFF  7B5,7C1
03062:  MOVWF  xC0
03064:  MOVFF  7B3,7BF
03068:  MOVLB  0
0306A:  CALL   27DE
0306E:  MOVFF  03,7BE
03072:  MOVFF  02,7BD
03076:  MOVFF  01,7BC
0307A:  MOVFF  00,7BB
0307E:  MOVFF  03,7E2
03082:  MOVFF  02,7E1
03086:  MOVFF  01,7E0
0308A:  MOVFF  00,7DF
0308E:  MOVFF  7BA,7E6
03092:  MOVFF  7B9,7E5
03096:  MOVFF  7B8,7E4
0309A:  MOVFF  7B7,7E3
0309E:  CALL   20C8
030A2:  MOVFF  03,7BE
030A6:  MOVFF  02,7BD
030AA:  MOVFF  01,7BC
030AE:  MOVFF  00,7BB
030B2:  MOVFF  03,7C2
030B6:  MOVFF  02,7C1
030BA:  MOVFF  01,7C0
030BE:  MOVFF  00,7BF
030C2:  RCALL  2B6C
030C4:  BRA    328C
....................       } else { 
030C6:  BRA    314C
....................          return (-exp(log(-x) * y)); 
030C8:  MOVFF  7B3,7BB
030CC:  MOVLB  7
030CE:  MOVF   xB4,W
030D0:  XORLW  80
030D2:  MOVWF  xBC
030D4:  MOVFF  7B5,7BD
030D8:  MOVFF  7B6,7BE
030DC:  MOVFF  7B6,7C2
030E0:  MOVFF  7B5,7C1
030E4:  MOVWF  xC0
030E6:  MOVFF  7B3,7BF
030EA:  MOVLB  0
030EC:  CALL   27DE
030F0:  MOVFF  03,7BE
030F4:  MOVFF  02,7BD
030F8:  MOVFF  01,7BC
030FC:  MOVFF  00,7BB
03100:  MOVFF  03,7E2
03104:  MOVFF  02,7E1
03108:  MOVFF  01,7E0
0310C:  MOVFF  00,7DF
03110:  MOVFF  7BA,7E6
03114:  MOVFF  7B9,7E5
03118:  MOVFF  7B8,7E4
0311C:  MOVFF  7B7,7E3
03120:  CALL   20C8
03124:  MOVFF  03,7BE
03128:  MOVFF  02,7BD
0312C:  MOVFF  01,7BC
03130:  MOVFF  00,7BB
03134:  MOVFF  03,7C2
03138:  MOVFF  02,7C1
0313C:  MOVFF  01,7C0
03140:  MOVFF  00,7BF
03144:  RCALL  2B6C
03146:  MOVLW  80
03148:  XORWF  01,F
0314A:  BRA    328C
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
0314C:  BRA    328C
0314E:  MOVFF  7B6,7E2
03152:  MOVFF  7B5,7E1
03156:  MOVFF  7B4,7E0
0315A:  MOVFF  7B3,7DF
0315E:  MOVLB  7
03160:  CLRF   xE6
03162:  CLRF   xE5
03164:  CLRF   xE4
03166:  CLRF   xE3
03168:  MOVLB  0
0316A:  CALL   21F4
0316E:  BNC   31D0
03170:  MOVFF  7BA,7BE
03174:  MOVFF  7B9,7BD
03178:  MOVFF  7B8,7BC
0317C:  MOVFF  7B7,7BB
03180:  MOVLB  7
03182:  CLRF   xC2
03184:  CLRF   xC1
03186:  CLRF   xC0
03188:  MOVLW  7F
0318A:  MOVWF  xBF
0318C:  MOVLB  0
0318E:  CALL   2634
03192:  MOVFF  03,7BE
03196:  MOVFF  02,7BD
0319A:  MOVFF  01,7BC
0319E:  MOVFF  00,7BB
031A2:  MOVFF  03,7E2
031A6:  MOVFF  02,7E1
031AA:  MOVFF  01,7E0
031AE:  MOVFF  00,7DF
031B2:  MOVLB  7
031B4:  CLRF   xE6
031B6:  CLRF   xE5
031B8:  CLRF   xE4
031BA:  CLRF   xE3
031BC:  MOVLB  0
031BE:  CALL   21F4
031C2:  BZ    31D0
....................       return 0; 
031C4:  CLRF   00
031C6:  CLRF   01
031C8:  CLRF   02
031CA:  CLRF   03
031CC:  BRA    328C
....................    } else { 
031CE:  BRA    328C
....................       if(x != 0 || 0 >= y) { 
031D0:  MOVFF  7B6,7E2
031D4:  MOVFF  7B5,7E1
031D8:  MOVFF  7B4,7E0
031DC:  MOVFF  7B3,7DF
031E0:  MOVLB  7
031E2:  CLRF   xE6
031E4:  CLRF   xE5
031E6:  CLRF   xE4
031E8:  CLRF   xE3
031EA:  MOVLB  0
031EC:  CALL   21F4
031F0:  BNZ   3216
031F2:  MOVFF  7BA,7E2
031F6:  MOVFF  7B9,7E1
031FA:  MOVFF  7B8,7E0
031FE:  MOVFF  7B7,7DF
03202:  MOVLB  7
03204:  CLRF   xE6
03206:  CLRF   xE5
03208:  CLRF   xE4
0320A:  CLRF   xE3
0320C:  MOVLB  0
0320E:  CALL   21F4
03212:  BC    3216
03214:  BNZ   3284
....................          return (exp(log(x) * y)); 
03216:  MOVFF  7B6,7C2
0321A:  MOVFF  7B5,7C1
0321E:  MOVFF  7B4,7C0
03222:  MOVFF  7B3,7BF
03226:  CALL   27DE
0322A:  MOVFF  03,7BE
0322E:  MOVFF  02,7BD
03232:  MOVFF  01,7BC
03236:  MOVFF  00,7BB
0323A:  MOVFF  03,7E2
0323E:  MOVFF  02,7E1
03242:  MOVFF  01,7E0
03246:  MOVFF  00,7DF
0324A:  MOVFF  7BA,7E6
0324E:  MOVFF  7B9,7E5
03252:  MOVFF  7B8,7E4
03256:  MOVFF  7B7,7E3
0325A:  CALL   20C8
0325E:  MOVFF  03,7BE
03262:  MOVFF  02,7BD
03266:  MOVFF  01,7BC
0326A:  MOVFF  00,7BB
0326E:  MOVFF  03,7C2
03272:  MOVFF  02,7C1
03276:  MOVFF  01,7C0
0327A:  MOVFF  00,7BF
0327E:  RCALL  2B6C
03280:  BRA    328C
....................       } else return 0; 
03282:  BRA    328C
03284:  CLRF   00
03286:  CLRF   01
03288:  CLRF   02
0328A:  CLRF   03
....................    } 
0328C:  GOTO   3D3E (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <STDIO.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #define SDAPIN PIN_B0 
.................... #define SCLPIN PIN_B1 
....................  
.................... #define SENSORBOARDA PIN_B5 
.................... #define SENSORBOARDB PIN_B4 
....................  
.................... #define TESTER 1 
.................... #define NOTOSMOBOT 1 
.................... #define ADCREZ 1024 
.................... #define OSMOBOT 0    // this not the main board, but the programmer 
.................... #define TIRHTEMP 1 
.................... char adcBuff[20]; 
.................... char bt_cmd[50]; // buffer where the command is kept for parsing.  Added July 10, 2015 
.................... char rec_buffer[65]; 
.................... unsigned int16 reading[128];  // this is the linear array 
.................... unsigned int8 streamCntr = 0; 
.................... unsigned int8 dispCntr = 0; 
.................... int1 writeReady = 0; 
.................... unsigned int8 xCntr = 0; 
.................... unsigned int8 yCntr = 0; 
.................... unsigned int16 stufftocheck; 
....................  
.................... #fuses  NOWDT, NOLVP, NOBROWNOUT, NOPROTECT, PUT  
.................... #use delay(crystal=20000000, clock=20000000) 
*
01202:  MOVLW  07
01204:  MOVWF  FEA
01206:  MOVLW  C1
01208:  MOVWF  FE9
0120A:  MOVF   FEF,W
0120C:  BZ    1228
0120E:  MOVLW  06
01210:  MOVWF  01
01212:  CLRF   00
01214:  DECFSZ 00,F
01216:  BRA    1214
01218:  DECFSZ 01,F
0121A:  BRA    1212
0121C:  MOVLW  7B
0121E:  MOVWF  00
01220:  DECFSZ 00,F
01222:  BRA    1220
01224:  DECFSZ FEF,F
01226:  BRA    120E
01228:  RETURN 0
....................  
....................  
.................... #use i2c(stream=PH_LIGHT, MASTER, sda=SDAPIN, scl=SCLPIN, fast=10000)    // this is the master I2c for talking with removote sensor boards.  There is only one I2c on this chip. 
*
0364C:  MOVLW  08
0364E:  MOVWF  01
03650:  MOVLW  50
03652:  MOVWF  00
03654:  DECFSZ 00,F
03656:  BRA    3654
03658:  BCF    F8A.1
0365A:  BCF    F93.1
0365C:  MOVLW  51
0365E:  MOVWF  00
03660:  DECFSZ 00,F
03662:  BRA    3660
03664:  MOVLB  7
03666:  RLCF   xB4,F
03668:  BCF    F8A.0
0366A:  BTFSC  FD8.0
0366C:  BSF    F93.0
0366E:  BTFSS  FD8.0
03670:  BCF    F93.0
03672:  BSF    F93.1
03674:  BTFSS  F81.1
03676:  BRA    3674
03678:  DECFSZ 01,F
0367A:  BRA    367E
0367C:  BRA    3682
0367E:  MOVLB  0
03680:  BRA    3650
03682:  MOVLW  50
03684:  MOVWF  00
03686:  DECFSZ 00,F
03688:  BRA    3686
0368A:  BCF    F8A.1
0368C:  BCF    F93.1
0368E:  NOP   
03690:  BSF    F93.0
03692:  MOVLW  51
03694:  MOVWF  00
03696:  DECFSZ 00,F
03698:  BRA    3696
0369A:  MOVLW  51
0369C:  MOVWF  00
0369E:  DECFSZ 00,F
036A0:  BRA    369E
036A2:  BSF    F93.1
036A4:  BTFSS  F81.1
036A6:  BRA    36A4
036A8:  CLRF   01
036AA:  MOVLW  51
036AC:  MOVWF  00
036AE:  DECFSZ 00,F
036B0:  BRA    36AE
036B2:  BTFSC  F81.0
036B4:  BSF    01.0
036B6:  BCF    F8A.1
036B8:  BCF    F93.1
036BA:  BCF    F8A.0
036BC:  BCF    F93.0
036BE:  MOVLB  0
036C0:  RETURN 0
036C2:  MOVLW  08
036C4:  MOVLB  7
036C6:  MOVWF  xB5
036C8:  MOVFF  00,7B6
036CC:  BSF    F93.0
036CE:  MOVLW  51
036D0:  MOVWF  00
036D2:  DECFSZ 00,F
036D4:  BRA    36D2
036D6:  BSF    F93.1
036D8:  BTFSS  F81.1
036DA:  BRA    36D8
036DC:  BTFSC  F81.0
036DE:  BSF    FD8.0
036E0:  BTFSS  F81.0
036E2:  BCF    FD8.0
036E4:  RLCF   01,F
036E6:  MOVLW  50
036E8:  MOVWF  00
036EA:  DECFSZ 00,F
036EC:  BRA    36EA
036EE:  BCF    F93.1
036F0:  BCF    F8A.1
036F2:  DECFSZ xB5,F
036F4:  BRA    36CC
036F6:  BSF    F93.0
036F8:  MOVLW  51
036FA:  MOVWF  00
036FC:  DECFSZ 00,F
036FE:  BRA    36FC
03700:  BCF    F8A.0
03702:  MOVF   xB6,W
03704:  BTFSS  FD8.2
03706:  BCF    F93.0
03708:  NOP   
0370A:  BSF    F93.1
0370C:  BTFSS  F81.1
0370E:  BRA    370C
03710:  MOVLW  50
03712:  MOVWF  00
03714:  DECFSZ 00,F
03716:  BRA    3714
03718:  BCF    F8A.1
0371A:  BCF    F93.1
0371C:  MOVLW  51
0371E:  MOVWF  00
03720:  DECFSZ 00,F
03722:  BRA    3720
03724:  BCF    F8A.0
03726:  BCF    F93.0
03728:  MOVLB  0
0372A:  RETURN 0
.................... #use rs232(uart1, baud=9600, xmit=PIN_C6, rcv=PIN_C7, stream=BT) 
*
04F50:  BTFSS  F9E.4
04F52:  BRA    4F50
04F54:  MOVWF  FAD
04F56:  RETURN 0
....................  
.................... void selectsensor(int sensornumber); 
.................... int readlineararray(void); 
.................... int16 DORaw, WTRaw, NH4Raw; 
....................  
.................... typedef struct outputDataStruct { 
....................     char deviceID[16]; 
....................     unsigned int8 hour; 
....................     unsigned int8 minute; 
....................     unsigned int8 second; 
....................     unsigned int8 day; 
....................     unsigned int8 month; 
....................     unsigned int16 year; 
....................     unsigned int8 taosVersion; 
....................     float dOxy; 
....................     float wTemp; 
....................     float pH; 
....................     float pHLow; 
....................     float WhiteBalance; 
....................     float tdsLevel; 
....................     float wLevel; 
....................     float lLevelX; 
....................     float lLevelY; 
....................  
....................     int32 lLevelRed; 
....................     int32 lLevelGreen; 
....................     int32 lLevelBlue; 
....................     int32 lLevelClear; 
....................     int8 time; 
....................     int16 date; 
....................  
....................  
....................     float lLevelScale; 
....................     float rH, averagepH; 
....................     float aTemp; 
....................     int16 cO2; 
....................     float nh3; 
....................     float dPoint; 
....................     char DIEHARD[8]; 
.................... } outputData; 
....................  
....................  
.................... outputData sysOutput; 
.................... unsigned int16 selectitem; // this is the var used for local configurations 
.................... //int16 DORaw, WTRaw, NH4Raw, CO2Raw, stuffit,NHWhiteRaw, NHRedRaw,NHGreenRaw, NHBlueRaw; 
.................... int16 stuffit; 
.................... int8 startupdate = 0; // this is the flag to start an upload  
.................... int16 th,tl,hh,hl;  // variables for 1050 RH and temp sensor 
....................  
.................... #include <CU20045SCPB-U1J.c> 
.................... /////////////Configuration//////////////////// 
.................... #define RSPIN PIN_E2 
.................... #define WRPIN PIN_E1 
.................... #define RDPIN PIN_E0 
.................... #define WRITEPORT PORT_D 
....................  
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /////////////Definitions////////////////////// 
.................... #ifndef BYTE 
.................... #define BYTE int8 
.................... #endif 
.................... #ifndef BOOL 
.................... #define BOOL int1 
.................... #endif 
....................  
.................... #ifndef HIGH 
.................... #define HIGH 1 
.................... #endif 
....................  
.................... #ifndef LOW 
.................... #define LOW 0 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
....................  
.................... void initDispIO(void) 
.................... { 
.................... output_bit(WRPIN,HIGH); 
*
011EE:  BSF    F8D.1
011F0:  BCF    F96.1
.................... output_bit(RDPIN,HIGH); 
011F2:  BSF    F8D.0
011F4:  BCF    F96.0
.................... output_bit(RSPIN,LOW); 
011F6:  BCF    F8D.2
011F8:  BCF    F96.2
.................... output_d(0x00); 
011FA:  CLRF   F95
011FC:  CLRF   F8C
011FE:  GOTO   8FC2 (RETURN)
.................... } 
....................  
....................  
.................... void output_d_flipped(BYTE val){ 
.................... output_bit(PIN_D0,(val&(1<<7))); 
*
0122A:  MOVLB  7
0122C:  BTFSC  xCB.7
0122E:  BRA    1234
01230:  BCF    F8C.0
01232:  BRA    1236
01234:  BSF    F8C.0
01236:  BCF    F95.0
.................... output_bit(PIN_D1,(val&(1<<6))); 
01238:  BTFSC  xCB.6
0123A:  BRA    1240
0123C:  BCF    F8C.1
0123E:  BRA    1242
01240:  BSF    F8C.1
01242:  BCF    F95.1
.................... output_bit(PIN_D2,(val&(1<<5))); 
01244:  BTFSC  xCB.5
01246:  BRA    124C
01248:  BCF    F8C.2
0124A:  BRA    124E
0124C:  BSF    F8C.2
0124E:  BCF    F95.2
.................... output_bit(PIN_D3,(val&(1<<4))); 
01250:  BTFSC  xCB.4
01252:  BRA    1258
01254:  BCF    F8C.3
01256:  BRA    125A
01258:  BSF    F8C.3
0125A:  BCF    F95.3
.................... output_bit(PIN_D4,(val&(1<<3))); 
0125C:  BTFSC  xCB.3
0125E:  BRA    1264
01260:  BCF    F8C.4
01262:  BRA    1266
01264:  BSF    F8C.4
01266:  BCF    F95.4
.................... output_bit(PIN_D5,(val&(1<<2))); 
01268:  BTFSC  xCB.2
0126A:  BRA    1270
0126C:  BCF    F8C.5
0126E:  BRA    1272
01270:  BSF    F8C.5
01272:  BCF    F95.5
.................... output_bit(PIN_D6,(val&(1<<1))); 
01274:  BTFSC  xCB.1
01276:  BRA    127C
01278:  BCF    F8C.6
0127A:  BRA    127E
0127C:  BSF    F8C.6
0127E:  BCF    F95.6
.................... output_bit(PIN_D7,(val&(1<<0))); 
01280:  BTFSC  xCB.0
01282:  BRA    1288
01284:  BCF    F8C.7
01286:  BRA    128A
01288:  BSF    F8C.7
0128A:  BCF    F95.7
0128C:  MOVLB  0
0128E:  GOTO   1298 (RETURN)
.................... } 
....................  
....................  
.................... BYTE readByte(BOOL RSval) 
.................... { 
.................... output_bit(RDPIN,HIGH); 
.................... delay_cycles(1); 
.................... output_bit(RSPIN,RSval); 
.................... delay_cycles(1); 
.................... output_bit(RDPIN,LOW); 
.................... delay_cycles(1); 
.................... BYTE dataVal=input_d(); 
.................... delay_cycles(1); 
.................... output_bit(RDPIN,HIGH); 
.................... delay_cycles(1); 
....................  
.................... return dataVal; 
.................... } 
....................  
....................  
....................  
.................... BOOL writeByte(BOOL RSval, BYTE val){ 
.................... //RSval=RSval&0x01; 
.................... //BYTE startByte = (0x00|(RSval));	//Sets startByte depending on RSval 
.................... //BYTE stopByte = (0x02|(RSval));	//Sets stopByte depending on RSval 
....................  
.................... /* 
.................... if((readByte(0)&0x80)==1){ 
....................  
.................... delay_cycles(255); 
....................  
.................... } 
.................... else 
.................... { 
....................  
.................... } 
.................... */ 
.................... output_d_flipped(val); 
01292:  MOVFF  7CA,7CB
01296:  BRA    122A
.................... output_bit(WRPIN,HIGH); 
01298:  BSF    F8D.1
0129A:  BCF    F96.1
.................... ////RS is LOW when writing and HIGH otherwise 
.................... //output_d(val); 
....................  
.................... //output_d(0xff); 
....................  
....................  
.................... if(RSval!=0) 
0129C:  MOVLB  7
0129E:  MOVF   xC9,F
012A0:  BZ    12A8
.................... { 
.................... output_bit(RSPIN,HIGH); 
012A2:  BSF    F8D.2
012A4:  BCF    F96.2
.................... } 
012A6:  BRA    12AC
.................... else{ 
.................... output_bit(RSPIN,LOW); 
012A8:  BCF    F8D.2
012AA:  BCF    F96.2
.................... } 
.................... output_bit(WRPIN,HIGH); 
012AC:  BSF    F8D.1
012AE:  BCF    F96.1
.................... //delay_cycles(1); 
.................... output_bit(WRPIN,LOW); 
012B0:  BCF    F8D.1
012B2:  BCF    F96.1
.................... //output_E(0x00);	//Write RS	"START" 
.................... //delay_cycles(1); 
....................  
....................  
....................  
.................... //delay_cycles(1); 
.................... //output_E(0x02);	//Write RS ... & RW HIGH "STOP" 
.................... output_bit(WRPIN,HIGH); 
012B4:  BSF    F8D.1
012B6:  BCF    F96.1
.................... //delay_cycles(1); 
.................... return HIGH; 
012B8:  MOVLW  01
012BA:  MOVWF  01
012BC:  MOVLB  0
012BE:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... BOOL writeChar(BYTE val){ 
.................... writeByte(1,val); 
*
01336:  MOVLW  01
01338:  MOVLB  7
0133A:  MOVWF  xC9
0133C:  MOVFF  7C8,7CA
01340:  MOVLB  0
01342:  RCALL  1292
.................... return HIGH; 
01344:  MOVLW  01
01346:  MOVWF  01
01348:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... BOOL writeCharPos(BYTE xPos, BYTE yPos, BYTE strPtr) 
.................... { 
....................  
....................  
.................... BYTE WAMpos=0x80+xPos+(0x20*yPos); 
.................... writeByte(0,WAMpos);	//Set WAM Address 
....................  
.................... int i=0; 
....................  
....................  
.................... writeChar(strPtr); 
.................... return HIGH; 
.................... } 
....................  
....................  
.................... void clearLine(int8 xPos, int8 yPos){ 
....................  
.................... BYTE linePos=((0x20*yPos)+0x80); 
.................... writeByte(0,linePos); 
.................... for(int ct=0; ct<20; ct++) 
.................... { 
.................... writeChar(' '); 
.................... } 
.................... BYTE WAMpos=0x80+xPos+(0x20*yPos); 
.................... writeByte(0,WAMpos);	//Set WAM Address 
.................... } 
....................  
....................  
....................  
....................  
.................... BOOL writeString(BYTE xPos, BYTE yPos, BYTE strPtr[]) 
0134A:  MOVLB  7
0134C:  MOVF   xC1,W
0134E:  MULLW  20
01350:  MOVF   FF3,W
01352:  ADDLW  80
01354:  MOVWF  xC4
.................... { 
....................  
.................... BYTE linePos=((0x20*yPos)+0x80); 
.................... writeByte(0,linePos); 
01356:  CLRF   xC9
01358:  MOVFF  7C4,7CA
0135C:  MOVLB  0
0135E:  RCALL  1292
.................... //for(int ct=0; ct<20; ct++) 
.................... //{ 
.................... //writeChar(' '); 
.................... //} 
....................  
.................... BYTE WAMpos=0x80+xPos+(0x20*yPos); 
01360:  MOVLW  80
01362:  MOVLB  7
01364:  ADDWF  xC0,W
01366:  MOVWF  xC7
01368:  MOVF   xC1,W
0136A:  MULLW  20
0136C:  MOVF   FF3,W
0136E:  ADDWF  xC7,W
01370:  MOVWF  xC5
.................... writeByte(0,WAMpos);	//Set WAM Address 
01372:  CLRF   xC9
01374:  MOVFF  7C5,7CA
01378:  MOVLB  0
0137A:  RCALL  1292
....................  
.................... int i=0; 
0137C:  MOVLB  7
0137E:  CLRF   xC6
....................  
.................... while(strPtr[i]!='\0') 
01380:  MOVF   xC6,W
01382:  ADDWF  xC2,W
01384:  MOVWF  FE9
01386:  MOVLW  00
01388:  ADDWFC xC3,W
0138A:  MOVWF  FEA
0138C:  MOVF   FEF,F
0138E:  BZ    13B2
.................... { 
.................... writeChar(strPtr[i]); 
01390:  MOVF   xC6,W
01392:  ADDWF  xC2,W
01394:  MOVWF  FE9
01396:  MOVLW  00
01398:  ADDWFC xC3,W
0139A:  MOVWF  FEA
0139C:  MOVFF  FEF,7C8
013A0:  MOVLB  0
013A2:  RCALL  1336
.................... i++; 
013A4:  MOVLB  7
013A6:  INCF   xC6,F
.................... if(i>=20) 
013A8:  MOVF   xC6,W
013AA:  SUBLW  13
013AC:  BC    13B0
.................... { 
.................... break; 
013AE:  BRA    13B2
.................... } 
013B0:  BRA    1380
....................  
.................... } 
.................... return HIGH; 
013B2:  MOVLW  01
013B4:  MOVWF  01
013B6:  MOVLB  0
013B8:  RETURN 0
.................... } 
....................  
....................  
.................... void clearDisplay(){ 
.................... writeByte(0,0x01);	//Clear Display 
*
0131E:  MOVLB  7
01320:  CLRF   xC9
01322:  MOVLW  01
01324:  MOVWF  xCA
01326:  MOVLB  0
01328:  RCALL  1292
.................... delay_ms(5); 
0132A:  MOVLW  05
0132C:  MOVLB  7
0132E:  MOVWF  xC1
01330:  MOVLB  0
01332:  RCALL  1202
01334:  RETURN 0
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... void initDisplay(void){ 
.................... writeByte(0,0x3F);	//Set 8 bit mode 
*
012C0:  MOVLB  7
012C2:  CLRF   xC9
012C4:  MOVLW  3F
012C6:  MOVWF  xCA
012C8:  MOVLB  0
012CA:  RCALL  1292
.................... delay_cycles(127); 
012CC:  MOVLW  2A
012CE:  MOVWF  00
012D0:  DECFSZ 00,F
012D2:  BRA    12D0
.................... writeByte(0,0x01);	//Clear Display 
012D4:  MOVLB  7
012D6:  CLRF   xC9
012D8:  MOVLW  01
012DA:  MOVWF  xCA
012DC:  MOVLB  0
012DE:  RCALL  1292
.................... delay_ms(5); 
012E0:  MOVLW  05
012E2:  MOVLB  7
012E4:  MOVWF  xC1
012E6:  MOVLB  0
012E8:  RCALL  1202
.................... //writeByte(0,0x02);	//Cursor Home 
.................... writeByte(0,0x06);	//Entry Mode Set 
012EA:  MOVLB  7
012EC:  CLRF   xC9
012EE:  MOVLW  06
012F0:  MOVWF  xCA
012F2:  MOVLB  0
012F4:  RCALL  1292
.................... writeByte(0,0x0F);	//Display On Cursor On 
012F6:  MOVLB  7
012F8:  CLRF   xC9
012FA:  MOVLW  0F
012FC:  MOVWF  xCA
012FE:  MOVLB  0
01300:  RCALL  1292
.................... writeByte(0,0x10);	//Cursor Shift 
01302:  MOVLB  7
01304:  CLRF   xC9
01306:  MOVLW  10
01308:  MOVWF  xCA
0130A:  MOVLB  0
0130C:  RCALL  1292
.................... writeByte(0,0x80);	//Set WAM Address 
0130E:  MOVLB  7
01310:  CLRF   xC9
01312:  MOVLW  80
01314:  MOVWF  xCA
01316:  MOVLB  0
01318:  RCALL  1292
0131A:  GOTO   8FDE (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... #include "G:\OsmobotLocalDisplay Via Bluetooth\VacDisplayRoutines.c" 
....................  
....................  
....................  
.................... void VacDisplayinit(void) 
.................... { 
.................... 	//wait(1000000);	 
.................... 	delay_ms(1000); 
.................... 	output_high(RDPIN); // Pin 11 E/(~RD) 
.................... 	output_high(WRPIN);//pin 10 R/~WR 
.................... 	output_d(0x0F);	//  Dispaly Turns ON, Blink Off. 
.................... 	output_low(RSPIN); // Pin 9 RS  
.................... 	output_low(WRPIN); //Pin 10 ~WR 
.................... 	output_high(WRPIN);//pin 10 R/~WR 
.................... } 
....................  
.................... void VacWriteChar(char letter) 
.................... { 
.................... 	//wait(10); 
....................     int stuff; 
....................     stuff = writeChar(letter); 
*
04184:  MOVFF  7AC,7C8
04188:  CALL   1336
0418C:  MOVFF  01,7AD
04190:  RETURN 0
....................      
.................... 	} 
....................  
....................  
....................  
.................... void VacSetXY(int X, int Y) 
.................... { 
.................... 	//output_low(RSPIN); 
.................... 	//output_d(0x06); //  Address counter incremented, cursor shift en 
.................... //	output_low(WRPIN); //Pin 10 ~WR 
.................... 	//output_high(WRPIN);//pin 10 R/~WR*/ 
....................     writeByte(0,0x06);	//Address counter incremented, cursor shift en 
*
040F2:  MOVLB  7
040F4:  CLRF   xC9
040F6:  MOVLW  06
040F8:  MOVWF  xCA
040FA:  MOVLB  0
040FC:  CALL   1292
....................     writeByte(0,0x02);	//Move cursor home 
04100:  MOVLB  7
04102:  CLRF   xC9
04104:  MOVLW  02
04106:  MOVWF  xCA
04108:  MOVLB  0
0410A:  CALL   1292
.................... 	int location=0; 
0410E:  MOVLB  7
04110:  CLRF   xAE
.................... 	switch (Y) 
04112:  MOVLW  01
04114:  SUBWF  xAD,W
04116:  ADDLW  FC
04118:  BC    4144
0411A:  ADDLW  04
0411C:  MOVLB  0
0411E:  GOTO   4162
.................... 	{ 
.................... 	case 1 : 
.................... 		location = 128; 
04122:  MOVLW  80
04124:  MOVLB  7
04126:  MOVWF  xAE
.................... 		break;	 
04128:  BRA    4144
....................  
.................... 	case 2 : 
.................... 		location = 160; 
0412A:  MOVLW  A0
0412C:  MOVLB  7
0412E:  MOVWF  xAE
.................... 		break;	 
04130:  BRA    4144
.................... 		 
.................... 	case 3 : 
.................... 		location = 192; 
04132:  MOVLW  C0
04134:  MOVLB  7
04136:  MOVWF  xAE
.................... 		break;	 
04138:  BRA    4144
.................... 	 
.................... 	case 4 : 
.................... 		location = 224; 
0413A:  MOVLW  E0
0413C:  MOVLB  7
0413E:  MOVWF  xAE
.................... 		break;	 
04140:  BRA    4144
04142:  MOVLB  7
.................... 	} 
.................... 	location = location + x; 
04144:  MOVF   xAC,W
04146:  ADDWF  xAE,F
....................     //    writeByte(0,0x0d);	//Clear Display 
....................     writeByte(0,location);	//Clear Display 
04148:  CLRF   xC9
0414A:  MOVFF  7AE,7CA
0414E:  MOVLB  0
04150:  CALL   1292
.................... //	output_d(location); 
.................... //	wait(100); 
.................... //	delay_us(100); 
.................... //	output_low(WRPIN); // write pin low 
.................... //	wait(100); 
.................... 	delay_us(100); 
04154:  MOVLW  A6
04156:  MOVWF  00
04158:  DECFSZ 00,F
0415A:  BRA    4158
0415C:  NOP   
0415E:  GOTO   419E (RETURN)
.................... //	output_high(WRPIN); // write pin high 
.................... } 
....................  
.................... void VacDisplayString(char* string) 
.................... { 
.................... 	 
.................... 	int i; 
.................... 	int len = strlen(string); 
.................... 	//for length of string, take i-th position and output 
.................... 	for (i = 0; i < len; i++) 
.................... 	{ 
.................... 		VacWriteChar(string[i]); 
.................... 	} 
....................  
.................... } 
.................... //*********************************************** 
.................... //  The Y input is from 0 to 3.  0 is the top line and 3 is the bottom line on the VFD 
.................... //*********************************************** 
.................... void Display_XYString(int x, int y, char* string) 
.................... { 
.................... 	if (y < 5) 
....................     { 
....................     VacSetXY(x,y); 
.................... //	wait(50); 
.................... 	delay_ms(100); 
.................... 	VacDisplayString(string); 
....................     } 
.................... } 
....................  
....................  
....................  
.................... //**************************************************************** 
.................... // Created November 22, 2016 
.................... // Display the selected items on the VFD.  This is only used on the PIC18 CPUS for testing and production. 
.................... // Returns nothing. 
.................... // A max of 16 items can be selected.  Only four of the selected items are displayed.  The format goes  ITEM  RAWDATA  CONVERTEDDATA 
.................... //**************************************************************** 
.................... void displayselecteddata(int16 selectitem) 
.................... { 
....................     int linenumber = 1; 
....................     clearDisplay(); 
....................     if (selectitem & 0x0004) 
....................     { 
....................     sprintf(adcBuff, "DO %Lu %f  ",DORaw,sysOutput.dOxy); 
....................     Display_XYString(0,linenumber,adcBuff);  
....................         //  1  sysOutput.dOxy     
....................     linenumber++; 
....................     } 
....................     if (selectitem & 0x0400) 
....................     { 
....................     sprintf(adcBuff, "WT %Lu  %f   ",WTRaw,sysOutput.wTemp); 
....................     Display_XYString(0,linenumber,adcBuff); 
....................         //  2  sysOutput.wTemp     
....................     linenumber++; 
....................     }   
....................     if (selectitem & 0x1000) 
....................     { 
....................     sprintf(adcBuff, "NH4 %Lu  %f",NH4Raw,sysOutput.nh3); 
....................     Display_XYString(0,linenumber,adcBuff);  
....................         //  2  sysOutput.nh4     
....................     linenumber++; 
....................     }  
....................     if (selectitem & 0x0200) 
....................     { 
....................     sprintf(adcBuff, "CO2 %Lu ppm",sysOutput.cO2); 
....................     Display_XYString(0,linenumber,adcBuff);  
....................         //  2  sysOutput.co2     
....................     linenumber++; 
....................     }  
....................  if (selectitem & 0x0002) 
....................     { 
....................     sprintf(adcBuff, "AT+RH %fC %f%%",sysOutput.aTemp,sysOutput.rH); 
....................     Display_XYString(0,linenumber,adcBuff);  
....................         //  2  This is the air temperature and RH    
....................     linenumber++; 
....................     }  
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Feb 18, 2017 
.................... // Creates a bar graph on one row of the VFD. 
.................... //  An array is entered with the threashold limit. 
.................... //  The third element is the row number.  Starts from 1 to 4 
....................  
.................... //  The bar graphs scales 128 points into 20. 
.................... // Nothing is returned. 
.................... //****************************************************************************** 
.................... void displaybar(int threashold, int row) 
.................... { 
....................     int x; 
....................      
....................     VacSetXY(0x00,row);    
*
04192:  MOVLB  7
04194:  CLRF   xAC
04196:  MOVFF  7AA,7AD
0419A:  MOVLB  0
0419C:  BRA    40F2
....................     for (x=0; x < 128; x=x+7) 
0419E:  MOVLB  7
041A0:  CLRF   xAB
041A2:  MOVF   xAB,W
041A4:  SUBLW  7F
041A6:  BNC   420A
....................     { 
....................         if (reading[x] > threashold) 
041A8:  BCF    FD8.0
041AA:  RLCF   xAB,W
041AC:  CLRF   03
041AE:  ADDLW  A6
041B0:  MOVWF  FE9
041B2:  MOVLW  00
041B4:  ADDWFC 03,W
041B6:  MOVWF  FEA
041B8:  MOVFF  FEC,7AD
041BC:  MOVF   FED,F
041BE:  MOVFF  FEF,7AC
041C2:  MOVF   xAD,F
041C4:  BNZ   41CC
041C6:  MOVF   xAC,W
041C8:  SUBWF  xA9,W
041CA:  BC    41D6
....................             VacWriteChar(0x14); 
041CC:  MOVLW  14
041CE:  MOVWF  xAC
041D0:  MOVLB  0
041D2:  RCALL  4184
041D4:  MOVLB  7
....................          if (reading[x] <= threashold) 
041D6:  BCF    FD8.0
041D8:  RLCF   xAB,W
041DA:  CLRF   03
041DC:  ADDLW  A6
041DE:  MOVWF  FE9
041E0:  MOVLW  00
041E2:  ADDWFC 03,W
041E4:  MOVWF  FEA
041E6:  MOVFF  FEC,7AD
041EA:  MOVF   FED,F
041EC:  MOVFF  FEF,7AC
041F0:  MOVF   xAD,F
041F2:  BNZ   4204
041F4:  MOVF   xAC,W
041F6:  SUBWF  xA9,W
041F8:  BNC   4204
....................             VacWriteChar(0x20);            
041FA:  MOVLW  20
041FC:  MOVWF  xAC
041FE:  MOVLB  0
04200:  RCALL  4184
04202:  MOVLB  7
04204:  MOVLW  07
04206:  ADDWF  xAB,F
04208:  BRA    41A2
....................     } 
0420A:  MOVLB  0
0420C:  GOTO   4376 (RETURN)
....................      
....................      
.................... } 
....................  
.................... #include <MasterReadWriteTeRemoteDevice.c> 
....................  
....................  
.................... #ifdef NOTOSMOBOT 
.................... #include "CommonPassedDataFromMaterToSlave.h" 
.................... //********************************************************************************************** 
.................... // Created November 23, 2016 
.................... //these are the calibration varibles so far on the tester.   
.................... //********************************************************************************************** 
....................  
.................... typedef struct { 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
.................... float eccal1x; 
.................... float eccal2x; 
.................... float eccal3x; 
.................... float eccal1y; 
.................... float eccal2y; 
.................... float eccal3y; 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... }Calstuff; 
.................... Calstuff sysInput;  
.................... /* 
....................  
.................... typedef struct inputDataStruct{ 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... float eccal1x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal1y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3y;    //  This the EC data point  Added July 18, 2016 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... }inputData; 
.................... inputData sysInput; 
....................  
.................... */ 
....................  
.................... #ifdef SLAVE 
....................  
.................... float Temp1DOOne; 
.................... float Temp1DOTwo; 
.................... float Temp1DOThree; 
.................... float Temp2DOOne; 
.................... float Temp2DOTwo; 
.................... float Temp2DOThree; 
.................... float Temp3DOOne; 
.................... float Temp3DOTwo; 
.................... float Temp3DOThree; 
.................... float Temp1ReadingOne; 
.................... float Temp1ReadingTwo; 
.................... float Temp1ReadingThree; 
.................... float Temp2ReadingOne; 
.................... float Temp2ReadingTwo; 
.................... float Temp2ReadingThree; 
.................... float Temp3ReadingOne; 
.................... float Temp3ReadingTwo; 
.................... float Temp3ReadingThree; 
....................  
.................... unsigned int16 TempOne; 
.................... unsigned int16 TempTwo; 
.................... unsigned int16 TempThree; 
....................  
.................... #endif 
....................  
.................... int16 CO2Raw,NHredRaw,NHGreenRaw,NHBlueRaw,NHWhiteRaw,DpHredRaw,DpHGreenRaw,DpHBlueRaw,DpHWhiteRaw; 
.................... #else 
.................... int16  DORaw, WTRaw, NH4Raw, CO2Raw,NHredRaw,NHGreenRaw,NHBlueRaw,NHWhiteRaw; 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #ifndef BTTestEvent 
.................... void BTTestEvent(void); 
.................... #endif 
.................... //  See the slave include file calle ITwoSeeGeneralCommunicationSlave.c  for the data structure for sending data to the master.  All  
.................... //  updates to the data structure are done on the Slave include file.  Not the master. 
....................  
.................... // Added Oct 24, 2016 
.................... // These routines are moved to a sharable file for the Osmobot and all other programs to read/write to i2c sensors. 
.................... // This routine is used in the Osmobot where there are no printf for a display. 
.................... int ReadRemoteDeviceOsmobot(int deviceaddress) 
.................... { 
....................      
....................     int x; 
....................     //  Selection of 0  internal Digital DO and NH4 sensor 
....................     //  Selection of 1  Top RJ45 connector 
....................     //  Selection of 2  Bottom RJ45 connector     
....................     //  Selection of 3  no connection 
....................             selectsensor(deviceaddress);  // this sets the SCL to the right I2C device. 
....................      
....................     	    i2c_start(PH_LIGHT); 
.................... 			i2c_write(PH_LIGHT,0xa0);  //Move the address number left on and add a zero.  This is the command with address to write data to the address pointer 
.................... 			i2c_write(PH_LIGHT,0x00);  //This is the locations of the first buffer to address 
.................... 			i2c_stop(PH_LIGHT); 
....................              
....................             i2c_start(PH_LIGHT);  // start again 
....................             i2c_write(PH_LIGHT,0xa1);   // this starts the reading from the device.  Remember that a 1 in the first place is the command to send data from the device to the Master. 
....................             delay_ms(75); 
....................             for (x=0; x < 65; x++)            // read 128 locations and quit.  Put this in the returned array.   
....................             { 
....................                 rec_buffer[x] =  i2c_read(PH_LIGHT,FALSE); 
....................              //   sprintf(adcBuff, "%i",rec_buffer[x]); 
....................  
....................              //  adcStrCntr=0; 
....................  
....................             //    while(adcBuff[adcStrCntr]!= '\0') 
....................              //   { 
....................             //    writeCharPos(adcStrCntr,0,adcBuff[adcStrCntr]); 
....................              //   adcStrCntr++; 
....................              //   } 
....................                  delay_ms(1); 
....................             } 
....................             x++; 
....................             rec_buffer[x] =  i2c_read(PH_LIGHT,FALSE); 
....................             i2c_stop(PH_LIGHT); 
....................      
....................     return(1); 
.................... } 
....................  
....................  
....................  
.................... //  See the slave include file calle ITwoSeeGeneralCommunicationSlave.c  for the data structure for sending data to the master.  All  
.................... //  updates to the data structure are done on the Slave include file.  Not the master. 
....................  
....................  
....................  
.................... int ReadRemoteDevice(int deviceaddress) 
.................... { 
....................      
....................     int x; 
....................  
....................     //  Selection of 0  internal Digital DO and NH4 sensor 
....................     //  Selection of 1  Top RJ45 connector 
....................     //  Selection of 2  Bottom RJ45 connector     
....................     //  Selection of 3  no connection 
....................             selectsensor(deviceaddress);  // this sets the SCL to the right I2C device. 
*
0784E:  MOVFF  791,7B4
07852:  CALL   3608
....................      
....................     	    i2c_start(PH_LIGHT); 
07856:  BSF    F93.0
07858:  MOVLW  50
0785A:  MOVWF  00
0785C:  DECFSZ 00,F
0785E:  BRA    785C
07860:  BSF    F93.1
07862:  MOVLW  51
07864:  MOVWF  00
07866:  DECFSZ 00,F
07868:  BRA    7866
0786A:  BCF    F8A.0
0786C:  BCF    F93.0
0786E:  MOVLW  50
07870:  MOVWF  00
07872:  DECFSZ 00,F
07874:  BRA    7872
07876:  BCF    F8A.1
07878:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0xa0);  //Move the address number left on and add a zero.  This is the command with address to write data to the address pointer 
0787A:  MOVLW  A0
0787C:  MOVLB  7
0787E:  MOVWF  xB4
07880:  MOVLB  0
07882:  CALL   364C
.................... 			i2c_write(PH_LIGHT,0x00);  //This is the locations of the first buffer to address 
07886:  MOVLB  7
07888:  CLRF   xB4
0788A:  MOVLB  0
0788C:  CALL   364C
.................... 			i2c_stop(PH_LIGHT); 
07890:  BCF    F93.0
07892:  NOP   
07894:  BSF    F93.1
07896:  BTFSS  F81.1
07898:  BRA    7896
0789A:  MOVLW  50
0789C:  MOVWF  00
0789E:  DECFSZ 00,F
078A0:  BRA    789E
078A2:  BRA    78A4
078A4:  NOP   
078A6:  BSF    F93.0
078A8:  MOVLW  50
078AA:  MOVWF  00
078AC:  DECFSZ 00,F
078AE:  BRA    78AC
....................              
....................             i2c_start(PH_LIGHT);  // start again 
078B0:  BSF    F93.0
078B2:  MOVLW  50
078B4:  MOVWF  00
078B6:  DECFSZ 00,F
078B8:  BRA    78B6
078BA:  BSF    F93.1
078BC:  MOVLW  51
078BE:  MOVWF  00
078C0:  DECFSZ 00,F
078C2:  BRA    78C0
078C4:  BCF    F8A.0
078C6:  BCF    F93.0
078C8:  MOVLW  50
078CA:  MOVWF  00
078CC:  DECFSZ 00,F
078CE:  BRA    78CC
078D0:  BCF    F8A.1
078D2:  BCF    F93.1
....................             i2c_write(PH_LIGHT,0xa1);   // this starts the reading from the device.  Remember that a 1 in the first place is the command to send data from the device to the Master. 
078D4:  MOVLW  A1
078D6:  MOVLB  7
078D8:  MOVWF  xB4
078DA:  MOVLB  0
078DC:  CALL   364C
....................             delay_ms(75); 
078E0:  MOVLW  4B
078E2:  MOVLB  7
078E4:  MOVWF  xC1
078E6:  MOVLB  0
078E8:  CALL   1202
....................             for (x=0; x < 65; x++)            // read 128 locations and quit.  Put this in the returned array.   
078EC:  MOVLB  7
078EE:  CLRF   x92
078F0:  MOVF   x92,W
078F2:  SUBLW  40
078F4:  BNC   7926
....................             { 
....................                 rec_buffer[x] =  i2c_read(PH_LIGHT); 
078F6:  CLRF   03
078F8:  MOVF   x92,W
078FA:  ADDLW  65
078FC:  MOVWF  FE9
078FE:  MOVLW  00
07900:  ADDWFC 03,W
07902:  MOVWF  FEA
07904:  MOVLW  01
07906:  MOVWF  00
07908:  MOVLB  0
0790A:  CALL   36C2
0790E:  MOVFF  01,FEF
....................                // sprintf(adcBuff, "%i %i",rec_buffer[x],deviceaddress); 
....................               //  Display_XYString(0,1,adcBuff);  
....................                 //adcStrCntr=0; 
....................  
....................                 //while(adcBuff[adcStrCntr]!= '\0') 
....................                 //{ 
....................                 //writeCharPos(adcStrCntr,0,adcBuff[adcStrCntr]); 
....................                // adcStrCntr++; 
....................                 //} 
.................... #if OSMOBOT 
....................                 BTBasicTest(); 
.................... #else 
....................                 BTTestEvent();   // check for the data coming back to displayable 
07912:  RCALL  77B4
.................... #endif                
....................                 delay_ms(10); 
07914:  MOVLW  0A
07916:  MOVLB  7
07918:  MOVWF  xC1
0791A:  MOVLB  0
0791C:  CALL   1202
07920:  MOVLB  7
07922:  INCF   x92,F
07924:  BRA    78F0
....................             } 
....................             x++; 
07926:  INCF   x92,F
....................             rec_buffer[x] =  i2c_read(PH_LIGHT,FALSE); 
07928:  CLRF   03
0792A:  MOVF   x92,W
0792C:  ADDLW  65
0792E:  MOVWF  FE9
07930:  MOVLW  00
07932:  ADDWFC 03,W
07934:  MOVWF  FEA
07936:  CLRF   00
07938:  MOVLB  0
0793A:  CALL   36C2
0793E:  MOVFF  01,FEF
....................             i2c_stop(PH_LIGHT); 
07942:  BCF    F93.0
07944:  NOP   
07946:  BSF    F93.1
07948:  BTFSS  F81.1
0794A:  BRA    7948
0794C:  MOVLW  50
0794E:  MOVWF  00
07950:  DECFSZ 00,F
07952:  BRA    7950
07954:  BRA    7956
07956:  NOP   
07958:  BSF    F93.0
0795A:  MOVLW  50
0795C:  MOVWF  00
0795E:  DECFSZ 00,F
07960:  BRA    795E
....................      
....................     return(1); 
07962:  MOVLW  01
07964:  MOVWF  01
07966:  RETURN 0
.................... } 
....................  
....................   
....................     
.................... //******************************************************************************* 
.................... // Created October 28, 2016 
.................... // This routine takes the returned array of data from the remote device and moves it into the selected data startures. 
.................... //  It returns nothing. 
.................... // if the data in the returned array is 0xFF, nothing is done.   
.................... //  The data structure is connected with the listing above. 
.................... //  The input is the array that needs to have the data moved into.  The numbering starts at 0 and goes through 4.  This means five different sensors can be used at the same time. 
.................... // If the same sensor is used, it is kept straight where the data sits and is sent to the server. 
.................... //  As of now, the input is ignorned because there is only one array.   
.................... //******************************************************************************* 
....................     void  moveReceivedData(int portid) 
....................     { 
....................         float tempvar; 
....................         int16 tempvarint; 
....................          // there are 100 points in the transmit buffer. 
....................            // water temperature 
....................             if ((rec_buffer[6] != 0xFF) && (rec_buffer[5] != 0xFF)) 
07968:  INCFSZ x6B,W
0796A:  BRA    796E
0796C:  BRA    7A0A
0796E:  INCFSZ x6A,W
07970:  BRA    7974
07972:  BRA    7A0A
....................             { 
....................               tempvar = (float) rec_buffer[5]; 
07974:  MOVLB  7
07976:  CLRF   xE4
07978:  MOVFF  6A,7E3
0797C:  MOVLB  0
0797E:  CALL   21BE
07982:  MOVFF  03,795
07986:  MOVFF  02,794
0798A:  MOVFF  01,793
0798E:  MOVFF  00,792
....................               sysOutput.wTemp = tempvar  + ((float) rec_buffer[6])/100; 
07992:  MOVLB  7
07994:  CLRF   xE4
07996:  MOVFF  6B,7E3
0799A:  MOVLB  0
0799C:  CALL   21BE
079A0:  MOVFF  03,79B
079A4:  MOVFF  02,79A
079A8:  MOVFF  01,799
079AC:  MOVFF  00,798
079B0:  MOVFF  03,7DB
079B4:  MOVFF  02,7DA
079B8:  MOVFF  01,7D9
079BC:  MOVFF  00,7D8
079C0:  MOVLB  7
079C2:  CLRF   xDF
079C4:  CLRF   xDE
079C6:  MOVLW  48
079C8:  MOVWF  xDD
079CA:  MOVLW  85
079CC:  MOVWF  xDC
079CE:  MOVLB  0
079D0:  CALL   1F6A
079D4:  BCF    FD8.1
079D6:  MOVFF  795,7E6
079DA:  MOVFF  794,7E5
079DE:  MOVFF  793,7E4
079E2:  MOVFF  792,7E3
079E6:  MOVFF  03,7EA
079EA:  MOVFF  02,7E9
079EE:  MOVFF  01,7E8
079F2:  MOVFF  00,7E7
079F6:  CALL   1CF2
079FA:  MOVFF  03,1D2
079FE:  MOVFF  02,1D1
07A02:  MOVFF  01,1D0
07A06:  MOVFF  00,1CF
....................             } 
....................          
....................          
....................             // CO2 
....................             if ((rec_buffer[7] != 0xFF) && (rec_buffer[8] != 0xFF)) 
07A0A:  INCFSZ x6C,W
07A0C:  BRA    7A10
07A0E:  BRA    7A3E
07A10:  INCFSZ x6D,W
07A12:  BRA    7A16
07A14:  BRA    7A3E
....................             { 
....................                  tempvarint = rec_buffer[7]; 
07A16:  MOVLB  7
07A18:  CLRF   x97
07A1A:  MOVFF  6C,796
....................                  tempvarint = tempvarint*256 + rec_buffer[8]; 
07A1E:  MOVFF  796,799
07A22:  CLRF   x98
07A24:  MOVLB  0
07A26:  MOVF   x6D,W
07A28:  MOVLB  7
07A2A:  ADDWF  x98,W
07A2C:  MOVWF  x96
07A2E:  MOVLW  00
07A30:  ADDWFC x99,W
07A32:  MOVWF  x97
....................                  sysOutput.cO2 = tempvarint; 
07A34:  MOVFF  797,213
07A38:  MOVFF  796,212
07A3C:  MOVLB  0
....................             }        
....................              // Air Temperature 
....................             if ((rec_buffer[9] != 0xFF) && (rec_buffer[10] != 0xFF)) 
07A3E:  INCFSZ x6E,W
07A40:  BRA    7A44
07A42:  BRA    7AE0
07A44:  INCFSZ x6F,W
07A46:  BRA    7A4A
07A48:  BRA    7AE0
....................             { 
....................             tempvar = (float) rec_buffer[9]; 
07A4A:  MOVLB  7
07A4C:  CLRF   xE4
07A4E:  MOVFF  6E,7E3
07A52:  MOVLB  0
07A54:  CALL   21BE
07A58:  MOVFF  03,795
07A5C:  MOVFF  02,794
07A60:  MOVFF  01,793
07A64:  MOVFF  00,792
....................             sysOutput.aTemp = tempvar  + ((float) rec_buffer[10])/100; 
07A68:  MOVLB  7
07A6A:  CLRF   xE4
07A6C:  MOVFF  6F,7E3
07A70:  MOVLB  0
07A72:  CALL   21BE
07A76:  MOVFF  03,79B
07A7A:  MOVFF  02,79A
07A7E:  MOVFF  01,799
07A82:  MOVFF  00,798
07A86:  MOVFF  03,7DB
07A8A:  MOVFF  02,7DA
07A8E:  MOVFF  01,7D9
07A92:  MOVFF  00,7D8
07A96:  MOVLB  7
07A98:  CLRF   xDF
07A9A:  CLRF   xDE
07A9C:  MOVLW  48
07A9E:  MOVWF  xDD
07AA0:  MOVLW  85
07AA2:  MOVWF  xDC
07AA4:  MOVLB  0
07AA6:  CALL   1F6A
07AAA:  BCF    FD8.1
07AAC:  MOVFF  795,7E6
07AB0:  MOVFF  794,7E5
07AB4:  MOVFF  793,7E4
07AB8:  MOVFF  792,7E3
07ABC:  MOVFF  03,7EA
07AC0:  MOVFF  02,7E9
07AC4:  MOVFF  01,7E8
07AC8:  MOVFF  00,7E7
07ACC:  CALL   1CF2
07AD0:  MOVFF  03,211
07AD4:  MOVFF  02,210
07AD8:  MOVFF  01,20F
07ADC:  MOVFF  00,20E
....................             }          
....................             // Air RH 
....................             if ((rec_buffer[11] != 0xFF) && (rec_buffer[12] != 0xFF)) 
07AE0:  INCFSZ x70,W
07AE2:  BRA    7AE6
07AE4:  BRA    7B82
07AE6:  INCFSZ x71,W
07AE8:  BRA    7AEC
07AEA:  BRA    7B82
....................             { 
....................             tempvar = (float) rec_buffer[11]; 
07AEC:  MOVLB  7
07AEE:  CLRF   xE4
07AF0:  MOVFF  70,7E3
07AF4:  MOVLB  0
07AF6:  CALL   21BE
07AFA:  MOVFF  03,795
07AFE:  MOVFF  02,794
07B02:  MOVFF  01,793
07B06:  MOVFF  00,792
....................             sysOutput.rH = tempvar  + ((float) rec_buffer[12])/100; 
07B0A:  MOVLB  7
07B0C:  CLRF   xE4
07B0E:  MOVFF  71,7E3
07B12:  MOVLB  0
07B14:  CALL   21BE
07B18:  MOVFF  03,79B
07B1C:  MOVFF  02,79A
07B20:  MOVFF  01,799
07B24:  MOVFF  00,798
07B28:  MOVFF  03,7DB
07B2C:  MOVFF  02,7DA
07B30:  MOVFF  01,7D9
07B34:  MOVFF  00,7D8
07B38:  MOVLB  7
07B3A:  CLRF   xDF
07B3C:  CLRF   xDE
07B3E:  MOVLW  48
07B40:  MOVWF  xDD
07B42:  MOVLW  85
07B44:  MOVWF  xDC
07B46:  MOVLB  0
07B48:  CALL   1F6A
07B4C:  BCF    FD8.1
07B4E:  MOVFF  795,7E6
07B52:  MOVFF  794,7E5
07B56:  MOVFF  793,7E4
07B5A:  MOVFF  792,7E3
07B5E:  MOVFF  03,7EA
07B62:  MOVFF  02,7E9
07B66:  MOVFF  01,7E8
07B6A:  MOVFF  00,7E7
07B6E:  CALL   1CF2
07B72:  MOVFF  03,209
07B76:  MOVFF  02,208
07B7A:  MOVFF  01,207
07B7E:  MOVFF  00,206
....................             }    
....................   
....................             // DO 
....................             if ((rec_buffer[3] != 0xFF) && (rec_buffer[4] != 0xFF)) 
07B82:  INCFSZ x68,W
07B84:  BRA    7B88
07B86:  BRA    7C24
07B88:  INCFSZ x69,W
07B8A:  BRA    7B8E
07B8C:  BRA    7C24
....................             { 
....................             tempvar = (float) rec_buffer[3]; 
07B8E:  MOVLB  7
07B90:  CLRF   xE4
07B92:  MOVFF  68,7E3
07B96:  MOVLB  0
07B98:  CALL   21BE
07B9C:  MOVFF  03,795
07BA0:  MOVFF  02,794
07BA4:  MOVFF  01,793
07BA8:  MOVFF  00,792
....................             sysOutput.dOxy = tempvar  + ((float) rec_buffer[4])/100; 
07BAC:  MOVLB  7
07BAE:  CLRF   xE4
07BB0:  MOVFF  69,7E3
07BB4:  MOVLB  0
07BB6:  CALL   21BE
07BBA:  MOVFF  03,79B
07BBE:  MOVFF  02,79A
07BC2:  MOVFF  01,799
07BC6:  MOVFF  00,798
07BCA:  MOVFF  03,7DB
07BCE:  MOVFF  02,7DA
07BD2:  MOVFF  01,7D9
07BD6:  MOVFF  00,7D8
07BDA:  MOVLB  7
07BDC:  CLRF   xDF
07BDE:  CLRF   xDE
07BE0:  MOVLW  48
07BE2:  MOVWF  xDD
07BE4:  MOVLW  85
07BE6:  MOVWF  xDC
07BE8:  MOVLB  0
07BEA:  CALL   1F6A
07BEE:  BCF    FD8.1
07BF0:  MOVFF  795,7E6
07BF4:  MOVFF  794,7E5
07BF8:  MOVFF  793,7E4
07BFC:  MOVFF  792,7E3
07C00:  MOVFF  03,7EA
07C04:  MOVFF  02,7E9
07C08:  MOVFF  01,7E8
07C0C:  MOVFF  00,7E7
07C10:  CALL   1CF2
07C14:  MOVFF  03,1CE
07C18:  MOVFF  02,1CD
07C1C:  MOVFF  01,1CC
07C20:  MOVFF  00,1CB
....................             }   
....................               // NH4-NH3 
....................             if ((rec_buffer[1] != 0xFF) && (rec_buffer[2] != 0xFF)) 
07C24:  INCFSZ x66,W
07C26:  BRA    7C2A
07C28:  BRA    7CC6
07C2A:  INCFSZ x67,W
07C2C:  BRA    7C30
07C2E:  BRA    7CC6
....................             { 
....................             tempvar = (float) rec_buffer[1]; 
07C30:  MOVLB  7
07C32:  CLRF   xE4
07C34:  MOVFF  66,7E3
07C38:  MOVLB  0
07C3A:  CALL   21BE
07C3E:  MOVFF  03,795
07C42:  MOVFF  02,794
07C46:  MOVFF  01,793
07C4A:  MOVFF  00,792
....................             sysOutput.nh3 = tempvar  + ((float) rec_buffer[2])/100; 
07C4E:  MOVLB  7
07C50:  CLRF   xE4
07C52:  MOVFF  67,7E3
07C56:  MOVLB  0
07C58:  CALL   21BE
07C5C:  MOVFF  03,79B
07C60:  MOVFF  02,79A
07C64:  MOVFF  01,799
07C68:  MOVFF  00,798
07C6C:  MOVFF  03,7DB
07C70:  MOVFF  02,7DA
07C74:  MOVFF  01,7D9
07C78:  MOVFF  00,7D8
07C7C:  MOVLB  7
07C7E:  CLRF   xDF
07C80:  CLRF   xDE
07C82:  MOVLW  48
07C84:  MOVWF  xDD
07C86:  MOVLW  85
07C88:  MOVWF  xDC
07C8A:  MOVLB  0
07C8C:  CALL   1F6A
07C90:  BCF    FD8.1
07C92:  MOVFF  795,7E6
07C96:  MOVFF  794,7E5
07C9A:  MOVFF  793,7E4
07C9E:  MOVFF  792,7E3
07CA2:  MOVFF  03,7EA
07CA6:  MOVFF  02,7E9
07CAA:  MOVFF  01,7E8
07CAE:  MOVFF  00,7E7
07CB2:  CALL   1CF2
07CB6:  MOVFF  03,217
07CBA:  MOVFF  02,216
07CBE:  MOVFF  01,215
07CC2:  MOVFF  00,214
....................             }     
....................             if ((rec_buffer[15] != 0xFF) && (rec_buffer[16] != 0xFF)) 
07CC6:  INCFSZ x74,W
07CC8:  BRA    7CCC
07CCA:  BRA    7CFA
07CCC:  INCFSZ x75,W
07CCE:  BRA    7CD2
07CD0:  BRA    7CFA
....................             { 
....................                  tempvarint = rec_buffer[15]; 
07CD2:  MOVLB  7
07CD4:  CLRF   x97
07CD6:  MOVFF  74,796
....................                  tempvarint = tempvarint*256 + rec_buffer[16]; 
07CDA:  MOVFF  796,799
07CDE:  CLRF   x98
07CE0:  MOVLB  0
07CE2:  MOVF   x75,W
07CE4:  MOVLB  7
07CE6:  ADDWF  x98,W
07CE8:  MOVWF  x96
07CEA:  MOVLW  00
07CEC:  ADDWFC x99,W
07CEE:  MOVWF  x97
....................                  DORaw = tempvarint; 
07CF0:  MOVFF  797,1AE
07CF4:  MOVFF  796,1AD
07CF8:  MOVLB  0
....................             }  
....................             if ((rec_buffer[17] != 0xFF) && (rec_buffer[18] != 0xFF)) 
07CFA:  INCFSZ x76,W
07CFC:  BRA    7D00
07CFE:  BRA    7D2E
07D00:  INCFSZ x77,W
07D02:  BRA    7D06
07D04:  BRA    7D2E
....................             { 
....................                  tempvarint = rec_buffer[17]; 
07D06:  MOVLB  7
07D08:  CLRF   x97
07D0A:  MOVFF  76,796
....................                  tempvarint = tempvarint*256 + rec_buffer[18]; 
07D0E:  MOVFF  796,799
07D12:  CLRF   x98
07D14:  MOVLB  0
07D16:  MOVF   x77,W
07D18:  MOVLB  7
07D1A:  ADDWF  x98,W
07D1C:  MOVWF  x96
07D1E:  MOVLW  00
07D20:  ADDWFC x99,W
07D22:  MOVWF  x97
....................                  NH4Raw = tempvarint; 
07D24:  MOVFF  797,1B2
07D28:  MOVFF  796,1B1
07D2C:  MOVLB  0
....................             }  
....................             if ((rec_buffer[13] != 0xFF) && (rec_buffer[14] != 0xFF)) 
07D2E:  INCFSZ x72,W
07D30:  BRA    7D34
07D32:  BRA    7D62
07D34:  INCFSZ x73,W
07D36:  BRA    7D3A
07D38:  BRA    7D62
....................             { 
....................                  tempvarint = rec_buffer[13]; 
07D3A:  MOVLB  7
07D3C:  CLRF   x97
07D3E:  MOVFF  72,796
....................                  tempvarint = tempvarint*256 + rec_buffer[14]; 
07D42:  MOVFF  796,799
07D46:  CLRF   x98
07D48:  MOVLB  0
07D4A:  MOVF   x73,W
07D4C:  MOVLB  7
07D4E:  ADDWF  x98,W
07D50:  MOVWF  x96
07D52:  MOVLW  00
07D54:  ADDWFC x99,W
07D56:  MOVWF  x97
....................                  WTRaw = tempvarint; 
07D58:  MOVFF  797,1B0
07D5C:  MOVFF  796,1AF
07D60:  MOVLB  0
....................             }  
....................         // Added Feb 26, 2017 
....................         // these items are the raw numbers for NH4 
....................         //RED 
....................             if ((rec_buffer[19] != 0xFF) && (rec_buffer[20] != 0xFF)) 
07D62:  INCFSZ x78,W
07D64:  BRA    7D68
07D66:  BRA    7D96
07D68:  INCFSZ x79,W
07D6A:  BRA    7D6E
07D6C:  BRA    7D96
....................             { 
....................                  tempvarint = rec_buffer[19]; 
07D6E:  MOVLB  7
07D70:  CLRF   x97
07D72:  MOVFF  78,796
....................                  tempvarint = tempvarint*256 + rec_buffer[20]; 
07D76:  MOVFF  796,799
07D7A:  CLRF   x98
07D7C:  MOVLB  0
07D7E:  MOVF   x79,W
07D80:  MOVLB  7
07D82:  ADDWF  x98,W
07D84:  MOVWF  x96
07D86:  MOVLW  00
07D88:  ADDWFC x99,W
07D8A:  MOVWF  x97
....................                  NHredRaw = tempvarint; 
07D8C:  MOVFF  797,2B7
07D90:  MOVFF  796,2B6
07D94:  MOVLB  0
....................             } 
....................         //GREEN 
....................             if ((rec_buffer[21] != 0xFF) && (rec_buffer[22] != 0xFF)) 
07D96:  INCFSZ x7A,W
07D98:  BRA    7D9C
07D9A:  BRA    7DCA
07D9C:  INCFSZ x7B,W
07D9E:  BRA    7DA2
07DA0:  BRA    7DCA
....................             { 
....................                  tempvarint = rec_buffer[21]; 
07DA2:  MOVLB  7
07DA4:  CLRF   x97
07DA6:  MOVFF  7A,796
....................                  tempvarint = tempvarint*256 + rec_buffer[22]; 
07DAA:  MOVFF  796,799
07DAE:  CLRF   x98
07DB0:  MOVLB  0
07DB2:  MOVF   x7B,W
07DB4:  MOVLB  7
07DB6:  ADDWF  x98,W
07DB8:  MOVWF  x96
07DBA:  MOVLW  00
07DBC:  ADDWFC x99,W
07DBE:  MOVWF  x97
....................                  NHGreenRaw = tempvarint; 
07DC0:  MOVFF  797,2B9
07DC4:  MOVFF  796,2B8
07DC8:  MOVLB  0
....................             } 
....................         //BLUE 
....................             if ((rec_buffer[23] != 0xFF) && (rec_buffer[24] != 0xFF)) 
07DCA:  INCFSZ x7C,W
07DCC:  BRA    7DD0
07DCE:  BRA    7DFE
07DD0:  INCFSZ x7D,W
07DD2:  BRA    7DD6
07DD4:  BRA    7DFE
....................             { 
....................                  tempvarint = rec_buffer[23]; 
07DD6:  MOVLB  7
07DD8:  CLRF   x97
07DDA:  MOVFF  7C,796
....................                  tempvarint = tempvarint*256 + rec_buffer[24]; 
07DDE:  MOVFF  796,799
07DE2:  CLRF   x98
07DE4:  MOVLB  0
07DE6:  MOVF   x7D,W
07DE8:  MOVLB  7
07DEA:  ADDWF  x98,W
07DEC:  MOVWF  x96
07DEE:  MOVLW  00
07DF0:  ADDWFC x99,W
07DF2:  MOVWF  x97
....................                  NHBlueRaw = tempvarint; 
07DF4:  MOVFF  797,2BB
07DF8:  MOVFF  796,2BA
07DFC:  MOVLB  0
....................             }  
....................         //WHITE 
....................             if ((rec_buffer[25] != 0xFF) && (rec_buffer[26] != 0xFF)) 
07DFE:  INCFSZ x7E,W
07E00:  BRA    7E04
07E02:  BRA    7E32
07E04:  INCFSZ x7F,W
07E06:  BRA    7E0A
07E08:  BRA    7E32
....................             { 
....................                  tempvarint = rec_buffer[25]; 
07E0A:  MOVLB  7
07E0C:  CLRF   x97
07E0E:  MOVFF  7E,796
....................                  tempvarint = tempvarint*256 + rec_buffer[26]; 
07E12:  MOVFF  796,799
07E16:  CLRF   x98
07E18:  MOVLB  0
07E1A:  MOVF   x7F,W
07E1C:  MOVLB  7
07E1E:  ADDWF  x98,W
07E20:  MOVWF  x96
07E22:  MOVLW  00
07E24:  ADDWFC x99,W
07E26:  MOVWF  x97
....................                  NHWhiteRaw = tempvarint; 
07E28:  MOVFF  797,2BD
07E2C:  MOVFF  796,2BC
07E30:  MOVLB  0
....................             }          
....................         // Added April 3, 2017         
....................              //RED 
....................                 // these items are the raw numbers for the Oscean Optics DpH Patch 
....................             if ((rec_buffer[27] != 0xFF) && (rec_buffer[28] != 0xFF)) 
07E32:  INCFSZ x80,W
07E34:  BRA    7E38
07E36:  BRA    7E66
07E38:  INCFSZ x81,W
07E3A:  BRA    7E3E
07E3C:  BRA    7E66
....................             { 
....................                  tempvarint = rec_buffer[27]; 
07E3E:  MOVLB  7
07E40:  CLRF   x97
07E42:  MOVFF  80,796
....................                  tempvarint = tempvarint*256 + rec_buffer[28]; 
07E46:  MOVFF  796,799
07E4A:  CLRF   x98
07E4C:  MOVLB  0
07E4E:  MOVF   x81,W
07E50:  MOVLB  7
07E52:  ADDWF  x98,W
07E54:  MOVWF  x96
07E56:  MOVLW  00
07E58:  ADDWFC x99,W
07E5A:  MOVWF  x97
....................                  DpHredRaw = tempvarint; 
07E5C:  MOVFF  797,2BF
07E60:  MOVFF  796,2BE
07E64:  MOVLB  0
....................             } 
....................         //GREEN 
....................             if ((rec_buffer[31] != 0xFF) && (rec_buffer[32] != 0xFF)) 
07E66:  INCFSZ x84,W
07E68:  BRA    7E6C
07E6A:  BRA    7E9A
07E6C:  INCFSZ x85,W
07E6E:  BRA    7E72
07E70:  BRA    7E9A
....................             { 
....................                  tempvarint = rec_buffer[31]; 
07E72:  MOVLB  7
07E74:  CLRF   x97
07E76:  MOVFF  84,796
....................                  tempvarint = tempvarint*256 + rec_buffer[32]; 
07E7A:  MOVFF  796,799
07E7E:  CLRF   x98
07E80:  MOVLB  0
07E82:  MOVF   x85,W
07E84:  MOVLB  7
07E86:  ADDWF  x98,W
07E88:  MOVWF  x96
07E8A:  MOVLW  00
07E8C:  ADDWFC x99,W
07E8E:  MOVWF  x97
....................                  DpHGreenRaw = tempvarint; 
07E90:  MOVFF  797,2C1
07E94:  MOVFF  796,2C0
07E98:  MOVLB  0
....................             } 
....................         //BLUE 
....................             if ((rec_buffer[33] != 0xFF) && (rec_buffer[34] != 0xFF)) 
07E9A:  INCFSZ x86,W
07E9C:  BRA    7EA0
07E9E:  BRA    7ECE
07EA0:  INCFSZ x87,W
07EA2:  BRA    7EA6
07EA4:  BRA    7ECE
....................             { 
....................                  tempvarint = rec_buffer[33]; 
07EA6:  MOVLB  7
07EA8:  CLRF   x97
07EAA:  MOVFF  86,796
....................                  tempvarint = tempvarint*256 + rec_buffer[34]; 
07EAE:  MOVFF  796,799
07EB2:  CLRF   x98
07EB4:  MOVLB  0
07EB6:  MOVF   x87,W
07EB8:  MOVLB  7
07EBA:  ADDWF  x98,W
07EBC:  MOVWF  x96
07EBE:  MOVLW  00
07EC0:  ADDWFC x99,W
07EC2:  MOVWF  x97
....................                  DpHBlueRaw = tempvarint; 
07EC4:  MOVFF  797,2C3
07EC8:  MOVFF  796,2C2
07ECC:  MOVLB  0
....................             }  
....................         //WHITE 
....................             if ((rec_buffer[35] != 0xFF) && (rec_buffer[36] != 0xFF)) 
07ECE:  INCFSZ x88,W
07ED0:  BRA    7ED4
07ED2:  BRA    7F02
07ED4:  INCFSZ x89,W
07ED6:  BRA    7EDA
07ED8:  BRA    7F02
....................             { 
....................                  tempvarint = rec_buffer[35]; 
07EDA:  MOVLB  7
07EDC:  CLRF   x97
07EDE:  MOVFF  88,796
....................                  tempvarint = tempvarint*256 + rec_buffer[36]; 
07EE2:  MOVFF  796,799
07EE6:  CLRF   x98
07EE8:  MOVLB  0
07EEA:  MOVF   x89,W
07EEC:  MOVLB  7
07EEE:  ADDWF  x98,W
07EF0:  MOVWF  x96
07EF2:  MOVLW  00
07EF4:  ADDWFC x99,W
07EF6:  MOVWF  x97
....................                 DpHWhiteRaw = tempvarint; 
07EF8:  MOVFF  797,2C5
07EFC:  MOVFF  796,2C4
07F00:  MOVLB  0
....................             }            
07F02:  RETURN 0
....................          
....................          
....................         }     
....................          
....................      
....................      
.................... //****************************************************************************** 
.................... // Created November 24, 2016 
.................... // Calibrations Data is sent to the remote unit.  Another routine call this routine. 
.................... // Data input: 
.................... // int DeviceSelected  -- this is the IO port 
.................... // int VariableIDNumber  -- this is the same on the receiving device.  This is defined here 
.................... // int Variable Length 
.................... // pointer to the Variable  -- this is used to send the data to the remote device.  Characters are not sent to the remote device, but data 
.................... // Returned data: 
.................... // A 0 is returned if all is well.  A 1 is returned if it did not hear it. 
.................... // Each calibration number is sent with an address and pointer.  There is no dump of multi cal numbers.   
.................... //******************************************************************************* 
.................... int sendConfigData(int deviceaddress, int8 VarIDNumber)  
.................... { 
....................        int x; 
....................        unsigned int8 *data; 
....................        unsigned char length; 
....................  
....................     //  Selection of 0  internal Digital DO and NH4 sensor 
....................     //  Selection of 1  Top RJ45 connector 
....................     //  Selection of 2  Bottom RJ45 connector     
....................     //  Selection of 3  no connection 
....................             selectsensor(deviceaddress);  // this sets the SCL to the right I2C device. 
*
085FA:  MOVFF  770,7B4
085FE:  CALL   3608
....................   
....................              
....................     	    i2c_start(PH_LIGHT); 
08602:  BSF    F93.0
08604:  MOVLW  50
08606:  MOVWF  00
08608:  DECFSZ 00,F
0860A:  BRA    8608
0860C:  BSF    F93.1
0860E:  MOVLW  51
08610:  MOVWF  00
08612:  DECFSZ 00,F
08614:  BRA    8612
08616:  BCF    F8A.0
08618:  BCF    F93.0
0861A:  MOVLW  50
0861C:  MOVWF  00
0861E:  DECFSZ 00,F
08620:  BRA    861E
08622:  BCF    F8A.1
08624:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0xa0);  //Move the address number left on and add a zero.  This is the command with address to write data to the address pointer 
08626:  MOVLW  A0
08628:  MOVLB  7
0862A:  MOVWF  xB4
0862C:  MOVLB  0
0862E:  CALL   364C
.................... 			i2c_write(PH_LIGHT,VarIDNumber);  //This is the locations of the first buffer to address 
08632:  MOVFF  771,7B4
08636:  CALL   364C
....................             length = sizeof(sysInput.nh4pt1cal1of3); 
0863A:  MOVLW  02
0863C:  MOVLB  7
0863E:  MOVWF  x75
....................             data = &sysInput.nh4pt1cal1of3; 
08640:  MOVWF  x74
08642:  MOVLW  3F
08644:  MOVWF  x73
....................             while (length--) { 
08646:  MOVF   x75,W
08648:  DECF   x75,F
0864A:  XORLW  00
0864C:  BZ    866E
....................                i2c_write(PH_LIGHT, *data++); 
0864E:  MOVFF  774,03
08652:  MOVF   x73,W
08654:  INCF   x73,F
08656:  BTFSC  FD8.2
08658:  INCF   x74,F
0865A:  MOVWF  FE9
0865C:  MOVFF  03,FEA
08660:  MOVFF  FEF,7B4
08664:  MOVLB  0
08666:  CALL   364C
0866A:  MOVLB  7
0866C:  BRA    8646
....................                 }  
....................             length = sizeof(sysInput.nh4pt1cal2of3); 
0866E:  MOVLW  02
08670:  MOVWF  x75
....................             data = &sysInput.nh4pt1cal2of3; 
08672:  MOVWF  x74
08674:  MOVLW  41
08676:  MOVWF  x73
....................             while (length--) { 
08678:  MOVF   x75,W
0867A:  DECF   x75,F
0867C:  XORLW  00
0867E:  BZ    86A0
....................                i2c_write(PH_LIGHT, *data++); 
08680:  MOVFF  774,03
08684:  MOVF   x73,W
08686:  INCF   x73,F
08688:  BTFSC  FD8.2
0868A:  INCF   x74,F
0868C:  MOVWF  FE9
0868E:  MOVFF  03,FEA
08692:  MOVFF  FEF,7B4
08696:  MOVLB  0
08698:  CALL   364C
0869C:  MOVLB  7
0869E:  BRA    8678
....................                 }  
....................             length = sizeof(sysInput.nh4pt1cal3of3); 
086A0:  MOVLW  02
086A2:  MOVWF  x75
....................             data = &sysInput.nh4pt1cal3of3; 
086A4:  MOVWF  x74
086A6:  MOVLW  43
086A8:  MOVWF  x73
....................             while (length--) { 
086AA:  MOVF   x75,W
086AC:  DECF   x75,F
086AE:  XORLW  00
086B0:  BZ    86D2
....................                i2c_write(PH_LIGHT, *data++); 
086B2:  MOVFF  774,03
086B6:  MOVF   x73,W
086B8:  INCF   x73,F
086BA:  BTFSC  FD8.2
086BC:  INCF   x74,F
086BE:  MOVWF  FE9
086C0:  MOVFF  03,FEA
086C4:  MOVFF  FEF,7B4
086C8:  MOVLB  0
086CA:  CALL   364C
086CE:  MOVLB  7
086D0:  BRA    86AA
....................                 }  
....................             length = sizeof(sysInput.nh4pt2cal1of3); 
086D2:  MOVLW  02
086D4:  MOVWF  x75
....................             data = &sysInput.nh4pt2cal1of3; 
086D6:  MOVWF  x74
086D8:  MOVLW  45
086DA:  MOVWF  x73
....................             while (length--) { 
086DC:  MOVF   x75,W
086DE:  DECF   x75,F
086E0:  XORLW  00
086E2:  BZ    8704
....................                i2c_write(PH_LIGHT, *data++); 
086E4:  MOVFF  774,03
086E8:  MOVF   x73,W
086EA:  INCF   x73,F
086EC:  BTFSC  FD8.2
086EE:  INCF   x74,F
086F0:  MOVWF  FE9
086F2:  MOVFF  03,FEA
086F6:  MOVFF  FEF,7B4
086FA:  MOVLB  0
086FC:  CALL   364C
08700:  MOVLB  7
08702:  BRA    86DC
....................                 }  
....................             length = sizeof(sysInput.nh4pt2cal2of3); 
08704:  MOVLW  02
08706:  MOVWF  x75
....................             data = &sysInput.nh4pt2cal2of3; 
08708:  MOVWF  x74
0870A:  MOVLW  47
0870C:  MOVWF  x73
....................             while (length--) { 
0870E:  MOVF   x75,W
08710:  DECF   x75,F
08712:  XORLW  00
08714:  BZ    8736
....................                i2c_write(PH_LIGHT, *data++); 
08716:  MOVFF  774,03
0871A:  MOVF   x73,W
0871C:  INCF   x73,F
0871E:  BTFSC  FD8.2
08720:  INCF   x74,F
08722:  MOVWF  FE9
08724:  MOVFF  03,FEA
08728:  MOVFF  FEF,7B4
0872C:  MOVLB  0
0872E:  CALL   364C
08732:  MOVLB  7
08734:  BRA    870E
....................                 }      
....................             length = sizeof(sysInput.nh4pt2cal3of3); 
08736:  MOVLW  02
08738:  MOVWF  x75
....................             data = &sysInput.nh4pt2cal3of3; 
0873A:  MOVWF  x74
0873C:  MOVLW  49
0873E:  MOVWF  x73
....................             while (length--) { 
08740:  MOVF   x75,W
08742:  DECF   x75,F
08744:  XORLW  00
08746:  BZ    8768
....................                i2c_write(PH_LIGHT, *data++); 
08748:  MOVFF  774,03
0874C:  MOVF   x73,W
0874E:  INCF   x73,F
08750:  BTFSC  FD8.2
08752:  INCF   x74,F
08754:  MOVWF  FE9
08756:  MOVFF  03,FEA
0875A:  MOVFF  FEF,7B4
0875E:  MOVLB  0
08760:  CALL   364C
08764:  MOVLB  7
08766:  BRA    8740
....................                 }  
....................             length = sizeof(sysInput.nh4pt3cal1of3); 
08768:  MOVLW  02
0876A:  MOVWF  x75
....................             data = &sysInput.nh4pt3cal1of3; 
0876C:  MOVWF  x74
0876E:  MOVLW  4B
08770:  MOVWF  x73
....................             while (length--) { 
08772:  MOVF   x75,W
08774:  DECF   x75,F
08776:  XORLW  00
08778:  BZ    879A
....................                i2c_write(PH_LIGHT, *data++); 
0877A:  MOVFF  774,03
0877E:  MOVF   x73,W
08780:  INCF   x73,F
08782:  BTFSC  FD8.2
08784:  INCF   x74,F
08786:  MOVWF  FE9
08788:  MOVFF  03,FEA
0878C:  MOVFF  FEF,7B4
08790:  MOVLB  0
08792:  CALL   364C
08796:  MOVLB  7
08798:  BRA    8772
....................                 }  
....................             length = sizeof(sysInput.nh4pt3cal2of3); 
0879A:  MOVLW  02
0879C:  MOVWF  x75
....................             data = &sysInput.nh4pt3cal2of3; 
0879E:  MOVWF  x74
087A0:  MOVLW  4D
087A2:  MOVWF  x73
....................             while (length--) { 
087A4:  MOVF   x75,W
087A6:  DECF   x75,F
087A8:  XORLW  00
087AA:  BZ    87CC
....................                i2c_write(PH_LIGHT, *data++); 
087AC:  MOVFF  774,03
087B0:  MOVF   x73,W
087B2:  INCF   x73,F
087B4:  BTFSC  FD8.2
087B6:  INCF   x74,F
087B8:  MOVWF  FE9
087BA:  MOVFF  03,FEA
087BE:  MOVFF  FEF,7B4
087C2:  MOVLB  0
087C4:  CALL   364C
087C8:  MOVLB  7
087CA:  BRA    87A4
....................                 }      
....................             length = sizeof(sysInput.nh4pt3cal3of3); 
087CC:  MOVLW  02
087CE:  MOVWF  x75
....................             data = &sysInput.nh4pt3cal1of3; 
087D0:  MOVWF  x74
087D2:  MOVLW  4B
087D4:  MOVWF  x73
....................             while (length--) { 
087D6:  MOVF   x75,W
087D8:  DECF   x75,F
087DA:  XORLW  00
087DC:  BZ    87FE
....................                i2c_write(PH_LIGHT, *data++); 
087DE:  MOVFF  774,03
087E2:  MOVF   x73,W
087E4:  INCF   x73,F
087E6:  BTFSC  FD8.2
087E8:  INCF   x74,F
087EA:  MOVWF  FE9
087EC:  MOVFF  03,FEA
087F0:  MOVFF  FEF,7B4
087F4:  MOVLB  0
087F6:  CALL   364C
087FA:  MOVLB  7
087FC:  BRA    87D6
....................                 }  
....................              
....................             
....................              
....................             length = sizeof(sysInput.nh4pt1returnednumber); 
087FE:  MOVLW  04
08800:  MOVWF  x75
....................             data = &sysInput.nh4pt1returnednumber; 
08802:  MOVLW  02
08804:  MOVWF  x74
08806:  MOVLW  51
08808:  MOVWF  x73
....................             while (length--) { 
0880A:  MOVF   x75,W
0880C:  DECF   x75,F
0880E:  XORLW  00
08810:  BZ    8832
....................                i2c_write(PH_LIGHT, *data++); 
08812:  MOVFF  774,03
08816:  MOVF   x73,W
08818:  INCF   x73,F
0881A:  BTFSC  FD8.2
0881C:  INCF   x74,F
0881E:  MOVWF  FE9
08820:  MOVFF  03,FEA
08824:  MOVFF  FEF,7B4
08828:  MOVLB  0
0882A:  CALL   364C
0882E:  MOVLB  7
08830:  BRA    880A
....................                 }  
....................             length = sizeof(sysInput.nh4pt2returnednumber); 
08832:  MOVLW  04
08834:  MOVWF  x75
....................             data = &sysInput.nh4pt2returnednumber; 
08836:  MOVLW  02
08838:  MOVWF  x74
0883A:  MOVLW  55
0883C:  MOVWF  x73
....................             while (length--) { 
0883E:  MOVF   x75,W
08840:  DECF   x75,F
08842:  XORLW  00
08844:  BZ    8866
....................                i2c_write(PH_LIGHT, *data++); 
08846:  MOVFF  774,03
0884A:  MOVF   x73,W
0884C:  INCF   x73,F
0884E:  BTFSC  FD8.2
08850:  INCF   x74,F
08852:  MOVWF  FE9
08854:  MOVFF  03,FEA
08858:  MOVFF  FEF,7B4
0885C:  MOVLB  0
0885E:  CALL   364C
08862:  MOVLB  7
08864:  BRA    883E
....................                 }  
....................             length = sizeof(sysInput.nh4pt3returnednumber); 
08866:  MOVLW  04
08868:  MOVWF  x75
....................             data = &sysInput.nh4pt3returnednumber; 
0886A:  MOVLW  02
0886C:  MOVWF  x74
0886E:  MOVLW  59
08870:  MOVWF  x73
....................             while (length--) { 
08872:  MOVF   x75,W
08874:  DECF   x75,F
08876:  XORLW  00
08878:  BZ    889A
....................                i2c_write(PH_LIGHT, *data++); 
0887A:  MOVFF  774,03
0887E:  MOVF   x73,W
08880:  INCF   x73,F
08882:  BTFSC  FD8.2
08884:  INCF   x74,F
08886:  MOVWF  FE9
08888:  MOVFF  03,FEA
0888C:  MOVFF  FEF,7B4
08890:  MOVLB  0
08892:  CALL   364C
08896:  MOVLB  7
08898:  BRA    8872
....................                 }  
....................              
....................              
....................              
....................             // this is sending all of the DO stuff 
....................              
....................             length = sizeof(sysInput.DOpt1cal1of3); 
0889A:  MOVLW  02
0889C:  MOVWF  x75
....................             data = &sysInput.DOpt1cal1of3; 
0889E:  MOVWF  x74
088A0:  MOVLW  5D
088A2:  MOVWF  x73
....................             while (length--) { 
088A4:  MOVF   x75,W
088A6:  DECF   x75,F
088A8:  XORLW  00
088AA:  BZ    88CC
....................                i2c_write(PH_LIGHT, *data++); 
088AC:  MOVFF  774,03
088B0:  MOVF   x73,W
088B2:  INCF   x73,F
088B4:  BTFSC  FD8.2
088B6:  INCF   x74,F
088B8:  MOVWF  FE9
088BA:  MOVFF  03,FEA
088BE:  MOVFF  FEF,7B4
088C2:  MOVLB  0
088C4:  CALL   364C
088C8:  MOVLB  7
088CA:  BRA    88A4
....................                 }  
....................             length = sizeof(sysInput.DOpt1cal2of3); 
088CC:  MOVLW  02
088CE:  MOVWF  x75
....................             data = &sysInput.DOpt1cal2of3; 
088D0:  MOVWF  x74
088D2:  MOVLW  5F
088D4:  MOVWF  x73
....................             while (length--) { 
088D6:  MOVF   x75,W
088D8:  DECF   x75,F
088DA:  XORLW  00
088DC:  BZ    88FE
....................                i2c_write(PH_LIGHT, *data++); 
088DE:  MOVFF  774,03
088E2:  MOVF   x73,W
088E4:  INCF   x73,F
088E6:  BTFSC  FD8.2
088E8:  INCF   x74,F
088EA:  MOVWF  FE9
088EC:  MOVFF  03,FEA
088F0:  MOVFF  FEF,7B4
088F4:  MOVLB  0
088F6:  CALL   364C
088FA:  MOVLB  7
088FC:  BRA    88D6
....................                 }  
....................             length = sizeof(sysInput.DOpt1cal3of3); 
088FE:  MOVLW  02
08900:  MOVWF  x75
....................             data = &sysInput.DOpt1cal3of3; 
08902:  MOVWF  x74
08904:  MOVLW  61
08906:  MOVWF  x73
....................             while (length--) { 
08908:  MOVF   x75,W
0890A:  DECF   x75,F
0890C:  XORLW  00
0890E:  BZ    8930
....................                i2c_write(PH_LIGHT, *data++); 
08910:  MOVFF  774,03
08914:  MOVF   x73,W
08916:  INCF   x73,F
08918:  BTFSC  FD8.2
0891A:  INCF   x74,F
0891C:  MOVWF  FE9
0891E:  MOVFF  03,FEA
08922:  MOVFF  FEF,7B4
08926:  MOVLB  0
08928:  CALL   364C
0892C:  MOVLB  7
0892E:  BRA    8908
....................                 }  
....................             length = sizeof(sysInput.DOpt2cal1of3); 
08930:  MOVLW  02
08932:  MOVWF  x75
....................             data = &sysInput.DOpt2cal2of3; 
08934:  MOVWF  x74
08936:  MOVLW  65
08938:  MOVWF  x73
....................             while (length--) { 
0893A:  MOVF   x75,W
0893C:  DECF   x75,F
0893E:  XORLW  00
08940:  BZ    8962
....................                i2c_write(PH_LIGHT, *data++); 
08942:  MOVFF  774,03
08946:  MOVF   x73,W
08948:  INCF   x73,F
0894A:  BTFSC  FD8.2
0894C:  INCF   x74,F
0894E:  MOVWF  FE9
08950:  MOVFF  03,FEA
08954:  MOVFF  FEF,7B4
08958:  MOVLB  0
0895A:  CALL   364C
0895E:  MOVLB  7
08960:  BRA    893A
....................                 }  
....................             length = sizeof(sysInput.DOpt2cal2of3); 
08962:  MOVLW  02
08964:  MOVWF  x75
....................             data = &sysInput.DOpt2cal2of3; 
08966:  MOVWF  x74
08968:  MOVLW  65
0896A:  MOVWF  x73
....................             while (length--) { 
0896C:  MOVF   x75,W
0896E:  DECF   x75,F
08970:  XORLW  00
08972:  BZ    8994
....................                i2c_write(PH_LIGHT, *data++); 
08974:  MOVFF  774,03
08978:  MOVF   x73,W
0897A:  INCF   x73,F
0897C:  BTFSC  FD8.2
0897E:  INCF   x74,F
08980:  MOVWF  FE9
08982:  MOVFF  03,FEA
08986:  MOVFF  FEF,7B4
0898A:  MOVLB  0
0898C:  CALL   364C
08990:  MOVLB  7
08992:  BRA    896C
....................                 }      
....................             length = sizeof(sysInput.DOpt2cal3of3); 
08994:  MOVLW  02
08996:  MOVWF  x75
....................             data = &sysInput.DOpt2cal3of3; 
08998:  MOVWF  x74
0899A:  MOVLW  67
0899C:  MOVWF  x73
....................             while (length--) { 
0899E:  MOVF   x75,W
089A0:  DECF   x75,F
089A2:  XORLW  00
089A4:  BZ    89C6
....................                i2c_write(PH_LIGHT, *data++); 
089A6:  MOVFF  774,03
089AA:  MOVF   x73,W
089AC:  INCF   x73,F
089AE:  BTFSC  FD8.2
089B0:  INCF   x74,F
089B2:  MOVWF  FE9
089B4:  MOVFF  03,FEA
089B8:  MOVFF  FEF,7B4
089BC:  MOVLB  0
089BE:  CALL   364C
089C2:  MOVLB  7
089C4:  BRA    899E
....................                 }  
....................             length = sizeof(sysInput.DOpt3cal1of3); 
089C6:  MOVLW  02
089C8:  MOVWF  x75
....................             data = &sysInput.DOpt3cal1of3; 
089CA:  MOVWF  x74
089CC:  MOVLW  69
089CE:  MOVWF  x73
....................             while (length--) { 
089D0:  MOVF   x75,W
089D2:  DECF   x75,F
089D4:  XORLW  00
089D6:  BZ    89F8
....................                i2c_write(PH_LIGHT, *data++); 
089D8:  MOVFF  774,03
089DC:  MOVF   x73,W
089DE:  INCF   x73,F
089E0:  BTFSC  FD8.2
089E2:  INCF   x74,F
089E4:  MOVWF  FE9
089E6:  MOVFF  03,FEA
089EA:  MOVFF  FEF,7B4
089EE:  MOVLB  0
089F0:  CALL   364C
089F4:  MOVLB  7
089F6:  BRA    89D0
....................                 }  
....................             length = sizeof(sysInput.DOpt3cal2of3); 
089F8:  MOVLW  02
089FA:  MOVWF  x75
....................             data = &sysInput.DOpt3cal2of3; 
089FC:  MOVWF  x74
089FE:  MOVLW  6B
08A00:  MOVWF  x73
....................             while (length--) { 
08A02:  MOVF   x75,W
08A04:  DECF   x75,F
08A06:  XORLW  00
08A08:  BZ    8A2A
....................                i2c_write(PH_LIGHT, *data++); 
08A0A:  MOVFF  774,03
08A0E:  MOVF   x73,W
08A10:  INCF   x73,F
08A12:  BTFSC  FD8.2
08A14:  INCF   x74,F
08A16:  MOVWF  FE9
08A18:  MOVFF  03,FEA
08A1C:  MOVFF  FEF,7B4
08A20:  MOVLB  0
08A22:  CALL   364C
08A26:  MOVLB  7
08A28:  BRA    8A02
....................                 }      
....................             length = sizeof(sysInput.DOpt3cal3of3); 
08A2A:  MOVLW  02
08A2C:  MOVWF  x75
....................             data = &sysInput.DOpt3cal3of3; 
08A2E:  MOVWF  x74
08A30:  MOVLW  6D
08A32:  MOVWF  x73
....................             while (length--) { 
08A34:  MOVF   x75,W
08A36:  DECF   x75,F
08A38:  XORLW  00
08A3A:  BZ    8A5C
....................                i2c_write(PH_LIGHT, *data++); 
08A3C:  MOVFF  774,03
08A40:  MOVF   x73,W
08A42:  INCF   x73,F
08A44:  BTFSC  FD8.2
08A46:  INCF   x74,F
08A48:  MOVWF  FE9
08A4A:  MOVFF  03,FEA
08A4E:  MOVFF  FEF,7B4
08A52:  MOVLB  0
08A54:  CALL   364C
08A58:  MOVLB  7
08A5A:  BRA    8A34
....................                 }  
....................              
....................             
....................              
....................             length = sizeof(sysInput.DOpt1returnednumber); 
08A5C:  MOVLW  04
08A5E:  MOVWF  x75
....................             data = &sysInput.nh4pt1returnednumber; 
08A60:  MOVLW  02
08A62:  MOVWF  x74
08A64:  MOVLW  51
08A66:  MOVWF  x73
....................             while (length--) { 
08A68:  MOVF   x75,W
08A6A:  DECF   x75,F
08A6C:  XORLW  00
08A6E:  BZ    8A90
....................                i2c_write(PH_LIGHT, *data++); 
08A70:  MOVFF  774,03
08A74:  MOVF   x73,W
08A76:  INCF   x73,F
08A78:  BTFSC  FD8.2
08A7A:  INCF   x74,F
08A7C:  MOVWF  FE9
08A7E:  MOVFF  03,FEA
08A82:  MOVFF  FEF,7B4
08A86:  MOVLB  0
08A88:  CALL   364C
08A8C:  MOVLB  7
08A8E:  BRA    8A68
....................                 }  
....................             length = sizeof(sysInput.DOpt2returnednumber); 
08A90:  MOVLW  04
08A92:  MOVWF  x75
....................             data = &sysInput.nh4pt2returnednumber; 
08A94:  MOVLW  02
08A96:  MOVWF  x74
08A98:  MOVLW  55
08A9A:  MOVWF  x73
....................             while (length--) { 
08A9C:  MOVF   x75,W
08A9E:  DECF   x75,F
08AA0:  XORLW  00
08AA2:  BZ    8AC4
....................                i2c_write(PH_LIGHT, *data++); 
08AA4:  MOVFF  774,03
08AA8:  MOVF   x73,W
08AAA:  INCF   x73,F
08AAC:  BTFSC  FD8.2
08AAE:  INCF   x74,F
08AB0:  MOVWF  FE9
08AB2:  MOVFF  03,FEA
08AB6:  MOVFF  FEF,7B4
08ABA:  MOVLB  0
08ABC:  CALL   364C
08AC0:  MOVLB  7
08AC2:  BRA    8A9C
....................                 }  
....................             length = sizeof(sysInput.DOpt3returnednumber); 
08AC4:  MOVLW  04
08AC6:  MOVWF  x75
....................             data = &sysInput.nh4pt3returnednumber; 
08AC8:  MOVLW  02
08ACA:  MOVWF  x74
08ACC:  MOVLW  59
08ACE:  MOVWF  x73
....................             while (length--) { 
08AD0:  MOVF   x75,W
08AD2:  DECF   x75,F
08AD4:  XORLW  00
08AD6:  BZ    8AF8
....................                i2c_write(PH_LIGHT, *data++); 
08AD8:  MOVFF  774,03
08ADC:  MOVF   x73,W
08ADE:  INCF   x73,F
08AE0:  BTFSC  FD8.2
08AE2:  INCF   x74,F
08AE4:  MOVWF  FE9
08AE6:  MOVFF  03,FEA
08AEA:  MOVFF  FEF,7B4
08AEE:  MOVLB  0
08AF0:  CALL   364C
08AF4:  MOVLB  7
08AF6:  BRA    8AD0
....................                 }         
....................          
....................              
....................             // This is the therimister stuff 
....................              
....................              
....................             length = sizeof(sysInput.Thermisterpt1cal1of3); 
08AF8:  MOVLW  02
08AFA:  MOVWF  x75
....................             data = &sysInput.Thermisterpt1cal1of3; 
08AFC:  MOVWF  x74
08AFE:  MOVLW  7B
08B00:  MOVWF  x73
....................             while (length--) { 
08B02:  MOVF   x75,W
08B04:  DECF   x75,F
08B06:  XORLW  00
08B08:  BZ    8B2A
....................                i2c_write(PH_LIGHT, *data++); 
08B0A:  MOVFF  774,03
08B0E:  MOVF   x73,W
08B10:  INCF   x73,F
08B12:  BTFSC  FD8.2
08B14:  INCF   x74,F
08B16:  MOVWF  FE9
08B18:  MOVFF  03,FEA
08B1C:  MOVFF  FEF,7B4
08B20:  MOVLB  0
08B22:  CALL   364C
08B26:  MOVLB  7
08B28:  BRA    8B02
....................                 }  
....................             length = sizeof(sysInput.Thermisterpt1cal2of3); 
08B2A:  MOVLW  02
08B2C:  MOVWF  x75
....................             data = &sysInput.Thermisterpt1cal2of3; 
08B2E:  MOVWF  x74
08B30:  MOVLW  7D
08B32:  MOVWF  x73
....................             while (length--) { 
08B34:  MOVF   x75,W
08B36:  DECF   x75,F
08B38:  XORLW  00
08B3A:  BZ    8B5C
....................                i2c_write(PH_LIGHT, *data++); 
08B3C:  MOVFF  774,03
08B40:  MOVF   x73,W
08B42:  INCF   x73,F
08B44:  BTFSC  FD8.2
08B46:  INCF   x74,F
08B48:  MOVWF  FE9
08B4A:  MOVFF  03,FEA
08B4E:  MOVFF  FEF,7B4
08B52:  MOVLB  0
08B54:  CALL   364C
08B58:  MOVLB  7
08B5A:  BRA    8B34
....................                 }      
....................             length = sizeof(sysInput.Thermisterpt1cal3of3); 
08B5C:  MOVLW  02
08B5E:  MOVWF  x75
....................             data = &sysInput.Thermisterpt1cal3of3; 
08B60:  MOVWF  x74
08B62:  MOVLW  7F
08B64:  MOVWF  x73
....................             while (length--) { 
08B66:  MOVF   x75,W
08B68:  DECF   x75,F
08B6A:  XORLW  00
08B6C:  BZ    8B8E
....................                i2c_write(PH_LIGHT, *data++); 
08B6E:  MOVFF  774,03
08B72:  MOVF   x73,W
08B74:  INCF   x73,F
08B76:  BTFSC  FD8.2
08B78:  INCF   x74,F
08B7A:  MOVWF  FE9
08B7C:  MOVFF  03,FEA
08B80:  MOVFF  FEF,7B4
08B84:  MOVLB  0
08B86:  CALL   364C
08B8A:  MOVLB  7
08B8C:  BRA    8B66
....................                 }  
....................              
....................              
....................                length = sizeof(sysInput.Thermisterpt1returnednumber); 
08B8E:  MOVLW  04
08B90:  MOVWF  x75
....................             data = &sysInput.Thermisterpt1returnednumber; 
08B92:  MOVLW  02
08B94:  MOVWF  x74
08B96:  MOVLW  81
08B98:  MOVWF  x73
....................             while (length--) { 
08B9A:  MOVF   x75,W
08B9C:  DECF   x75,F
08B9E:  XORLW  00
08BA0:  BZ    8BC2
....................                i2c_write(PH_LIGHT, *data++); 
08BA2:  MOVFF  774,03
08BA6:  MOVF   x73,W
08BA8:  INCF   x73,F
08BAA:  BTFSC  FD8.2
08BAC:  INCF   x74,F
08BAE:  MOVWF  FE9
08BB0:  MOVFF  03,FEA
08BB4:  MOVFF  FEF,7B4
08BB8:  MOVLB  0
08BBA:  CALL   364C
08BBE:  MOVLB  7
08BC0:  BRA    8B9A
....................                 }  
....................             length = sizeof(sysInput.Thermisterpt2returnednumber); 
08BC2:  MOVLW  04
08BC4:  MOVWF  x75
....................             data = &sysInput.Thermisterpt2returnednumber; 
08BC6:  MOVLW  02
08BC8:  MOVWF  x74
08BCA:  MOVLW  85
08BCC:  MOVWF  x73
....................             while (length--) { 
08BCE:  MOVF   x75,W
08BD0:  DECF   x75,F
08BD2:  XORLW  00
08BD4:  BZ    8BF6
....................                i2c_write(PH_LIGHT, *data++); 
08BD6:  MOVFF  774,03
08BDA:  MOVF   x73,W
08BDC:  INCF   x73,F
08BDE:  BTFSC  FD8.2
08BE0:  INCF   x74,F
08BE2:  MOVWF  FE9
08BE4:  MOVFF  03,FEA
08BE8:  MOVFF  FEF,7B4
08BEC:  MOVLB  0
08BEE:  CALL   364C
08BF2:  MOVLB  7
08BF4:  BRA    8BCE
....................                 }  
....................             length = sizeof(sysInput.Thermisterpt3returnednumber); 
08BF6:  MOVLW  04
08BF8:  MOVWF  x75
....................             data = &sysInput.Thermisterpt3returnednumber; 
08BFA:  MOVLW  02
08BFC:  MOVWF  x74
08BFE:  MOVLW  89
08C00:  MOVWF  x73
....................             while (length--) { 
08C02:  MOVF   x75,W
08C04:  DECF   x75,F
08C06:  XORLW  00
08C08:  BZ    8C2A
....................                i2c_write(PH_LIGHT, *data++); 
08C0A:  MOVFF  774,03
08C0E:  MOVF   x73,W
08C10:  INCF   x73,F
08C12:  BTFSC  FD8.2
08C14:  INCF   x74,F
08C16:  MOVWF  FE9
08C18:  MOVFF  03,FEA
08C1C:  MOVFF  FEF,7B4
08C20:  MOVLB  0
08C22:  CALL   364C
08C26:  MOVLB  7
08C28:  BRA    8C02
....................                 }           
....................              
....................       //  this is where additional calibrations are added.  It has to be before the stop and the last I2C write to trigger the receiving unit for saving data. 
.................... 			i2c_stop(PH_LIGHT); 
08C2A:  BCF    F93.0
08C2C:  NOP   
08C2E:  BSF    F93.1
08C30:  BTFSS  F81.1
08C32:  BRA    8C30
08C34:  MOVLW  50
08C36:  MOVWF  00
08C38:  DECFSZ 00,F
08C3A:  BRA    8C38
08C3C:  BRA    8C3E
08C3E:  NOP   
08C40:  BSF    F93.0
08C42:  MOVLW  50
08C44:  MOVWF  00
08C46:  DECFSZ 00,F
08C48:  BRA    8C46
....................              
....................     	    i2c_start(PH_LIGHT); 
08C4A:  BSF    F93.0
08C4C:  MOVLW  50
08C4E:  MOVWF  00
08C50:  DECFSZ 00,F
08C52:  BRA    8C50
08C54:  BSF    F93.1
08C56:  MOVLW  51
08C58:  MOVWF  00
08C5A:  DECFSZ 00,F
08C5C:  BRA    8C5A
08C5E:  BCF    F8A.0
08C60:  BCF    F93.0
08C62:  MOVLW  50
08C64:  MOVWF  00
08C66:  DECFSZ 00,F
08C68:  BRA    8C66
08C6A:  BCF    F8A.1
08C6C:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0xa0);  //Move the address number left on and add a zero.  This is the command with address to write data to the address pointer 
08C6E:  MOVLW  A0
08C70:  MOVWF  xB4
08C72:  MOVLB  0
08C74:  CALL   364C
.................... 			i2c_write(PH_LIGHT,0x02);  //This is the locations of the first buffer to address            
08C78:  MOVLW  02
08C7A:  MOVLB  7
08C7C:  MOVWF  xB4
08C7E:  MOVLB  0
08C80:  CALL   364C
.................... 			i2c_write(PH_LIGHT,0x01);  //Set this location (0x02) to 1 to tell the receiver that all calibrations are uploaded and ready for EEPROMing.            
08C84:  MOVLW  01
08C86:  MOVLB  7
08C88:  MOVWF  xB4
08C8A:  MOVLB  0
08C8C:  CALL   364C
....................  			i2c_stop(PH_LIGHT);            
08C90:  BCF    F93.0
08C92:  NOP   
08C94:  BSF    F93.1
08C96:  BTFSS  F81.1
08C98:  BRA    8C96
08C9A:  MOVLW  50
08C9C:  MOVWF  00
08C9E:  DECFSZ 00,F
08CA0:  BRA    8C9E
08CA2:  BRA    8CA4
08CA4:  NOP   
08CA6:  BSF    F93.0
08CA8:  MOVLW  50
08CAA:  MOVWF  00
08CAC:  DECFSZ 00,F
08CAE:  BRA    8CAC
....................              
....................      return(0);        
08CB0:  MOVLW  00
08CB2:  MOVWF  01
08CB4:  GOTO   9106 (RETURN)
.................... } 
....................      
....................     
....................          
....................  
.................... #include "G:\OsmobotLocalDisplay Via Bluetooth\BluetoothRoutines.c" 
....................  
.................... int8 parsebluetoothcommand(void); 
.................... int savelocalconfigurations(int16 selectitem); 
.................... int SaveConfiguration(void); 
.................... int debugnumber = 0;  //Added July 13, 2015.  It keeps the current state of the debug routine calls.  Default is zero; or not in debug/calibration mode. 
....................  
.................... int CurrentCommand; 
.................... char scr[64];  
.................... char SplitResult[30][11];  
.................... unsigned int8 CommandModeOrNot = 0;   //  this is used to echo characters back to the unit.   
.................... int passed = 0;  // this is the pass once through flag 
....................  
.................... #define VAR_NAMESFORSETTING 8     //Created July 22, 2015    This is the number of varaibles to be parsed for setting new values to. 
.................... #define BT_COMMAND_SIZE 11 
....................  
.................... unsigned char settingvariables[VAR_NAMESFORSETTING][BT_COMMAND_SIZE]= 
.................... { 
....................    "?",      //This is a BT HC-05 command response    Show all of the avaiable commands 
....................    "display",     //This turns on and off the toggle to display something on the VFD.   Added nov 22, 2016 
....................    "set",     //this is the returned address of a BT device 
....................    "default",     // this command sets the EEPROM to the default values for the calibrations and instrumenetations.  After a program, all of the eeproms are cleared 
....................    "showconfig",   // this displays all of the current values for configurations 
....................    "saveconfig",   // this saves the current calibration values in EEPROM 
....................    "update",       // this updates the remote unit with the current configurations 
....................    "rst"           // this restarts this unit.  not the remote 
.................... }; 
....................  
....................  
.................... #define BT_NUM_SUBCOMMANDS 34     //This needs to be updated to the next command when a command is added. 
....................  
....................  
.................... unsigned char bluetoothsecond[BT_NUM_SUBCOMMANDS][BT_COMMAND_SIZE]= 
.................... { 
....................    "pph",      //Option 1, position of the pH sensors.  It displays all of the light values. 
....................    "at",     //Show all data from all instruments 
....................    "do",      //   for DO 
....................    "ph",     // ph with bulb 
....................    "wd",  //Show the current water depth 
....................    "phbulb",   //Changed from -> This sets up the position for the DO light pipe.  This is changed to showing current reading of the ph bulb.  May 19, 2016 
....................    "clear",     ///Clears the selected display and sets everyuthing to zero 
....................    "lux",    //  this is the command used show the full command set for Bluetooth.  If this is not correct, it shows a "users" version.  Added Augest 17, 2015. 
....................    "ec",    //Returns constant readings from the ec measurement. 
....................    "co2",    // This starts the program to run the DO patch with decay 
....................    "wt",      // this displays the current water temperature 
....................    "par",     // this displays the current water temperature 
....................    "nh4",     // this displays the current ammonia in the water  Added Jan 19, 2016 
....................    "retnh41",   // 13  the return value of ammonia point 1  This is the low point for the analog nh4 probe 
....................    "retnh42",    // 14  the return value of ammonia point 2 
....................    "retnh43",   // 15  the return value of ammonia point 3  This is the high point for the analog nh4 probe 
....................    "nh4pt1",   // 16 this is the input calibrations for ammonia,  it is for variable  nh4pt1cal1of3   This is the low point for the analog nh4 probe 
....................    "nh4pt2",   // 17 this is the input calibrations for ammonia,  it is for variable  nh4pt1cal2of3  This is the high point for the analog nh4 probe 
....................    "nh4pt3",   // 18  this is the input calibrations for ammonia,  it is for variable  nh4pt1cal3of3 
....................    "nh4pt4",   // 19  this is the input calibrations for ammonia,  it is for variable  nh4pt2cal1of3 
....................    "nh4pt5",   // 20  this is the input calibrations for ammonia,  it is for variable  nh4pt2cal2of3 
....................    "nh4pt6",   // 21  this is the input calibrations for ammonia,  it is for variable  nh4pt2cal3of3 
....................    "nh4pt7",   // 22 this is the input calibrations for ammonia,  it is for variable  nh4pt3cal1of3 
....................    "nh4pt8",   // 23 this is the input calibrations for ammonia,  it is for variable  nh4pt3cal2of3 
....................    "nh4pt9",    // 24 this is the input calibrations for ammonia,  it is for variable  nh4pt3cal3of3 
....................    "DOpt1",    // 25 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt2",    // 26 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt3",    // 27 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt4",    // 28 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt5",    // 29 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt6",    // 30 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt7",    // 31 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt8",    // 32 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
....................    "DOpt9"    // 33 this is the input calibrations for DO  it is for variable  DOpt1cal1of3 
.................... }; 
....................  
.................... /* 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
.................... float eccal1x; 
.................... float eccal2x; 
.................... float eccal3x; 
.................... float eccal1y; 
.................... float eccal2y; 
.................... float eccal3y; 
....................                  */ 
....................  
.................... //************************************************************************************************************ 
.................... // Created March 25, 2015 
.................... // This is a general parsing routine where it takes a sting and seperates it into sections with a delimiter and an end of sting. 
.................... //  The parameters going into this routine are as follows: 
.................... //  String as a pointer 
.................... //  delimiter 
.................... //  endofstring 
.................... // The output is in some array I have not figured out yet. 
.................... //  Each Item can not be more than 20 characters long 
.................... //************************************************************************************************************ 
.................... void split(char *EndOfLine) 
*
04F58:  MOVLW  20
04F5A:  MOVLB  7
04F5C:  MOVWF  x9B
.................... 	{ 
....................  
.................... int counter, row, letterlocation;   //This is the row for each item.  It is bumped up one when a delimieter is found.  letterlocation is the place where the cureent charater is saved. 
.................... char delimiter = ' '; 
.................... char  counter2,currentchar,endofchar, endoflinechar,junkcheck; 
.................... counter = 0;  //This is the start of the first location in the given string. 
04F5E:  CLRF   x98
.................... endoflinechar = EndOfLine[0]; 
04F60:  MOVFF  796,FE9
04F64:  MOVFF  797,FEA
04F68:  MOVFF  FEF,79F
....................  
.................... for (row = 0; row < 30; row++) 
04F6C:  CLRF   x99
04F6E:  MOVF   x99,W
04F70:  SUBLW  1D
04F72:  BTFSS  FD8.0
04F74:  BRA    505A
.................... 	{ 
.................... 	for (letterlocation=0; letterlocation < 30; letterlocation++) 
04F76:  CLRF   x9A
04F78:  MOVF   x9A,W
04F7A:  SUBLW  1D
04F7C:  BNC   503C
.................... 		{ 
.................... 		counter2 = delimiter; 
04F7E:  MOVFF  79B,79C
.................... 		currentchar = scr[counter]; 
04F82:  CLRF   03
04F84:  MOVF   x98,W
04F86:  ADDLW  C8
04F88:  MOVWF  FE9
04F8A:  MOVLW  02
04F8C:  ADDWFC 03,W
04F8E:  MOVWF  FEA
04F90:  MOVFF  FEF,79D
.................... 		junkcheck = scr[counter]; 
04F94:  CLRF   03
04F96:  MOVF   x98,W
04F98:  ADDLW  C8
04F9A:  MOVWF  FE9
04F9C:  MOVLW  02
04F9E:  ADDWFC 03,W
04FA0:  MOVWF  FEA
04FA2:  MOVFF  FEF,7A0
.................... 		if (currentchar != counter2) 
04FA6:  MOVF   x9C,W
04FA8:  SUBWF  x9D,W
04FAA:  BZ    5002
.................... 			{ 
....................             if (letterlocation < 11) 
04FAC:  MOVF   x9A,W
04FAE:  SUBLW  0A
04FB0:  BNC   5000
....................                { 
.................... 				SplitResult[row][letterlocation]=scr[counter]; 
04FB2:  CLRF   xB5
04FB4:  MOVFF  799,7B4
04FB8:  CLRF   xB7
04FBA:  MOVLW  0B
04FBC:  MOVWF  xB6
04FBE:  MOVLB  0
04FC0:  RCALL  4CFA
04FC2:  MOVFF  01,7A1
04FC6:  MOVLB  7
04FC8:  MOVF   x9A,W
04FCA:  ADDWF  01,W
04FCC:  MOVWF  01
04FCE:  MOVLW  00
04FD0:  ADDWFC 02,W
04FD2:  MOVWF  03
04FD4:  MOVF   01,W
04FD6:  ADDLW  08
04FD8:  MOVWF  01
04FDA:  MOVLW  03
04FDC:  ADDWFC 03,F
04FDE:  MOVFF  03,7A2
04FE2:  CLRF   03
04FE4:  MOVF   x98,W
04FE6:  ADDLW  C8
04FE8:  MOVWF  FE9
04FEA:  MOVLW  02
04FEC:  ADDWFC 03,W
04FEE:  MOVWF  FEA
04FF0:  MOVFF  FEF,7A3
04FF4:  MOVFF  7A2,FEA
04FF8:  MOVFF  01,FE9
04FFC:  MOVFF  7A3,FEF
....................                 } 
.................... 			} 
05000:  BRA    5036
.................... 			else 
.................... 			{ 
.................... 			SplitResult[row][letterlocation]=0x00; 
05002:  CLRF   xB5
05004:  MOVFF  799,7B4
05008:  CLRF   xB7
0500A:  MOVLW  0B
0500C:  MOVWF  xB6
0500E:  MOVLB  0
05010:  RCALL  4CFA
05012:  MOVFF  01,7A1
05016:  MOVLB  7
05018:  MOVF   x9A,W
0501A:  ADDWF  01,W
0501C:  MOVWF  01
0501E:  MOVLW  00
05020:  ADDWFC 02,W
05022:  MOVWF  03
05024:  MOVF   01,W
05026:  ADDLW  08
05028:  MOVWF  FE9
0502A:  MOVLW  03
0502C:  ADDWFC 03,W
0502E:  MOVWF  FEA
05030:  CLRF   FEF
.................... 			counter++; 
05032:  INCF   x98,F
.................... 			break; 
05034:  BRA    503C
.................... 			} 
.................... 		counter++; 
05036:  INCF   x98,F
05038:  INCF   x9A,F
0503A:  BRA    4F78
.................... 		} 
.................... 	endofchar = scr[counter]; 
0503C:  CLRF   03
0503E:  MOVF   x98,W
05040:  ADDLW  C8
05042:  MOVWF  FE9
05044:  MOVLW  02
05046:  ADDWFC 03,W
05048:  MOVWF  FEA
0504A:  MOVFF  FEF,79E
.................... 	if (endofchar == endoflinechar) 
0504E:  MOVF   x9F,W
05050:  SUBWF  x9E,W
05052:  BNZ   5056
.................... 		{ 
.................... 		break; 
05054:  BRA    505A
.................... 		} 
05056:  INCF   x99,F
05058:  BRA    4F6E
.................... 	} 
0505A:  MOVLB  0
0505C:  GOTO   7826 (RETURN)
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Created July 10, 2015 
.................... // See below: 
.................... //Summary: Finds a command from the global list of commands. 
.................... //Param: A pointer to the command string. 
.................... //Returns: The command number if the command is found in the command list. 
.................... //         0xFF if the command isn't found 
.................... //***************************************************************************** 
....................  
.................... int BT_FindCommand(void) 
.................... { 
....................    unsigned char buf[BT_COMMAND_SIZE]; 
....................    int i,stuff; 
....................  
....................    for (i=0; i<VAR_NAMESFORSETTING; i++) 
*
051CE:  MOVLB  7
051D0:  CLRF   xB3
051D2:  MOVF   xB3,W
051D4:  SUBLW  07
051D6:  BNC   5232
....................    { 
....................       strcpy(buf, &settingvariables[i][0]); 
051D8:  MOVF   xB3,W
051DA:  MULLW  0B
051DC:  MOVF   FF3,W
051DE:  CLRF   xB6
051E0:  MOVWF  xB5
051E2:  MOVLW  54
051E4:  ADDWF  xB5,W
051E6:  MOVWF  01
051E8:  MOVLW  04
051EA:  ADDWFC xB6,W
051EC:  MOVWF  03
051EE:  MOVFF  01,7B7
051F2:  MOVWF  xB8
051F4:  MOVLW  07
051F6:  MOVWF  FEA
051F8:  MOVLW  A8
051FA:  MOVWF  FE9
051FC:  MOVFF  03,FE2
05200:  MOVFF  01,FE1
05204:  MOVF   FE7,F
05206:  MOVFF  FE6,FEE
0520A:  BNZ   5204
....................       if (stricmp(buf, bt_cmd)==0)    
0520C:  MOVLW  07
0520E:  MOVWF  xB6
05210:  MOVLW  A8
05212:  MOVWF  xB5
05214:  CLRF   xB8
05216:  MOVLW  33
05218:  MOVWF  xB7
0521A:  MOVLB  0
0521C:  RCALL  50C6
0521E:  MOVF   01,F
05220:  BNZ   522C
....................          return(i); 
05222:  MOVLB  7
05224:  MOVFF  7B3,01
05228:  BRA    5236
0522A:  MOVLB  0
0522C:  MOVLB  7
0522E:  INCF   xB3,F
05230:  BRA    51D2
....................    } 
....................    return(0xFF); 
05232:  MOVLW  FF
05234:  MOVWF  01
05236:  MOVLB  0
05238:  GOTO   6432 (RETURN)
.................... } 
....................  
.................... int1 parseChar(char vala){ 
.................... char tempBuff[2]; 
....................  
.................... int1 newLine=0; 
.................... ////////OLD 
.................... /* 
.................... 	writeChar(val); 
.................... 	dispCntr++; 
.................... 	writeReady=0; 
.................... */ 
....................  
.................... if(vala==10) 
.................... 	{	 
.................... 	xCntr=0; 
.................... 	yCntr++; 
.................... 	newLine=1; 
.................... 	} 
.................... else{ 
.................... writeCharPos(xCntr,yCntr,vala); 
.................... xCntr++; 
.................... 	} 
.................... return newLine; 
.................... } 
.................... ////////////////////////RS232 Interrupt////////////////////// 
....................  
.................... #define BT_BUFF_SIZE 64 
....................  
.................... int16 BTnext_in  = 0; 
.................... int16 BTnext_out = 0; 
.................... int8 BTbuffer[BT_BUFF_SIZE]; 
....................  
.................... //char * BT_GetCMD(char *in) 
.................... void MoveOverReceivedData(int pointernumber) 
.................... 	{ 
.................... 	int8 x,leadingzero,y; 
....................     // get rid of leading zeros 
.................... 	for (x=0; x< 11; x++) 
.................... 		{   
....................             adcBuff[x] = SplitResult[pointernumber][x]; 
....................              
....................         } 
.................... 	} 
....................  
....................  
.................... //char * BT_GetCMD(char *in) 
.................... void BT_GetCMD(void) 
.................... 	{ 
.................... 	int8 x; 
.................... 	for (x=0; x< 18; x++) 
*
05060:  MOVLB  7
05062:  CLRF   xA8
05064:  MOVF   xA8,W
05066:  SUBLW  11
05068:  BNC   5098
.................... 		{ 
.................... 		bt_cmd[x] = SplitResult[0][x]; 
0506A:  CLRF   03
0506C:  MOVF   xA8,W
0506E:  ADDLW  33
05070:  MOVWF  01
05072:  MOVLW  00
05074:  ADDWFC 03,F
05076:  MOVLW  08
05078:  ADDWF  xA8,W
0507A:  MOVWF  FE9
0507C:  MOVLW  03
0507E:  MOVWF  FEA
05080:  BTFSC  FD8.0
05082:  INCF   FEA,F
05084:  MOVFF  FEF,7AB
05088:  MOVFF  03,FEA
0508C:  MOVFF  01,FE9
05090:  MOVFF  7AB,FEF
05094:  INCF   xA8,F
05096:  BRA    5064
.................... 		} 
05098:  MOVLB  0
0509A:  GOTO   6414 (RETURN)
.................... 	} 
....................  
....................  
.................... //////////////////////////////////////////////////////////// 
....................  
.................... #define BTbkbhit (BTnext_in != BTnext_out) 
.................... //#define bkbhitDebug (next_in != next_outDebug) 
....................  
.................... int8 BTbgetc() 
.................... { 
....................    int8 c; 
....................  
....................    while(!BTbkbhit); 
*
04F0C:  MOVLB  6
04F0E:  MOVF   x24,W
04F10:  SUBWF  x22,W
04F12:  BNZ   4F1A
04F14:  MOVF   x25,W
04F16:  SUBWF  x23,W
04F18:  BZ    4F0E
....................    c = BTbuffer[BTnext_out]; 
04F1A:  MOVLW  26
04F1C:  ADDWF  x24,W
04F1E:  MOVWF  FE9
04F20:  MOVLW  06
04F22:  ADDWFC x25,W
04F24:  MOVWF  FEA
04F26:  MOVFF  FEF,796
....................    BTnext_out = (BTnext_out+1) % sizeof(BTbuffer);  
04F2A:  MOVLW  01
04F2C:  ADDWF  x24,W
04F2E:  MOVLB  7
04F30:  MOVWF  x97
04F32:  MOVLW  00
04F34:  MOVLB  6
04F36:  ADDWFC x25,W
04F38:  MOVLB  7
04F3A:  MOVF   x97,W
04F3C:  ANDLW  3F
04F3E:  MOVLB  6
04F40:  MOVWF  x24
04F42:  CLRF   x25
....................    return c; 
04F44:  MOVLB  7
04F46:  MOVFF  796,01
04F4A:  MOVLB  0
04F4C:  GOTO   77D0 (RETURN)
.................... } 
....................  
.................... //********************************************************************* 
.................... // Updated November 15, 2016 
.................... // Below tests for a character from the bluetooth and then parses the command.  It does not run the command that is done in the  
.................... // lexal analyzer.   
.................... // Tokens are seperated by spaces 
.................... // Lines are teminated by CR/LF  depending on the terminal program used. 
.................... // The result returned is a -1 for fail and a 0 for OK. 
.................... //********************************************************************* 
....................  
....................  
.................... void BTTestEvent(void) 
.................... 	{ 
.................... 	 
.................... static int8 countcharacter; 
.................... char endofline[] = "\r"; 
*
077B4:  MOVLW  0D
077B6:  MOVLB  7
077B8:  MOVWF  x93
077BA:  CLRF   x94
....................  
.................... 	if(BTbkbhit){ 
077BC:  MOVLB  6
077BE:  MOVF   x24,W
077C0:  SUBWF  x22,W
077C2:  BNZ   77CA
077C4:  MOVF   x25,W
077C6:  SUBWF  x23,W
077C8:  BZ    784A
....................  
.................... 		char cvl =BTbgetc(); 		//getBTChar(); 
077CA:  MOVLB  0
077CC:  GOTO   4F0C
077D0:  MOVFF  01,795
.................... 		if (CommandModeOrNot == 0) 
077D4:  MOVLB  4
077D6:  MOVF   x52,F
077D8:  BNZ   77E6
....................         { 
....................          putc(cvl,BT); 
077DA:  MOVLB  7
077DC:  MOVF   x95,W
077DE:  MOVLB  0
077E0:  CALL   4F50
077E4:  MOVLB  4
....................         } 
.................... //  This is a carraige return.  This section takes the line sent from the command line and places it into a string where  
.................... //  it will be parsed into commands through the operating system. 
.................... if (cvl == 0x0D)   
077E6:  MOVLB  7
077E8:  MOVF   x95,W
077EA:  SUBLW  0D
077EC:  BNZ   7834
.................... 	{ 
....................     	if (CommandModeOrNot == 0) 
077EE:  MOVLB  4
077F0:  MOVF   x52,F
077F2:  BNZ   7804
....................             { 
.................... 		putc('\r',BT);    //Send back to the terminal the CR and LF. 
077F4:  MOVLW  0D
077F6:  MOVLB  0
077F8:  CALL   4F50
.................... 		putc('\n',BT); 
077FC:  MOVLW  0A
077FE:  CALL   4F50
07802:  MOVLB  4
....................             } 
.................... 	scr[countcharacter] = '\0';    // Insert the CR to end the command string.   
07804:  CLRF   03
07806:  MOVLB  6
07808:  MOVF   x66,W
0780A:  ADDLW  C8
0780C:  MOVWF  FE9
0780E:  MOVLW  02
07810:  ADDWFC 03,W
07812:  MOVWF  FEA
07814:  CLRF   FEF
.................... 	split(&endofline);    //Split the command into the array of tokens.  The first location starts at 0 which is the command requested. 
07816:  MOVLW  07
07818:  MOVLB  7
0781A:  MOVWF  x97
0781C:  MOVLW  93
0781E:  MOVWF  x96
07820:  MOVLB  0
07822:  GOTO   4F58
.................... 	countcharacter = 0; 
07826:  MOVLB  6
07828:  CLRF   x66
.................... 	parsebluetoothcommand();   // Parse and execute the command(s).... 
0782A:  MOVLB  0
0782C:  GOTO   6410
.................... 	} 
07830:  BRA    784C
07832:  MOVLB  7
.................... 	else 
.................... 	{ 
.................... 	//This section adds the current typed character to the array called "scr".  When there is a CR, it then resets to zero and parses the command line. 
.................... 	scr[countcharacter]=cvl;   // Add the current character to the array; waiting for the rest of the command. 
07834:  CLRF   03
07836:  MOVLB  6
07838:  MOVF   x66,W
0783A:  ADDLW  C8
0783C:  MOVWF  FE9
0783E:  MOVLW  02
07840:  ADDWFC 03,W
07842:  MOVWF  FEA
07844:  MOVFF  795,FEF
.................... 	countcharacter++;   // Kick the counter to the RDA_isrointer location. 
07848:  INCF   x66,F
0784A:  MOVLB  0
.................... 				//  Return back to the operating system to do other stuff. 
....................  
.................... 	} 
....................  
.................... 	} 
0784C:  RETURN 0
.................... } 
....................    
....................  
.................... //char * BT_GetCMD(char *in) 
.................... void BT_GetNextCMD(void) 
.................... 	{ 
.................... 	int8 x; 
.................... 	for (x=0; x< 35; x++) 
*
0523C:  MOVLB  7
0523E:  CLRF   xA8
05240:  MOVF   xA8,W
05242:  SUBLW  22
05244:  BNC   5274
.................... 		{ 
.................... 		bt_cmd[x] = SplitResult[1][x]; 
05246:  CLRF   03
05248:  MOVF   xA8,W
0524A:  ADDLW  33
0524C:  MOVWF  01
0524E:  MOVLW  00
05250:  ADDWFC 03,F
05252:  MOVLW  13
05254:  ADDWF  xA8,W
05256:  MOVWF  FE9
05258:  MOVLW  03
0525A:  MOVWF  FEA
0525C:  BTFSC  FD8.0
0525E:  INCF   FEA,F
05260:  MOVFF  FEF,7AB
05264:  MOVFF  03,FEA
05268:  MOVFF  01,FE9
0526C:  MOVFF  7AB,FEF
05270:  INCF   xA8,F
05272:  BRA    5240
.................... 		} 
05274:  MOVLB  0
05276:  RETURN 0
.................... 	} 
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Created July 10, 2015 
.................... // See below: 
.................... //Summary: Finds a command from the global list of commands. 
.................... //Param: A pointer to the command string. 
.................... //Returns: The command number if the command is found in the command list. 
.................... //         0xFF if the command isn't found 
.................... //***************************************************************************** 
....................  
.................... int BT_FindSubCommand(void) 
.................... { 
....................    unsigned char buf[BT_COMMAND_SIZE]; 
....................    int i; 
....................  
....................    for (i=0; i<BT_NUM_SUBCOMMANDS; i++) 
05278:  MOVLB  7
0527A:  CLRF   xB3
0527C:  MOVF   xB3,W
0527E:  SUBLW  21
05280:  BNC   52EC
....................    { 
....................       strcpy(buf, &bluetoothsecond[i][0]); 
05282:  CLRF   xB5
05284:  MOVFF  7B3,7B4
05288:  CLRF   xB7
0528A:  MOVLW  0B
0528C:  MOVWF  xB6
0528E:  MOVLB  0
05290:  RCALL  4CFA
05292:  MOVFF  02,7B5
05296:  MOVFF  01,7B4
0529A:  MOVLW  AC
0529C:  MOVLB  7
0529E:  ADDWF  01,W
052A0:  MOVWF  01
052A2:  MOVLW  04
052A4:  ADDWFC 02,W
052A6:  MOVWF  03
052A8:  MOVFF  01,7B6
052AC:  MOVWF  xB7
052AE:  MOVLW  07
052B0:  MOVWF  FEA
052B2:  MOVLW  A8
052B4:  MOVWF  FE9
052B6:  MOVFF  03,FE2
052BA:  MOVFF  01,FE1
052BE:  MOVF   FE7,F
052C0:  MOVFF  FE6,FEE
052C4:  BNZ   52BE
....................       if (stricmp(buf, bt_cmd)==0) 
052C6:  MOVLW  07
052C8:  MOVWF  xB6
052CA:  MOVLW  A8
052CC:  MOVWF  xB5
052CE:  CLRF   xB8
052D0:  MOVLW  33
052D2:  MOVWF  xB7
052D4:  MOVLB  0
052D6:  RCALL  50C6
052D8:  MOVF   01,F
052DA:  BNZ   52E6
....................          return(i); 
052DC:  MOVLB  7
052DE:  MOVFF  7B3,01
052E2:  BRA    52F0
052E4:  MOVLB  0
052E6:  MOVLB  7
052E8:  INCF   xB3,F
052EA:  BRA    527C
....................    } 
....................  
....................    return(0xFF); 
052EC:  MOVLW  FF
052EE:  MOVWF  01
052F0:  MOVLB  0
052F2:  RETURN 0
.................... } 
....................  
....................  
.................... //char * BT_GetCMD(char *in) 
.................... //This routine gets the thrid item in the command line.  It is normally a number that is converted for setting variables. 
.................... void BT_GetLastCMD(void) 
.................... 	{ 
.................... 	int8 x; 
.................... 	for (x=0; x< 35; x++) 
*
053BE:  MOVLB  7
053C0:  CLRF   xA8
053C2:  MOVF   xA8,W
053C4:  SUBLW  22
053C6:  BNC   53F6
.................... 		{ 
.................... 		bt_cmd[x] = SplitResult[2][x]; 
053C8:  CLRF   03
053CA:  MOVF   xA8,W
053CC:  ADDLW  33
053CE:  MOVWF  01
053D0:  MOVLW  00
053D2:  ADDWFC 03,F
053D4:  MOVLW  1E
053D6:  ADDWF  xA8,W
053D8:  MOVWF  FE9
053DA:  MOVLW  03
053DC:  MOVWF  FEA
053DE:  BTFSC  FD8.0
053E0:  INCF   FEA,F
053E2:  MOVFF  FEF,7AB
053E6:  MOVFF  03,FEA
053EA:  MOVFF  01,FE9
053EE:  MOVFF  7AB,FEF
053F2:  INCF   xA8,F
053F4:  BRA    53C2
.................... 		} 
053F6:  MOVLB  0
053F8:  RETURN 0
.................... 	} 
....................  
....................  
.................... //********************************************************************* 
.................... // Updated July 10, 2015 
.................... // Below tests for a character from the bluetooth and then parses the command.  It does not run the command that is done in the  
.................... // lexal analyzer.   
.................... // Tokens are seperated by spaces 
.................... // Lines are teminated by CR/LF  depending on the terminal program used. 
.................... // The result returned is a -1 for fail and a 0 for OK. 
.................... //********************************************************************* 
.................... /* 
....................  
.................... void BTBasicTest(void) 
.................... 	{ 
.................... 	 
.................... static int8 countcharacter; 
....................  
.................... 	if(BTbkbhit){ 
....................  
.................... 		char cvl =BTbgetc(); 		//getWIFIChar(); 
.................... 		//putc(cvl,BT); 
....................         if (CommandModeOrNot) 
....................         { 
....................        //  writeChar(cvl); 
....................         } 
.................... //  This is a carraige return.  This section takes the line sent from the command line and places it into a string where  
.................... //  it will be parsed into commands through the operating system. 
....................        if (cvl != '\r') 
....................        { 
.................... if (cvl == '\n') 
.................... 	{ 
.................... 		//putc('\r',BT);    //Send back to the terminal the CR and LF. 
....................        // writeChar('\r'); 
.................... 		//putc('\n',BT); 
....................        // writeChar('\n'); 
....................      
....................  
.................... 	bt_cmd[countcharacter] = '\0';    // Insert the CR to end the command string.   
....................     if (CommandModeOrNot==0) 
....................     { 
....................     passed = 0;  // clear flag     
....................  //   split(&bt_cmd,0x3A, '\n');    //Split the command into the array of tokens.  This splits for showing commands back from the BT device. 
....................     } 
....................     else 
....................     { 
.................... //     split(&bt_cmd,0x2C, '\n');    //Split the command into the array of tokens.  This splits all of the characters for showing data 
....................      BT_GetCMD(); 
....................      CurrentCommand =  BT_FindCommand(); 
.................... //     split(&bt_cmd,0x20, '\n');    //Split the command into the array of tokens.  This splits all of the characters for showing data 
....................      BT_GetCMD(); 
....................      CurrentCommand =  BT_FindCommand();      
....................      if (CurrentCommand!=0xff) 
....................      { 
....................          if ((CurrentCommand == 3) && (passed != 1)) 
....................          {     
....................               passed = 1;  // set the passed ito  
....................               CurrentCommand=99; 
....................               return; 
....................          } 
....................      }     
....................      
....................     } 
.................... //char * BT_GetCMD(char *in) 
....................     BT_GetCMD(); 
....................  
.................... 	countcharacter = 0; 
....................     CurrentCommand =  BT_FindCommand(); 
....................     CurrentCommand++; 
.................... 	//parsebluetoothcommand();   // Parse and execut the command(s).... 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 	//This section adds the current typed charater to the array called "scr".  When there is a CR, it then resets to zero and parses the command line. 
.................... 	bt_cmd[countcharacter]=cvl;   // Add the current character to the array; waiting for the rest of the command. 
.................... 	countcharacter++;   // Kick the counter to the pointer location. 
.................... 				//  Return back to the operating system to do other stuff. 
....................  
....................  
.................... //**************************************************** 
.................... // Created Oct. 20, 2015 
.................... // This sections checks for ESC sequencies and then does them. 
.................... //**************************************************** 
....................  
.................... 	} 
....................        } 
.................... 	} 
.................... } 
....................  
.................... */ 
.................... //**************************************************************************** 
.................... // Created July 9, 2015 
.................... // This is the main parsing routine for call fuctions commanded by Bluetooth.  This is called when a completed 
.................... // CR and LF are found from the remote bluetooth device.   
.................... // The output of this routine are called routines and the returned value is a -1 if there is an parsing error. 
.................... //  Return -1 if error 
.................... //  Return 0 if no error 
.................... //  The input to the function is an array of commands split into each command on each array pointer. 
.................... //  The end of the parsed line is a CR and/or LF. 
.................... // Updated/completed  July 10, 2015 
.................... // This is the main parsing routine for bluetooth.  It takes the remove commands from the Osmobot and/or the terminal and runs them. 
.................... // The inputs are as follows: 
.................... // The split command array is global and does not need to be passed. 
.................... //  
.................... // The output are as follows:  it returns an int8 where a -1 means it failed and a 0 means it made it. 
.................... //**************************************************************************** 
.................... int8 parsebluetoothcommand(void) 
.................... 	{ 
.................... 	int stuff, ScaleLevel,routernumber,exit,choice,changefolder; 
....................     int16 selection,selecteditems; 
.................... 	float ClearTemp,ScaleLevelfloat; 
....................     //char arryit[255]; 
.................... 	BT_GetCMD(); 
*
06410:  GOTO   5060
....................     fprintf(BT,"%s\r\n",bt_cmd); 
06414:  CLRF   FEA
06416:  MOVLW  33
06418:  MOVWF  FE9
0641A:  GOTO   509E
0641E:  MOVLW  0D
06420:  BTFSS  F9E.4
06422:  BRA    6420
06424:  MOVWF  FAD
06426:  MOVLW  0A
06428:  BTFSS  F9E.4
0642A:  BRA    6428
0642C:  MOVWF  FAD
....................   //  fprintf(BT,"Here is the command number - >%i\r\n",BT_FindCommand()); 
.................... 	switch(BT_FindCommand()) 
0642E:  GOTO   51CE
06432:  MOVF   01,W
06434:  BZ    646C
06436:  XORLW  01
06438:  BZ    651C
0643A:  XORLW  03
0643C:  BTFSC  FD8.2
0643E:  BRA    65DA
06440:  XORLW  01
06442:  BTFSC  FD8.2
06444:  GOTO   6DBE
06448:  XORLW  07
0644A:  BTFSC  FD8.2
0644C:  GOTO   6E5A
06450:  XORLW  01
06452:  BTFSC  FD8.2
06454:  GOTO   7774
06458:  XORLW  03
0645A:  BTFSC  FD8.2
0645C:  GOTO   7786
06460:  XORLW  01
06462:  BTFSC  FD8.2
06464:  GOTO   779C
06468:  GOTO   77A0
....................          { 
....................             case 0:  //help  as command "?" 
....................                fprintf(BT,"Osmobot Testing and Configuration Help\n\r"); 
0646C:  MOVLW  F0
0646E:  MOVWF  FF6
06470:  MOVLW  00
06472:  MOVWF  FF7
06474:  CALL   1C32
....................                fprintf(BT,"Below is a list of all the commands this unit can do.  Fabuary 11, 2017\n\r"); 
06478:  MOVLW  1A
0647A:  MOVWF  FF6
0647C:  MOVLW  01
0647E:  MOVWF  FF7
06480:  CALL   1C32
....................                fprintf(BT,"showconfig          Dumps all of the current calibrations for all sensors to date to the display.\n\r"); 
06484:  MOVLW  64
06486:  MOVWF  FF6
06488:  MOVLW  01
0648A:  MOVWF  FF7
0648C:  CALL   1C32
....................                fprintf(BT,"saveconfig          Saves all of the current calibration in EEPROM on this device.  It's used as default for initalizing new units.\n\r"); 
06490:  MOVLW  C8
06492:  MOVWF  FF6
06494:  MOVLW  01
06496:  MOVWF  FF7
06498:  CALL   1C32
....................                fprintf(BT,"display             Command to set or reset items to the VFD  display. Only 4 items can be shown at the same time.  All else will be truncated.\n\r"); 
0649C:  MOVLW  4E
0649E:  MOVWF  FF6
064A0:  MOVLW  02
064A2:  MOVWF  FF7
064A4:  CALL   1C32
....................                fprintf(BT,"                    Here are the options.\n\r"); 
064A8:  MOVLW  E0
064AA:  MOVWF  FF6
064AC:  MOVLW  02
064AE:  MOVWF  FF7
064B0:  CALL   1C32
....................                fprintf(BT,"                    pph do  ph  wd  phbulb  clear lux  ec   wt  par  nh4 \n\r"); 
064B4:  MOVLW  0C
064B6:  MOVWF  FF6
064B8:  MOVLW  03
064BA:  MOVWF  FF7
064BC:  CALL   1C32
....................                fprintf(BT,"default             This sets all of the calibration to default values.\n\r"); 
064C0:  MOVLW  58
064C2:  MOVWF  FF6
064C4:  MOVLW  03
064C6:  MOVWF  FF7
064C8:  CALL   1C32
....................                fprintf(BT,"update              It shoots the current calibration values to the remote device.\n\r"); 
064CC:  MOVLW  A2
064CE:  MOVWF  FF6
064D0:  MOVLW  03
064D2:  MOVWF  FF7
064D4:  CALL   1C32
....................                fprintf(BT,"set                 Sets the calibration var.  The format is >set varname value.  One space in between.\n\r"); 
064D8:  MOVLW  F8
064DA:  MOVWF  FF6
064DC:  MOVLW  03
064DE:  MOVWF  FF7
064E0:  CALL   1C32
....................                fprintf(BT,"                            Use the showconfig command to display the var names in ().\n\r");     
064E4:  MOVLW  62
064E6:  MOVWF  FF6
064E8:  MOVLW  04
064EA:  MOVWF  FF7
064EC:  CALL   1C32
....................                fprintf(BT,"rst                 reboot this unit.\n\r");     
064F0:  MOVLW  BC
064F2:  MOVWF  FF6
064F4:  MOVLW  04
064F6:  MOVWF  FF7
064F8:  CALL   1C32
....................                 
....................                fprintf(BT,"\n\r");                
064FC:  MOVLW  0A
064FE:  BTFSS  F9E.4
06500:  BRA    64FE
06502:  MOVWF  FAD
06504:  MOVLW  0D
06506:  BTFSS  F9E.4
06508:  BRA    6506
0650A:  MOVWF  FAD
....................                fprintf(BT,"end of line\n\r");                
0650C:  MOVLW  E4
0650E:  MOVWF  FF6
06510:  MOVLW  04
06512:  MOVWF  FF7
06514:  CALL   1C32
....................                break;                
06518:  GOTO   77AC
....................             case 1:  //this is the display command clear    The second command on the line is the sensor needed 
....................                debugnumber = 0;    //This clears the desired routine and exits back to the main loop.  Added July 13, 2015 
0651C:  MOVLB  2
0651E:  CLRF   xC6
.................... 			   BT_GetNextCMD(); 
06520:  MOVLB  0
06522:  CALL   523C
.................... 			   debugnumber = BT_FindSubCommand(); 
06526:  CALL   5278
0652A:  MOVFF  01,2C6
....................              //  fprintf(BT,"debugnumber -> %i\n\r",debugnumber);   
....................                if (debugnumber == 6) 
0652E:  MOVLB  2
06530:  MOVF   xC6,W
06532:  SUBLW  06
06534:  BNZ   656E
....................                { 
....................                     if (savelocalconfigurations(0x0000)) 
06536:  MOVLB  7
06538:  CLRF   xA9
0653A:  CLRF   xA8
0653C:  MOVLB  0
0653E:  CALL   52F4
06542:  MOVF   01,F
06544:  BZ    6554
....................                      { 
....................                     fprintf(BT,"Error Saving Local Configuration\n\r");     
06546:  MOVLW  F2
06548:  MOVWF  FF6
0654A:  MOVLW  04
0654C:  MOVWF  FF7
0654E:  CALL   1C32
....................                     } 
06552:  BRA    6568
....................                     else 
....................                     { 
....................                     selectitem = 0x0000;  // clears the run time varaibles 
06554:  MOVLB  2
06556:  CLRF   x25
06558:  CLRF   x24
....................                     fprintf(BT,"Local Configurations Cleared\n\r");   
0655A:  MOVLW  16
0655C:  MOVWF  FF6
0655E:  MOVLW  05
06560:  MOVWF  FF7
06562:  MOVLB  0
06564:  CALL   1C32
....................                     } 
....................                     break; 
06568:  GOTO   77AC
0656C:  MOVLB  2
....................                } 
....................                selecteditems = 0x0001; 
0656E:  MOVLB  7
06570:  CLRF   x9F
06572:  MOVLW  01
06574:  MOVWF  x9E
....................                selection = selecteditems<<debugnumber; 
06576:  MOVFF  79F,79D
0657A:  MOVFF  79E,79C
0657E:  MOVLB  2
06580:  MOVF   xC6,W
06582:  MOVWF  00
06584:  BZ    659A
06586:  BCF    FD8.0
06588:  MOVLB  7
0658A:  RLCF   x9C,F
0658C:  RLCF   x9D,F
0658E:  DECFSZ 00,F
06590:  BRA    6594
06592:  BRA    6598
06594:  MOVLB  2
06596:  BRA    6586
06598:  MOVLB  2
....................                selectitem ^= selection; 
0659A:  MOVLB  7
0659C:  MOVF   x9C,W
0659E:  MOVLB  2
065A0:  XORWF  x24,F
065A2:  MOVLB  7
065A4:  MOVF   x9D,W
065A6:  MOVLB  2
065A8:  XORWF  x25,F
....................                if (savelocalconfigurations(selectitem)) 
065AA:  MOVFF  225,7A9
065AE:  MOVFF  224,7A8
065B2:  MOVLB  0
065B4:  CALL   52F4
065B8:  MOVF   01,F
065BA:  BZ    65CA
....................                { 
....................                  fprintf(BT,"Error Saving Local Configuration\n\r");     
065BC:  MOVLW  36
065BE:  MOVWF  FF6
065C0:  MOVLW  05
065C2:  MOVWF  FF7
065C4:  CALL   1C32
....................                } 
065C8:  BRA    65D6
....................                else 
....................                { 
....................                   fprintf(BT,"Local Configurations Saved\n\r");  
065CA:  MOVLW  5A
065CC:  MOVWF  FF6
065CE:  MOVLW  05
065D0:  MOVWF  FF7
065D2:  CALL   1C32
....................                //   fprintf(BT,"saved local config -> %Lx\n\r",selectitem);  
....................                } 
....................                break; 
065D6:  GOTO   77AC
....................             case 2:  //this is the set command 
.................... 				BT_GetNextCMD(); 
065DA:  CALL   523C
.................... 			    debugnumber = BT_FindSubCommand(); 
065DE:  CALL   5278
065E2:  MOVFF  01,2C6
....................                 switch(debugnumber) 
065E6:  MOVLB  2
065E8:  MOVF   xC6,W
065EA:  XORLW  0D
065EC:  MOVLB  0
065EE:  BZ    666A
065F0:  XORLW  03
065F2:  BTFSC  FD8.2
065F4:  BRA    66E2
065F6:  XORLW  01
065F8:  BTFSC  FD8.2
065FA:  BRA    674E
065FC:  XORLW  1F
065FE:  BTFSC  FD8.2
06600:  BRA    67C6
06602:  XORLW  01
06604:  BTFSC  FD8.2
06606:  BRA    6822
06608:  XORLW  03
0660A:  BTFSC  FD8.2
0660C:  BRA    6872
0660E:  XORLW  01
06610:  BTFSC  FD8.2
06612:  BRA    68CE
06614:  XORLW  07
06616:  BTFSC  FD8.2
06618:  BRA    692A
0661A:  XORLW  01
0661C:  BTFSC  FD8.2
0661E:  BRA    6986
06620:  XORLW  03
06622:  BTFSC  FD8.2
06624:  BRA    69E2
06626:  XORLW  01
06628:  BTFSC  FD8.2
0662A:  BRA    6A3E
0662C:  XORLW  0F
0662E:  BTFSC  FD8.2
06630:  BRA    6A9A
06632:  XORLW  01
06634:  BTFSC  FD8.2
06636:  BRA    6AEA
06638:  XORLW  03
0663A:  BTFSC  FD8.2
0663C:  BRA    6B3A
0663E:  XORLW  01
06640:  BTFSC  FD8.2
06642:  BRA    6B8A
06644:  XORLW  07
06646:  BTFSC  FD8.2
06648:  BRA    6BDA
0664A:  XORLW  01
0664C:  BTFSC  FD8.2
0664E:  BRA    6C2A
06650:  XORLW  03
06652:  BTFSC  FD8.2
06654:  BRA    6C7A
06656:  XORLW  01
06658:  BTFSC  FD8.2
0665A:  BRA    6CCA
0665C:  XORLW  3F
0665E:  BTFSC  FD8.2
06660:  BRA    6D1A
06662:  XORLW  01
06664:  BTFSC  FD8.2
06666:  BRA    6D6A
06668:  BRA    6DBA
....................                 { 
....................                     case 13: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
0666A:  CALL   53BE
....................                             sysInput.nh4pt1returnednumber = atof(bt_cmd); 
0666E:  MOVLB  7
06670:  CLRF   xA9
06672:  MOVLW  33
06674:  MOVWF  xA8
06676:  CLRF   xAB
06678:  CLRF   xAA
0667A:  MOVLB  0
0667C:  CALL   53FA
06680:  MOVFF  03,254
06684:  MOVFF  02,253
06688:  MOVFF  01,252
0668C:  MOVFF  00,251
....................                             fprintf(BT,"(retnh41)  nh4pt1returnednumber set to %f\n\r",sysInput.nh4pt1returnednumber);   
06690:  MOVLW  78
06692:  MOVWF  FF6
06694:  MOVLW  05
06696:  MOVWF  FF7
06698:  MOVLW  27
0669A:  MOVLB  7
0669C:  MOVWF  xA8
0669E:  MOVLB  0
066A0:  CALL   5654
066A4:  MOVLW  89
066A6:  MOVWF  FE9
066A8:  MOVFF  254,7AB
066AC:  MOVFF  253,7AA
066B0:  MOVFF  252,7A9
066B4:  MOVFF  251,7A8
066B8:  MOVLW  02
066BA:  MOVLB  7
066BC:  MOVWF  xAC
066BE:  MOVLB  0
066C0:  CALL   567E
066C4:  MOVLW  0A
066C6:  BTFSS  F9E.4
066C8:  BRA    66C6
066CA:  MOVWF  FAD
066CC:  MOVLW  0D
066CE:  BTFSS  F9E.4
066D0:  BRA    66CE
066D2:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe output low number.\n\r");  
066D4:  MOVLW  A4
066D6:  MOVWF  FF6
066D8:  MOVLW  05
066DA:  MOVWF  FF7
066DC:  CALL   1C32
....................                             break; 
066E0:  BRA    6DBA
....................                     case 14: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
066E2:  CALL   53BE
....................                             sysInput.nh4pt2returnednumber = atof(bt_cmd); 
066E6:  MOVLB  7
066E8:  CLRF   xA9
066EA:  MOVLW  33
066EC:  MOVWF  xA8
066EE:  CLRF   xAB
066F0:  CLRF   xAA
066F2:  MOVLB  0
066F4:  CALL   53FA
066F8:  MOVFF  03,258
066FC:  MOVFF  02,257
06700:  MOVFF  01,256
06704:  MOVFF  00,255
....................                             fprintf(BT,"(retnh42)  nh4pt2returnednumber set to %f\n\r",sysInput.nh4pt2returnednumber);                             
06708:  MOVLW  D8
0670A:  MOVWF  FF6
0670C:  MOVLW  05
0670E:  MOVWF  FF7
06710:  MOVLW  27
06712:  MOVLB  7
06714:  MOVWF  xA8
06716:  MOVLB  0
06718:  CALL   5654
0671C:  MOVLW  89
0671E:  MOVWF  FE9
06720:  MOVFF  258,7AB
06724:  MOVFF  257,7AA
06728:  MOVFF  256,7A9
0672C:  MOVFF  255,7A8
06730:  MOVLW  02
06732:  MOVLB  7
06734:  MOVWF  xAC
06736:  MOVLB  0
06738:  CALL   567E
0673C:  MOVLW  0A
0673E:  BTFSS  F9E.4
06740:  BRA    673E
06742:  MOVWF  FAD
06744:  MOVLW  0D
06746:  BTFSS  F9E.4
06748:  BRA    6746
0674A:  MOVWF  FAD
....................                             break; 
0674C:  BRA    6DBA
....................                     case 15: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
0674E:  CALL   53BE
....................                             sysInput.nh4pt3returnednumber = atof(bt_cmd); 
06752:  MOVLB  7
06754:  CLRF   xA9
06756:  MOVLW  33
06758:  MOVWF  xA8
0675A:  CLRF   xAB
0675C:  CLRF   xAA
0675E:  MOVLB  0
06760:  CALL   53FA
06764:  MOVFF  03,25C
06768:  MOVFF  02,25B
0676C:  MOVFF  01,25A
06770:  MOVFF  00,259
....................                             fprintf(BT,"(retnh43)  nh4pt3returnednumber set to %f\n\r",sysInput.nh4pt3returnednumber);   
06774:  MOVLW  04
06776:  MOVWF  FF6
06778:  MOVLW  06
0677A:  MOVWF  FF7
0677C:  MOVLW  27
0677E:  MOVLB  7
06780:  MOVWF  xA8
06782:  MOVLB  0
06784:  CALL   5654
06788:  MOVLW  89
0678A:  MOVWF  FE9
0678C:  MOVFF  25C,7AB
06790:  MOVFF  25B,7AA
06794:  MOVFF  25A,7A9
06798:  MOVFF  259,7A8
0679C:  MOVLW  02
0679E:  MOVLB  7
067A0:  MOVWF  xAC
067A2:  MOVLB  0
067A4:  CALL   567E
067A8:  MOVLW  0A
067AA:  BTFSS  F9E.4
067AC:  BRA    67AA
067AE:  MOVWF  FAD
067B0:  MOVLW  0D
067B2:  BTFSS  F9E.4
067B4:  BRA    67B2
067B6:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe output high number.\n\r");  
067B8:  MOVLW  30
067BA:  MOVWF  FF6
067BC:  MOVLW  06
067BE:  MOVWF  FF7
067C0:  CALL   1C32
....................                             break; 
067C4:  BRA    6DBA
....................                     case 16: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
067C6:  CALL   53BE
....................                             sysInput.nh4pt1cal1of3 = atol(bt_cmd); 
067CA:  MOVLB  7
067CC:  CLRF   xA9
067CE:  MOVLW  33
067D0:  MOVWF  xA8
067D2:  MOVLB  0
067D4:  CALL   587A
067D8:  MOVFF  02,240
067DC:  MOVFF  01,23F
....................                             fprintf(BT,"(nh4pt1)  nh4pt1cal1of3 set to %Lu\n\r",sysInput.nh4pt1cal1of3);   
067E0:  MOVLW  64
067E2:  MOVWF  FF6
067E4:  MOVLW  06
067E6:  MOVWF  FF7
067E8:  MOVLW  1F
067EA:  MOVLB  7
067EC:  MOVWF  xA8
067EE:  MOVLB  0
067F0:  CALL   5654
067F4:  MOVLW  10
067F6:  MOVWF  FE9
067F8:  MOVFF  240,7A9
067FC:  MOVFF  23F,7A8
06800:  CALL   5A5E
06804:  MOVLW  0A
06806:  BTFSS  F9E.4
06808:  BRA    6806
0680A:  MOVWF  FAD
0680C:  MOVLW  0D
0680E:  BTFSS  F9E.4
06810:  BRA    680E
06812:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
06814:  MOVLW  8A
06816:  MOVWF  FF6
06818:  MOVLW  06
0681A:  MOVWF  FF7
0681C:  CALL   1C32
....................                             break; 
06820:  BRA    6DBA
....................                     case 17: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06822:  CALL   53BE
....................                             sysInput.nh4pt1cal2of3 = atol(bt_cmd); 
06826:  MOVLB  7
06828:  CLRF   xA9
0682A:  MOVLW  33
0682C:  MOVWF  xA8
0682E:  MOVLB  0
06830:  CALL   587A
06834:  MOVFF  02,242
06838:  MOVFF  01,241
....................                             fprintf(BT,"(nh4pt2)  nh4pt1cal2of3 set to %Lu\n\r",sysInput.nh4pt1cal2of3);                             
0683C:  MOVLW  BC
0683E:  MOVWF  FF6
06840:  MOVLW  06
06842:  MOVWF  FF7
06844:  MOVLW  1F
06846:  MOVLB  7
06848:  MOVWF  xA8
0684A:  MOVLB  0
0684C:  CALL   5654
06850:  MOVLW  10
06852:  MOVWF  FE9
06854:  MOVFF  242,7A9
06858:  MOVFF  241,7A8
0685C:  CALL   5A5E
06860:  MOVLW  0A
06862:  BTFSS  F9E.4
06864:  BRA    6862
06866:  MOVWF  FAD
06868:  MOVLW  0D
0686A:  BTFSS  F9E.4
0686C:  BRA    686A
0686E:  MOVWF  FAD
....................                             break; 
06870:  BRA    6DBA
....................                     case 18: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06872:  CALL   53BE
....................                             sysInput.nh4pt1cal3of3 = atol(bt_cmd); 
06876:  MOVLB  7
06878:  CLRF   xA9
0687A:  MOVLW  33
0687C:  MOVWF  xA8
0687E:  MOVLB  0
06880:  CALL   587A
06884:  MOVFF  02,244
06888:  MOVFF  01,243
....................                             fprintf(BT,"(nh4pt3)  nh4pt1cal3of3 set to %Lu\n\r",sysInput.nh4pt1cal3of3);   
0688C:  MOVLW  E2
0688E:  MOVWF  FF6
06890:  MOVLW  06
06892:  MOVWF  FF7
06894:  MOVLW  1F
06896:  MOVLB  7
06898:  MOVWF  xA8
0689A:  MOVLB  0
0689C:  CALL   5654
068A0:  MOVLW  10
068A2:  MOVWF  FE9
068A4:  MOVFF  244,7A9
068A8:  MOVFF  243,7A8
068AC:  CALL   5A5E
068B0:  MOVLW  0A
068B2:  BTFSS  F9E.4
068B4:  BRA    68B2
068B6:  MOVWF  FAD
068B8:  MOVLW  0D
068BA:  BTFSS  F9E.4
068BC:  BRA    68BA
068BE:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
068C0:  MOVLW  08
068C2:  MOVWF  FF6
068C4:  MOVLW  07
068C6:  MOVWF  FF7
068C8:  CALL   1C32
....................                             break; 
068CC:  BRA    6DBA
....................                     case 19: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
068CE:  CALL   53BE
....................                             sysInput.nh4pt2cal1of3 = atol(bt_cmd); 
068D2:  MOVLB  7
068D4:  CLRF   xA9
068D6:  MOVLW  33
068D8:  MOVWF  xA8
068DA:  MOVLB  0
068DC:  CALL   587A
068E0:  MOVFF  02,246
068E4:  MOVFF  01,245
....................                             fprintf(BT,"(nh4pt4)  nh4pt2cal1of3 set to %Lu\n\r",sysInput.nh4pt2cal1of3);   
068E8:  MOVLW  3A
068EA:  MOVWF  FF6
068EC:  MOVLW  07
068EE:  MOVWF  FF7
068F0:  MOVLW  1F
068F2:  MOVLB  7
068F4:  MOVWF  xA8
068F6:  MOVLB  0
068F8:  CALL   5654
068FC:  MOVLW  10
068FE:  MOVWF  FE9
06900:  MOVFF  246,7A9
06904:  MOVFF  245,7A8
06908:  CALL   5A5E
0690C:  MOVLW  0A
0690E:  BTFSS  F9E.4
06910:  BRA    690E
06912:  MOVWF  FAD
06914:  MOVLW  0D
06916:  BTFSS  F9E.4
06918:  BRA    6916
0691A:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
0691C:  MOVLW  60
0691E:  MOVWF  FF6
06920:  MOVLW  07
06922:  MOVWF  FF7
06924:  CALL   1C32
....................                             break; 
06928:  BRA    6DBA
....................                     case 20: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
0692A:  CALL   53BE
....................                             sysInput.nh4pt2cal2of3 = atol(bt_cmd); 
0692E:  MOVLB  7
06930:  CLRF   xA9
06932:  MOVLW  33
06934:  MOVWF  xA8
06936:  MOVLB  0
06938:  CALL   587A
0693C:  MOVFF  02,248
06940:  MOVFF  01,247
....................                             fprintf(BT,"(nh4pt5)  nh4pt2cal2of3 set to %Lu\n\r",sysInput.nh4pt2cal2of3);   
06944:  MOVLW  92
06946:  MOVWF  FF6
06948:  MOVLW  07
0694A:  MOVWF  FF7
0694C:  MOVLW  1F
0694E:  MOVLB  7
06950:  MOVWF  xA8
06952:  MOVLB  0
06954:  CALL   5654
06958:  MOVLW  10
0695A:  MOVWF  FE9
0695C:  MOVFF  248,7A9
06960:  MOVFF  247,7A8
06964:  CALL   5A5E
06968:  MOVLW  0A
0696A:  BTFSS  F9E.4
0696C:  BRA    696A
0696E:  MOVWF  FAD
06970:  MOVLW  0D
06972:  BTFSS  F9E.4
06974:  BRA    6972
06976:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
06978:  MOVLW  B8
0697A:  MOVWF  FF6
0697C:  MOVLW  07
0697E:  MOVWF  FF7
06980:  CALL   1C32
....................                             break; 
06984:  BRA    6DBA
....................                     case 21: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06986:  CALL   53BE
....................                             sysInput.nh4pt2cal3of3 = atol(bt_cmd); 
0698A:  MOVLB  7
0698C:  CLRF   xA9
0698E:  MOVLW  33
06990:  MOVWF  xA8
06992:  MOVLB  0
06994:  CALL   587A
06998:  MOVFF  02,24A
0699C:  MOVFF  01,249
....................                             fprintf(BT,"(nh4pt6)  nh4pt2cal3of3 set to %Lu\n\r",sysInput.nh4pt2cal3of3);   
069A0:  MOVLW  EA
069A2:  MOVWF  FF6
069A4:  MOVLW  07
069A6:  MOVWF  FF7
069A8:  MOVLW  1F
069AA:  MOVLB  7
069AC:  MOVWF  xA8
069AE:  MOVLB  0
069B0:  CALL   5654
069B4:  MOVLW  10
069B6:  MOVWF  FE9
069B8:  MOVFF  24A,7A9
069BC:  MOVFF  249,7A8
069C0:  CALL   5A5E
069C4:  MOVLW  0A
069C6:  BTFSS  F9E.4
069C8:  BRA    69C6
069CA:  MOVWF  FAD
069CC:  MOVLW  0D
069CE:  BTFSS  F9E.4
069D0:  BRA    69CE
069D2:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
069D4:  MOVLW  10
069D6:  MOVWF  FF6
069D8:  MOVLW  08
069DA:  MOVWF  FF7
069DC:  CALL   1C32
....................                             break; 
069E0:  BRA    6DBA
....................                     case 22: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
069E2:  CALL   53BE
....................                             sysInput.nh4pt3cal1of3 = atol(bt_cmd); 
069E6:  MOVLB  7
069E8:  CLRF   xA9
069EA:  MOVLW  33
069EC:  MOVWF  xA8
069EE:  MOVLB  0
069F0:  CALL   587A
069F4:  MOVFF  02,24C
069F8:  MOVFF  01,24B
....................                             fprintf(BT,"(nh4pt7)  nh4pt3cal1of3 set to %Lu\n\r",sysInput.nh4pt3cal1of3);   
069FC:  MOVLW  42
069FE:  MOVWF  FF6
06A00:  MOVLW  08
06A02:  MOVWF  FF7
06A04:  MOVLW  1F
06A06:  MOVLB  7
06A08:  MOVWF  xA8
06A0A:  MOVLB  0
06A0C:  CALL   5654
06A10:  MOVLW  10
06A12:  MOVWF  FE9
06A14:  MOVFF  24C,7A9
06A18:  MOVFF  24B,7A8
06A1C:  CALL   5A5E
06A20:  MOVLW  0A
06A22:  BTFSS  F9E.4
06A24:  BRA    6A22
06A26:  MOVWF  FAD
06A28:  MOVLW  0D
06A2A:  BTFSS  F9E.4
06A2C:  BRA    6A2A
06A2E:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
06A30:  MOVLW  68
06A32:  MOVWF  FF6
06A34:  MOVLW  08
06A36:  MOVWF  FF7
06A38:  CALL   1C32
....................                             break; 
06A3C:  BRA    6DBA
....................                     case 23: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06A3E:  CALL   53BE
....................                             sysInput.nh4pt2cal2of3 = atol(bt_cmd); 
06A42:  MOVLB  7
06A44:  CLRF   xA9
06A46:  MOVLW  33
06A48:  MOVWF  xA8
06A4A:  MOVLB  0
06A4C:  CALL   587A
06A50:  MOVFF  02,248
06A54:  MOVFF  01,247
....................                             fprintf(BT,"(nh4pt8)  nh4pt3cal2of3 set to %Lu\n\r",sysInput.nh4pt3cal2of3);   
06A58:  MOVLW  9A
06A5A:  MOVWF  FF6
06A5C:  MOVLW  08
06A5E:  MOVWF  FF7
06A60:  MOVLW  1F
06A62:  MOVLB  7
06A64:  MOVWF  xA8
06A66:  MOVLB  0
06A68:  CALL   5654
06A6C:  MOVLW  10
06A6E:  MOVWF  FE9
06A70:  MOVFF  24E,7A9
06A74:  MOVFF  24D,7A8
06A78:  CALL   5A5E
06A7C:  MOVLW  0A
06A7E:  BTFSS  F9E.4
06A80:  BRA    6A7E
06A82:  MOVWF  FAD
06A84:  MOVLW  0D
06A86:  BTFSS  F9E.4
06A88:  BRA    6A86
06A8A:  MOVWF  FAD
....................                             fprintf(BT,"Also used as Analog NH4 probe input low number.\n\r");  
06A8C:  MOVLW  C0
06A8E:  MOVWF  FF6
06A90:  MOVLW  08
06A92:  MOVWF  FF7
06A94:  CALL   1C32
....................                             break; 
06A98:  BRA    6DBA
....................                     case 24: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06A9A:  CALL   53BE
....................                             sysInput.nh4pt3cal3of3 = atol(bt_cmd); 
06A9E:  MOVLB  7
06AA0:  CLRF   xA9
06AA2:  MOVLW  33
06AA4:  MOVWF  xA8
06AA6:  MOVLB  0
06AA8:  CALL   587A
06AAC:  MOVFF  02,250
06AB0:  MOVFF  01,24F
....................                             fprintf(BT,"(nh4pt9)  nh4pt3cal3of3 set to %Lu\n\r",sysInput.nh4pt3cal3of3);   
06AB4:  MOVLW  F2
06AB6:  MOVWF  FF6
06AB8:  MOVLW  08
06ABA:  MOVWF  FF7
06ABC:  MOVLW  1F
06ABE:  MOVLB  7
06AC0:  MOVWF  xA8
06AC2:  MOVLB  0
06AC4:  CALL   5654
06AC8:  MOVLW  10
06ACA:  MOVWF  FE9
06ACC:  MOVFF  250,7A9
06AD0:  MOVFF  24F,7A8
06AD4:  CALL   5A5E
06AD8:  MOVLW  0A
06ADA:  BTFSS  F9E.4
06ADC:  BRA    6ADA
06ADE:  MOVWF  FAD
06AE0:  MOVLW  0D
06AE2:  BTFSS  F9E.4
06AE4:  BRA    6AE2
06AE6:  MOVWF  FAD
....................                             break; 
06AE8:  BRA    6DBA
....................                     case 25: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06AEA:  CALL   53BE
....................                             sysInput.DOpt1cal1of3 = atol(bt_cmd); 
06AEE:  MOVLB  7
06AF0:  CLRF   xA9
06AF2:  MOVLW  33
06AF4:  MOVWF  xA8
06AF6:  MOVLB  0
06AF8:  CALL   587A
06AFC:  MOVFF  02,25E
06B00:  MOVFF  01,25D
....................                             fprintf(BT,"(DOpt1)  DOpt1cal1of3 set to %Lu\n\r",sysInput.DOpt1cal1of3);   
06B04:  MOVLW  18
06B06:  MOVWF  FF6
06B08:  MOVLW  09
06B0A:  MOVWF  FF7
06B0C:  MOVLW  1D
06B0E:  MOVLB  7
06B10:  MOVWF  xA8
06B12:  MOVLB  0
06B14:  CALL   5654
06B18:  MOVLW  10
06B1A:  MOVWF  FE9
06B1C:  MOVFF  25E,7A9
06B20:  MOVFF  25D,7A8
06B24:  CALL   5A5E
06B28:  MOVLW  0A
06B2A:  BTFSS  F9E.4
06B2C:  BRA    6B2A
06B2E:  MOVWF  FAD
06B30:  MOVLW  0D
06B32:  BTFSS  F9E.4
06B34:  BRA    6B32
06B36:  MOVWF  FAD
....................                             break; 
06B38:  BRA    6DBA
....................                     case 26: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06B3A:  CALL   53BE
....................                             sysInput.DOpt1cal2of3 = atol(bt_cmd); 
06B3E:  MOVLB  7
06B40:  CLRF   xA9
06B42:  MOVLW  33
06B44:  MOVWF  xA8
06B46:  MOVLB  0
06B48:  CALL   587A
06B4C:  MOVFF  02,260
06B50:  MOVFF  01,25F
....................                             fprintf(BT,"(DOpt2)  DOpt1cal2of3 set to %Lu\n\r",sysInput.DOpt1cal2of3);   
06B54:  MOVLW  3C
06B56:  MOVWF  FF6
06B58:  MOVLW  09
06B5A:  MOVWF  FF7
06B5C:  MOVLW  1D
06B5E:  MOVLB  7
06B60:  MOVWF  xA8
06B62:  MOVLB  0
06B64:  CALL   5654
06B68:  MOVLW  10
06B6A:  MOVWF  FE9
06B6C:  MOVFF  260,7A9
06B70:  MOVFF  25F,7A8
06B74:  CALL   5A5E
06B78:  MOVLW  0A
06B7A:  BTFSS  F9E.4
06B7C:  BRA    6B7A
06B7E:  MOVWF  FAD
06B80:  MOVLW  0D
06B82:  BTFSS  F9E.4
06B84:  BRA    6B82
06B86:  MOVWF  FAD
....................                             break; 
06B88:  BRA    6DBA
....................                     case 27: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06B8A:  CALL   53BE
....................                             sysInput.DOpt1cal3of3 = atol(bt_cmd); 
06B8E:  MOVLB  7
06B90:  CLRF   xA9
06B92:  MOVLW  33
06B94:  MOVWF  xA8
06B96:  MOVLB  0
06B98:  CALL   587A
06B9C:  MOVFF  02,262
06BA0:  MOVFF  01,261
....................                             fprintf(BT,"(DOpt3)  DOpt1cal3of3 set to %Lu\n\r",sysInput.DOpt1cal3of3);   
06BA4:  MOVLW  60
06BA6:  MOVWF  FF6
06BA8:  MOVLW  09
06BAA:  MOVWF  FF7
06BAC:  MOVLW  1D
06BAE:  MOVLB  7
06BB0:  MOVWF  xA8
06BB2:  MOVLB  0
06BB4:  CALL   5654
06BB8:  MOVLW  10
06BBA:  MOVWF  FE9
06BBC:  MOVFF  262,7A9
06BC0:  MOVFF  261,7A8
06BC4:  CALL   5A5E
06BC8:  MOVLW  0A
06BCA:  BTFSS  F9E.4
06BCC:  BRA    6BCA
06BCE:  MOVWF  FAD
06BD0:  MOVLW  0D
06BD2:  BTFSS  F9E.4
06BD4:  BRA    6BD2
06BD6:  MOVWF  FAD
....................                             break; 
06BD8:  BRA    6DBA
....................                     case 28: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06BDA:  CALL   53BE
....................                             sysInput.DOpt2cal1of3 = atol(bt_cmd); 
06BDE:  MOVLB  7
06BE0:  CLRF   xA9
06BE2:  MOVLW  33
06BE4:  MOVWF  xA8
06BE6:  MOVLB  0
06BE8:  CALL   587A
06BEC:  MOVFF  02,264
06BF0:  MOVFF  01,263
....................                             fprintf(BT,"(DOpt4)  DOpt2cal1of3 set to %Lu\n\r",sysInput.DOpt2cal1of3);   
06BF4:  MOVLW  84
06BF6:  MOVWF  FF6
06BF8:  MOVLW  09
06BFA:  MOVWF  FF7
06BFC:  MOVLW  1D
06BFE:  MOVLB  7
06C00:  MOVWF  xA8
06C02:  MOVLB  0
06C04:  CALL   5654
06C08:  MOVLW  10
06C0A:  MOVWF  FE9
06C0C:  MOVFF  264,7A9
06C10:  MOVFF  263,7A8
06C14:  CALL   5A5E
06C18:  MOVLW  0A
06C1A:  BTFSS  F9E.4
06C1C:  BRA    6C1A
06C1E:  MOVWF  FAD
06C20:  MOVLW  0D
06C22:  BTFSS  F9E.4
06C24:  BRA    6C22
06C26:  MOVWF  FAD
....................                             break; 
06C28:  BRA    6DBA
....................                     case 29: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06C2A:  CALL   53BE
....................                             sysInput.DOpt2cal2of3 = atol(bt_cmd); 
06C2E:  MOVLB  7
06C30:  CLRF   xA9
06C32:  MOVLW  33
06C34:  MOVWF  xA8
06C36:  MOVLB  0
06C38:  CALL   587A
06C3C:  MOVFF  02,266
06C40:  MOVFF  01,265
....................                             fprintf(BT,"(DOpt5)  DOpt2cal2of3 set to %Lu\n\r",sysInput.DOpt2cal2of3);   
06C44:  MOVLW  A8
06C46:  MOVWF  FF6
06C48:  MOVLW  09
06C4A:  MOVWF  FF7
06C4C:  MOVLW  1D
06C4E:  MOVLB  7
06C50:  MOVWF  xA8
06C52:  MOVLB  0
06C54:  CALL   5654
06C58:  MOVLW  10
06C5A:  MOVWF  FE9
06C5C:  MOVFF  266,7A9
06C60:  MOVFF  265,7A8
06C64:  CALL   5A5E
06C68:  MOVLW  0A
06C6A:  BTFSS  F9E.4
06C6C:  BRA    6C6A
06C6E:  MOVWF  FAD
06C70:  MOVLW  0D
06C72:  BTFSS  F9E.4
06C74:  BRA    6C72
06C76:  MOVWF  FAD
....................                             break; 
06C78:  BRA    6DBA
....................                     case 30: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06C7A:  CALL   53BE
....................                             sysInput.DOpt2cal3of3 = atol(bt_cmd); 
06C7E:  MOVLB  7
06C80:  CLRF   xA9
06C82:  MOVLW  33
06C84:  MOVWF  xA8
06C86:  MOVLB  0
06C88:  CALL   587A
06C8C:  MOVFF  02,268
06C90:  MOVFF  01,267
....................                             fprintf(BT,"(DOpt6)  DOpt2cal3of3 set to %Lu\n\r",sysInput.DOpt2cal3of3);   
06C94:  MOVLW  CC
06C96:  MOVWF  FF6
06C98:  MOVLW  09
06C9A:  MOVWF  FF7
06C9C:  MOVLW  1D
06C9E:  MOVLB  7
06CA0:  MOVWF  xA8
06CA2:  MOVLB  0
06CA4:  CALL   5654
06CA8:  MOVLW  10
06CAA:  MOVWF  FE9
06CAC:  MOVFF  268,7A9
06CB0:  MOVFF  267,7A8
06CB4:  CALL   5A5E
06CB8:  MOVLW  0A
06CBA:  BTFSS  F9E.4
06CBC:  BRA    6CBA
06CBE:  MOVWF  FAD
06CC0:  MOVLW  0D
06CC2:  BTFSS  F9E.4
06CC4:  BRA    6CC2
06CC6:  MOVWF  FAD
....................                             break; 
06CC8:  BRA    6DBA
....................                     case 31: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06CCA:  CALL   53BE
....................                             sysInput.DOpt3cal1of3 = atol(bt_cmd); 
06CCE:  MOVLB  7
06CD0:  CLRF   xA9
06CD2:  MOVLW  33
06CD4:  MOVWF  xA8
06CD6:  MOVLB  0
06CD8:  CALL   587A
06CDC:  MOVFF  02,26A
06CE0:  MOVFF  01,269
....................                             fprintf(BT,"(DOpt17  DOpt3cal1of3 set to %Lu\n\r",sysInput.DOpt3cal1of3);   
06CE4:  MOVLW  F0
06CE6:  MOVWF  FF6
06CE8:  MOVLW  09
06CEA:  MOVWF  FF7
06CEC:  MOVLW  1D
06CEE:  MOVLB  7
06CF0:  MOVWF  xA8
06CF2:  MOVLB  0
06CF4:  CALL   5654
06CF8:  MOVLW  10
06CFA:  MOVWF  FE9
06CFC:  MOVFF  26A,7A9
06D00:  MOVFF  269,7A8
06D04:  CALL   5A5E
06D08:  MOVLW  0A
06D0A:  BTFSS  F9E.4
06D0C:  BRA    6D0A
06D0E:  MOVWF  FAD
06D10:  MOVLW  0D
06D12:  BTFSS  F9E.4
06D14:  BRA    6D12
06D16:  MOVWF  FAD
....................                             break; 
06D18:  BRA    6DBA
....................                     case 32: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06D1A:  CALL   53BE
....................                             sysInput.DOpt3cal2of3 = atol(bt_cmd); 
06D1E:  MOVLB  7
06D20:  CLRF   xA9
06D22:  MOVLW  33
06D24:  MOVWF  xA8
06D26:  MOVLB  0
06D28:  CALL   587A
06D2C:  MOVFF  02,26C
06D30:  MOVFF  01,26B
....................                             fprintf(BT,"(DOpt8)  DOpt3cal2of3 set to %Lu\n\r",sysInput.DOpt3cal2of3);   
06D34:  MOVLW  14
06D36:  MOVWF  FF6
06D38:  MOVLW  0A
06D3A:  MOVWF  FF7
06D3C:  MOVLW  1D
06D3E:  MOVLB  7
06D40:  MOVWF  xA8
06D42:  MOVLB  0
06D44:  CALL   5654
06D48:  MOVLW  10
06D4A:  MOVWF  FE9
06D4C:  MOVFF  26C,7A9
06D50:  MOVFF  26B,7A8
06D54:  CALL   5A5E
06D58:  MOVLW  0A
06D5A:  BTFSS  F9E.4
06D5C:  BRA    6D5A
06D5E:  MOVWF  FAD
06D60:  MOVLW  0D
06D62:  BTFSS  F9E.4
06D64:  BRA    6D62
06D66:  MOVWF  FAD
....................                             break; 
06D68:  BRA    6DBA
....................                     case 33: 
....................                            	BT_GetLastCMD();  // get the number from the third parameter. 
06D6A:  CALL   53BE
....................                             sysInput.DOpt3cal3of3 = atol(bt_cmd); 
06D6E:  MOVLB  7
06D70:  CLRF   xA9
06D72:  MOVLW  33
06D74:  MOVWF  xA8
06D76:  MOVLB  0
06D78:  CALL   587A
06D7C:  MOVFF  02,26E
06D80:  MOVFF  01,26D
....................                             fprintf(BT,"(DOpt9)  DOpt3cal3of3 set to %Lu\n\r",sysInput.DOpt3cal3of3);   
06D84:  MOVLW  38
06D86:  MOVWF  FF6
06D88:  MOVLW  0A
06D8A:  MOVWF  FF7
06D8C:  MOVLW  1D
06D8E:  MOVLB  7
06D90:  MOVWF  xA8
06D92:  MOVLB  0
06D94:  CALL   5654
06D98:  MOVLW  10
06D9A:  MOVWF  FE9
06D9C:  MOVFF  26E,7A9
06DA0:  MOVFF  26D,7A8
06DA4:  CALL   5A5E
06DA8:  MOVLW  0A
06DAA:  BTFSS  F9E.4
06DAC:  BRA    6DAA
06DAE:  MOVWF  FAD
06DB0:  MOVLW  0D
06DB2:  BTFSS  F9E.4
06DB4:  BRA    6DB2
06DB6:  MOVWF  FAD
....................                             break; 
06DB8:  BRA    6DBA
....................                     default: 
....................                         break; 
....................                 } 
....................                 
.................... 			    //debugnumber = 0;   // turns off the debuging command when exited.  Added July 23, 2015 
....................                 
....................                 
....................  			  // fprintf(BT,"Entering into first CAL routine.  Number %i\n\r",debugnumber); 
....................                break; 
06DBA:  GOTO   77AC
....................             case 3:  //this sets all of the calibrations values to defaults 
....................                 fprintf(BT,"Setting all calibration values to default.  Do a saveconfig to save it in EEPROM.\n\r"); 
06DBE:  MOVLW  5C
06DC0:  MOVWF  FF6
06DC2:  MOVLW  0A
06DC4:  MOVWF  FF7
06DC6:  CALL   1C32
....................                 sysInput.nh4pt1cal1of3 = 0; 
06DCA:  MOVLB  2
06DCC:  CLRF   x40
06DCE:  CLRF   x3F
....................                 sysInput.nh4pt1cal2of3 = 600; 
06DD0:  MOVLW  02
06DD2:  MOVWF  x42
06DD4:  MOVLW  58
06DD6:  MOVWF  x41
....................                 sysInput.nh4pt1cal3of3 = 1200; 
06DD8:  MOVLW  04
06DDA:  MOVWF  x44
06DDC:  MOVLW  B0
06DDE:  MOVWF  x43
....................                 sysInput.nh4pt2cal1of3 = 0; 
06DE0:  CLRF   x46
06DE2:  CLRF   x45
....................                 sysInput.nh4pt2cal2of3 = 0; 
06DE4:  CLRF   x48
06DE6:  CLRF   x47
....................                 sysInput.nh4pt2cal3of3 = 0; 
06DE8:  CLRF   x4A
06DEA:  CLRF   x49
....................                 sysInput.nh4pt3cal1of3 = 0; 
06DEC:  CLRF   x4C
06DEE:  CLRF   x4B
....................                 sysInput.nh4pt3cal2of3 = 0; 
06DF0:  CLRF   x4E
06DF2:  CLRF   x4D
....................                 sysInput.nh4pt3cal3of3 = 0; 
06DF4:  CLRF   x50
06DF6:  CLRF   x4F
....................                 sysInput.nh4pt1returnednumber = 2.5; 
06DF8:  CLRF   x54
06DFA:  CLRF   x53
06DFC:  MOVLW  20
06DFE:  MOVWF  x52
06E00:  MOVLW  80
06E02:  MOVWF  x51
....................                 sysInput.nh4pt2returnednumber = 75.0; 
06E04:  CLRF   x58
06E06:  CLRF   x57
06E08:  MOVLW  16
06E0A:  MOVWF  x56
06E0C:  MOVLW  85
06E0E:  MOVWF  x55
....................                 sysInput.nh4pt3returnednumber = 150.0; 
06E10:  CLRF   x5C
06E12:  CLRF   x5B
06E14:  MOVLW  16
06E16:  MOVWF  x5A
06E18:  MOVLW  86
06E1A:  MOVWF  x59
....................                 sysInput.Thermisterpt1returnednumber = 40.0; 
06E1C:  CLRF   x84
06E1E:  CLRF   x83
06E20:  MOVLW  20
06E22:  MOVWF  x82
06E24:  MOVLW  84
06E26:  MOVWF  x81
....................                 sysInput.Thermisterpt2returnednumber = 21.0; 
06E28:  CLRF   x88
06E2A:  CLRF   x87
06E2C:  MOVLW  28
06E2E:  MOVWF  x86
06E30:  MOVLW  83
06E32:  MOVWF  x85
....................                 sysInput.Thermisterpt3returnednumber = 0.0; 
06E34:  CLRF   x8C
06E36:  CLRF   x8B
06E38:  CLRF   x8A
06E3A:  CLRF   x89
....................                 sysInput.Thermisterpt1cal1of3 = 5000; 
06E3C:  MOVLW  13
06E3E:  MOVWF  x7C
06E40:  MOVLW  88
06E42:  MOVWF  x7B
....................                 sysInput.Thermisterpt1cal2of3 = 2500; 
06E44:  MOVLW  09
06E46:  MOVWF  x7E
06E48:  MOVLW  C4
06E4A:  MOVWF  x7D
....................                 sysInput.Thermisterpt1cal3of3 = 500; 
06E4C:  MOVLW  01
06E4E:  MOVWF  x80
06E50:  MOVLW  F4
06E52:  MOVWF  x7F
....................                break; 
06E54:  MOVLB  0
06E56:  GOTO   77AC
....................             case 4:     // showconfig    // the strcture is on the Master include file 
....................                 /* 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
....................  
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
....................                  */ 
....................                 fprintf(BT,"Current Calibrations\n\r");    
06E5A:  MOVLW  B0
06E5C:  MOVWF  FF6
06E5E:  MOVLW  0A
06E60:  MOVWF  FF7
06E62:  CALL   1C32
....................                 fprintf(BT,"phcallow = %f\n\r",sysInput.phcallow);  
06E66:  MOVLW  C8
06E68:  MOVWF  FF6
06E6A:  MOVLW  0A
06E6C:  MOVWF  FF7
06E6E:  MOVLW  0B
06E70:  MOVLB  7
06E72:  MOVWF  xA8
06E74:  MOVLB  0
06E76:  CALL   5654
06E7A:  MOVLW  89
06E7C:  MOVWF  FE9
06E7E:  MOVFF  236,7AB
06E82:  MOVFF  235,7AA
06E86:  MOVFF  234,7A9
06E8A:  MOVFF  233,7A8
06E8E:  MOVLW  02
06E90:  MOVLB  7
06E92:  MOVWF  xAC
06E94:  MOVLB  0
06E96:  CALL   567E
06E9A:  MOVLW  0A
06E9C:  BTFSS  F9E.4
06E9E:  BRA    6E9C
06EA0:  MOVWF  FAD
06EA2:  MOVLW  0D
06EA4:  BTFSS  F9E.4
06EA6:  BRA    6EA4
06EA8:  MOVWF  FAD
....................                 fprintf(BT,"phcalhigh = %f\n\r",sysInput.phcalhigh);  
06EAA:  MOVLW  D8
06EAC:  MOVWF  FF6
06EAE:  MOVLW  0A
06EB0:  MOVWF  FF7
06EB2:  MOVLW  0C
06EB4:  MOVLB  7
06EB6:  MOVWF  xA8
06EB8:  MOVLB  0
06EBA:  CALL   5654
06EBE:  MOVLW  89
06EC0:  MOVWF  FE9
06EC2:  MOVFF  23A,7AB
06EC6:  MOVFF  239,7AA
06ECA:  MOVFF  238,7A9
06ECE:  MOVFF  237,7A8
06ED2:  MOVLW  02
06ED4:  MOVLB  7
06ED6:  MOVWF  xAC
06ED8:  MOVLB  0
06EDA:  CALL   567E
06EDE:  MOVLW  0A
06EE0:  BTFSS  F9E.4
06EE2:  BRA    6EE0
06EE4:  MOVWF  FAD
06EE6:  MOVLW  0D
06EE8:  BTFSS  F9E.4
06EEA:  BRA    6EE8
06EEC:  MOVWF  FAD
....................                 fprintf(BT,"phnumberupper = %f\n\r",sysInput.phnumberupper);  
06EEE:  MOVLW  EA
06EF0:  MOVWF  FF6
06EF2:  MOVLW  0A
06EF4:  MOVWF  FF7
06EF6:  MOVLW  10
06EF8:  MOVLB  7
06EFA:  MOVWF  xA8
06EFC:  MOVLB  0
06EFE:  CALL   5654
06F02:  MOVLW  89
06F04:  MOVWF  FE9
06F06:  MOVFF  23E,7AB
06F0A:  MOVFF  23D,7AA
06F0E:  MOVFF  23C,7A9
06F12:  MOVFF  23B,7A8
06F16:  MOVLW  02
06F18:  MOVLB  7
06F1A:  MOVWF  xAC
06F1C:  MOVLB  0
06F1E:  CALL   567E
06F22:  MOVLW  0A
06F24:  BTFSS  F9E.4
06F26:  BRA    6F24
06F28:  MOVWF  FAD
06F2A:  MOVLW  0D
06F2C:  BTFSS  F9E.4
06F2E:  BRA    6F2C
06F30:  MOVWF  FAD
....................                  
....................                 fprintf(BT,"(nh4pt1) nh4pt1cal1of3 = %Lu\n\r",sysInput.nh4pt1cal1of3); 
06F32:  MOVLW  00
06F34:  MOVWF  FF6
06F36:  MOVLW  0B
06F38:  MOVWF  FF7
06F3A:  MOVLW  19
06F3C:  MOVLB  7
06F3E:  MOVWF  xA8
06F40:  MOVLB  0
06F42:  CALL   5654
06F46:  MOVLW  10
06F48:  MOVWF  FE9
06F4A:  MOVFF  240,7A9
06F4E:  MOVFF  23F,7A8
06F52:  CALL   5A5E
06F56:  MOVLW  0A
06F58:  BTFSS  F9E.4
06F5A:  BRA    6F58
06F5C:  MOVWF  FAD
06F5E:  MOVLW  0D
06F60:  BTFSS  F9E.4
06F62:  BRA    6F60
06F64:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt2) nh4pt1cal2of3 = %Lu\n\r",sysInput.nh4pt1cal2of3); 
06F66:  MOVLW  20
06F68:  MOVWF  FF6
06F6A:  MOVLW  0B
06F6C:  MOVWF  FF7
06F6E:  MOVLW  19
06F70:  MOVLB  7
06F72:  MOVWF  xA8
06F74:  MOVLB  0
06F76:  CALL   5654
06F7A:  MOVLW  10
06F7C:  MOVWF  FE9
06F7E:  MOVFF  242,7A9
06F82:  MOVFF  241,7A8
06F86:  CALL   5A5E
06F8A:  MOVLW  0A
06F8C:  BTFSS  F9E.4
06F8E:  BRA    6F8C
06F90:  MOVWF  FAD
06F92:  MOVLW  0D
06F94:  BTFSS  F9E.4
06F96:  BRA    6F94
06F98:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt3) nh4pt1cal3of3 = %Lu\n\r",sysInput.nh4pt1cal3of3); 
06F9A:  MOVLW  40
06F9C:  MOVWF  FF6
06F9E:  MOVLW  0B
06FA0:  MOVWF  FF7
06FA2:  MOVLW  19
06FA4:  MOVLB  7
06FA6:  MOVWF  xA8
06FA8:  MOVLB  0
06FAA:  CALL   5654
06FAE:  MOVLW  10
06FB0:  MOVWF  FE9
06FB2:  MOVFF  244,7A9
06FB6:  MOVFF  243,7A8
06FBA:  CALL   5A5E
06FBE:  MOVLW  0A
06FC0:  BTFSS  F9E.4
06FC2:  BRA    6FC0
06FC4:  MOVWF  FAD
06FC6:  MOVLW  0D
06FC8:  BTFSS  F9E.4
06FCA:  BRA    6FC8
06FCC:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt4) nh4pt2cal1of3 = %Lu\n\r",sysInput.nh4pt2cal1of3); 
06FCE:  MOVLW  60
06FD0:  MOVWF  FF6
06FD2:  MOVLW  0B
06FD4:  MOVWF  FF7
06FD6:  MOVLW  19
06FD8:  MOVLB  7
06FDA:  MOVWF  xA8
06FDC:  MOVLB  0
06FDE:  CALL   5654
06FE2:  MOVLW  10
06FE4:  MOVWF  FE9
06FE6:  MOVFF  246,7A9
06FEA:  MOVFF  245,7A8
06FEE:  CALL   5A5E
06FF2:  MOVLW  0A
06FF4:  BTFSS  F9E.4
06FF6:  BRA    6FF4
06FF8:  MOVWF  FAD
06FFA:  MOVLW  0D
06FFC:  BTFSS  F9E.4
06FFE:  BRA    6FFC
07000:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt5) nh4pt2cal2of3 = %Lu\n\r",sysInput.nh4pt2cal2of3); 
07002:  MOVLW  80
07004:  MOVWF  FF6
07006:  MOVLW  0B
07008:  MOVWF  FF7
0700A:  MOVLW  19
0700C:  MOVLB  7
0700E:  MOVWF  xA8
07010:  MOVLB  0
07012:  CALL   5654
07016:  MOVLW  10
07018:  MOVWF  FE9
0701A:  MOVFF  248,7A9
0701E:  MOVFF  247,7A8
07022:  CALL   5A5E
07026:  MOVLW  0A
07028:  BTFSS  F9E.4
0702A:  BRA    7028
0702C:  MOVWF  FAD
0702E:  MOVLW  0D
07030:  BTFSS  F9E.4
07032:  BRA    7030
07034:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt6) nh4pt2cal3of3 = %Lu\n\r",sysInput.nh4pt2cal3of3); 
07036:  MOVLW  A0
07038:  MOVWF  FF6
0703A:  MOVLW  0B
0703C:  MOVWF  FF7
0703E:  MOVLW  19
07040:  MOVLB  7
07042:  MOVWF  xA8
07044:  MOVLB  0
07046:  CALL   5654
0704A:  MOVLW  10
0704C:  MOVWF  FE9
0704E:  MOVFF  24A,7A9
07052:  MOVFF  249,7A8
07056:  CALL   5A5E
0705A:  MOVLW  0A
0705C:  BTFSS  F9E.4
0705E:  BRA    705C
07060:  MOVWF  FAD
07062:  MOVLW  0D
07064:  BTFSS  F9E.4
07066:  BRA    7064
07068:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt7) nh4pt3cal1of3 = %Lu\n\r",sysInput.nh4pt3cal1of3); 
0706A:  MOVLW  C0
0706C:  MOVWF  FF6
0706E:  MOVLW  0B
07070:  MOVWF  FF7
07072:  MOVLW  19
07074:  MOVLB  7
07076:  MOVWF  xA8
07078:  MOVLB  0
0707A:  CALL   5654
0707E:  MOVLW  10
07080:  MOVWF  FE9
07082:  MOVFF  24C,7A9
07086:  MOVFF  24B,7A8
0708A:  CALL   5A5E
0708E:  MOVLW  0A
07090:  BTFSS  F9E.4
07092:  BRA    7090
07094:  MOVWF  FAD
07096:  MOVLW  0D
07098:  BTFSS  F9E.4
0709A:  BRA    7098
0709C:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt8) nh4pt3cal2of3 = %Lu\n\r",sysInput.nh4pt3cal2of3); 
0709E:  MOVLW  E0
070A0:  MOVWF  FF6
070A2:  MOVLW  0B
070A4:  MOVWF  FF7
070A6:  MOVLW  19
070A8:  MOVLB  7
070AA:  MOVWF  xA8
070AC:  MOVLB  0
070AE:  CALL   5654
070B2:  MOVLW  10
070B4:  MOVWF  FE9
070B6:  MOVFF  24E,7A9
070BA:  MOVFF  24D,7A8
070BE:  CALL   5A5E
070C2:  MOVLW  0A
070C4:  BTFSS  F9E.4
070C6:  BRA    70C4
070C8:  MOVWF  FAD
070CA:  MOVLW  0D
070CC:  BTFSS  F9E.4
070CE:  BRA    70CC
070D0:  MOVWF  FAD
....................                 fprintf(BT,"(nh4pt9) nh4pt3cal3of3 = %Lu\n\r",sysInput.nh4pt3cal3of3);  
070D2:  MOVLW  00
070D4:  MOVWF  FF6
070D6:  MOVLW  0C
070D8:  MOVWF  FF7
070DA:  MOVLW  19
070DC:  MOVLB  7
070DE:  MOVWF  xA8
070E0:  MOVLB  0
070E2:  CALL   5654
070E6:  MOVLW  10
070E8:  MOVWF  FE9
070EA:  MOVFF  250,7A9
070EE:  MOVFF  24F,7A8
070F2:  CALL   5A5E
070F6:  MOVLW  0A
070F8:  BTFSS  F9E.4
070FA:  BRA    70F8
070FC:  MOVWF  FAD
070FE:  MOVLW  0D
07100:  BTFSS  F9E.4
07102:  BRA    7100
07104:  MOVWF  FAD
....................  
....................                 fprintf(BT,"(retnh41) nh4pt1returnednumber = %f\n\r",sysInput.nh4pt1returnednumber);  
07106:  MOVLW  20
07108:  MOVWF  FF6
0710A:  MOVLW  0C
0710C:  MOVWF  FF7
0710E:  MOVLW  21
07110:  MOVLB  7
07112:  MOVWF  xA8
07114:  MOVLB  0
07116:  CALL   5654
0711A:  MOVLW  89
0711C:  MOVWF  FE9
0711E:  MOVFF  254,7AB
07122:  MOVFF  253,7AA
07126:  MOVFF  252,7A9
0712A:  MOVFF  251,7A8
0712E:  MOVLW  02
07130:  MOVLB  7
07132:  MOVWF  xAC
07134:  MOVLB  0
07136:  CALL   567E
0713A:  MOVLW  0A
0713C:  BTFSS  F9E.4
0713E:  BRA    713C
07140:  MOVWF  FAD
07142:  MOVLW  0D
07144:  BTFSS  F9E.4
07146:  BRA    7144
07148:  MOVWF  FAD
....................                 fprintf(BT,"(retnh42) nh4pt2returnednumber = %f\n\r",sysInput.nh4pt2returnednumber);  
0714A:  MOVLW  46
0714C:  MOVWF  FF6
0714E:  MOVLW  0C
07150:  MOVWF  FF7
07152:  MOVLW  21
07154:  MOVLB  7
07156:  MOVWF  xA8
07158:  MOVLB  0
0715A:  CALL   5654
0715E:  MOVLW  89
07160:  MOVWF  FE9
07162:  MOVFF  258,7AB
07166:  MOVFF  257,7AA
0716A:  MOVFF  256,7A9
0716E:  MOVFF  255,7A8
07172:  MOVLW  02
07174:  MOVLB  7
07176:  MOVWF  xAC
07178:  MOVLB  0
0717A:  CALL   567E
0717E:  MOVLW  0A
07180:  BTFSS  F9E.4
07182:  BRA    7180
07184:  MOVWF  FAD
07186:  MOVLW  0D
07188:  BTFSS  F9E.4
0718A:  BRA    7188
0718C:  MOVWF  FAD
....................                 fprintf(BT,"(retnh43) nh4pt3returnednumber = %f\n\r",sysInput.nh4pt3returnednumber);   
0718E:  MOVLW  6C
07190:  MOVWF  FF6
07192:  MOVLW  0C
07194:  MOVWF  FF7
07196:  MOVLW  21
07198:  MOVLB  7
0719A:  MOVWF  xA8
0719C:  MOVLB  0
0719E:  CALL   5654
071A2:  MOVLW  89
071A4:  MOVWF  FE9
071A6:  MOVFF  25C,7AB
071AA:  MOVFF  25B,7AA
071AE:  MOVFF  25A,7A9
071B2:  MOVFF  259,7A8
071B6:  MOVLW  02
071B8:  MOVLB  7
071BA:  MOVWF  xAC
071BC:  MOVLB  0
071BE:  CALL   567E
071C2:  MOVLW  0A
071C4:  BTFSS  F9E.4
071C6:  BRA    71C4
071C8:  MOVWF  FAD
071CA:  MOVLW  0D
071CC:  BTFSS  F9E.4
071CE:  BRA    71CC
071D0:  MOVWF  FAD
....................                  
....................                 fprintf(BT,"(DOpt1) DOpt1cal1of3 = %Lu\n\r",sysInput.DOpt1cal1of3); 
071D2:  MOVLW  92
071D4:  MOVWF  FF6
071D6:  MOVLW  0C
071D8:  MOVWF  FF7
071DA:  MOVLW  17
071DC:  MOVLB  7
071DE:  MOVWF  xA8
071E0:  MOVLB  0
071E2:  CALL   5654
071E6:  MOVLW  10
071E8:  MOVWF  FE9
071EA:  MOVFF  25E,7A9
071EE:  MOVFF  25D,7A8
071F2:  CALL   5A5E
071F6:  MOVLW  0A
071F8:  BTFSS  F9E.4
071FA:  BRA    71F8
071FC:  MOVWF  FAD
071FE:  MOVLW  0D
07200:  BTFSS  F9E.4
07202:  BRA    7200
07204:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt2) DOpt1cal2of3 = %Lu\n\r",sysInput.DOpt1cal2of3); 
07206:  MOVLW  B0
07208:  MOVWF  FF6
0720A:  MOVLW  0C
0720C:  MOVWF  FF7
0720E:  MOVLW  17
07210:  MOVLB  7
07212:  MOVWF  xA8
07214:  MOVLB  0
07216:  CALL   5654
0721A:  MOVLW  10
0721C:  MOVWF  FE9
0721E:  MOVFF  260,7A9
07222:  MOVFF  25F,7A8
07226:  CALL   5A5E
0722A:  MOVLW  0A
0722C:  BTFSS  F9E.4
0722E:  BRA    722C
07230:  MOVWF  FAD
07232:  MOVLW  0D
07234:  BTFSS  F9E.4
07236:  BRA    7234
07238:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt3) DOpt1cal3of3 = %Lu\n\r",sysInput.DOpt1cal3of3); 
0723A:  MOVLW  CE
0723C:  MOVWF  FF6
0723E:  MOVLW  0C
07240:  MOVWF  FF7
07242:  MOVLW  17
07244:  MOVLB  7
07246:  MOVWF  xA8
07248:  MOVLB  0
0724A:  CALL   5654
0724E:  MOVLW  10
07250:  MOVWF  FE9
07252:  MOVFF  262,7A9
07256:  MOVFF  261,7A8
0725A:  CALL   5A5E
0725E:  MOVLW  0A
07260:  BTFSS  F9E.4
07262:  BRA    7260
07264:  MOVWF  FAD
07266:  MOVLW  0D
07268:  BTFSS  F9E.4
0726A:  BRA    7268
0726C:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt4) DOpt2cal1of3 = %Lu\n\r",sysInput.DOpt2cal1of3); 
0726E:  MOVLW  EC
07270:  MOVWF  FF6
07272:  MOVLW  0C
07274:  MOVWF  FF7
07276:  MOVLW  17
07278:  MOVLB  7
0727A:  MOVWF  xA8
0727C:  MOVLB  0
0727E:  CALL   5654
07282:  MOVLW  10
07284:  MOVWF  FE9
07286:  MOVFF  264,7A9
0728A:  MOVFF  263,7A8
0728E:  CALL   5A5E
07292:  MOVLW  0A
07294:  BTFSS  F9E.4
07296:  BRA    7294
07298:  MOVWF  FAD
0729A:  MOVLW  0D
0729C:  BTFSS  F9E.4
0729E:  BRA    729C
072A0:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt5) DOpt2cal2of3 = %Lu\n\r",sysInput.DOpt2cal2of3); 
072A2:  MOVLW  0A
072A4:  MOVWF  FF6
072A6:  MOVLW  0D
072A8:  MOVWF  FF7
072AA:  MOVLW  17
072AC:  MOVLB  7
072AE:  MOVWF  xA8
072B0:  MOVLB  0
072B2:  CALL   5654
072B6:  MOVLW  10
072B8:  MOVWF  FE9
072BA:  MOVFF  266,7A9
072BE:  MOVFF  265,7A8
072C2:  CALL   5A5E
072C6:  MOVLW  0A
072C8:  BTFSS  F9E.4
072CA:  BRA    72C8
072CC:  MOVWF  FAD
072CE:  MOVLW  0D
072D0:  BTFSS  F9E.4
072D2:  BRA    72D0
072D4:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt6) DOpt2cal3of3 = %Lu\n\r",sysInput.DOpt2cal3of3); 
072D6:  MOVLW  28
072D8:  MOVWF  FF6
072DA:  MOVLW  0D
072DC:  MOVWF  FF7
072DE:  MOVLW  17
072E0:  MOVLB  7
072E2:  MOVWF  xA8
072E4:  MOVLB  0
072E6:  CALL   5654
072EA:  MOVLW  10
072EC:  MOVWF  FE9
072EE:  MOVFF  268,7A9
072F2:  MOVFF  267,7A8
072F6:  CALL   5A5E
072FA:  MOVLW  0A
072FC:  BTFSS  F9E.4
072FE:  BRA    72FC
07300:  MOVWF  FAD
07302:  MOVLW  0D
07304:  BTFSS  F9E.4
07306:  BRA    7304
07308:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt7) DOpt3cal1of3 = %Lu\n\r",sysInput.DOpt3cal1of3); 
0730A:  MOVLW  46
0730C:  MOVWF  FF6
0730E:  MOVLW  0D
07310:  MOVWF  FF7
07312:  MOVLW  17
07314:  MOVLB  7
07316:  MOVWF  xA8
07318:  MOVLB  0
0731A:  CALL   5654
0731E:  MOVLW  10
07320:  MOVWF  FE9
07322:  MOVFF  26A,7A9
07326:  MOVFF  269,7A8
0732A:  CALL   5A5E
0732E:  MOVLW  0A
07330:  BTFSS  F9E.4
07332:  BRA    7330
07334:  MOVWF  FAD
07336:  MOVLW  0D
07338:  BTFSS  F9E.4
0733A:  BRA    7338
0733C:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt8) DOpt3cal2of3 = %Lu\n\r",sysInput.DOpt3cal2of3); 
0733E:  MOVLW  64
07340:  MOVWF  FF6
07342:  MOVLW  0D
07344:  MOVWF  FF7
07346:  MOVLW  17
07348:  MOVLB  7
0734A:  MOVWF  xA8
0734C:  MOVLB  0
0734E:  CALL   5654
07352:  MOVLW  10
07354:  MOVWF  FE9
07356:  MOVFF  26C,7A9
0735A:  MOVFF  26B,7A8
0735E:  CALL   5A5E
07362:  MOVLW  0A
07364:  BTFSS  F9E.4
07366:  BRA    7364
07368:  MOVWF  FAD
0736A:  MOVLW  0D
0736C:  BTFSS  F9E.4
0736E:  BRA    736C
07370:  MOVWF  FAD
....................                 fprintf(BT,"(DOpt9) DOpt3cal3of3 = %Lu\n\r",sysInput.DOpt3cal3of3);  
07372:  MOVLW  82
07374:  MOVWF  FF6
07376:  MOVLW  0D
07378:  MOVWF  FF7
0737A:  MOVLW  17
0737C:  MOVLB  7
0737E:  MOVWF  xA8
07380:  MOVLB  0
07382:  CALL   5654
07386:  MOVLW  10
07388:  MOVWF  FE9
0738A:  MOVFF  26E,7A9
0738E:  MOVFF  26D,7A8
07392:  CALL   5A5E
07396:  MOVLW  0A
07398:  BTFSS  F9E.4
0739A:  BRA    7398
0739C:  MOVWF  FAD
0739E:  MOVLW  0D
073A0:  BTFSS  F9E.4
073A2:  BRA    73A0
073A4:  MOVWF  FAD
....................                  
....................                 fprintf(BT,"(DOret1) DOpt1returnednumber = %f\n\r",sysInput.DOpt1returnednumber);  
073A6:  MOVLW  A0
073A8:  MOVWF  FF6
073AA:  MOVLW  0D
073AC:  MOVWF  FF7
073AE:  MOVLW  1F
073B0:  MOVLB  7
073B2:  MOVWF  xA8
073B4:  MOVLB  0
073B6:  CALL   5654
073BA:  MOVLW  89
073BC:  MOVWF  FE9
073BE:  MOVFF  272,7AB
073C2:  MOVFF  271,7AA
073C6:  MOVFF  270,7A9
073CA:  MOVFF  26F,7A8
073CE:  MOVLW  02
073D0:  MOVLB  7
073D2:  MOVWF  xAC
073D4:  MOVLB  0
073D6:  CALL   567E
073DA:  MOVLW  0A
073DC:  BTFSS  F9E.4
073DE:  BRA    73DC
073E0:  MOVWF  FAD
073E2:  MOVLW  0D
073E4:  BTFSS  F9E.4
073E6:  BRA    73E4
073E8:  MOVWF  FAD
....................                 fprintf(BT,"(DOret) DOpt2returnednumber = %f\n\r",sysInput.DOpt2returnednumber);  
073EA:  MOVLW  C4
073EC:  MOVWF  FF6
073EE:  MOVLW  0D
073F0:  MOVWF  FF7
073F2:  MOVLW  1E
073F4:  MOVLB  7
073F6:  MOVWF  xA8
073F8:  MOVLB  0
073FA:  CALL   5654
073FE:  MOVLW  89
07400:  MOVWF  FE9
07402:  MOVFF  276,7AB
07406:  MOVFF  275,7AA
0740A:  MOVFF  274,7A9
0740E:  MOVFF  273,7A8
07412:  MOVLW  02
07414:  MOVLB  7
07416:  MOVWF  xAC
07418:  MOVLB  0
0741A:  CALL   567E
0741E:  MOVLW  0A
07420:  BTFSS  F9E.4
07422:  BRA    7420
07424:  MOVWF  FAD
07426:  MOVLW  0D
07428:  BTFSS  F9E.4
0742A:  BRA    7428
0742C:  MOVWF  FAD
....................                 fprintf(BT,"(DOret3) DOpt3returnednumber = %f\n\r",sysInput.DOpt3returnednumber);    
0742E:  MOVLW  E8
07430:  MOVWF  FF6
07432:  MOVLW  0D
07434:  MOVWF  FF7
07436:  MOVLW  1F
07438:  MOVLB  7
0743A:  MOVWF  xA8
0743C:  MOVLB  0
0743E:  CALL   5654
07442:  MOVLW  89
07444:  MOVWF  FE9
07446:  MOVFF  27A,7AB
0744A:  MOVFF  279,7AA
0744E:  MOVFF  278,7A9
07452:  MOVFF  277,7A8
07456:  MOVLW  02
07458:  MOVLB  7
0745A:  MOVWF  xAC
0745C:  MOVLB  0
0745E:  CALL   567E
07462:  MOVLW  0A
07464:  BTFSS  F9E.4
07466:  BRA    7464
07468:  MOVWF  FAD
0746A:  MOVLW  0D
0746C:  BTFSS  F9E.4
0746E:  BRA    746C
07470:  MOVWF  FAD
....................                  
....................                 fprintf(BT,"(THpt1) Thermisterpt1cal1of3 = %Lu\n\r",sysInput.Thermisterpt1cal1of3); 
07472:  MOVLW  0C
07474:  MOVWF  FF6
07476:  MOVLW  0E
07478:  MOVWF  FF7
0747A:  MOVLW  1F
0747C:  MOVLB  7
0747E:  MOVWF  xA8
07480:  MOVLB  0
07482:  CALL   5654
07486:  MOVLW  10
07488:  MOVWF  FE9
0748A:  MOVFF  27C,7A9
0748E:  MOVFF  27B,7A8
07492:  CALL   5A5E
07496:  MOVLW  0A
07498:  BTFSS  F9E.4
0749A:  BRA    7498
0749C:  MOVWF  FAD
0749E:  MOVLW  0D
074A0:  BTFSS  F9E.4
074A2:  BRA    74A0
074A4:  MOVWF  FAD
....................                 fprintf(BT,"(THpt2) Thermisterpt2cal1of3 = %Lu\n\r",sysInput.Thermisterpt1cal2of3); 
074A6:  MOVLW  32
074A8:  MOVWF  FF6
074AA:  MOVLW  0E
074AC:  MOVWF  FF7
074AE:  MOVLW  1F
074B0:  MOVLB  7
074B2:  MOVWF  xA8
074B4:  MOVLB  0
074B6:  CALL   5654
074BA:  MOVLW  10
074BC:  MOVWF  FE9
074BE:  MOVFF  27E,7A9
074C2:  MOVFF  27D,7A8
074C6:  CALL   5A5E
074CA:  MOVLW  0A
074CC:  BTFSS  F9E.4
074CE:  BRA    74CC
074D0:  MOVWF  FAD
074D2:  MOVLW  0D
074D4:  BTFSS  F9E.4
074D6:  BRA    74D4
074D8:  MOVWF  FAD
....................                 fprintf(BT,"(THpt3) Thermisterpt3cal1of3 = %Lu\n\r",sysInput.Thermisterpt1cal3of3);  
074DA:  MOVLW  58
074DC:  MOVWF  FF6
074DE:  MOVLW  0E
074E0:  MOVWF  FF7
074E2:  MOVLW  1F
074E4:  MOVLB  7
074E6:  MOVWF  xA8
074E8:  MOVLB  0
074EA:  CALL   5654
074EE:  MOVLW  10
074F0:  MOVWF  FE9
074F2:  MOVFF  280,7A9
074F6:  MOVFF  27F,7A8
074FA:  CALL   5A5E
074FE:  MOVLW  0A
07500:  BTFSS  F9E.4
07502:  BRA    7500
07504:  MOVWF  FAD
07506:  MOVLW  0D
07508:  BTFSS  F9E.4
0750A:  BRA    7508
0750C:  MOVWF  FAD
....................   
....................                 fprintf(BT,"(THret1) Thermisterpt1returnednumber = %f\n\r",sysInput.Thermisterpt1returnednumber);  
0750E:  MOVLW  7E
07510:  MOVWF  FF6
07512:  MOVLW  0E
07514:  MOVWF  FF7
07516:  MOVLW  27
07518:  MOVLB  7
0751A:  MOVWF  xA8
0751C:  MOVLB  0
0751E:  CALL   5654
07522:  MOVLW  89
07524:  MOVWF  FE9
07526:  MOVFF  284,7AB
0752A:  MOVFF  283,7AA
0752E:  MOVFF  282,7A9
07532:  MOVFF  281,7A8
07536:  MOVLW  02
07538:  MOVLB  7
0753A:  MOVWF  xAC
0753C:  MOVLB  0
0753E:  CALL   567E
07542:  MOVLW  0A
07544:  BTFSS  F9E.4
07546:  BRA    7544
07548:  MOVWF  FAD
0754A:  MOVLW  0D
0754C:  BTFSS  F9E.4
0754E:  BRA    754C
07550:  MOVWF  FAD
....................                 fprintf(BT,"(THret2) Thermisterpt2returnednumber = %f\n\r",sysInput.Thermisterpt2returnednumber);  
07552:  MOVLW  AA
07554:  MOVWF  FF6
07556:  MOVLW  0E
07558:  MOVWF  FF7
0755A:  MOVLW  27
0755C:  MOVLB  7
0755E:  MOVWF  xA8
07560:  MOVLB  0
07562:  CALL   5654
07566:  MOVLW  89
07568:  MOVWF  FE9
0756A:  MOVFF  288,7AB
0756E:  MOVFF  287,7AA
07572:  MOVFF  286,7A9
07576:  MOVFF  285,7A8
0757A:  MOVLW  02
0757C:  MOVLB  7
0757E:  MOVWF  xAC
07580:  MOVLB  0
07582:  CALL   567E
07586:  MOVLW  0A
07588:  BTFSS  F9E.4
0758A:  BRA    7588
0758C:  MOVWF  FAD
0758E:  MOVLW  0D
07590:  BTFSS  F9E.4
07592:  BRA    7590
07594:  MOVWF  FAD
....................                 fprintf(BT,"(THret3) Thermisterpt3returnednumber = %f\n\r",sysInput.Thermisterpt3returnednumber);    
07596:  MOVLW  D6
07598:  MOVWF  FF6
0759A:  MOVLW  0E
0759C:  MOVWF  FF7
0759E:  MOVLW  27
075A0:  MOVLB  7
075A2:  MOVWF  xA8
075A4:  MOVLB  0
075A6:  CALL   5654
075AA:  MOVLW  89
075AC:  MOVWF  FE9
075AE:  MOVFF  28C,7AB
075B2:  MOVFF  28B,7AA
075B6:  MOVFF  28A,7A9
075BA:  MOVFF  289,7A8
075BE:  MOVLW  02
075C0:  MOVLB  7
075C2:  MOVWF  xAC
075C4:  MOVLB  0
075C6:  CALL   567E
075CA:  MOVLW  0A
075CC:  BTFSS  F9E.4
075CE:  BRA    75CC
075D0:  MOVWF  FAD
075D2:  MOVLW  0D
075D4:  BTFSS  F9E.4
075D6:  BRA    75D4
075D8:  MOVWF  FAD
....................             
....................                 fprintf(BT,"eccal1x = %f\n\r",sysInput.eccal1x);  
075DA:  MOVLW  02
075DC:  MOVWF  FF6
075DE:  MOVLW  0F
075E0:  MOVWF  FF7
075E2:  MOVLW  0A
075E4:  MOVLB  7
075E6:  MOVWF  xA8
075E8:  MOVLB  0
075EA:  CALL   5654
075EE:  MOVLW  89
075F0:  MOVWF  FE9
075F2:  MOVFF  290,7AB
075F6:  MOVFF  28F,7AA
075FA:  MOVFF  28E,7A9
075FE:  MOVFF  28D,7A8
07602:  MOVLW  02
07604:  MOVLB  7
07606:  MOVWF  xAC
07608:  MOVLB  0
0760A:  CALL   567E
0760E:  MOVLW  0A
07610:  BTFSS  F9E.4
07612:  BRA    7610
07614:  MOVWF  FAD
07616:  MOVLW  0D
07618:  BTFSS  F9E.4
0761A:  BRA    7618
0761C:  MOVWF  FAD
....................                 fprintf(BT,"eccal2x = %f\n\r",sysInput.eccal2x);  
0761E:  MOVLW  12
07620:  MOVWF  FF6
07622:  MOVLW  0F
07624:  MOVWF  FF7
07626:  MOVLW  0A
07628:  MOVLB  7
0762A:  MOVWF  xA8
0762C:  MOVLB  0
0762E:  CALL   5654
07632:  MOVLW  89
07634:  MOVWF  FE9
07636:  MOVFF  294,7AB
0763A:  MOVFF  293,7AA
0763E:  MOVFF  292,7A9
07642:  MOVFF  291,7A8
07646:  MOVLW  02
07648:  MOVLB  7
0764A:  MOVWF  xAC
0764C:  MOVLB  0
0764E:  CALL   567E
07652:  MOVLW  0A
07654:  BTFSS  F9E.4
07656:  BRA    7654
07658:  MOVWF  FAD
0765A:  MOVLW  0D
0765C:  BTFSS  F9E.4
0765E:  BRA    765C
07660:  MOVWF  FAD
....................                 fprintf(BT,"eccal3x = %f\n\r",sysInput.eccal3x);  
07662:  MOVLW  22
07664:  MOVWF  FF6
07666:  MOVLW  0F
07668:  MOVWF  FF7
0766A:  MOVLW  0A
0766C:  MOVLB  7
0766E:  MOVWF  xA8
07670:  MOVLB  0
07672:  CALL   5654
07676:  MOVLW  89
07678:  MOVWF  FE9
0767A:  MOVFF  298,7AB
0767E:  MOVFF  297,7AA
07682:  MOVFF  296,7A9
07686:  MOVFF  295,7A8
0768A:  MOVLW  02
0768C:  MOVLB  7
0768E:  MOVWF  xAC
07690:  MOVLB  0
07692:  CALL   567E
07696:  MOVLW  0A
07698:  BTFSS  F9E.4
0769A:  BRA    7698
0769C:  MOVWF  FAD
0769E:  MOVLW  0D
076A0:  BTFSS  F9E.4
076A2:  BRA    76A0
076A4:  MOVWF  FAD
....................                  
....................                 fprintf(BT,"eccal1y = %f\n\r",sysInput.eccal1y);  
076A6:  MOVLW  32
076A8:  MOVWF  FF6
076AA:  MOVLW  0F
076AC:  MOVWF  FF7
076AE:  MOVLW  0A
076B0:  MOVLB  7
076B2:  MOVWF  xA8
076B4:  MOVLB  0
076B6:  CALL   5654
076BA:  MOVLW  89
076BC:  MOVWF  FE9
076BE:  MOVFF  29C,7AB
076C2:  MOVFF  29B,7AA
076C6:  MOVFF  29A,7A9
076CA:  MOVFF  299,7A8
076CE:  MOVLW  02
076D0:  MOVLB  7
076D2:  MOVWF  xAC
076D4:  MOVLB  0
076D6:  CALL   567E
076DA:  MOVLW  0A
076DC:  BTFSS  F9E.4
076DE:  BRA    76DC
076E0:  MOVWF  FAD
076E2:  MOVLW  0D
076E4:  BTFSS  F9E.4
076E6:  BRA    76E4
076E8:  MOVWF  FAD
....................                 fprintf(BT,"eccal2y = %f\n\r",sysInput.eccal2y);  
076EA:  MOVLW  42
076EC:  MOVWF  FF6
076EE:  MOVLW  0F
076F0:  MOVWF  FF7
076F2:  MOVLW  0A
076F4:  MOVLB  7
076F6:  MOVWF  xA8
076F8:  MOVLB  0
076FA:  CALL   5654
076FE:  MOVLW  89
07700:  MOVWF  FE9
07702:  MOVFF  2A0,7AB
07706:  MOVFF  29F,7AA
0770A:  MOVFF  29E,7A9
0770E:  MOVFF  29D,7A8
07712:  MOVLW  02
07714:  MOVLB  7
07716:  MOVWF  xAC
07718:  MOVLB  0
0771A:  CALL   567E
0771E:  MOVLW  0A
07720:  BTFSS  F9E.4
07722:  BRA    7720
07724:  MOVWF  FAD
07726:  MOVLW  0D
07728:  BTFSS  F9E.4
0772A:  BRA    7728
0772C:  MOVWF  FAD
....................                 fprintf(BT,"eccal3y = %f\n\r",sysInput.eccal3y);   
0772E:  MOVLW  52
07730:  MOVWF  FF6
07732:  MOVLW  0F
07734:  MOVWF  FF7
07736:  MOVLW  0A
07738:  MOVLB  7
0773A:  MOVWF  xA8
0773C:  MOVLB  0
0773E:  CALL   5654
07742:  MOVLW  89
07744:  MOVWF  FE9
07746:  MOVFF  2A4,7AB
0774A:  MOVFF  2A3,7AA
0774E:  MOVFF  2A2,7A9
07752:  MOVFF  2A1,7A8
07756:  MOVLW  02
07758:  MOVLB  7
0775A:  MOVWF  xAC
0775C:  MOVLB  0
0775E:  CALL   567E
07762:  MOVLW  0A
07764:  BTFSS  F9E.4
07766:  BRA    7764
07768:  MOVWF  FAD
0776A:  MOVLW  0D
0776C:  BTFSS  F9E.4
0776E:  BRA    776C
07770:  MOVWF  FAD
....................                 break; 
07772:  BRA    77AC
....................             case 5:   // saveconfig 
....................                 fprintf(BT,"Saving Calibrations into EEPROM\n\r");  
07774:  MOVLW  62
07776:  MOVWF  FF6
07778:  MOVLW  0F
0777A:  MOVWF  FF7
0777C:  CALL   1C32
....................                 SaveConfiguration(); 
07780:  GOTO   5B74
....................                 break; 
07784:  BRA    77AC
....................             case 6:   //  update 
....................                 startupdate = 1;  // this sets the flag to do an update to the remote unit when all data polling is completed. 
07786:  MOVLW  01
07788:  MOVLB  2
0778A:  MOVWF  x28
....................                 fprintf(BT,"Completing last polling before updating\n\r"); 
0778C:  MOVLW  84
0778E:  MOVWF  FF6
07790:  MOVLW  0F
07792:  MOVWF  FF7
07794:  MOVLB  0
07796:  CALL   1C32
....................                 break; 
0779A:  BRA    77AC
....................             case 7: 
....................                 reset_cpu(); 
0779C:  RESET
....................                 break; 
0779E:  BRA    77AC
....................             default: 
....................            //    fprintf(BT,"\r\nUnknown Command '%s', use 'help' or '?' to get list of commands\n\r", SplitResult[0][0]); 
....................                fprintf(BT,"\r\n>"); 
077A0:  MOVLW  AE
077A2:  MOVWF  FF6
077A4:  MOVLW  0F
077A6:  MOVWF  FF7
077A8:  CALL   1C32
....................                break; 
....................                 
....................          } 
....................      
.................... 	return(0); 
077AC:  MOVLW  00
077AE:  MOVWF  01
077B0:  GOTO   7830 (RETURN)
.................... 	} 
....................  
....................  
.................... #include "G:\Osmobot4PostProduction\Instrumentation\CheapRHAndTemp.c" 
.................... #ifdef TESTER 
.................... //****************************************************************************** 
.................... // Created Jan 12, 2017 
.................... // This routine gets the current model number and serial number of the HDC1080 RH/Temp chip.   
.................... // Returned values are valid if the function returns a zero. 
.................... // The RH and Temp is saved in the normal OUTPUT varaibles if the devices is attached to the usnit. 
.................... // The index is used to select the RJ45 port needed.   
.................... // For this set of boards, it's set to one port as a default.  It still needs to be called with the default value in place. 
.................... //****************************************************************************** 
.................... int16 GetHDC1080Version(int index) 
.................... { 
....................     int16 version, tempver; 
.................... #ifndef COTWOSENSOR 
.................... 	selectsensor(index);   // make the selection to talk with this sensor. 
*
0372C:  MOVFF  7AF,7B4
03730:  RCALL  3608
.................... #endif 
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
....................  
.................... 	i2c_start(PH_LIGHT); 
03732:  BSF    F93.0
03734:  MOVLW  50
03736:  MOVWF  00
03738:  DECFSZ 00,F
0373A:  BRA    3738
0373C:  BSF    F93.1
0373E:  MOVLW  51
03740:  MOVWF  00
03742:  DECFSZ 00,F
03744:  BRA    3742
03746:  BCF    F8A.0
03748:  BCF    F93.0
0374A:  MOVLW  50
0374C:  MOVWF  00
0374E:  DECFSZ 00,F
03750:  BRA    374E
03752:  BCF    F8A.1
03754:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
03756:  MOVLW  80
03758:  MOVLB  7
0375A:  MOVWF  xB4
0375C:  MOVLB  0
0375E:  RCALL  364C
.................... 	i2c_write(PH_LIGHT,0xFF);  //Send the command for reading the version 
03760:  MOVLB  7
03762:  SETF   xB4
03764:  MOVLB  0
03766:  RCALL  364C
.................... 	i2c_stop(PH_LIGHT); 
03768:  BCF    F93.0
0376A:  NOP   
0376C:  BSF    F93.1
0376E:  BTFSS  F81.1
03770:  BRA    376E
03772:  MOVLW  50
03774:  MOVWF  00
03776:  DECFSZ 00,F
03778:  BRA    3776
0377A:  BRA    377C
0377C:  NOP   
0377E:  BSF    F93.0
03780:  MOVLW  50
03782:  MOVWF  00
03784:  DECFSZ 00,F
03786:  BRA    3784
....................     i2c_start(PH_LIGHT); 
03788:  BSF    F93.0
0378A:  MOVLW  50
0378C:  MOVWF  00
0378E:  DECFSZ 00,F
03790:  BRA    378E
03792:  BSF    F93.1
03794:  MOVLW  51
03796:  MOVWF  00
03798:  DECFSZ 00,F
0379A:  BRA    3798
0379C:  BCF    F8A.0
0379E:  BCF    F93.0
037A0:  MOVLW  50
037A2:  MOVWF  00
037A4:  DECFSZ 00,F
037A6:  BRA    37A4
037A8:  BCF    F8A.1
037AA:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x81);  //Move the address number left on and add a one to make is a read command. 
037AC:  MOVLW  81
037AE:  MOVLB  7
037B0:  MOVWF  xB4
037B2:  MOVLB  0
037B4:  RCALL  364C
.................... 	tempver = i2c_read(PH_LIGHT); 
037B6:  MOVLW  01
037B8:  MOVWF  00
037BA:  RCALL  36C2
037BC:  MOVLB  7
037BE:  CLRF   xB3
037C0:  MOVFF  01,7B2
....................     version = i2c_read(PH_LIGHT); 
037C4:  MOVLW  01
037C6:  MOVWF  00
037C8:  MOVLB  0
037CA:  RCALL  36C2
037CC:  MOVLB  7
037CE:  CLRF   xB1
037D0:  MOVFF  01,7B0
.................... 	i2c_stop(PH_LIGHT); 
037D4:  BCF    F93.0
037D6:  NOP   
037D8:  BSF    F93.1
037DA:  BTFSS  F81.1
037DC:  BRA    37DA
037DE:  MOVLW  50
037E0:  MOVWF  00
037E2:  DECFSZ 00,F
037E4:  BRA    37E2
037E6:  BRA    37E8
037E8:  NOP   
037EA:  BSF    F93.0
037EC:  MOVLW  50
037EE:  MOVWF  00
037F0:  DECFSZ 00,F
037F2:  BRA    37F0
....................      version = version + (tempver<<8); 
037F4:  MOVLW  00
037F6:  ADDWF  xB0,F
037F8:  MOVF   xB2,W
037FA:  ADDWFC xB1,F
....................     return(version); 
037FC:  MOVFF  7B0,01
03800:  MOVFF  7B1,02
03804:  MOVLB  0
03806:  RETURN 0
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Jan 13, 2017 
.................... // This routine inits the HDC1080 RH/Temp chip.   
.................... // No returned value.  Sets all measurements to max resolution which is 14 bits 
.................... // The index is used to select the RJ45 port needed.   
.................... // For this set of boards, it's set to one port as a default.  It still needs to be called with the default value in place. 
.................... //****************************************************************************** 
.................... void GetHDC1080init(int index) 
.................... { 
....................     int version, tempver; 
....................  
.................... #ifndef COTWOSENSOR 
.................... 	selectsensor(index);   // make the selection to talk with this sensor. 
*
03EB2:  MOVFF  79D,7B4
03EB6:  CALL   3608
.................... #endif 
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
....................     // set the configuration register 
.................... 	i2c_start(PH_LIGHT); 
03EBA:  BSF    F93.0
03EBC:  MOVLW  50
03EBE:  MOVWF  00
03EC0:  DECFSZ 00,F
03EC2:  BRA    3EC0
03EC4:  BSF    F93.1
03EC6:  MOVLW  51
03EC8:  MOVWF  00
03ECA:  DECFSZ 00,F
03ECC:  BRA    3ECA
03ECE:  BCF    F8A.0
03ED0:  BCF    F93.0
03ED2:  MOVLW  50
03ED4:  MOVWF  00
03ED6:  DECFSZ 00,F
03ED8:  BRA    3ED6
03EDA:  BCF    F8A.1
03EDC:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
03EDE:  MOVLW  80
03EE0:  MOVLB  7
03EE2:  MOVWF  xB4
03EE4:  MOVLB  0
03EE6:  CALL   364C
.................... 	i2c_write(PH_LIGHT,0x02);  //Point the next two  bytes to the command register. 
03EEA:  MOVLW  02
03EEC:  MOVLB  7
03EEE:  MOVWF  xB4
03EF0:  MOVLB  0
03EF2:  CALL   364C
....................     i2c_write(PH_LIGHT,0x00);  // Send the MSB first.  In this case it is the default witch is 14 bits 
03EF6:  MOVLB  7
03EF8:  CLRF   xB4
03EFA:  MOVLB  0
03EFC:  CALL   364C
.................... 	i2c_write(PH_LIGHT,0x00);  //Send the configuration LSB 
03F00:  MOVLB  7
03F02:  CLRF   xB4
03F04:  MOVLB  0
03F06:  CALL   364C
.................... 	i2c_stop(PH_LIGHT); 
03F0A:  BCF    F93.0
03F0C:  NOP   
03F0E:  BSF    F93.1
03F10:  BTFSS  F81.1
03F12:  BRA    3F10
03F14:  MOVLW  50
03F16:  MOVWF  00
03F18:  DECFSZ 00,F
03F1A:  BRA    3F18
03F1C:  BRA    3F1E
03F1E:  NOP   
03F20:  BSF    F93.0
03F22:  MOVLW  50
03F24:  MOVWF  00
03F26:  DECFSZ 00,F
03F28:  BRA    3F26
....................     delay_ms(45);  //This is the time it takes to get the first measurement 
03F2A:  MOVLW  2D
03F2C:  MOVLB  7
03F2E:  MOVWF  xC1
03F30:  MOVLB  0
03F32:  CALL   1202
03F36:  GOTO   3F40 (RETURN)
....................       
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Jan 11, 2017 
.................... // This routine gets the current reading of the HDC1080 RH/Temp chip.   
.................... // Returned values are valid if the runction returns a zero. 
.................... // The RH and Temp is saved in the normal OUTPUT varaibles if the devices is attached to the usnit. 
.................... // The index is used to select the RJ45 port needed.   
.................... // For this set of boards, it's set to one port as a default.  It still needs to be called with the default value in place. 
.................... //****************************************************************************** 
.................... float GetHDC1080RHTemp(int index) 
.................... { 
....................     unsigned int8 temphigh,templow,rhhigh, rhlow; 
....................     float t,h; 
....................     //int th,tl,hh,hl; 
....................     GetHDC1080init(index); 
03F3A:  MOVFF  790,79D
03F3E:  BRA    3EB2
.................... #ifndef COTWOSENSOR 
.................... 	selectsensor(index);   // make the selection to talk with this sensor. 
03F40:  MOVFF  790,7B4
03F44:  CALL   3608
.................... #endif 
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
.................... // trigger tempeerature  measurement 
.................... 	i2c_start(PH_LIGHT); 
03F48:  BSF    F93.0
03F4A:  MOVLW  50
03F4C:  MOVWF  00
03F4E:  DECFSZ 00,F
03F50:  BRA    3F4E
03F52:  BSF    F93.1
03F54:  MOVLW  51
03F56:  MOVWF  00
03F58:  DECFSZ 00,F
03F5A:  BRA    3F58
03F5C:  BCF    F8A.0
03F5E:  BCF    F93.0
03F60:  MOVLW  50
03F62:  MOVWF  00
03F64:  DECFSZ 00,F
03F66:  BRA    3F64
03F68:  BCF    F8A.1
03F6A:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
03F6C:  MOVLW  80
03F6E:  MOVLB  7
03F70:  MOVWF  xB4
03F72:  MOVLB  0
03F74:  CALL   364C
.................... 	i2c_write(PH_LIGHT,0x00);  //Send the command for reading the version 
03F78:  MOVLB  7
03F7A:  CLRF   xB4
03F7C:  MOVLB  0
03F7E:  CALL   364C
.................... //	i2c_stop(PH_LIGHT); 
....................     delay_ms(20);   // wait for measurement 
03F82:  MOVLW  14
03F84:  MOVLB  7
03F86:  MOVWF  xC1
03F88:  MOVLB  0
03F8A:  CALL   1202
....................      
....................      
....................      
....................  //   Start over to read the measurement.  This kicks the chip out of low power mode. 
....................     i2c_start(PH_LIGHT); 
03F8E:  BSF    F93.0
03F90:  MOVLW  50
03F92:  MOVWF  00
03F94:  DECFSZ 00,F
03F96:  BRA    3F94
03F98:  BSF    F93.1
03F9A:  MOVLW  51
03F9C:  MOVWF  00
03F9E:  DECFSZ 00,F
03FA0:  BRA    3F9E
03FA2:  BTFSS  F81.1
03FA4:  BRA    3FA2
03FA6:  BCF    F8A.0
03FA8:  BCF    F93.0
03FAA:  MOVLW  50
03FAC:  MOVWF  00
03FAE:  DECFSZ 00,F
03FB0:  BRA    3FAE
03FB2:  BCF    F8A.1
03FB4:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x81);  //Move the address number left on and add a one to make is a read command. 
03FB6:  MOVLW  81
03FB8:  MOVLB  7
03FBA:  MOVWF  xB4
03FBC:  MOVLB  0
03FBE:  CALL   364C
.................... 	temphigh = i2c_read(PH_LIGHT); 
03FC2:  MOVLW  01
03FC4:  MOVWF  00
03FC6:  CALL   36C2
03FCA:  MOVFF  01,791
....................     delay_ms(10);   // wait for measurement 
03FCE:  MOVLW  0A
03FD0:  MOVLB  7
03FD2:  MOVWF  xC1
03FD4:  MOVLB  0
03FD6:  CALL   1202
....................       
....................     templow = i2c_read(PH_LIGHT,0); 
03FDA:  CLRF   00
03FDC:  CALL   36C2
03FE0:  MOVFF  01,792
....................   	i2c_stop(PH_LIGHT);   
03FE4:  BCF    F93.0
03FE6:  NOP   
03FE8:  BSF    F93.1
03FEA:  BTFSS  F81.1
03FEC:  BRA    3FEA
03FEE:  MOVLW  50
03FF0:  MOVWF  00
03FF2:  DECFSZ 00,F
03FF4:  BRA    3FF2
03FF6:  BRA    3FF8
03FF8:  NOP   
03FFA:  BSF    F93.0
03FFC:  MOVLW  50
03FFE:  MOVWF  00
04000:  DECFSZ 00,F
04002:  BRA    4000
....................    
....................      
....................     // trigger rh  measurement 
.................... 	i2c_start(PH_LIGHT); 
04004:  BSF    F93.0
04006:  MOVLW  50
04008:  MOVWF  00
0400A:  DECFSZ 00,F
0400C:  BRA    400A
0400E:  BSF    F93.1
04010:  MOVLW  51
04012:  MOVWF  00
04014:  DECFSZ 00,F
04016:  BRA    4014
04018:  BCF    F8A.0
0401A:  BCF    F93.0
0401C:  MOVLW  50
0401E:  MOVWF  00
04020:  DECFSZ 00,F
04022:  BRA    4020
04024:  BCF    F8A.1
04026:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
04028:  MOVLW  80
0402A:  MOVLB  7
0402C:  MOVWF  xB4
0402E:  MOVLB  0
04030:  CALL   364C
.................... 	i2c_write(PH_LIGHT,0x01);  //Send the command for reading the version 
04034:  MOVLW  01
04036:  MOVLB  7
04038:  MOVWF  xB4
0403A:  MOVLB  0
0403C:  CALL   364C
.................... //	i2c_stop(PH_LIGHT); 
....................     delay_ms(20);   // wait for measurement 
04040:  MOVLW  14
04042:  MOVLB  7
04044:  MOVWF  xC1
04046:  MOVLB  0
04048:  CALL   1202
....................      
....................   //   Start over to read the measurement.  This kicks the chip out of low power mode. 
....................     i2c_start(PH_LIGHT); 
0404C:  BSF    F93.0
0404E:  MOVLW  50
04050:  MOVWF  00
04052:  DECFSZ 00,F
04054:  BRA    4052
04056:  BSF    F93.1
04058:  MOVLW  51
0405A:  MOVWF  00
0405C:  DECFSZ 00,F
0405E:  BRA    405C
04060:  BTFSS  F81.1
04062:  BRA    4060
04064:  BCF    F8A.0
04066:  BCF    F93.0
04068:  MOVLW  50
0406A:  MOVWF  00
0406C:  DECFSZ 00,F
0406E:  BRA    406C
04070:  BCF    F8A.1
04072:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x81);  //Move the address number left on and add a one to make is a read command.    
04074:  MOVLW  81
04076:  MOVLB  7
04078:  MOVWF  xB4
0407A:  MOVLB  0
0407C:  CALL   364C
....................     rhhigh = i2c_read(PH_LIGHT); 
04080:  MOVLW  01
04082:  MOVWF  00
04084:  CALL   36C2
04088:  MOVFF  01,793
....................        delay_ms(10);   // wait for measurement 
0408C:  MOVLW  0A
0408E:  MOVLB  7
04090:  MOVWF  xC1
04092:  MOVLB  0
04094:  CALL   1202
....................     rhlow = i2c_read(PH_LIGHT,0); 
04098:  CLRF   00
0409A:  CALL   36C2
0409E:  MOVFF  01,794
.................... 	i2c_stop(PH_LIGHT); 
040A2:  BCF    F93.0
040A4:  NOP   
040A6:  BSF    F93.1
040A8:  BTFSS  F81.1
040AA:  BRA    40A8
040AC:  MOVLW  50
040AE:  MOVWF  00
040B0:  DECFSZ 00,F
040B2:  BRA    40B0
040B4:  BRA    40B6
040B6:  NOP   
040B8:  BSF    F93.0
040BA:  MOVLW  50
040BC:  MOVWF  00
040BE:  DECFSZ 00,F
040C0:  BRA    40BE
....................      
....................     th = (int) temphigh; 
040C2:  MOVLB  2
040C4:  CLRF   x2A
040C6:  MOVFF  791,229
....................     tl = (int) templow; 
040CA:  CLRF   x2C
040CC:  MOVFF  792,22B
....................     hh = (int) rhhigh; 
040D0:  CLRF   x2E
040D2:  MOVFF  793,22D
....................     hl = (int) rhlow; 
040D6:  CLRF   x30
040D8:  MOVFF  794,22F
....................      
....................  //   t = (float) (th << 8 | tl); 
....................  //   h = (float) (hh << 8 | hl); 
....................  //   t = t * 165.0 / 65536.0 - 40.0; 
.................... //	h = h * 100.0 / 65536.0;	 
....................  
....................      
....................      
....................     return(t); 
040DC:  MOVFF  795,00
040E0:  MOVFF  796,01
040E4:  MOVFF  797,02
040E8:  MOVFF  798,03
040EC:  MOVLB  0
040EE:  GOTO   43DC (RETURN)
.................... } 
....................  
.................... #endif 
....................  
.................... #ifndef TIRHTEMP 
....................  
.................... float RHData, Temperature;   // These are the values for the coefenents for decay solutions. 
....................  
.................... //**************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // Init all of the I/O bits to make the RH/Temp sensor work 
.................... // Returns nothing 
.................... //**************************************************************************** 
.................... void initRHTemp(void) 
.................... 	{ 
.................... 	output_high(RHTEMP);   //This sets the output high. 
.................... 	} 
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // Find the check sum number 
.................... //  0 - all is good, 1 - all is bad 
.................... //**************************************************************************** 
.................... int16 CheckSumRHTemp(long RawRH, long RawTemp) 
.................... 	{ 
.................... 	int16 checksum2,checksum3; 
....................  
.................... 	checksum2 = (int16) 0xFF00 & RawRH; 
....................     checksum2 = checksum2>>8; 
.................... 	checksum2 = checksum2 + (int16) (0x00FF & RawRH); 
....................  
.................... 	checksum3 = (int16) (0xFF00 & RawTemp); 
....................     checksum3 = checksum3>>8; 
.................... 	checksum2 = checksum3 + checksum2 + (int16) (0x00FF & RawTemp); 
....................  
.................... 	return(0x00FF & checksum2); 
.................... 	} 
....................  
....................  
.................... //*************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // This routine returns the RH and Temps as float through global variables 
.................... // Returns 1 if there is an error.  a zero if there none 
.................... // All calculations for converion and reading the sensor is done here. 
.................... //*************************************************************************** 
.................... int GetTempRH(void) 
.................... 	{ 
.................... 	int x,y,w,counter; 
....................     long  RawRH, RawTemp, CheckSum;//These are the global varaibles for RH and Temperature 
....................  
....................  
.................... //  Send command out to the I/O pin 
.................... 	output_high(RHTEMP);   //This sets the output high. 
.................... 	output_low(RHTEMP);   //This sets the output high. 
.................... 	delay_ms(5); 
.................... 	output_high(RHTEMP);   //This sets the output high. 
.................... 	delay_us(40); 
.................... 	output_float(RHTEMP); 
.................... 	delay_us(20); 
....................  
.................... 	for (x=0; x < 5; x++) ///This waits to get out of the MCU command 
.................... 		{ 
.................... 		y=input_state(RHTEMP); 
.................... 		if (!y) break; 
.................... 		delay_us(10); 
.................... 		} 
.................... 	for (x=0; x < 20; x++)   //This waits through the zero and finds a 1 
.................... 		{ 
.................... 		y=input_state(RHTEMP); 
.................... 		if (y) break; 
.................... 		delay_us(10); 
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(10); 
.................... 		} 
.................... 	 
.................... //beginning of first bit zero 
.................... //Setup the for loop 
.................... RawRH = 0; /// Clear out the variable 
.................... for (counter=0; counter < 16; counter++) 
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the bit to time out the zero for the next bit 
.................... 		if (y) break; 
.................... 		delay_us(5); 
.................... 		} 
.................... 		w=y; 
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(5); 
.................... 		} 
....................  
.................... 	RawRH=RawRH<<1;	// Shift the whole word one bit left. 
.................... 	if (x > 6) 
.................... 		{ 
.................... 		RawRH = RawRH + 0x0001; 
.................... 		} 
.................... 	} 
.................... 	 
....................  
....................  
.................... RawTemp = 0; /// Clear out the variable 
.................... for (counter=0; counter < 16; counter++) 
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the bit to time out the zero for the next bit 
.................... 		if (y) break; 
.................... 		delay_us(5); 
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(5); 
.................... 		} 
.................... 	 
....................  
.................... 	RawTemp=RawTemp<<1;	// Shift the whole word one bit left. 
.................... 	if (x > 6) 
.................... 		{ 
.................... 		RawTemp = RawTemp + 0x0001; 
.................... 		} 
.................... 	} 
....................  
....................  
....................  
.................... CheckSum = 0; /// Clear out the variable 
.................... for (counter=0; counter < 8; counter++) 
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the bit to time out the zero for the next bit 
.................... 		if (y) break; 
.................... 		delay_us(5); 
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(5); 
.................... 		} 
.................... 	 
....................  
.................... 	CheckSum=CheckSum<<1;	// Shift the whole word one bit left. 
.................... 	if (x > 6) 
.................... 		{ 
.................... 		CheckSum = CheckSum + 0x0001; 
.................... 		} 
.................... 	} 
....................  
.................... 	RHData = (float)RawRH; 
....................  
.................... if (CheckSum == CheckSumRHTemp(RawRH,RawTemp)) 
.................... 	{ 
.................... 	RHData = (float)RawRH/10.0; 
....................     Temperature = ((float)RawTemp)/10.0; 
.................... 	return(0); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 	return(1); 
.................... 	} 
.................... 	} 
....................  
.................... #endif 
....................  
.................... #ifdef CHEAPEC  
.................... //************************************************************************************* 
.................... // Created September 2, 2015 
.................... // This routines calculated all of the values for a given set of decay equation. 
.................... //  The equation is y = AA + BBexp^-CCx.  This is an electrcial decay equation that has to be run several times to get the values for AA, BB and CC. 
.................... // It's assumed the first value is the highest ppm  with the lowst value for x as in imput. 
.................... // The result are gloabe variables for AA, BB and BC. 
.................... // AA is calculated by knowing the first assmetopt. 
....................  
.................... float solvefordecay(int32 measurement)	 
.................... 	{ 
....................  
.................... 	float eccheck;    //These are used for holding the caluclated values for the current returned iteration.  The x input is not needed because it's already defined. 
.................... 	int x; 
....................  
....................  
.................... //********************************************************************** 
.................... // Added Sept 3, 2015 
.................... // Updated with regression equations May 31, 2016 
.................... // The attempt to solve for a decaying curve is stopped for now.   
.................... // Currently a liner approach is used for three points. 
.................... //********************************************************************** 
.................... // Form the calibration data proved on the EEPROM, find all of the coef for the lineized LOG function. 
.................... //  Y = B + m(ln(x)) 
.................... // B =  
.................... // Find Y     
....................      
....................      
....................      
....................      
....................      
....................      
.................... eccheck = (float) measurement;   /// Change over the data type to a float for correct operations in the range testing. 
....................  
....................  
.................... if (eccheck > eccalibrationx[0])    
.................... 	{ 
.................... 	y = 0.0; 
.................... 	return(y);   //Send out the result if it's to a limit. 
.................... 	} 
....................  
.................... if (eccheck <= eccalibrationx[2]) 
.................... 	{ 
.................... 	y = 2000.0; 
.................... 	return(y);  //Send out the result if it's to a limit. 
.................... 	} 
....................  
.................... } 
....................  
....................  
....................  
.................... //************************************************************************************ 
.................... // Created Augest 24, 2015 
.................... // This routine measures the time delay for EC  or TDS.  It does this by cycling through a decay of an RC circute. 
.................... // The pinouts are as follwos: 
.................... // PICCPU    Function 
.................... // RC14     - C+ 
.................... // RC13     - C- 
.................... // RD0      - EC+ 
.................... // RD11     - EC- 
.................... // This is the firing order for measurement: 
.................... // EC1     input   low       low               input        measuere decay    high 
.................... // C+      high    input     measuere decay    high         low               input 
.................... // C-      low     low       low               high         high              high 
.................... // The returned results is an average of 16 measurements of plus and mnues measurentents at 1Khz 
.................... // returns a float with the current EC value. 
.................... //************************************************************************************* 
.................... float measureTDS(void) 
.................... 	{ 
....................  
.................... 	int statecounter,x; 
.................... 	int32 currentreadingunder=0,y,z;  // This is used as the state counter for the measurmeents.  It goes between 1 to seven. 
.................... 	int32 measurement=0, currentreading;   //This is the measurement accumlator and then it's averaged. 
.................... 	float result; 
....................  
.................... //  Set up the output and input for the EC meter. 
.................... /* 
.................... while(1) 
.................... 	{ 
.................... 	output_high(PIN_D10);    //  Define as EC1 
.................... 	output_low(PIN_D10);    //  Define as EC1 
.................... 	} 
.................... */ 
.................... output_high(PIN_D10);    //  Define as EC1- 
....................  
.................... //************************************************* 
.................... // Changed from the old board to the last version on March 28, 2016 
.................... // The two C+ and C- are changed from D0  & C13 to D8 and RD9 for C+ and RD8 for C- 
.................... // Old settings are below. 
.................... //output_high(PIN_D0);     // Define as C+   // Added September 6, 2015  Needs to be changed to RD9 for the new board 
.................... //output_float(PIN_C13);           // Define as C-   // Added September 6, 2015  Needs to be changed to RD8 for the new board 
.................... //************************************************************** 
....................  
.................... output_high(PIN_D9);     // Define as C+   // Added September 6, 2015  Needs to be changed to RD9 for the new board 
.................... output_float(PIN_D8);           // Define as C-   // Added September 6, 2015  Needs to be changed to RD8 for the new board 
....................  
.................... output_high(PIN_D11);    //  Define as EC2+   This is the negative direction charge compared to ground.  
.................... // input_state(); 
.................... //while(1) 
.................... //	{ 
.................... restart_wdt();   // restart the WD timer.  It set for 65 seconds 
.................... for (x = 1; x <=16; x++) 
.................... 	{ 
....................  
.................... 	for (statecounter = 1; statecounter < 7; statecounter++) 
.................... 		{ 
.................... 		switch(statecounter) 
.................... 			{ 
.................... 			case 1:     //  Charge Cap to max in + direction. 
.................... 				output_float(PIN_D10);    //  Define as EC- 
.................... 				input(PIN_D11);    //  Define as EC+    keep floarting to no interferiw with measurement.				 
.................... 				//output_high(PIN_D0);     // Define as C+ 
....................                 output_high(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				//output_low(PIN_C13);           // Define as C- 
....................                 output_low(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 				delay_us(100);   // Wait for the CAP to charge to Vcc.  Check on scope. 
.................... 				break; 
.................... 			case 2: 
.................... 				output_low(PIN_D11);    //  Define as EC+ 
.................... 				output_float(PIN_D10);    //  Define as EC-    keep floarting to no interferiw with measurement.				 
.................... //				input(PIN_D0);     // Define as C+ 
....................  
.................... 		//		output_low(PIN_D0);     // Define as C+ 
.................... 				//output_low(PIN_C13);           // Define as C- 
....................                 output_low(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 			//	currentreading = input(PIN_D11);   // update the output for the first one. 
.................... 				for (currentreading = 0; currentreading < 20000; currentreading++) 
.................... 					{ 
.................... 				//	fprintf(BT,"Current EC currentreading %i\n\r",currentreading); 
.................... 				/*	if (!input(PIN_D0)) 
.................... 							{ 
.................... 							 y = currentreading;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							}  */ 
....................  					if (!input(PIN_D9))   //New Board I/O pin  March 28, 2016 
.................... 							{ 
.................... 							 y = currentreading;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							}                    
.................... 					} 
.................... 				break; 
.................... 			case 3: 
.................... 			    input(PIN_D10);    //  Define as EC- 
.................... 				output_float(PIN_D11);    //  Define as EC+    keep floarting to no interferiw with measurement.				 
....................  
.................... 				//output_high(PIN_D0);     // Define as C+   //Discharge the CAP in the other direction. 
....................                 output_high(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				//output_high(PIN_C13);           // Define as C- 
....................                 output_high(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 				delay_us(100);   // Wait for the CAP to charge to Vcc.  Check on scope. 
....................  
.................... 				break; 
.................... 			case 4: 
.................... 				//output_high(PIN_C13);     // Define as C+ 
....................                 output_high(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 				//output_low(PIN_D0);           // Define as C- 
....................                 output_low(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				delay_us(100);   // Wait for the CAP to charge to Vcc.  Check on scope. 
.................... 				break; 
.................... 			case 5: 
.................... 				output_high(PIN_D10);    //  Define as EC- 
.................... 				output_float(PIN_D11);    //  Define as EC+    keep floarting to no interferiw with measurement.				 
.................... //				input(PIN_D0);     // Define as C+ 
....................  
.................... 		//		output_low(PIN_D0);     // Define as C+ 
.................... 			//	output_high(PIN_D0);           // Define as C+ 
.................... 			//	currentreading = input(PIN_D11);   // update the output for the first one. 
.................... 				for (currentreadingunder = 0; currentreadingunder < 20000; currentreadingunder++) 
.................... 					{ 
.................... 				//	fprintf(BT,"Current EC currentreading %i\n\r",currentreading); 
.................... 				/*	if (input(PIN_D0))    //  measure using C- 
.................... 							{ 
.................... 							 z = currentreadingunder;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							}  */ 
....................                     if (input(PIN_D9))    //  measure using C-  New Board I/O pin  March 28, 2016 
.................... 							{ 
.................... 							 z = currentreadingunder;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							} 
.................... 					} 
.................... 				break; 
....................  
.................... 			case 6: 
....................  
.................... 				//output_low(PIN_D0);     // Define as C+   //Discharge the CAP in the other direction. 
....................                 output_low(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				//output_low(PIN_C13);           // Define as C- 
....................                 output_low(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
....................  
....................  
....................  
.................... 				break; 
.................... 			default: 
....................  
....................  
.................... 				break; 
.................... 			} 
....................  
.................... 	 measurement =  measurement + y;   // Add together all of the 16 numbers. 
.................... currentreadingunder = currentreadingunder + z; 
.................... restart_wdt();   // restart the WD timer.  It set for 65 seconds 
.................... 		} 
....................  
....................  
.................... 	} 
.................... currentreadingunder = currentreadingunder/16; 
.................... 	measurement = measurement/16;   // Do the average 
....................  
....................  
.................... //********************************************************************************* 
.................... // Created Aug 10, 2016 
.................... // Set all EC probe levels to zero when leaving the routine. 
.................... //******************************************************************************** 
....................   output_low(PIN_D8);     //Set to low to prevent interference with pH bulb. 
....................   output_low(PIN_D9); 
....................   output_low(PIN_D10); 
....................   output_low(PIN_D11); 
....................  
.................... //************************************************************************************************ 
.................... // Created Sept 1, 2015 
.................... // Below takes the decay value from the C+ side and converts it into ppm.   
.................... // At this time there is no temperature compensation. 
.................... // At this time the calibration values are not saved in SD Card. 
.................... //************************************************************************************************ 
....................  
.................... //  Current measured data 
.................... //  Reading            ppm 
.................... //  36                 1553 
.................... //  51                 468 
.................... //  700                24 
....................  
.................... eccalibrationx[0] = 447.0; 
.................... eccalibrationx[1] = 44.0; 
.................... eccalibrationx[2] = 19.0; 
....................  
....................  
.................... eccalibrationy[0]  = 33.0; 
.................... eccalibrationy[1]  = 481.0; 
.................... eccalibrationy[2]  = 1718.0; 
....................  
....................  
.................... result = solvefordecay(measurement); // Solve for the current value for calibration for this EC meter 
.................... fprintf(BT,"Current EC reading top %Lu under %Lu  ppm %f\n\r",measurement,currentreadingunder,result); 
.................... result =  (float) measurement; 
.................... //measurement=0; 
.................... //} 
.................... //return(result);   // this is the old return  Changed April 14, 2016 
.................... return(result);	 
.................... 	}   // end of function. 
....................  
.................... #endif 
....................  
.................... //GPIO Initialization 
.................... #USE STANDARD_IO(d) 
.................... #USE STANDARD_IO(e) 
....................  
.................... #include "G:\Osmobot4PostProduction\Instrumentation\ECcalculation.c" 
....................  
....................  
....................  
.................... float bb,mm;   // this is the offset in the regression 
.................... // ************************************************************************************ 
.................... // Created June 10, 2016 
.................... // Get the regression raw data from the Unit serial number table. 
.................... // It gets the values and calculates all of the required averages and summations. 
.................... //************************************************************************************ 
.................... void getalleccalibration(void) { 
....................  
....................     float nn,eccalxaverage,eccalyaverage,sumofproducts,sumofxsquare,sumofysquare; 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created June 20, 2016 
.................... //  Calculate the averages of the x value and the y value 
.................... // Find x, y, ?(x2), ?(xy), ?(y2) 
.................... //******************************************************************************* 
.................... eccalxaverage = (log(sysInput.eccal1x) + log(sysInput.eccal2x) + log(sysInput.eccal3x))/3; 
.................... eccalyaverage = (sysInput.eccal1y  + sysInput.eccal2y + sysInput.eccal3y)/3; 
....................  
.................... //****************************************************************************** 
.................... //Created June 20, 2016 
.................... // Calculate the sum of the products of x times y 
.................... //****************************************************************************** 
.................... sumofproducts = log(sysInput.eccal1x) * sysInput.eccal1y + log(sysInput.eccal2x) * sysInput.eccal2y + log(sysInput.eccal3x) * sysInput.eccal3y; 
....................  
.................... //****************************************************************************** 
.................... //Created June 20, 2016 
.................... // Calculate the sum of the squares of x  
.................... //****************************************************************************** 
.................... sumofxsquare = log(sysInput.eccal1x) * log(sysInput.eccal1x) + log(sysInput.eccal2x) * log(sysInput.eccal2x) + log(sysInput.eccal3x) * log(sysInput.eccal3x); 
.................... //****************************************************************************** 
.................... //Created June 20, 2016 
.................... // Calculate the sum of the squares of y  
.................... //****************************************************************************** 
.................... sumofysquare = sysInput.eccal1y * sysInput.eccal1y + sysInput.eccal2y * sysInput.eccal2y + sysInput.eccal3y * sysInput.eccal3y; 
.................... nn=3.0;  // this is the number of data points 
....................  
.................... //   Find m = [?(xy) - n(x)(y)]/[?(x2) - n(x)2] 
....................  
.................... mm = (sumofproducts - nn*eccalxaverage*eccalyaverage)/(sumofxsquare-nn*eccalxaverage*eccalxaverage); 
.................... //echo ($mm. "<br>"); 
.................... // find   b = y - mx 
....................  
.................... bb = eccalyaverage - mm*eccalxaverage; 
.................... //echo ($bb. "<br>"); 
.................... // Calculate the fit ratio      [?(xy) - n(x)(y)]/sqrt[(?(x2) - n(x)2)(?(y2) - n(y)2)] 
.................... // Similarly, the equation y = axc can be linearlized to Ln(y) = Ln(a) + cLn(x). This is now linear in the variables Ln(y) and Ln(x).  
.................... } 
....................  
.................... //******************************************************************************************* 
.................... // Created June 21, 2016 
.................... //  This function returns the EC calculation for the graphs.  The coefficenst for $bb and $mm need to be run before hand. 
.................... //********************************************************************************************** 
.................... float findec(float inputreading){ 
....................  
....................     float outputreading; 
....................      
....................     getalleccalibration();   // Get the varaibles if they change.  Each time calculation is done, find all of the calibration numbers. 
....................      
.................... if (inputreading <= 0.0) 
....................      { 
....................       outputreading = 0.0; 
....................       } 
....................      else 
....................      { 
.................... outputreading = mm*log(inputreading) + bb; 
....................    } 
.................... //$outputreading =  $inputreading; 
.................... return(outputreading); 
.................... } 
....................  
....................  
.................... //********************************************************************************* 
.................... // Added May 21, 2015 
.................... // This is the calibrations for temperature on the thermister for water 
.................... //********************************************************************************* 
....................  
.................... float temp1 = 40.0; 
.................... float reading1 = 5140.00; 
.................... float temp2 = 20.0; 
.................... float reading2 = 11700.00; 
.................... float temp3 = 6.0; 
.................... float reading3 = 21594.00; 
.................... float tempa1, tempa2, tempa3; //Addded May 15, 2014 These are the coefecents for thermister calculation 
.................... float matx[3][3]; //This is the global diffinition of solving a 3X3 matrix equation. This is a scrach pad matrix used to pass arrays between functions. Added May 13, 2013 
.................... float matrixequation[3][3]; //  Added May 13, 2013  This is the array used for setting up the eqaution for solving a 3X3 equation. 
.................... float fourbyfourmatrix[4][4]; 
.................... float matrixequals[3]; 
....................  
.................... int colorlow, colorhigh;   // gain, scale;  //This is the pair of bytes used to return the current selected color. 
.................... unsigned int16 red,green,blue,clear; 
....................  
....................  
.................... //************************************************************************ 
.................... // Addded Sept 2, 2015 
.................... // Global varables for decay solution 
.................... //************************************************************************ 
.................... float eccalibrationy[4]; //The four numbers for the y axis or the ppm axis. 
.................... float eccalibrationx[4]; //The four numbers for the x axis or the count axis. 
.................... float x, y, z; //Color chart positions,coored. 
....................  
....................  
.................... //*************************************************************************** 
.................... // Created December 2, 2015 
.................... // Changed for the digital sensor board Oct 13, 2016 
.................... // This routine sets the encoder to select where the I2C clock signal goes to. 
.................... // It returns nothing. 
.................... // The input is number for 0 to 5;  each one selecting a sensor. 
.................... // Added March 17, 2016 
.................... //  SENSORBOARDA    0       1      0         1 
.................... //  SENSORBOARDB    0       0      1         1 
.................... //                in unit   top   bot Rj45   nothing 
.................... //*************************************************************************** 
....................  
.................... void selectsensor(int sensornumber) { 
....................     //fprintf(BT,"Device Number Selected %i\n\r",sensor number); 
....................     if (sensornumber > 3) // Set the high bit 
*
03608:  MOVLB  7
0360A:  MOVF   xB4,W
0360C:  SUBLW  03
0360E:  BC    3614
....................     { 
....................         sensornumber = sensornumber - 4; // Remove the offset so the bottom part of the byte can be accessed 
03610:  MOVLW  04
03612:  SUBWF  xB4,F
....................     } 
....................  
....................     if (sensornumber == 0) // Set the lower bits. 
03614:  MOVF   xB4,F
03616:  BNZ   3620
....................     { 
....................         output_low(SENSORBOARDA); // This is connected to the input for the A on both 74139 chips. 
03618:  BCF    F93.5
0361A:  BCF    F8A.5
....................         output_low(SENSORBOARDB); // This is connected to the input for the B on both 74139 chips. 
0361C:  BCF    F93.4
0361E:  BCF    F8A.4
....................     } 
....................  
....................     if (sensornumber == 1) { 
03620:  DECFSZ xB4,W
03622:  BRA    362C
....................         output_high(SENSORBOARDA); // This is connected to the input for the A on both 74139 chips. 
03624:  BCF    F93.5
03626:  BSF    F8A.5
....................         output_low(SENSORBOARDB); // This is connected to the input for the B on both 74139 chips. 
03628:  BCF    F93.4
0362A:  BCF    F8A.4
....................     } 
....................     if (sensornumber == 2) { 
0362C:  MOVF   xB4,W
0362E:  SUBLW  02
03630:  BNZ   363A
....................         output_low(SENSORBOARDA); // This is connected to the input for the A on both 74139 chips. 
03632:  BCF    F93.5
03634:  BCF    F8A.5
....................         output_high(SENSORBOARDB); // This is connected to the input for the B on both 74139 chips. 
03636:  BCF    F93.4
03638:  BSF    F8A.4
....................     } 
....................     if (sensornumber == 3) { 
0363A:  MOVF   xB4,W
0363C:  SUBLW  03
0363E:  BNZ   3648
....................         output_high(SENSORBOARDA); // This is connected to the input for the A on both 74139 chips. 
03640:  BCF    F93.5
03642:  BSF    F8A.5
....................         output_high(SENSORBOARDB); // This is connected to the input for the B on both 74139 chips. 
03644:  BCF    F93.4
03646:  BSF    F8A.4
....................     } 
03648:  MOVLB  0
0364A:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... //*********************************************************************** 
.................... //Created September 26, 2016 
.................... // This routines returns the calucated pH from the given system inputs and of the calibration derived from the server. 
.................... // It returns a float 
.................... //*********************************************************************** 
....................  
.................... float CalculatepH(float ADCNumber) { 
....................  
....................     float mm, b, result; 
....................  
....................     mm = (sysInput.phnumberupper - 4.0) / (sysInput.phcalhigh - sysInput.phcallow); 
....................     //y = mx +b 
....................     // find b 
....................     // b = y - mx 
....................     b = sysInput.phnumberupper - mm * sysInput.phcalhigh; 
....................     result = ADCNumber * mm + b; 
....................  
....................  
....................  
....................     return (result); 
.................... } 
....................  
.................... #include <EEPROMReadWriteRoutines.c>     // this is included to connect to the master Osmobot. 
....................  
.................... #ifndef TESTER 
.................... #include "CommonPassedDataFromMaterToSlave.h" 
.................... #endif 
.................... //******************************************************************************* 
.................... // Create November 2, 2016 
.................... // Save this float into eeprom 
.................... // returns nothing. 
.................... //  give the pointer to the number, the location in eeprom and length 
.................... //****************************************************************************** 
.................... void eeprom_write_blocktest(int8 *ptr, unsigned int8 addr, unsigned char len) 
*
05B12:  MOVFF  7AD,7B1
05B16:  MOVFF  7AC,7B0
05B1A:  MOVFF  7AE,7BA
.................... { 
....................   unsigned int8 *data = ptr; 
....................     unsigned int16 bufferin[4]; 
....................     unsigned int8 stuff = addr; 
....................    // len=len>>1;    // Since we are using 16 bits, two bytes are used at a time because of defs. 
....................   //  addr=addr<<1;   //mult by two offset to the correct location. 
....................  
....................    while (len--) { 
05B1E:  MOVLB  7
05B20:  MOVF   xAF,W
05B22:  DECF   xAF,F
05B24:  XORLW  00
05B26:  BZ    5B70
....................         write_eeprom(addr, *data++); 
05B28:  MOVF   xB1,W
05B2A:  MOVWF  03
05B2C:  MOVF   xB0,W
05B2E:  INCF   xB0,F
05B30:  BTFSC  FD8.2
05B32:  INCF   xB1,F
05B34:  MOVWF  FE9
05B36:  MOVFF  03,FEA
05B3A:  MOVFF  FEF,7BB
05B3E:  MOVF   FF2,W
05B40:  MOVWF  00
05B42:  BCF    FF2.7
05B44:  CLRF   FAA
05B46:  MOVFF  7AE,FA9
05B4A:  MOVFF  7BB,FA8
05B4E:  BCF    FA6.6
05B50:  BCF    FA6.7
05B52:  BSF    FA6.2
05B54:  MOVLB  F
05B56:  MOVLW  55
05B58:  MOVWF  FA7
05B5A:  MOVLW  AA
05B5C:  MOVWF  FA7
05B5E:  BSF    FA6.1
05B60:  BTFSC  FA6.1
05B62:  BRA    5B60
05B64:  BCF    FA6.2
05B66:  MOVF   00,W
05B68:  IORWF  FF2,F
....................         //addr=addr+2;  // need to skip two bytes since this is a 16 bit CPU  
....................         addr++; 
05B6A:  MOVLB  7
05B6C:  INCF   xAE,F
05B6E:  BRA    5B20
....................         // this is commented out since this is on an 8 bit machine. 
....................     }  
05B70:  MOVLB  0
05B72:  RETURN 0
....................   
.................... } 
....................  
....................  
....................  
....................  
.................... //******************************************************************* 
.................... // Created November 22, 2016 
.................... // Save the local configures for this machine into internal EEPROM   THIS ROUTINE IS USED ONLY ON 8 BIT CPUS 
.................... // Returns a 0 if it worked, it returns a 1 if failed. 
.................... // List of data saved for local unit configuration.  There is only 256 bytes on a PIC18F4550  And is saved as 8 bits, I think, not 16 at once 
.................... //  Here is the link to the data documintation for the configuration and calibration for remote sensors.  This points to the 16 bit CPUS 
.................... //#include "..\OsomobotCarbonDioxideDigitalSensor\OsomobotCarbonDioxideDigitalSensor.X\ITwoSeeGeneralCommunicationSlave.c"     // this is included to connect to the master Osmobot. 
.................... //  All saved calibration data is 16 bits.  That means two bytes per data point.  128 words.   
.................... // Which display items  -> int16      Address  120  or 0x78 
.................... //******************************************************************* 
.................... int SaveConfiguration(void) 
.................... { 
....................     int8 lowbyte,highbyte; 
....................     unsigned int16 items; 
....................      
....................      
....................     //this is all NH4 stuff 
....................     eeprom_write_blocktest(&sysInput.nh4pt1returnednumber, 0x12, sizeof sysInput.nh4pt1returnednumber);   // this is for nh4pt1returnednumber   This should be four bytes 
05B74:  MOVLW  02
05B76:  MOVLB  7
05B78:  MOVWF  xAD
05B7A:  MOVLW  51
05B7C:  MOVWF  xAC
05B7E:  MOVLW  12
05B80:  MOVWF  xAE
05B82:  MOVLW  04
05B84:  MOVWF  xAF
05B86:  MOVLB  0
05B88:  RCALL  5B12
....................     fprintf(BT,"*");    
05B8A:  MOVLW  2A
05B8C:  BTFSS  F9E.4
05B8E:  BRA    5B8C
05B90:  MOVWF  FAD
....................     eeprom_write_blocktest(&sysInput.nh4pt2returnednumber, 0x16, sizeof sysInput.nh4pt2returnednumber);   // this is for nh4pt1returnednumber   This should be four bytes 
05B92:  MOVLW  02
05B94:  MOVLB  7
05B96:  MOVWF  xAD
05B98:  MOVLW  55
05B9A:  MOVWF  xAC
05B9C:  MOVLW  16
05B9E:  MOVWF  xAE
05BA0:  MOVLW  04
05BA2:  MOVWF  xAF
05BA4:  MOVLB  0
05BA6:  RCALL  5B12
....................     fprintf(BT,"*");    
05BA8:  MOVLW  2A
05BAA:  BTFSS  F9E.4
05BAC:  BRA    5BAA
05BAE:  MOVWF  FAD
....................     eeprom_write_blocktest(&sysInput.nh4pt3returnednumber, 0x1a, sizeof sysInput.nh4pt3returnednumber);   // this is for nh4pt1returnednumber   This should be four bytes 
05BB0:  MOVLW  02
05BB2:  MOVLB  7
05BB4:  MOVWF  xAD
05BB6:  MOVLW  59
05BB8:  MOVWF  xAC
05BBA:  MOVLW  1A
05BBC:  MOVWF  xAE
05BBE:  MOVLW  04
05BC0:  MOVWF  xAF
05BC2:  MOVLB  0
05BC4:  RCALL  5B12
....................     fprintf(BT,"*");    
05BC6:  MOVLW  2A
05BC8:  BTFSS  F9E.4
05BCA:  BRA    5BC8
05BCC:  MOVWF  FAD
.................... //  nh4pt1cal1of3 
....................     items = sysInput.nh4pt1cal1of3; 
05BCE:  MOVFF  240,7AB
05BD2:  MOVFF  23F,7AA
....................     lowbyte =(int8) items; 
05BD6:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05BDA:  MOVLB  7
05BDC:  MOVF   xAB,W
05BDE:  MOVWF  xA9
....................     write_eeprom(0x00,lowbyte); 
05BE0:  MOVF   FF2,W
05BE2:  MOVWF  00
05BE4:  BCF    FF2.7
05BE6:  CLRF   FAA
05BE8:  CLRF   FA9
05BEA:  MOVFF  7A8,FA8
05BEE:  BCF    FA6.6
05BF0:  BCF    FA6.7
05BF2:  BSF    FA6.2
05BF4:  MOVLB  F
05BF6:  MOVLW  55
05BF8:  MOVWF  FA7
05BFA:  MOVLW  AA
05BFC:  MOVWF  FA7
05BFE:  BSF    FA6.1
05C00:  BTFSC  FA6.1
05C02:  BRA    5C00
05C04:  BCF    FA6.2
05C06:  MOVF   00,W
05C08:  IORWF  FF2,F
....................     write_eeprom(0x01,highbyte);   
05C0A:  MOVFF  FF2,00
05C0E:  BCF    FF2.7
05C10:  CLRF   FAA
05C12:  MOVLW  01
05C14:  MOVWF  FA9
05C16:  MOVFF  7A9,FA8
05C1A:  BCF    FA6.6
05C1C:  BCF    FA6.7
05C1E:  BSF    FA6.2
05C20:  MOVLW  55
05C22:  MOVWF  FA7
05C24:  MOVLW  AA
05C26:  MOVWF  FA7
05C28:  BSF    FA6.1
05C2A:  BTFSC  FA6.1
05C2C:  BRA    5C2A
05C2E:  BCF    FA6.2
05C30:  MOVF   00,W
05C32:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05C34:  MOVLW  2A
05C36:  BTFSS  F9E.4
05C38:  BRA    5C36
05C3A:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt1ca2of3 
....................     items = sysInput.nh4pt1cal2of3; 
05C3C:  MOVFF  242,7AB
05C40:  MOVFF  241,7AA
....................     lowbyte =(int8) items; 
05C44:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05C48:  MOVLB  7
05C4A:  MOVF   xAB,W
05C4C:  MOVWF  xA9
....................     write_eeprom(0x02,lowbyte); 
05C4E:  MOVF   FF2,W
05C50:  MOVWF  00
05C52:  BCF    FF2.7
05C54:  CLRF   FAA
05C56:  MOVLW  02
05C58:  MOVWF  FA9
05C5A:  MOVFF  7A8,FA8
05C5E:  BCF    FA6.6
05C60:  BCF    FA6.7
05C62:  BSF    FA6.2
05C64:  MOVLB  F
05C66:  MOVLW  55
05C68:  MOVWF  FA7
05C6A:  MOVLW  AA
05C6C:  MOVWF  FA7
05C6E:  BSF    FA6.1
05C70:  BTFSC  FA6.1
05C72:  BRA    5C70
05C74:  BCF    FA6.2
05C76:  MOVF   00,W
05C78:  IORWF  FF2,F
....................     write_eeprom(0x03,highbyte);   
05C7A:  MOVFF  FF2,00
05C7E:  BCF    FF2.7
05C80:  CLRF   FAA
05C82:  MOVLW  03
05C84:  MOVWF  FA9
05C86:  MOVFF  7A9,FA8
05C8A:  BCF    FA6.6
05C8C:  BCF    FA6.7
05C8E:  BSF    FA6.2
05C90:  MOVLW  55
05C92:  MOVWF  FA7
05C94:  MOVLW  AA
05C96:  MOVWF  FA7
05C98:  BSF    FA6.1
05C9A:  BTFSC  FA6.1
05C9C:  BRA    5C9A
05C9E:  BCF    FA6.2
05CA0:  MOVF   00,W
05CA2:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05CA4:  MOVLW  2A
05CA6:  BTFSS  F9E.4
05CA8:  BRA    5CA6
05CAA:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt1cal3of3 
....................     items = sysInput.nh4pt1cal3of3; 
05CAC:  MOVFF  244,7AB
05CB0:  MOVFF  243,7AA
....................     lowbyte =(int8) items; 
05CB4:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05CB8:  MOVLB  7
05CBA:  MOVF   xAB,W
05CBC:  MOVWF  xA9
....................     write_eeprom(0x04,lowbyte); 
05CBE:  MOVF   FF2,W
05CC0:  MOVWF  00
05CC2:  BCF    FF2.7
05CC4:  CLRF   FAA
05CC6:  MOVLW  04
05CC8:  MOVWF  FA9
05CCA:  MOVFF  7A8,FA8
05CCE:  BCF    FA6.6
05CD0:  BCF    FA6.7
05CD2:  BSF    FA6.2
05CD4:  MOVLB  F
05CD6:  MOVLW  55
05CD8:  MOVWF  FA7
05CDA:  MOVLW  AA
05CDC:  MOVWF  FA7
05CDE:  BSF    FA6.1
05CE0:  BTFSC  FA6.1
05CE2:  BRA    5CE0
05CE4:  BCF    FA6.2
05CE6:  MOVF   00,W
05CE8:  IORWF  FF2,F
....................     write_eeprom(0x05,highbyte);   
05CEA:  MOVFF  FF2,00
05CEE:  BCF    FF2.7
05CF0:  CLRF   FAA
05CF2:  MOVLW  05
05CF4:  MOVWF  FA9
05CF6:  MOVFF  7A9,FA8
05CFA:  BCF    FA6.6
05CFC:  BCF    FA6.7
05CFE:  BSF    FA6.2
05D00:  MOVLW  55
05D02:  MOVWF  FA7
05D04:  MOVLW  AA
05D06:  MOVWF  FA7
05D08:  BSF    FA6.1
05D0A:  BTFSC  FA6.1
05D0C:  BRA    5D0A
05D0E:  BCF    FA6.2
05D10:  MOVF   00,W
05D12:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05D14:  MOVLW  2A
05D16:  BTFSS  F9E.4
05D18:  BRA    5D16
05D1A:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt2cal1of3 
....................     items = sysInput.nh4pt2cal1of3; 
05D1C:  MOVFF  246,7AB
05D20:  MOVFF  245,7AA
....................     lowbyte =(int8) items; 
05D24:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05D28:  MOVLB  7
05D2A:  MOVF   xAB,W
05D2C:  MOVWF  xA9
....................     write_eeprom(0x06,lowbyte); 
05D2E:  MOVF   FF2,W
05D30:  MOVWF  00
05D32:  BCF    FF2.7
05D34:  CLRF   FAA
05D36:  MOVLW  06
05D38:  MOVWF  FA9
05D3A:  MOVFF  7A8,FA8
05D3E:  BCF    FA6.6
05D40:  BCF    FA6.7
05D42:  BSF    FA6.2
05D44:  MOVLB  F
05D46:  MOVLW  55
05D48:  MOVWF  FA7
05D4A:  MOVLW  AA
05D4C:  MOVWF  FA7
05D4E:  BSF    FA6.1
05D50:  BTFSC  FA6.1
05D52:  BRA    5D50
05D54:  BCF    FA6.2
05D56:  MOVF   00,W
05D58:  IORWF  FF2,F
....................     write_eeprom(0x07,highbyte);   
05D5A:  MOVFF  FF2,00
05D5E:  BCF    FF2.7
05D60:  CLRF   FAA
05D62:  MOVLW  07
05D64:  MOVWF  FA9
05D66:  MOVFF  7A9,FA8
05D6A:  BCF    FA6.6
05D6C:  BCF    FA6.7
05D6E:  BSF    FA6.2
05D70:  MOVLW  55
05D72:  MOVWF  FA7
05D74:  MOVLW  AA
05D76:  MOVWF  FA7
05D78:  BSF    FA6.1
05D7A:  BTFSC  FA6.1
05D7C:  BRA    5D7A
05D7E:  BCF    FA6.2
05D80:  MOVF   00,W
05D82:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05D84:  MOVLW  2A
05D86:  BTFSS  F9E.4
05D88:  BRA    5D86
05D8A:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt2cal2of3 
....................     items = sysInput.nh4pt2cal2of3; 
05D8C:  MOVFF  248,7AB
05D90:  MOVFF  247,7AA
....................     lowbyte =(int8) items; 
05D94:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05D98:  MOVLB  7
05D9A:  MOVF   xAB,W
05D9C:  MOVWF  xA9
....................     write_eeprom(0x08,lowbyte); 
05D9E:  MOVF   FF2,W
05DA0:  MOVWF  00
05DA2:  BCF    FF2.7
05DA4:  CLRF   FAA
05DA6:  MOVLW  08
05DA8:  MOVWF  FA9
05DAA:  MOVFF  7A8,FA8
05DAE:  BCF    FA6.6
05DB0:  BCF    FA6.7
05DB2:  BSF    FA6.2
05DB4:  MOVLB  F
05DB6:  MOVLW  55
05DB8:  MOVWF  FA7
05DBA:  MOVLW  AA
05DBC:  MOVWF  FA7
05DBE:  BSF    FA6.1
05DC0:  BTFSC  FA6.1
05DC2:  BRA    5DC0
05DC4:  BCF    FA6.2
05DC6:  MOVF   00,W
05DC8:  IORWF  FF2,F
....................     write_eeprom(0x09,highbyte);   
05DCA:  MOVFF  FF2,00
05DCE:  BCF    FF2.7
05DD0:  CLRF   FAA
05DD2:  MOVLW  09
05DD4:  MOVWF  FA9
05DD6:  MOVFF  7A9,FA8
05DDA:  BCF    FA6.6
05DDC:  BCF    FA6.7
05DDE:  BSF    FA6.2
05DE0:  MOVLW  55
05DE2:  MOVWF  FA7
05DE4:  MOVLW  AA
05DE6:  MOVWF  FA7
05DE8:  BSF    FA6.1
05DEA:  BTFSC  FA6.1
05DEC:  BRA    5DEA
05DEE:  BCF    FA6.2
05DF0:  MOVF   00,W
05DF2:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05DF4:  MOVLW  2A
05DF6:  BTFSS  F9E.4
05DF8:  BRA    5DF6
05DFA:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt2cal3of3 
....................     items = sysInput.nh4pt2cal3of3; 
05DFC:  MOVFF  24A,7AB
05E00:  MOVFF  249,7AA
....................     lowbyte =(int8) items; 
05E04:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05E08:  MOVLB  7
05E0A:  MOVF   xAB,W
05E0C:  MOVWF  xA9
....................     write_eeprom(0x0a,lowbyte); 
05E0E:  MOVF   FF2,W
05E10:  MOVWF  00
05E12:  BCF    FF2.7
05E14:  CLRF   FAA
05E16:  MOVLW  0A
05E18:  MOVWF  FA9
05E1A:  MOVFF  7A8,FA8
05E1E:  BCF    FA6.6
05E20:  BCF    FA6.7
05E22:  BSF    FA6.2
05E24:  MOVLB  F
05E26:  MOVLW  55
05E28:  MOVWF  FA7
05E2A:  MOVLW  AA
05E2C:  MOVWF  FA7
05E2E:  BSF    FA6.1
05E30:  BTFSC  FA6.1
05E32:  BRA    5E30
05E34:  BCF    FA6.2
05E36:  MOVF   00,W
05E38:  IORWF  FF2,F
....................     write_eeprom(0x0b,highbyte);   
05E3A:  MOVFF  FF2,00
05E3E:  BCF    FF2.7
05E40:  CLRF   FAA
05E42:  MOVLW  0B
05E44:  MOVWF  FA9
05E46:  MOVFF  7A9,FA8
05E4A:  BCF    FA6.6
05E4C:  BCF    FA6.7
05E4E:  BSF    FA6.2
05E50:  MOVLW  55
05E52:  MOVWF  FA7
05E54:  MOVLW  AA
05E56:  MOVWF  FA7
05E58:  BSF    FA6.1
05E5A:  BTFSC  FA6.1
05E5C:  BRA    5E5A
05E5E:  BCF    FA6.2
05E60:  MOVF   00,W
05E62:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05E64:  MOVLW  2A
05E66:  BTFSS  F9E.4
05E68:  BRA    5E66
05E6A:  MOVWF  FAD
.................... //***************************************    
.................... //  nh4pt3cal1of3 
....................     items = sysInput.nh4pt3cal1of3; 
05E6C:  MOVFF  24C,7AB
05E70:  MOVFF  24B,7AA
....................     lowbyte =(int8) items; 
05E74:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05E78:  MOVLB  7
05E7A:  MOVF   xAB,W
05E7C:  MOVWF  xA9
....................     write_eeprom(0x0c,lowbyte); 
05E7E:  MOVF   FF2,W
05E80:  MOVWF  00
05E82:  BCF    FF2.7
05E84:  CLRF   FAA
05E86:  MOVLW  0C
05E88:  MOVWF  FA9
05E8A:  MOVFF  7A8,FA8
05E8E:  BCF    FA6.6
05E90:  BCF    FA6.7
05E92:  BSF    FA6.2
05E94:  MOVLB  F
05E96:  MOVLW  55
05E98:  MOVWF  FA7
05E9A:  MOVLW  AA
05E9C:  MOVWF  FA7
05E9E:  BSF    FA6.1
05EA0:  BTFSC  FA6.1
05EA2:  BRA    5EA0
05EA4:  BCF    FA6.2
05EA6:  MOVF   00,W
05EA8:  IORWF  FF2,F
....................     write_eeprom(0x0d,highbyte);   
05EAA:  MOVFF  FF2,00
05EAE:  BCF    FF2.7
05EB0:  CLRF   FAA
05EB2:  MOVLW  0D
05EB4:  MOVWF  FA9
05EB6:  MOVFF  7A9,FA8
05EBA:  BCF    FA6.6
05EBC:  BCF    FA6.7
05EBE:  BSF    FA6.2
05EC0:  MOVLW  55
05EC2:  MOVWF  FA7
05EC4:  MOVLW  AA
05EC6:  MOVWF  FA7
05EC8:  BSF    FA6.1
05ECA:  BTFSC  FA6.1
05ECC:  BRA    5ECA
05ECE:  BCF    FA6.2
05ED0:  MOVF   00,W
05ED2:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05ED4:  MOVLW  2A
05ED6:  BTFSS  F9E.4
05ED8:  BRA    5ED6
05EDA:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt3cal2of3 
....................     items = sysInput.nh4pt3cal2of3; 
05EDC:  MOVFF  24E,7AB
05EE0:  MOVFF  24D,7AA
....................     lowbyte =(int8) items; 
05EE4:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05EE8:  MOVLB  7
05EEA:  MOVF   xAB,W
05EEC:  MOVWF  xA9
....................     write_eeprom(0x0e,lowbyte); 
05EEE:  MOVF   FF2,W
05EF0:  MOVWF  00
05EF2:  BCF    FF2.7
05EF4:  CLRF   FAA
05EF6:  MOVLW  0E
05EF8:  MOVWF  FA9
05EFA:  MOVFF  7A8,FA8
05EFE:  BCF    FA6.6
05F00:  BCF    FA6.7
05F02:  BSF    FA6.2
05F04:  MOVLB  F
05F06:  MOVLW  55
05F08:  MOVWF  FA7
05F0A:  MOVLW  AA
05F0C:  MOVWF  FA7
05F0E:  BSF    FA6.1
05F10:  BTFSC  FA6.1
05F12:  BRA    5F10
05F14:  BCF    FA6.2
05F16:  MOVF   00,W
05F18:  IORWF  FF2,F
....................     write_eeprom(0x0f,highbyte);   
05F1A:  MOVFF  FF2,00
05F1E:  BCF    FF2.7
05F20:  CLRF   FAA
05F22:  MOVLW  0F
05F24:  MOVWF  FA9
05F26:  MOVFF  7A9,FA8
05F2A:  BCF    FA6.6
05F2C:  BCF    FA6.7
05F2E:  BSF    FA6.2
05F30:  MOVLW  55
05F32:  MOVWF  FA7
05F34:  MOVLW  AA
05F36:  MOVWF  FA7
05F38:  BSF    FA6.1
05F3A:  BTFSC  FA6.1
05F3C:  BRA    5F3A
05F3E:  BCF    FA6.2
05F40:  MOVF   00,W
05F42:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05F44:  MOVLW  2A
05F46:  BTFSS  F9E.4
05F48:  BRA    5F46
05F4A:  MOVWF  FAD
.................... //*************************************** 
.................... //  nh4pt3cal3of3 
....................     items = sysInput.nh4pt3cal3of3; 
05F4C:  MOVFF  250,7AB
05F50:  MOVFF  24F,7AA
....................     lowbyte =(int8) items; 
05F54:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05F58:  MOVLB  7
05F5A:  MOVF   xAB,W
05F5C:  MOVWF  xA9
....................     write_eeprom(0x10,lowbyte); 
05F5E:  MOVF   FF2,W
05F60:  MOVWF  00
05F62:  BCF    FF2.7
05F64:  CLRF   FAA
05F66:  MOVLW  10
05F68:  MOVWF  FA9
05F6A:  MOVFF  7A8,FA8
05F6E:  BCF    FA6.6
05F70:  BCF    FA6.7
05F72:  BSF    FA6.2
05F74:  MOVLB  F
05F76:  MOVLW  55
05F78:  MOVWF  FA7
05F7A:  MOVLW  AA
05F7C:  MOVWF  FA7
05F7E:  BSF    FA6.1
05F80:  BTFSC  FA6.1
05F82:  BRA    5F80
05F84:  BCF    FA6.2
05F86:  MOVF   00,W
05F88:  IORWF  FF2,F
....................     write_eeprom(0x11,highbyte);   
05F8A:  MOVFF  FF2,00
05F8E:  BCF    FF2.7
05F90:  CLRF   FAA
05F92:  MOVLW  11
05F94:  MOVWF  FA9
05F96:  MOVFF  7A9,FA8
05F9A:  BCF    FA6.6
05F9C:  BCF    FA6.7
05F9E:  BSF    FA6.2
05FA0:  MOVLW  55
05FA2:  MOVWF  FA7
05FA4:  MOVLW  AA
05FA6:  MOVWF  FA7
05FA8:  BSF    FA6.1
05FAA:  BTFSC  FA6.1
05FAC:  BRA    5FAA
05FAE:  BCF    FA6.2
05FB0:  MOVF   00,W
05FB2:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
05FB4:  MOVLW  2A
05FB6:  BTFSS  F9E.4
05FB8:  BRA    5FB6
05FBA:  MOVWF  FAD
.................... //***************************************    
....................      
.................... //Created Feb 27, 2017 
....................     //this is all DO stuff   
....................     // it starts after the NH4 stuff.  The first address for these numbers is 0x1E 
....................      
....................      
....................     //  DOpt1cal1of3 
....................     items = sysInput.DOpt1cal1of3; 
05FBC:  MOVFF  25E,7AB
05FC0:  MOVFF  25D,7AA
....................     lowbyte =(int8) items; 
05FC4:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
05FC8:  MOVLB  7
05FCA:  MOVF   xAB,W
05FCC:  MOVWF  xA9
....................     write_eeprom(0x1E,lowbyte); 
05FCE:  MOVF   FF2,W
05FD0:  MOVWF  00
05FD2:  BCF    FF2.7
05FD4:  CLRF   FAA
05FD6:  MOVLW  1E
05FD8:  MOVWF  FA9
05FDA:  MOVFF  7A8,FA8
05FDE:  BCF    FA6.6
05FE0:  BCF    FA6.7
05FE2:  BSF    FA6.2
05FE4:  MOVLB  F
05FE6:  MOVLW  55
05FE8:  MOVWF  FA7
05FEA:  MOVLW  AA
05FEC:  MOVWF  FA7
05FEE:  BSF    FA6.1
05FF0:  BTFSC  FA6.1
05FF2:  BRA    5FF0
05FF4:  BCF    FA6.2
05FF6:  MOVF   00,W
05FF8:  IORWF  FF2,F
....................     write_eeprom(0x1F,highbyte);   
05FFA:  MOVFF  FF2,00
05FFE:  BCF    FF2.7
06000:  CLRF   FAA
06002:  MOVLW  1F
06004:  MOVWF  FA9
06006:  MOVFF  7A9,FA8
0600A:  BCF    FA6.6
0600C:  BCF    FA6.7
0600E:  BSF    FA6.2
06010:  MOVLW  55
06012:  MOVWF  FA7
06014:  MOVLW  AA
06016:  MOVWF  FA7
06018:  BSF    FA6.1
0601A:  BTFSC  FA6.1
0601C:  BRA    601A
0601E:  BCF    FA6.2
06020:  MOVF   00,W
06022:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
06024:  MOVLW  2A
06026:  BTFSS  F9E.4
06028:  BRA    6026
0602A:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt1cal2of3 
....................     items = sysInput.DOpt1cal2of3; 
0602C:  MOVFF  260,7AB
06030:  MOVFF  25F,7AA
....................     lowbyte =(int8) items; 
06034:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
06038:  MOVLB  7
0603A:  MOVF   xAB,W
0603C:  MOVWF  xA9
....................     write_eeprom(0x20,lowbyte); 
0603E:  MOVF   FF2,W
06040:  MOVWF  00
06042:  BCF    FF2.7
06044:  CLRF   FAA
06046:  MOVLW  20
06048:  MOVWF  FA9
0604A:  MOVFF  7A8,FA8
0604E:  BCF    FA6.6
06050:  BCF    FA6.7
06052:  BSF    FA6.2
06054:  MOVLB  F
06056:  MOVLW  55
06058:  MOVWF  FA7
0605A:  MOVLW  AA
0605C:  MOVWF  FA7
0605E:  BSF    FA6.1
06060:  BTFSC  FA6.1
06062:  BRA    6060
06064:  BCF    FA6.2
06066:  MOVF   00,W
06068:  IORWF  FF2,F
....................     write_eeprom(0x21,highbyte);   
0606A:  MOVFF  FF2,00
0606E:  BCF    FF2.7
06070:  CLRF   FAA
06072:  MOVLW  21
06074:  MOVWF  FA9
06076:  MOVFF  7A9,FA8
0607A:  BCF    FA6.6
0607C:  BCF    FA6.7
0607E:  BSF    FA6.2
06080:  MOVLW  55
06082:  MOVWF  FA7
06084:  MOVLW  AA
06086:  MOVWF  FA7
06088:  BSF    FA6.1
0608A:  BTFSC  FA6.1
0608C:  BRA    608A
0608E:  BCF    FA6.2
06090:  MOVF   00,W
06092:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
06094:  MOVLW  2A
06096:  BTFSS  F9E.4
06098:  BRA    6096
0609A:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt1cal3of3 
....................     items = sysInput.DOpt1cal3of3; 
0609C:  MOVFF  262,7AB
060A0:  MOVFF  261,7AA
....................     lowbyte =(int8) items; 
060A4:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
060A8:  MOVLB  7
060AA:  MOVF   xAB,W
060AC:  MOVWF  xA9
....................     write_eeprom(0x22,lowbyte); 
060AE:  MOVF   FF2,W
060B0:  MOVWF  00
060B2:  BCF    FF2.7
060B4:  CLRF   FAA
060B6:  MOVLW  22
060B8:  MOVWF  FA9
060BA:  MOVFF  7A8,FA8
060BE:  BCF    FA6.6
060C0:  BCF    FA6.7
060C2:  BSF    FA6.2
060C4:  MOVLB  F
060C6:  MOVLW  55
060C8:  MOVWF  FA7
060CA:  MOVLW  AA
060CC:  MOVWF  FA7
060CE:  BSF    FA6.1
060D0:  BTFSC  FA6.1
060D2:  BRA    60D0
060D4:  BCF    FA6.2
060D6:  MOVF   00,W
060D8:  IORWF  FF2,F
....................     write_eeprom(0x23,highbyte);   
060DA:  MOVFF  FF2,00
060DE:  BCF    FF2.7
060E0:  CLRF   FAA
060E2:  MOVLW  23
060E4:  MOVWF  FA9
060E6:  MOVFF  7A9,FA8
060EA:  BCF    FA6.6
060EC:  BCF    FA6.7
060EE:  BSF    FA6.2
060F0:  MOVLW  55
060F2:  MOVWF  FA7
060F4:  MOVLW  AA
060F6:  MOVWF  FA7
060F8:  BSF    FA6.1
060FA:  BTFSC  FA6.1
060FC:  BRA    60FA
060FE:  BCF    FA6.2
06100:  MOVF   00,W
06102:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
06104:  MOVLW  2A
06106:  BTFSS  F9E.4
06108:  BRA    6106
0610A:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt2cal1of3 
....................     items = sysInput.DOpt2cal1of3; 
0610C:  MOVFF  264,7AB
06110:  MOVFF  263,7AA
....................     lowbyte =(int8) items; 
06114:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
06118:  MOVLB  7
0611A:  MOVF   xAB,W
0611C:  MOVWF  xA9
....................     write_eeprom(0x24,lowbyte); 
0611E:  MOVF   FF2,W
06120:  MOVWF  00
06122:  BCF    FF2.7
06124:  CLRF   FAA
06126:  MOVLW  24
06128:  MOVWF  FA9
0612A:  MOVFF  7A8,FA8
0612E:  BCF    FA6.6
06130:  BCF    FA6.7
06132:  BSF    FA6.2
06134:  MOVLB  F
06136:  MOVLW  55
06138:  MOVWF  FA7
0613A:  MOVLW  AA
0613C:  MOVWF  FA7
0613E:  BSF    FA6.1
06140:  BTFSC  FA6.1
06142:  BRA    6140
06144:  BCF    FA6.2
06146:  MOVF   00,W
06148:  IORWF  FF2,F
....................     write_eeprom(0x25,highbyte);   
0614A:  MOVFF  FF2,00
0614E:  BCF    FF2.7
06150:  CLRF   FAA
06152:  MOVLW  25
06154:  MOVWF  FA9
06156:  MOVFF  7A9,FA8
0615A:  BCF    FA6.6
0615C:  BCF    FA6.7
0615E:  BSF    FA6.2
06160:  MOVLW  55
06162:  MOVWF  FA7
06164:  MOVLW  AA
06166:  MOVWF  FA7
06168:  BSF    FA6.1
0616A:  BTFSC  FA6.1
0616C:  BRA    616A
0616E:  BCF    FA6.2
06170:  MOVF   00,W
06172:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
06174:  MOVLW  2A
06176:  BTFSS  F9E.4
06178:  BRA    6176
0617A:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt2cal2of3 
....................     items = sysInput.DOpt2cal2of3; 
0617C:  MOVFF  266,7AB
06180:  MOVFF  265,7AA
....................     lowbyte =(int8) items; 
06184:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
06188:  MOVLB  7
0618A:  MOVF   xAB,W
0618C:  MOVWF  xA9
....................     write_eeprom(0x26,lowbyte); 
0618E:  MOVF   FF2,W
06190:  MOVWF  00
06192:  BCF    FF2.7
06194:  CLRF   FAA
06196:  MOVLW  26
06198:  MOVWF  FA9
0619A:  MOVFF  7A8,FA8
0619E:  BCF    FA6.6
061A0:  BCF    FA6.7
061A2:  BSF    FA6.2
061A4:  MOVLB  F
061A6:  MOVLW  55
061A8:  MOVWF  FA7
061AA:  MOVLW  AA
061AC:  MOVWF  FA7
061AE:  BSF    FA6.1
061B0:  BTFSC  FA6.1
061B2:  BRA    61B0
061B4:  BCF    FA6.2
061B6:  MOVF   00,W
061B8:  IORWF  FF2,F
....................     write_eeprom(0x27,highbyte);   
061BA:  MOVFF  FF2,00
061BE:  BCF    FF2.7
061C0:  CLRF   FAA
061C2:  MOVLW  27
061C4:  MOVWF  FA9
061C6:  MOVFF  7A9,FA8
061CA:  BCF    FA6.6
061CC:  BCF    FA6.7
061CE:  BSF    FA6.2
061D0:  MOVLW  55
061D2:  MOVWF  FA7
061D4:  MOVLW  AA
061D6:  MOVWF  FA7
061D8:  BSF    FA6.1
061DA:  BTFSC  FA6.1
061DC:  BRA    61DA
061DE:  BCF    FA6.2
061E0:  MOVF   00,W
061E2:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
061E4:  MOVLW  2A
061E6:  BTFSS  F9E.4
061E8:  BRA    61E6
061EA:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt2cal3of3 
....................     items = sysInput.DOpt2cal3of3; 
061EC:  MOVFF  268,7AB
061F0:  MOVFF  267,7AA
....................     lowbyte =(int8) items; 
061F4:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
061F8:  MOVLB  7
061FA:  MOVF   xAB,W
061FC:  MOVWF  xA9
....................     write_eeprom(0x28,lowbyte); 
061FE:  MOVF   FF2,W
06200:  MOVWF  00
06202:  BCF    FF2.7
06204:  CLRF   FAA
06206:  MOVLW  28
06208:  MOVWF  FA9
0620A:  MOVFF  7A8,FA8
0620E:  BCF    FA6.6
06210:  BCF    FA6.7
06212:  BSF    FA6.2
06214:  MOVLB  F
06216:  MOVLW  55
06218:  MOVWF  FA7
0621A:  MOVLW  AA
0621C:  MOVWF  FA7
0621E:  BSF    FA6.1
06220:  BTFSC  FA6.1
06222:  BRA    6220
06224:  BCF    FA6.2
06226:  MOVF   00,W
06228:  IORWF  FF2,F
....................     write_eeprom(0x29,highbyte);   
0622A:  MOVFF  FF2,00
0622E:  BCF    FF2.7
06230:  CLRF   FAA
06232:  MOVLW  29
06234:  MOVWF  FA9
06236:  MOVFF  7A9,FA8
0623A:  BCF    FA6.6
0623C:  BCF    FA6.7
0623E:  BSF    FA6.2
06240:  MOVLW  55
06242:  MOVWF  FA7
06244:  MOVLW  AA
06246:  MOVWF  FA7
06248:  BSF    FA6.1
0624A:  BTFSC  FA6.1
0624C:  BRA    624A
0624E:  BCF    FA6.2
06250:  MOVF   00,W
06252:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
06254:  MOVLW  2A
06256:  BTFSS  F9E.4
06258:  BRA    6256
0625A:  MOVWF  FAD
.................... //***************************************    
.................... //  DOpt3cal1of3 
....................     items = sysInput.DOpt3cal1of3; 
0625C:  MOVFF  26A,7AB
06260:  MOVFF  269,7AA
....................     lowbyte =(int8) items; 
06264:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
06268:  MOVLB  7
0626A:  MOVF   xAB,W
0626C:  MOVWF  xA9
....................     write_eeprom(0x2a,lowbyte); 
0626E:  MOVF   FF2,W
06270:  MOVWF  00
06272:  BCF    FF2.7
06274:  CLRF   FAA
06276:  MOVLW  2A
06278:  MOVWF  FA9
0627A:  MOVFF  7A8,FA8
0627E:  BCF    FA6.6
06280:  BCF    FA6.7
06282:  BSF    FA6.2
06284:  MOVLB  F
06286:  MOVLW  55
06288:  MOVWF  FA7
0628A:  MOVLW  AA
0628C:  MOVWF  FA7
0628E:  BSF    FA6.1
06290:  BTFSC  FA6.1
06292:  BRA    6290
06294:  BCF    FA6.2
06296:  MOVF   00,W
06298:  IORWF  FF2,F
....................     write_eeprom(0x2b,highbyte);   
0629A:  MOVFF  FF2,00
0629E:  BCF    FF2.7
062A0:  CLRF   FAA
062A2:  MOVLW  2B
062A4:  MOVWF  FA9
062A6:  MOVFF  7A9,FA8
062AA:  BCF    FA6.6
062AC:  BCF    FA6.7
062AE:  BSF    FA6.2
062B0:  MOVLW  55
062B2:  MOVWF  FA7
062B4:  MOVLW  AA
062B6:  MOVWF  FA7
062B8:  BSF    FA6.1
062BA:  BTFSC  FA6.1
062BC:  BRA    62BA
062BE:  BCF    FA6.2
062C0:  MOVF   00,W
062C2:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
062C4:  MOVLW  2A
062C6:  BTFSS  F9E.4
062C8:  BRA    62C6
062CA:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt3cal2of3 
....................     items = sysInput.DOpt3cal2of3; 
062CC:  MOVFF  26C,7AB
062D0:  MOVFF  26B,7AA
....................     lowbyte =(int8) items; 
062D4:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
062D8:  MOVLB  7
062DA:  MOVF   xAB,W
062DC:  MOVWF  xA9
....................     write_eeprom(0x2c,lowbyte); 
062DE:  MOVF   FF2,W
062E0:  MOVWF  00
062E2:  BCF    FF2.7
062E4:  CLRF   FAA
062E6:  MOVLW  2C
062E8:  MOVWF  FA9
062EA:  MOVFF  7A8,FA8
062EE:  BCF    FA6.6
062F0:  BCF    FA6.7
062F2:  BSF    FA6.2
062F4:  MOVLB  F
062F6:  MOVLW  55
062F8:  MOVWF  FA7
062FA:  MOVLW  AA
062FC:  MOVWF  FA7
062FE:  BSF    FA6.1
06300:  BTFSC  FA6.1
06302:  BRA    6300
06304:  BCF    FA6.2
06306:  MOVF   00,W
06308:  IORWF  FF2,F
....................     write_eeprom(0x2d,highbyte);   
0630A:  MOVFF  FF2,00
0630E:  BCF    FF2.7
06310:  CLRF   FAA
06312:  MOVLW  2D
06314:  MOVWF  FA9
06316:  MOVFF  7A9,FA8
0631A:  BCF    FA6.6
0631C:  BCF    FA6.7
0631E:  BSF    FA6.2
06320:  MOVLW  55
06322:  MOVWF  FA7
06324:  MOVLW  AA
06326:  MOVWF  FA7
06328:  BSF    FA6.1
0632A:  BTFSC  FA6.1
0632C:  BRA    632A
0632E:  BCF    FA6.2
06330:  MOVF   00,W
06332:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
06334:  MOVLW  2A
06336:  BTFSS  F9E.4
06338:  BRA    6336
0633A:  MOVWF  FAD
.................... //*************************************** 
.................... //  DOpt3cal3of3 
....................     items = sysInput.DOpt3cal3of3; 
0633C:  MOVFF  26E,7AB
06340:  MOVFF  26D,7AA
....................     lowbyte =(int8) items; 
06344:  MOVFF  7AA,7A8
....................     highbyte = (int8) (items>>8); 
06348:  MOVLB  7
0634A:  MOVF   xAB,W
0634C:  MOVWF  xA9
....................     write_eeprom(0x2e,lowbyte); 
0634E:  MOVF   FF2,W
06350:  MOVWF  00
06352:  BCF    FF2.7
06354:  CLRF   FAA
06356:  MOVLW  2E
06358:  MOVWF  FA9
0635A:  MOVFF  7A8,FA8
0635E:  BCF    FA6.6
06360:  BCF    FA6.7
06362:  BSF    FA6.2
06364:  MOVLB  F
06366:  MOVLW  55
06368:  MOVWF  FA7
0636A:  MOVLW  AA
0636C:  MOVWF  FA7
0636E:  BSF    FA6.1
06370:  BTFSC  FA6.1
06372:  BRA    6370
06374:  BCF    FA6.2
06376:  MOVF   00,W
06378:  IORWF  FF2,F
....................     write_eeprom(0x2F,highbyte);   
0637A:  MOVFF  FF2,00
0637E:  BCF    FF2.7
06380:  CLRF   FAA
06382:  MOVLW  2F
06384:  MOVWF  FA9
06386:  MOVFF  7A9,FA8
0638A:  BCF    FA6.6
0638C:  BCF    FA6.7
0638E:  BSF    FA6.2
06390:  MOVLW  55
06392:  MOVWF  FA7
06394:  MOVLW  AA
06396:  MOVWF  FA7
06398:  BSF    FA6.1
0639A:  BTFSC  FA6.1
0639C:  BRA    639A
0639E:  BCF    FA6.2
063A0:  MOVF   00,W
063A2:  IORWF  FF2,F
....................     fprintf(BT,"*"); 
063A4:  MOVLW  2A
063A6:  BTFSS  F9E.4
063A8:  BRA    63A6
063AA:  MOVWF  FAD
.................... //***************************************  
....................     eeprom_write_blocktest(&sysInput.DOpt1returnednumber, 0x30, sizeof sysInput.DOpt1returnednumber);   // this is forDOpt1returnednumber   This should be four bytes 
063AC:  MOVLW  02
063AE:  MOVLB  7
063B0:  MOVWF  xAD
063B2:  MOVLW  6F
063B4:  MOVWF  xAC
063B6:  MOVLW  30
063B8:  MOVWF  xAE
063BA:  MOVLW  04
063BC:  MOVWF  xAF
063BE:  MOVLB  0
063C0:  CALL   5B12
....................     fprintf(BT,"*");    
063C4:  MOVLW  2A
063C6:  BTFSS  F9E.4
063C8:  BRA    63C6
063CA:  MOVWF  FAD
....................     eeprom_write_blocktest(&sysInput.DOpt2returnednumber, 0x34, sizeof sysInput.DOpt2returnednumber);   // this is for DOpt2returnednumber   This should be four bytes 
063CC:  MOVLW  02
063CE:  MOVLB  7
063D0:  MOVWF  xAD
063D2:  MOVLW  73
063D4:  MOVWF  xAC
063D6:  MOVLW  34
063D8:  MOVWF  xAE
063DA:  MOVLW  04
063DC:  MOVWF  xAF
063DE:  MOVLB  0
063E0:  CALL   5B12
....................     fprintf(BT,"*");    
063E4:  MOVLW  2A
063E6:  BTFSS  F9E.4
063E8:  BRA    63E6
063EA:  MOVWF  FAD
....................     eeprom_write_blocktest(&sysInput.DOpt3returnednumber, 0x38, sizeof sysInput.DOpt3returnednumber);   // this is forDOpt3returnednumber   This should be four bytes 
063EC:  MOVLW  02
063EE:  MOVLB  7
063F0:  MOVWF  xAD
063F2:  MOVLW  77
063F4:  MOVWF  xAC
063F6:  MOVLW  38
063F8:  MOVWF  xAE
063FA:  MOVLW  04
063FC:  MOVWF  xAF
063FE:  MOVLB  0
06400:  CALL   5B12
....................     fprintf(BT,"*");  
06404:  MOVLW  2A
06406:  BTFSS  F9E.4
06408:  BRA    6406
0640A:  MOVWF  FAD
0640C:  GOTO   77AC (RETURN)
....................      
....................      
....................      
....................  //Created Feb 27, 2017 
....................     //this is all Theremister stuff    
....................      
....................      
.................... } 
....................  
....................  
.................... //************************************************************** 
.................... // Created November 24, 2016 
.................... // This routine sucks in the data number as a float from the Interenal EEOPROM.  This is for the 8 bit version 
.................... //************************************************************** 
.................... float READ_FLOAT_EEPROM(int n) {  
....................    int i;  
....................    float data; 
....................  
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
*
01594:  MOVLB  7
01596:  CLRF   x75
01598:  MOVF   x75,W
0159A:  SUBLW  03
0159C:  BNC   15DE
....................       *((int8*)&data + i) = read_eeprom(i + n); 
0159E:  MOVLW  07
015A0:  MOVWF  x7B
015A2:  MOVLW  76
015A4:  MOVWF  x7A
015A6:  MOVF   x75,W
015A8:  ADDWF  x7A,W
015AA:  MOVWF  01
015AC:  MOVLW  00
015AE:  ADDWFC x7B,W
015B0:  MOVWF  03
015B2:  MOVF   01,W
015B4:  MOVWF  FE9
015B6:  MOVFF  03,FEA
015BA:  MOVF   x74,W
015BC:  ADDWF  x75,W
015BE:  MOVWF  x7C
015C0:  MOVFF  FF2,77D
015C4:  BCF    FF2.7
015C6:  CLRF   FAA
015C8:  MOVFF  77C,FA9
015CC:  BCF    FA6.6
015CE:  BCF    FA6.7
015D0:  BSF    FA6.0
015D2:  MOVF   FA8,W
015D4:  BTFSC  x7D.7
015D6:  BSF    FF2.7
015D8:  MOVWF  FEF
015DA:  INCF   x75,F
015DC:  BRA    1598
....................  
....................    return(data);  
015DE:  MOVFF  776,00
015E2:  MOVFF  777,01
015E6:  MOVFF  778,02
015EA:  MOVFF  779,03
015EE:  MOVLB  0
015F0:  RETURN 0
.................... } 
....................  
....................  
.................... void LoadConfigurations(void) 
.................... { 
....................     int8 lowbyte,highbyte; 
....................     unsigned int16 items; 
....................      
....................      
....................     sysInput.nh4pt1returnednumber = READ_FLOAT_EEPROM(0x12);   // this gets the four bytes from EEPROM to make   nh4pt1returnednumber   
015F2:  MOVLW  12
015F4:  MOVLB  7
015F6:  MOVWF  x74
015F8:  MOVLB  0
015FA:  RCALL  1594
015FC:  MOVFF  03,254
01600:  MOVFF  02,253
01604:  MOVFF  01,252
01608:  MOVFF  00,251
....................     sysInput.nh4pt2returnednumber = READ_FLOAT_EEPROM(0x16);   // this gets the four bytes from EEPROM to make   nh4pt1returnednumber   
0160C:  MOVLW  16
0160E:  MOVLB  7
01610:  MOVWF  x74
01612:  MOVLB  0
01614:  RCALL  1594
01616:  MOVFF  03,258
0161A:  MOVFF  02,257
0161E:  MOVFF  01,256
01622:  MOVFF  00,255
....................     sysInput.nh4pt3returnednumber = READ_FLOAT_EEPROM(0x1a);   // this gets the four bytes from EEPROM to make   nh4pt1returnednumber   
01626:  MOVLW  1A
01628:  MOVLB  7
0162A:  MOVWF  x74
0162C:  MOVLB  0
0162E:  RCALL  1594
01630:  MOVFF  03,25C
01634:  MOVFF  02,25B
01638:  MOVFF  01,25A
0163C:  MOVFF  00,259
....................   //  nh4pt1cal1of3   
....................     lowbyte = read_eeprom(0x00); 
01640:  MOVFF  FF2,774
01644:  BCF    FF2.7
01646:  CLRF   FAA
01648:  CLRF   FA9
0164A:  BCF    FA6.6
0164C:  BCF    FA6.7
0164E:  BSF    FA6.0
01650:  MOVF   FA8,W
01652:  MOVLB  7
01654:  BTFSC  x74.7
01656:  BSF    FF2.7
01658:  MOVWF  x70
....................     highbyte = read_eeprom(0x01); 
0165A:  MOVFF  FF2,774
0165E:  BCF    FF2.7
01660:  CLRF   FAA
01662:  MOVLW  01
01664:  MOVWF  FA9
01666:  BCF    FA6.6
01668:  BCF    FA6.7
0166A:  BSF    FA6.0
0166C:  MOVF   FA8,W
0166E:  BTFSC  x74.7
01670:  BSF    FF2.7
01672:  MOVWF  x71
....................     items = (int16) highbyte; 
01674:  CLRF   x73
01676:  MOVFF  771,772
....................     sysInput.nh4pt1cal1of3 = (items<<8) +  lowbyte;   
0167A:  CLRF   x74
0167C:  MOVF   x70,W
0167E:  ADDWF  x74,W
01680:  MOVLB  2
01682:  MOVWF  x3F
01684:  MOVLW  00
01686:  MOVLB  7
01688:  ADDWFC x72,W
0168A:  MOVLB  2
0168C:  MOVWF  x40
.................... //*************************************** 
.................... //  nh4pt1ca2of3   
....................     lowbyte = read_eeprom(0x02); 
0168E:  MOVFF  FF2,774
01692:  BCF    FF2.7
01694:  CLRF   FAA
01696:  MOVLW  02
01698:  MOVWF  FA9
0169A:  BCF    FA6.6
0169C:  BCF    FA6.7
0169E:  BSF    FA6.0
016A0:  MOVF   FA8,W
016A2:  MOVLB  7
016A4:  BTFSC  x74.7
016A6:  BSF    FF2.7
016A8:  MOVWF  x70
....................     highbyte = read_eeprom(0x03); 
016AA:  MOVFF  FF2,774
016AE:  BCF    FF2.7
016B0:  CLRF   FAA
016B2:  MOVLW  03
016B4:  MOVWF  FA9
016B6:  BCF    FA6.6
016B8:  BCF    FA6.7
016BA:  BSF    FA6.0
016BC:  MOVF   FA8,W
016BE:  BTFSC  x74.7
016C0:  BSF    FF2.7
016C2:  MOVWF  x71
....................     items = (int16) highbyte; 
016C4:  CLRF   x73
016C6:  MOVFF  771,772
....................     sysInput.nh4pt1cal2of3 = (items<<8) +  lowbyte;   
016CA:  CLRF   x74
016CC:  MOVF   x70,W
016CE:  ADDWF  x74,W
016D0:  MOVLB  2
016D2:  MOVWF  x41
016D4:  MOVLW  00
016D6:  MOVLB  7
016D8:  ADDWFC x72,W
016DA:  MOVLB  2
016DC:  MOVWF  x42
.................... //*************************************** 
.................... //  nh4pt1ca3of3   
....................     lowbyte = read_eeprom(0x04); 
016DE:  MOVFF  FF2,774
016E2:  BCF    FF2.7
016E4:  CLRF   FAA
016E6:  MOVLW  04
016E8:  MOVWF  FA9
016EA:  BCF    FA6.6
016EC:  BCF    FA6.7
016EE:  BSF    FA6.0
016F0:  MOVF   FA8,W
016F2:  MOVLB  7
016F4:  BTFSC  x74.7
016F6:  BSF    FF2.7
016F8:  MOVWF  x70
....................     highbyte = read_eeprom(0x05); 
016FA:  MOVFF  FF2,774
016FE:  BCF    FF2.7
01700:  CLRF   FAA
01702:  MOVLW  05
01704:  MOVWF  FA9
01706:  BCF    FA6.6
01708:  BCF    FA6.7
0170A:  BSF    FA6.0
0170C:  MOVF   FA8,W
0170E:  BTFSC  x74.7
01710:  BSF    FF2.7
01712:  MOVWF  x71
....................     items = (int16) highbyte; 
01714:  CLRF   x73
01716:  MOVFF  771,772
....................     sysInput.nh4pt1cal3of3 = (items<<8) +  lowbyte;   
0171A:  CLRF   x74
0171C:  MOVF   x70,W
0171E:  ADDWF  x74,W
01720:  MOVLB  2
01722:  MOVWF  x43
01724:  MOVLW  00
01726:  MOVLB  7
01728:  ADDWFC x72,W
0172A:  MOVLB  2
0172C:  MOVWF  x44
.................... //***************************************   
.................... //  nh4pt2ca1of3   
....................     lowbyte = read_eeprom(0x06); 
0172E:  MOVFF  FF2,774
01732:  BCF    FF2.7
01734:  CLRF   FAA
01736:  MOVLW  06
01738:  MOVWF  FA9
0173A:  BCF    FA6.6
0173C:  BCF    FA6.7
0173E:  BSF    FA6.0
01740:  MOVF   FA8,W
01742:  MOVLB  7
01744:  BTFSC  x74.7
01746:  BSF    FF2.7
01748:  MOVWF  x70
....................     highbyte = read_eeprom(0x07); 
0174A:  MOVFF  FF2,774
0174E:  BCF    FF2.7
01750:  CLRF   FAA
01752:  MOVLW  07
01754:  MOVWF  FA9
01756:  BCF    FA6.6
01758:  BCF    FA6.7
0175A:  BSF    FA6.0
0175C:  MOVF   FA8,W
0175E:  BTFSC  x74.7
01760:  BSF    FF2.7
01762:  MOVWF  x71
....................     items = (int16) highbyte; 
01764:  CLRF   x73
01766:  MOVFF  771,772
....................     sysInput.nh4pt2cal1of3 = (items<<8) +  lowbyte;   
0176A:  CLRF   x74
0176C:  MOVF   x70,W
0176E:  ADDWF  x74,W
01770:  MOVLB  2
01772:  MOVWF  x45
01774:  MOVLW  00
01776:  MOVLB  7
01778:  ADDWFC x72,W
0177A:  MOVLB  2
0177C:  MOVWF  x46
.................... //***************************************     
.................... //  nh4pt2ca2of3   
....................     lowbyte = read_eeprom(0x08); 
0177E:  MOVFF  FF2,774
01782:  BCF    FF2.7
01784:  CLRF   FAA
01786:  MOVLW  08
01788:  MOVWF  FA9
0178A:  BCF    FA6.6
0178C:  BCF    FA6.7
0178E:  BSF    FA6.0
01790:  MOVF   FA8,W
01792:  MOVLB  7
01794:  BTFSC  x74.7
01796:  BSF    FF2.7
01798:  MOVWF  x70
....................     highbyte = read_eeprom(0x09); 
0179A:  MOVFF  FF2,774
0179E:  BCF    FF2.7
017A0:  CLRF   FAA
017A2:  MOVLW  09
017A4:  MOVWF  FA9
017A6:  BCF    FA6.6
017A8:  BCF    FA6.7
017AA:  BSF    FA6.0
017AC:  MOVF   FA8,W
017AE:  BTFSC  x74.7
017B0:  BSF    FF2.7
017B2:  MOVWF  x71
....................     items = (int16) highbyte; 
017B4:  CLRF   x73
017B6:  MOVFF  771,772
....................     sysInput.nh4pt2cal2of3 = (items<<8) +  lowbyte;   
017BA:  CLRF   x74
017BC:  MOVF   x70,W
017BE:  ADDWF  x74,W
017C0:  MOVLB  2
017C2:  MOVWF  x47
017C4:  MOVLW  00
017C6:  MOVLB  7
017C8:  ADDWFC x72,W
017CA:  MOVLB  2
017CC:  MOVWF  x48
.................... //***************************************     
.................... //  nh4pt2ca13of3   
....................     lowbyte = read_eeprom(0x0a); 
017CE:  MOVFF  FF2,774
017D2:  BCF    FF2.7
017D4:  CLRF   FAA
017D6:  MOVLW  0A
017D8:  MOVWF  FA9
017DA:  BCF    FA6.6
017DC:  BCF    FA6.7
017DE:  BSF    FA6.0
017E0:  MOVF   FA8,W
017E2:  MOVLB  7
017E4:  BTFSC  x74.7
017E6:  BSF    FF2.7
017E8:  MOVWF  x70
....................     highbyte = read_eeprom(0x0b); 
017EA:  MOVFF  FF2,774
017EE:  BCF    FF2.7
017F0:  CLRF   FAA
017F2:  MOVLW  0B
017F4:  MOVWF  FA9
017F6:  BCF    FA6.6
017F8:  BCF    FA6.7
017FA:  BSF    FA6.0
017FC:  MOVF   FA8,W
017FE:  BTFSC  x74.7
01800:  BSF    FF2.7
01802:  MOVWF  x71
....................     items = (int16) highbyte; 
01804:  CLRF   x73
01806:  MOVFF  771,772
....................     sysInput.nh4pt2cal3of3 = (items<<8) +  lowbyte;   
0180A:  CLRF   x74
0180C:  MOVF   x70,W
0180E:  ADDWF  x74,W
01810:  MOVLB  2
01812:  MOVWF  x49
01814:  MOVLW  00
01816:  MOVLB  7
01818:  ADDWFC x72,W
0181A:  MOVLB  2
0181C:  MOVWF  x4A
.................... //***************************************     
.................... //  nh4pt3ca1of3   
....................     lowbyte = read_eeprom(0x0c); 
0181E:  MOVFF  FF2,774
01822:  BCF    FF2.7
01824:  CLRF   FAA
01826:  MOVLW  0C
01828:  MOVWF  FA9
0182A:  BCF    FA6.6
0182C:  BCF    FA6.7
0182E:  BSF    FA6.0
01830:  MOVF   FA8,W
01832:  MOVLB  7
01834:  BTFSC  x74.7
01836:  BSF    FF2.7
01838:  MOVWF  x70
....................     highbyte = read_eeprom(0x0d); 
0183A:  MOVFF  FF2,774
0183E:  BCF    FF2.7
01840:  CLRF   FAA
01842:  MOVLW  0D
01844:  MOVWF  FA9
01846:  BCF    FA6.6
01848:  BCF    FA6.7
0184A:  BSF    FA6.0
0184C:  MOVF   FA8,W
0184E:  BTFSC  x74.7
01850:  BSF    FF2.7
01852:  MOVWF  x71
....................     items = (int16) highbyte; 
01854:  CLRF   x73
01856:  MOVFF  771,772
....................     sysInput.nh4pt3cal1of3 = (items<<8) +  lowbyte;   
0185A:  CLRF   x74
0185C:  MOVF   x70,W
0185E:  ADDWF  x74,W
01860:  MOVLB  2
01862:  MOVWF  x4B
01864:  MOVLW  00
01866:  MOVLB  7
01868:  ADDWFC x72,W
0186A:  MOVLB  2
0186C:  MOVWF  x4C
.................... //***************************************     
.................... //  nh4pt3ca2of3   
....................     lowbyte = read_eeprom(0x0e); 
0186E:  MOVFF  FF2,774
01872:  BCF    FF2.7
01874:  CLRF   FAA
01876:  MOVLW  0E
01878:  MOVWF  FA9
0187A:  BCF    FA6.6
0187C:  BCF    FA6.7
0187E:  BSF    FA6.0
01880:  MOVF   FA8,W
01882:  MOVLB  7
01884:  BTFSC  x74.7
01886:  BSF    FF2.7
01888:  MOVWF  x70
....................     highbyte = read_eeprom(0x0f); 
0188A:  MOVFF  FF2,774
0188E:  BCF    FF2.7
01890:  CLRF   FAA
01892:  MOVLW  0F
01894:  MOVWF  FA9
01896:  BCF    FA6.6
01898:  BCF    FA6.7
0189A:  BSF    FA6.0
0189C:  MOVF   FA8,W
0189E:  BTFSC  x74.7
018A0:  BSF    FF2.7
018A2:  MOVWF  x71
....................     items = (int16) highbyte; 
018A4:  CLRF   x73
018A6:  MOVFF  771,772
....................     sysInput.nh4pt3cal2of3 = (items<<8) +  lowbyte;   
018AA:  CLRF   x74
018AC:  MOVF   x70,W
018AE:  ADDWF  x74,W
018B0:  MOVLB  2
018B2:  MOVWF  x4D
018B4:  MOVLW  00
018B6:  MOVLB  7
018B8:  ADDWFC x72,W
018BA:  MOVLB  2
018BC:  MOVWF  x4E
.................... //***************************************     
.................... //  nh4pt3ca3of3   
....................     lowbyte = read_eeprom(0x10); 
018BE:  MOVFF  FF2,774
018C2:  BCF    FF2.7
018C4:  CLRF   FAA
018C6:  MOVLW  10
018C8:  MOVWF  FA9
018CA:  BCF    FA6.6
018CC:  BCF    FA6.7
018CE:  BSF    FA6.0
018D0:  MOVF   FA8,W
018D2:  MOVLB  7
018D4:  BTFSC  x74.7
018D6:  BSF    FF2.7
018D8:  MOVWF  x70
....................     highbyte = read_eeprom(0x11); 
018DA:  MOVFF  FF2,774
018DE:  BCF    FF2.7
018E0:  CLRF   FAA
018E2:  MOVLW  11
018E4:  MOVWF  FA9
018E6:  BCF    FA6.6
018E8:  BCF    FA6.7
018EA:  BSF    FA6.0
018EC:  MOVF   FA8,W
018EE:  BTFSC  x74.7
018F0:  BSF    FF2.7
018F2:  MOVWF  x71
....................     items = (int16) highbyte; 
018F4:  CLRF   x73
018F6:  MOVFF  771,772
....................     sysInput.nh4pt3cal3of3 = (items<<8) +  lowbyte;   
018FA:  CLRF   x74
018FC:  MOVF   x70,W
018FE:  ADDWF  x74,W
01900:  MOVLB  2
01902:  MOVWF  x4F
01904:  MOVLW  00
01906:  MOVLB  7
01908:  ADDWFC x72,W
0190A:  MOVLB  2
0190C:  MOVWF  x50
.................... //***************************************     
....................     
....................      
....................      
....................      
.................... // load the DO stuff out of EEPROM   Added Feb 27, 2017 
....................  
....................     sysInput.DOpt1returnednumber = READ_FLOAT_EEPROM(0x30);   // this gets the four bytes from EEPROM to make   DOpt1returnednumber   
0190E:  MOVLW  30
01910:  MOVLB  7
01912:  MOVWF  x74
01914:  MOVLB  0
01916:  RCALL  1594
01918:  MOVFF  03,272
0191C:  MOVFF  02,271
01920:  MOVFF  01,270
01924:  MOVFF  00,26F
....................     sysInput.DOpt2returnednumber = READ_FLOAT_EEPROM(0x34);   // this gets the four bytes from EEPROM to make   DOpt2returnednumber   
01928:  MOVLW  34
0192A:  MOVLB  7
0192C:  MOVWF  x74
0192E:  MOVLB  0
01930:  RCALL  1594
01932:  MOVFF  03,276
01936:  MOVFF  02,275
0193A:  MOVFF  01,274
0193E:  MOVFF  00,273
....................     sysInput.DOpt3returnednumber = READ_FLOAT_EEPROM(0x38);   // this gets the four bytes from EEPROM to make   DOpt3returnednumber   
01942:  MOVLW  38
01944:  MOVLB  7
01946:  MOVWF  x74
01948:  MOVLB  0
0194A:  RCALL  1594
0194C:  MOVFF  03,27A
01950:  MOVFF  02,279
01954:  MOVFF  01,278
01958:  MOVFF  00,277
....................   //  DOpt1cal1of3    
....................     lowbyte = read_eeprom(0x1e); 
0195C:  MOVFF  FF2,774
01960:  BCF    FF2.7
01962:  CLRF   FAA
01964:  MOVLW  1E
01966:  MOVWF  FA9
01968:  BCF    FA6.6
0196A:  BCF    FA6.7
0196C:  BSF    FA6.0
0196E:  MOVF   FA8,W
01970:  MOVLB  7
01972:  BTFSC  x74.7
01974:  BSF    FF2.7
01976:  MOVWF  x70
....................     highbyte = read_eeprom(0x1f); 
01978:  MOVFF  FF2,774
0197C:  BCF    FF2.7
0197E:  CLRF   FAA
01980:  MOVLW  1F
01982:  MOVWF  FA9
01984:  BCF    FA6.6
01986:  BCF    FA6.7
01988:  BSF    FA6.0
0198A:  MOVF   FA8,W
0198C:  BTFSC  x74.7
0198E:  BSF    FF2.7
01990:  MOVWF  x71
....................     items = (int16) highbyte; 
01992:  CLRF   x73
01994:  MOVFF  771,772
....................     sysInput.DOpt1cal1of3 = (items<<8) +  lowbyte;   
01998:  CLRF   x74
0199A:  MOVF   x70,W
0199C:  ADDWF  x74,W
0199E:  MOVLB  2
019A0:  MOVWF  x5D
019A2:  MOVLW  00
019A4:  MOVLB  7
019A6:  ADDWFC x72,W
019A8:  MOVLB  2
019AA:  MOVWF  x5E
.................... //*************************************** 
.................... //  DOpt1cal2of3    
....................     lowbyte = read_eeprom(0x20); 
019AC:  MOVFF  FF2,774
019B0:  BCF    FF2.7
019B2:  CLRF   FAA
019B4:  MOVLW  20
019B6:  MOVWF  FA9
019B8:  BCF    FA6.6
019BA:  BCF    FA6.7
019BC:  BSF    FA6.0
019BE:  MOVF   FA8,W
019C0:  MOVLB  7
019C2:  BTFSC  x74.7
019C4:  BSF    FF2.7
019C6:  MOVWF  x70
....................     highbyte = read_eeprom(0x21); 
019C8:  MOVFF  FF2,774
019CC:  BCF    FF2.7
019CE:  CLRF   FAA
019D0:  MOVLW  21
019D2:  MOVWF  FA9
019D4:  BCF    FA6.6
019D6:  BCF    FA6.7
019D8:  BSF    FA6.0
019DA:  MOVF   FA8,W
019DC:  BTFSC  x74.7
019DE:  BSF    FF2.7
019E0:  MOVWF  x71
....................     items = (int16) highbyte; 
019E2:  CLRF   x73
019E4:  MOVFF  771,772
....................     sysInput.DOpt1cal2of3 = (items<<8) +  lowbyte;   
019E8:  CLRF   x74
019EA:  MOVF   x70,W
019EC:  ADDWF  x74,W
019EE:  MOVLB  2
019F0:  MOVWF  x5F
019F2:  MOVLW  00
019F4:  MOVLB  7
019F6:  ADDWFC x72,W
019F8:  MOVLB  2
019FA:  MOVWF  x60
.................... //*************************************** 
.................... //  DOpt1cal3of3   
....................     lowbyte = read_eeprom(0x22); 
019FC:  MOVFF  FF2,774
01A00:  BCF    FF2.7
01A02:  CLRF   FAA
01A04:  MOVLW  22
01A06:  MOVWF  FA9
01A08:  BCF    FA6.6
01A0A:  BCF    FA6.7
01A0C:  BSF    FA6.0
01A0E:  MOVF   FA8,W
01A10:  MOVLB  7
01A12:  BTFSC  x74.7
01A14:  BSF    FF2.7
01A16:  MOVWF  x70
....................     highbyte = read_eeprom(0x23); 
01A18:  MOVFF  FF2,774
01A1C:  BCF    FF2.7
01A1E:  CLRF   FAA
01A20:  MOVLW  23
01A22:  MOVWF  FA9
01A24:  BCF    FA6.6
01A26:  BCF    FA6.7
01A28:  BSF    FA6.0
01A2A:  MOVF   FA8,W
01A2C:  BTFSC  x74.7
01A2E:  BSF    FF2.7
01A30:  MOVWF  x71
....................     items = (int16) highbyte; 
01A32:  CLRF   x73
01A34:  MOVFF  771,772
....................     sysInput.DOpt1cal3of3 = (items<<8) +  lowbyte;   
01A38:  CLRF   x74
01A3A:  MOVF   x70,W
01A3C:  ADDWF  x74,W
01A3E:  MOVLB  2
01A40:  MOVWF  x61
01A42:  MOVLW  00
01A44:  MOVLB  7
01A46:  ADDWFC x72,W
01A48:  MOVLB  2
01A4A:  MOVWF  x62
.................... //***************************************   
.................... //  DOpt2cal1of3   
....................     lowbyte = read_eeprom(0x24); 
01A4C:  MOVFF  FF2,774
01A50:  BCF    FF2.7
01A52:  CLRF   FAA
01A54:  MOVLW  24
01A56:  MOVWF  FA9
01A58:  BCF    FA6.6
01A5A:  BCF    FA6.7
01A5C:  BSF    FA6.0
01A5E:  MOVF   FA8,W
01A60:  MOVLB  7
01A62:  BTFSC  x74.7
01A64:  BSF    FF2.7
01A66:  MOVWF  x70
....................     highbyte = read_eeprom(0x25); 
01A68:  MOVFF  FF2,774
01A6C:  BCF    FF2.7
01A6E:  CLRF   FAA
01A70:  MOVLW  25
01A72:  MOVWF  FA9
01A74:  BCF    FA6.6
01A76:  BCF    FA6.7
01A78:  BSF    FA6.0
01A7A:  MOVF   FA8,W
01A7C:  BTFSC  x74.7
01A7E:  BSF    FF2.7
01A80:  MOVWF  x71
....................     items = (int16) highbyte; 
01A82:  CLRF   x73
01A84:  MOVFF  771,772
....................     sysInput.DOpt2cal1of3 = (items<<8) +  lowbyte;   
01A88:  CLRF   x74
01A8A:  MOVF   x70,W
01A8C:  ADDWF  x74,W
01A8E:  MOVLB  2
01A90:  MOVWF  x63
01A92:  MOVLW  00
01A94:  MOVLB  7
01A96:  ADDWFC x72,W
01A98:  MOVLB  2
01A9A:  MOVWF  x64
.................... //***************************************     
.................... //  DOpt2cal2of3   
....................     lowbyte = read_eeprom(0x26); 
01A9C:  MOVFF  FF2,774
01AA0:  BCF    FF2.7
01AA2:  CLRF   FAA
01AA4:  MOVLW  26
01AA6:  MOVWF  FA9
01AA8:  BCF    FA6.6
01AAA:  BCF    FA6.7
01AAC:  BSF    FA6.0
01AAE:  MOVF   FA8,W
01AB0:  MOVLB  7
01AB2:  BTFSC  x74.7
01AB4:  BSF    FF2.7
01AB6:  MOVWF  x70
....................     highbyte = read_eeprom(0x27); 
01AB8:  MOVFF  FF2,774
01ABC:  BCF    FF2.7
01ABE:  CLRF   FAA
01AC0:  MOVLW  27
01AC2:  MOVWF  FA9
01AC4:  BCF    FA6.6
01AC6:  BCF    FA6.7
01AC8:  BSF    FA6.0
01ACA:  MOVF   FA8,W
01ACC:  BTFSC  x74.7
01ACE:  BSF    FF2.7
01AD0:  MOVWF  x71
....................     items = (int16) highbyte; 
01AD2:  CLRF   x73
01AD4:  MOVFF  771,772
....................     sysInput.DOpt2cal2of3 = (items<<8) +  lowbyte;   
01AD8:  CLRF   x74
01ADA:  MOVF   x70,W
01ADC:  ADDWF  x74,W
01ADE:  MOVLB  2
01AE0:  MOVWF  x65
01AE2:  MOVLW  00
01AE4:  MOVLB  7
01AE6:  ADDWFC x72,W
01AE8:  MOVLB  2
01AEA:  MOVWF  x66
.................... //***************************************     
.................... //  DOpt2cal3of3   
....................     lowbyte = read_eeprom(0x28); 
01AEC:  MOVFF  FF2,774
01AF0:  BCF    FF2.7
01AF2:  CLRF   FAA
01AF4:  MOVLW  28
01AF6:  MOVWF  FA9
01AF8:  BCF    FA6.6
01AFA:  BCF    FA6.7
01AFC:  BSF    FA6.0
01AFE:  MOVF   FA8,W
01B00:  MOVLB  7
01B02:  BTFSC  x74.7
01B04:  BSF    FF2.7
01B06:  MOVWF  x70
....................     highbyte = read_eeprom(0x29); 
01B08:  MOVFF  FF2,774
01B0C:  BCF    FF2.7
01B0E:  CLRF   FAA
01B10:  MOVLW  29
01B12:  MOVWF  FA9
01B14:  BCF    FA6.6
01B16:  BCF    FA6.7
01B18:  BSF    FA6.0
01B1A:  MOVF   FA8,W
01B1C:  BTFSC  x74.7
01B1E:  BSF    FF2.7
01B20:  MOVWF  x71
....................     items = (int16) highbyte; 
01B22:  CLRF   x73
01B24:  MOVFF  771,772
....................     sysInput.DOpt2cal3of3 = (items<<8) +  lowbyte;   
01B28:  CLRF   x74
01B2A:  MOVF   x70,W
01B2C:  ADDWF  x74,W
01B2E:  MOVLB  2
01B30:  MOVWF  x67
01B32:  MOVLW  00
01B34:  MOVLB  7
01B36:  ADDWFC x72,W
01B38:  MOVLB  2
01B3A:  MOVWF  x68
.................... //***************************************     
.................... //  DOpt3cal1of3   
....................     lowbyte = read_eeprom(0x2a); 
01B3C:  MOVFF  FF2,774
01B40:  BCF    FF2.7
01B42:  CLRF   FAA
01B44:  MOVLW  2A
01B46:  MOVWF  FA9
01B48:  BCF    FA6.6
01B4A:  BCF    FA6.7
01B4C:  BSF    FA6.0
01B4E:  MOVF   FA8,W
01B50:  MOVLB  7
01B52:  BTFSC  x74.7
01B54:  BSF    FF2.7
01B56:  MOVWF  x70
....................     highbyte = read_eeprom(0x2b); 
01B58:  MOVFF  FF2,774
01B5C:  BCF    FF2.7
01B5E:  CLRF   FAA
01B60:  MOVLW  2B
01B62:  MOVWF  FA9
01B64:  BCF    FA6.6
01B66:  BCF    FA6.7
01B68:  BSF    FA6.0
01B6A:  MOVF   FA8,W
01B6C:  BTFSC  x74.7
01B6E:  BSF    FF2.7
01B70:  MOVWF  x71
....................     items = (int16) highbyte; 
01B72:  CLRF   x73
01B74:  MOVFF  771,772
....................     sysInput.DOpt3cal1of3 = (items<<8) +  lowbyte;   
01B78:  CLRF   x74
01B7A:  MOVF   x70,W
01B7C:  ADDWF  x74,W
01B7E:  MOVLB  2
01B80:  MOVWF  x69
01B82:  MOVLW  00
01B84:  MOVLB  7
01B86:  ADDWFC x72,W
01B88:  MOVLB  2
01B8A:  MOVWF  x6A
.................... //***************************************     
.................... //  DOpt3cal2of3   
....................     lowbyte = read_eeprom(0x2c); 
01B8C:  MOVFF  FF2,774
01B90:  BCF    FF2.7
01B92:  CLRF   FAA
01B94:  MOVLW  2C
01B96:  MOVWF  FA9
01B98:  BCF    FA6.6
01B9A:  BCF    FA6.7
01B9C:  BSF    FA6.0
01B9E:  MOVF   FA8,W
01BA0:  MOVLB  7
01BA2:  BTFSC  x74.7
01BA4:  BSF    FF2.7
01BA6:  MOVWF  x70
....................     highbyte = read_eeprom(0x2d); 
01BA8:  MOVFF  FF2,774
01BAC:  BCF    FF2.7
01BAE:  CLRF   FAA
01BB0:  MOVLW  2D
01BB2:  MOVWF  FA9
01BB4:  BCF    FA6.6
01BB6:  BCF    FA6.7
01BB8:  BSF    FA6.0
01BBA:  MOVF   FA8,W
01BBC:  BTFSC  x74.7
01BBE:  BSF    FF2.7
01BC0:  MOVWF  x71
....................     items = (int16) highbyte; 
01BC2:  CLRF   x73
01BC4:  MOVFF  771,772
....................     sysInput.DOpt3cal2of3 = (items<<8) +  lowbyte;   
01BC8:  CLRF   x74
01BCA:  MOVF   x70,W
01BCC:  ADDWF  x74,W
01BCE:  MOVLB  2
01BD0:  MOVWF  x6B
01BD2:  MOVLW  00
01BD4:  MOVLB  7
01BD6:  ADDWFC x72,W
01BD8:  MOVLB  2
01BDA:  MOVWF  x6C
.................... //***************************************     
.................... //  DOpt3cal3of3   
....................     lowbyte = read_eeprom(0x2e); 
01BDC:  MOVFF  FF2,774
01BE0:  BCF    FF2.7
01BE2:  CLRF   FAA
01BE4:  MOVLW  2E
01BE6:  MOVWF  FA9
01BE8:  BCF    FA6.6
01BEA:  BCF    FA6.7
01BEC:  BSF    FA6.0
01BEE:  MOVF   FA8,W
01BF0:  MOVLB  7
01BF2:  BTFSC  x74.7
01BF4:  BSF    FF2.7
01BF6:  MOVWF  x70
....................     highbyte = read_eeprom(0x2f); 
01BF8:  MOVFF  FF2,774
01BFC:  BCF    FF2.7
01BFE:  CLRF   FAA
01C00:  MOVLW  2F
01C02:  MOVWF  FA9
01C04:  BCF    FA6.6
01C06:  BCF    FA6.7
01C08:  BSF    FA6.0
01C0A:  MOVF   FA8,W
01C0C:  BTFSC  x74.7
01C0E:  BSF    FF2.7
01C10:  MOVWF  x71
....................     items = (int16) highbyte; 
01C12:  CLRF   x73
01C14:  MOVFF  771,772
....................     sysInput.DOpt3cal3of3 = (items<<8) +  lowbyte;   
01C18:  CLRF   x74
01C1A:  MOVF   x70,W
01C1C:  ADDWF  x74,W
01C1E:  MOVLB  2
01C20:  MOVWF  x6D
01C22:  MOVLW  00
01C24:  MOVLB  7
01C26:  ADDWFC x72,W
01C28:  MOVLB  2
01C2A:  MOVWF  x6E
01C2C:  MOVLB  0
01C2E:  GOTO   8FF2 (RETURN)
.................... //***************************************     
....................         
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //******************************************************************** 
.................... // Created November 22, 2016 
.................... // Load the local routines out of the internal EEPROM for the PIC18 series CPUs.  This does not work on the PIC24 or PIC33 CPUS 
.................... //  The data is saved different for each CPU for the data type.   
.................... //  Returns nothing. 
.................... //******************************************************************** 
.................... unsigned int16 getlocalconfigurations(void) 
.................... { 
....................     int8 lowbyte,highbyte; 
....................     unsigned int16 items; 
....................      
....................     lowbyte = read_eeprom(0x78); 
*
01538:  MOVFF  FF2,774
0153C:  BCF    FF2.7
0153E:  CLRF   FAA
01540:  MOVLW  78
01542:  MOVWF  FA9
01544:  BCF    FA6.6
01546:  BCF    FA6.7
01548:  BSF    FA6.0
0154A:  MOVF   FA8,W
0154C:  MOVLB  7
0154E:  BTFSC  x74.7
01550:  BSF    FF2.7
01552:  MOVWF  x70
....................     highbyte = read_eeprom(0x79); 
01554:  MOVFF  FF2,774
01558:  BCF    FF2.7
0155A:  CLRF   FAA
0155C:  MOVLW  79
0155E:  MOVWF  FA9
01560:  BCF    FA6.6
01562:  BCF    FA6.7
01564:  BSF    FA6.0
01566:  MOVF   FA8,W
01568:  BTFSC  x74.7
0156A:  BSF    FF2.7
0156C:  MOVWF  x71
....................     items = (int16) highbyte; 
0156E:  CLRF   x73
01570:  MOVFF  771,772
....................     
....................     items = (items<<8) +  lowbyte; 
01574:  MOVFF  772,775
01578:  CLRF   x74
0157A:  MOVF   x70,W
0157C:  ADDWF  x74,W
0157E:  MOVWF  x72
01580:  MOVLW  00
01582:  ADDWFC x75,W
01584:  MOVWF  x73
....................     return(items); 
01586:  MOVFF  772,01
0158A:  MOVFF  773,02
0158E:  MOVLB  0
01590:  GOTO   8FE6 (RETURN)
.................... } 
....................  
.................... //********************************************************************** 
.................... // Created November 22, 2016 
.................... // This saves the local configurations to the EEPROM.  The data so far is only 16 bits. 
.................... // int16 word saved to address 
.................... // Returns if the data is save OK.  A 0 for OK, a 1 for not OK 
.................... //********************************************************************** 
.................... int savelocalconfigurations(int16 selectitem) 
.................... { 
....................     int8 lowbyte,highbyte; 
....................      unsigned int16 items; 
....................       
....................     lowbyte =(int8) selectitem; 
*
052F4:  MOVFF  7A8,7AA
....................     highbyte = (int8) (selectitem>>8); 
052F8:  MOVLB  7
052FA:  MOVF   xA9,W
052FC:  MOVWF  xAB
....................     write_eeprom(0x78,lowbyte); 
052FE:  MOVF   FF2,W
05300:  MOVWF  00
05302:  BCF    FF2.7
05304:  CLRF   FAA
05306:  MOVLW  78
05308:  MOVWF  FA9
0530A:  MOVFF  7AA,FA8
0530E:  BCF    FA6.6
05310:  BCF    FA6.7
05312:  BSF    FA6.2
05314:  MOVLB  F
05316:  MOVLW  55
05318:  MOVWF  FA7
0531A:  MOVLW  AA
0531C:  MOVWF  FA7
0531E:  BSF    FA6.1
05320:  BTFSC  FA6.1
05322:  BRA    5320
05324:  BCF    FA6.2
05326:  MOVF   00,W
05328:  IORWF  FF2,F
....................     write_eeprom(0x79,highbyte); 
0532A:  MOVFF  FF2,00
0532E:  BCF    FF2.7
05330:  CLRF   FAA
05332:  MOVLW  79
05334:  MOVWF  FA9
05336:  MOVFF  7AB,FA8
0533A:  BCF    FA6.6
0533C:  BCF    FA6.7
0533E:  BSF    FA6.2
05340:  MOVLW  55
05342:  MOVWF  FA7
05344:  MOVLW  AA
05346:  MOVWF  FA7
05348:  BSF    FA6.1
0534A:  BTFSC  FA6.1
0534C:  BRA    534A
0534E:  BCF    FA6.2
05350:  MOVF   00,W
05352:  IORWF  FF2,F
....................      
....................     lowbyte = read_eeprom(0x78); 
05354:  MOVFF  FF2,7AE
05358:  BCF    FF2.7
0535A:  CLRF   FAA
0535C:  MOVLW  78
0535E:  MOVWF  FA9
05360:  BCF    FA6.6
05362:  BCF    FA6.7
05364:  BSF    FA6.0
05366:  MOVF   FA8,W
05368:  MOVLB  7
0536A:  BTFSC  xAE.7
0536C:  BSF    FF2.7
0536E:  MOVWF  xAA
....................     highbyte = read_eeprom(0x79); 
05370:  MOVFF  FF2,7AE
05374:  BCF    FF2.7
05376:  CLRF   FAA
05378:  MOVLW  79
0537A:  MOVWF  FA9
0537C:  BCF    FA6.6
0537E:  BCF    FA6.7
05380:  BSF    FA6.0
05382:  MOVF   FA8,W
05384:  BTFSC  xAE.7
05386:  BSF    FF2.7
05388:  MOVWF  xAB
....................     items = (int16) highbyte; 
0538A:  CLRF   xAD
0538C:  MOVFF  7AB,7AC
....................     
....................     items = (items<<8) +  lowbyte;  
05390:  MOVFF  7AC,7AF
05394:  CLRF   xAE
05396:  MOVF   xAA,W
05398:  ADDWF  xAE,W
0539A:  MOVWF  xAC
0539C:  MOVLW  00
0539E:  ADDWFC xAF,W
053A0:  MOVWF  xAD
....................      
....................     if (items == selectitem) 
053A2:  MOVF   xA8,W
053A4:  SUBWF  xAC,W
053A6:  BNZ   53B6
053A8:  MOVF   xA9,W
053AA:  SUBWF  xAD,W
053AC:  BNZ   53B6
....................     { 
....................         return(0); 
053AE:  MOVLW  00
053B0:  MOVWF  01
053B2:  BRA    53BA
....................     } 
053B4:  BRA    53BA
....................     else 
....................     { 
....................         return(1); 
053B6:  MOVLW  01
053B8:  MOVWF  01
....................     } 
053BA:  MOVLB  0
053BC:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... //********************************************************************* 
.................... // Created July 15, 2015 
.................... // Splash screen for 1 second before going into the main loop; 
.................... //  Give Version, credit to Erik and Paul 
.................... // Provide Version Date 
.................... //********************************************************************* 
....................  
.................... void splash(void) { 
....................     clearDisplay(); 
*
013BA:  RCALL  131E
....................     char teststr4[20] = "Ver 5.03 4/6/2017"; 
013BC:  MOVLW  56
013BE:  MOVLB  7
013C0:  MOVWF  x70
013C2:  MOVLW  65
013C4:  MOVWF  x71
013C6:  MOVLW  72
013C8:  MOVWF  x72
013CA:  MOVLW  20
013CC:  MOVWF  x73
013CE:  MOVLW  35
013D0:  MOVWF  x74
013D2:  MOVLW  2E
013D4:  MOVWF  x75
013D6:  MOVLW  30
013D8:  MOVWF  x76
013DA:  MOVLW  33
013DC:  MOVWF  x77
013DE:  MOVLW  20
013E0:  MOVWF  x78
013E2:  MOVLW  34
013E4:  MOVWF  x79
013E6:  MOVLW  2F
013E8:  MOVWF  x7A
013EA:  MOVLW  36
013EC:  MOVWF  x7B
013EE:  MOVLW  2F
013F0:  MOVWF  x7C
013F2:  MOVLW  32
013F4:  MOVWF  x7D
013F6:  MOVLW  30
013F8:  MOVWF  x7E
013FA:  MOVLW  31
013FC:  MOVWF  x7F
013FE:  MOVLW  37
01400:  MOVWF  x80
01402:  CLRF   x81
....................     char teststr1[20] = "Production Tester"; 
01404:  MOVLW  50
01406:  MOVWF  x84
01408:  MOVLW  72
0140A:  MOVWF  x85
0140C:  MOVLW  6F
0140E:  MOVWF  x86
01410:  MOVLW  64
01412:  MOVWF  x87
01414:  MOVLW  75
01416:  MOVWF  x88
01418:  MOVLW  63
0141A:  MOVWF  x89
0141C:  MOVLW  74
0141E:  MOVWF  x8A
01420:  MOVLW  69
01422:  MOVWF  x8B
01424:  MOVLW  6F
01426:  MOVWF  x8C
01428:  MOVLW  6E
0142A:  MOVWF  x8D
0142C:  MOVLW  20
0142E:  MOVWF  x8E
01430:  MOVLW  54
01432:  MOVWF  x8F
01434:  MOVLW  65
01436:  MOVWF  x90
01438:  MOVLW  73
0143A:  MOVWF  x91
0143C:  MOVLW  74
0143E:  MOVWF  x92
01440:  MOVLW  65
01442:  MOVWF  x93
01444:  MOVLW  72
01446:  MOVWF  x94
01448:  CLRF   x95
....................     char teststr2[20] = "Config Editor"; 
0144A:  MOVLW  43
0144C:  MOVWF  x98
0144E:  MOVLW  6F
01450:  MOVWF  x99
01452:  MOVLW  6E
01454:  MOVWF  x9A
01456:  MOVLW  66
01458:  MOVWF  x9B
0145A:  MOVLW  69
0145C:  MOVWF  x9C
0145E:  MOVLW  67
01460:  MOVWF  x9D
01462:  MOVLW  20
01464:  MOVWF  x9E
01466:  MOVLW  45
01468:  MOVWF  x9F
0146A:  MOVLW  64
0146C:  MOVWF  xA0
0146E:  MOVLW  69
01470:  MOVWF  xA1
01472:  MOVLW  74
01474:  MOVWF  xA2
01476:  MOVLW  6F
01478:  MOVWF  xA3
0147A:  MOVLW  72
0147C:  MOVWF  xA4
0147E:  CLRF   xA5
....................     char teststr3[20] = "Paul Holowko-Titular"; 
01480:  MOVLW  50
01482:  MOVWF  xAC
01484:  MOVLW  61
01486:  MOVWF  xAD
01488:  MOVLW  75
0148A:  MOVWF  xAE
0148C:  MOVLW  6C
0148E:  MOVWF  xAF
01490:  MOVLW  20
01492:  MOVWF  xB0
01494:  MOVLW  48
01496:  MOVWF  xB1
01498:  MOVLW  6F
0149A:  MOVWF  xB2
0149C:  MOVLW  6C
0149E:  MOVWF  xB3
014A0:  MOVLW  6F
014A2:  MOVWF  xB4
014A4:  MOVLW  77
014A6:  MOVWF  xB5
014A8:  MOVLW  6B
014AA:  MOVWF  xB6
014AC:  MOVLW  6F
014AE:  MOVWF  xB7
014B0:  MOVLW  2D
014B2:  MOVWF  xB8
014B4:  MOVLW  54
014B6:  MOVWF  xB9
014B8:  MOVLW  69
014BA:  MOVWF  xBA
014BC:  MOVLW  74
014BE:  MOVWF  xBB
014C0:  MOVLW  75
014C2:  MOVWF  xBC
014C4:  MOVLW  6C
014C6:  MOVWF  xBD
014C8:  MOVLW  61
014CA:  MOVWF  xBE
014CC:  MOVLW  72
014CE:  MOVWF  xBF
....................     writeString(0, 0, teststr1); 
014D0:  CLRF   xC0
014D2:  CLRF   xC1
014D4:  MOVLW  07
014D6:  MOVWF  xC3
014D8:  MOVLW  84
014DA:  MOVWF  xC2
014DC:  MOVLB  0
014DE:  RCALL  134A
....................     writeString(0, 1, teststr2); 
014E0:  MOVLB  7
014E2:  CLRF   xC0
014E4:  MOVLW  01
014E6:  MOVWF  xC1
014E8:  MOVLW  07
014EA:  MOVWF  xC3
014EC:  MOVLW  98
014EE:  MOVWF  xC2
014F0:  MOVLB  0
014F2:  RCALL  134A
....................     writeString(0, 2, teststr3); 
014F4:  MOVLB  7
014F6:  CLRF   xC0
014F8:  MOVLW  02
014FA:  MOVWF  xC1
014FC:  MOVLW  07
014FE:  MOVWF  xC3
01500:  MOVLW  AC
01502:  MOVWF  xC2
01504:  MOVLB  0
01506:  RCALL  134A
....................     writeString(0, 3, teststr4); 
01508:  MOVLB  7
0150A:  CLRF   xC0
0150C:  MOVLW  03
0150E:  MOVWF  xC1
01510:  MOVLW  07
01512:  MOVWF  xC3
01514:  MOVLW  70
01516:  MOVWF  xC2
01518:  MOVLB  0
0151A:  RCALL  134A
....................     delay_ms(2500); 
0151C:  MOVLW  0A
0151E:  MOVLB  7
01520:  MOVWF  xC0
01522:  MOVLW  FA
01524:  MOVWF  xC1
01526:  MOVLB  0
01528:  RCALL  1202
0152A:  MOVLB  7
0152C:  DECFSZ xC0,F
0152E:  BRA    1522
....................     clearDisplay(); 
01530:  MOVLB  0
01532:  RCALL  131E
01534:  GOTO   8FE2 (RETURN)
.................... } 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... // Created May 13, 2013 
.................... // This routine returns the determinent for a given 3X3 mastrix passed through the funtion stack as a pointer to address. 
.................... // The Deteminete is returned at the end of the funtion call. 
.................... // This method for solving equations is called Cramer's rule 
.................... //****************************************************************************** 
....................  
.................... float FindTheDetermint(void) { 
....................     float det, part1, part2; //Define the determint as float. 
....................  
....................     part1 = matx[0][0] * matx[1][1] * matx[2][2]; 
....................  
....................     det = (part1 + matx[1][0] * matx[2][1] * matx[0][2] + matx[2][0] * matx[0][1] * matx[1][2]); 
....................     part2 = (matx[0][2] * matx[1][1] * matx[2][0] + matx[1][2] * matx[2][1] * matx[0][0] + matx[2][2] * matx[0][1] * matx[1][0]); 
....................     det = det - (matx[0][2] * matx[1][1] * matx[2][0] + matx[1][2] * matx[2][1] * matx[0][0] + matx[2][2] * matx[0][1] * matx[1][0]); 
....................  
....................     return (det); 
.................... } 
....................  
.................... int16 GetADCValue(int selection) { 
....................     int16 ReturnedADC, Summer; 
....................     int f; 
....................     //setup_adc(ADC_CLOCK_INTERNAL);  //Setup the ADC to run.. 
....................     set_adc_channel(selection); 
*
01C96:  MOVLB  7
01C98:  RLCF   xAF,W
01C9A:  MOVWF  00
01C9C:  RLCF   00,F
01C9E:  MOVLW  FC
01CA0:  ANDWF  00,F
01CA2:  MOVF   FC2,W
01CA4:  ANDLW  83
01CA6:  IORWF  00,W
01CA8:  MOVWF  FC2
....................     //		delay_ms(10); 
....................     Summer = 0; 
01CAA:  CLRF   xB3
01CAC:  CLRF   xB2
....................     for (f = 0; f < 32; f++) { 
01CAE:  CLRF   xB4
01CB0:  MOVF   xB4,W
01CB2:  SUBLW  1F
01CB4:  BNC   1CC8
....................         //delay_us(10); 
....................         Summer = Summer + read_adc(); // Read adc channel 10  
01CB6:  BSF    FC2.1
01CB8:  BTFSC  FC2.1
01CBA:  BRA    1CB8
01CBC:  MOVF   FC3,W
01CBE:  ADDWF  xB2,F
01CC0:  MOVF   FC4,W
01CC2:  ADDWFC xB3,F
01CC4:  INCF   xB4,F
01CC6:  BRA    1CB0
....................     } 
....................     ReturnedADC = Summer >> 5; 
01CC8:  RRCF   xB3,W
01CCA:  MOVWF  xB1
01CCC:  RRCF   xB2,W
01CCE:  MOVWF  xB0
01CD0:  RRCF   xB1,F
01CD2:  RRCF   xB0,F
01CD4:  RRCF   xB1,F
01CD6:  RRCF   xB0,F
01CD8:  RRCF   xB1,F
01CDA:  RRCF   xB0,F
01CDC:  RRCF   xB1,F
01CDE:  RRCF   xB0,F
01CE0:  MOVLW  07
01CE2:  ANDWF  xB1,F
....................     return (ReturnedADC); 
01CE4:  MOVFF  7B0,01
01CE8:  MOVFF  7B1,02
01CEC:  MOVLB  0
01CEE:  GOTO   3A98 (RETURN)
.................... } 
....................  
....................  
....................  
.................... //***************************************************************** 
.................... // Created May 19, 2016 
.................... // This takes a sampling of the pHBulb and averages them all together. 
.................... // The result is the raw data from the ADC.  In this case it is connected to AD7 
.................... // It returns a float 
.................... //**************************************************************** 
....................  
.................... float ConvertADCTophBulb(void) { 
....................     int16 ReturnedADC; 
....................     int x; 
....................     float tempfloater, tempsummer; 
....................     tempsummer = 0.0; 
....................     for (x = 0; x < 10; x++) { 
....................  
....................         ReturnedADC = GetADCValue(0); //This gets the current ADC conversion for the channel number. 
....................  
....................         tempfloater = (float) ReturnedADC; 
....................         tempsummer = tempsummer + tempfloater; 
....................  
....................     } 
....................     tempfloater = tempsummer / 10.0; 
....................     return (tempfloater); 
.................... } 
....................  
.................... //************************************************************* 
.................... // Created May 15, 2015 
.................... // This routine solves for the coefficents for thermisters ai 
.................... // This routine reads the EEPROM (when completed) and calculates the curve and temperature from four thermal points. 
.................... //************************************************************* 
....................  
.................... void DetermineTempCoef(void) { 
....................     //This has been removed and placed in TaosLightSensor.h  May 21, 2015 
....................     //float temp1,reading1,temp2,reading2,temp3,reading3; 
....................     float temp1in, temp2in, temp3in; 
....................     float reading1in, reading2in, reading3in; 
....................     float det, det1, det2, det3; //These are the other dets for each solution 
....................     // This is the raw data.  Added May 15, 2015 
....................  
....................     //temp1 = 40;     
....................     //temp2 = 21; 
....................     //temp3 = 6; 
....................  
....................     //*************************************************************************** 
....................     //Added January 13, 2015 
....................     // These are the values used for the 10K reistor stolen from Animatics 
....................     //*************************************************************************** 
....................     //reading1 = 5140; 
....................     //reading2 = 13037; 
....................     //reading3 = 27594; 
....................     //*************************************************************************** 
....................     //Added January 13, 2015 
....................     // These are the values used for the ?K reistor supplied by Rick 
....................     //*************************************************************************** 
....................  
....................     //reading1 = 12000;   //this one is measured at 45 degrees C   // these numbers are for the 30K reistor 
....................     //reading2 = 40000;   //this is measured at 22 C  Checked on May 14, 2015 
....................     //reading3 = 72000;   // this tempature is measured at 12 degrees C 
....................  
....................  
....................     temp1in = 1.0 / (temp1 + 273.0); 
....................     temp2in = 1.0 / (temp2 + 273.0); 
....................     temp3in = 1.0 / (temp3 + 273.0); 
....................  
....................  
....................     reading1in = log(reading1); 
....................     reading2in = log(reading2); 
....................     reading3in = log(reading3); 
....................  
....................  
....................     //  This part solves for tempa1, tempa2, tempa3 4 
....................     // Find the divistion determinent 
....................  
....................     matx[0][0] = 1.0; 
....................     matx[1][0] = 1.0; 
....................     matx[2][0] = 1.0; 
....................     matx[0][1] = reading1in; 
....................     matx[1][1] = reading2in; 
....................     matx[2][1] = reading3in; 
....................     matx[0][2] = reading1in*reading1in; 
....................     matx[1][2] = reading2in*reading2in; 
....................     matx[2][2] = reading3in*reading3in; 
....................  
....................     det = FindTheDetermint(); 
....................  
....................     //Find the det for tempa1 
....................  
....................     matx[0][0] = temp1in; 
....................     matx[1][0] = temp2in; 
....................     matx[2][0] = temp3in; 
....................     matx[0][1] = reading1in; 
....................     matx[1][1] = reading2in; 
....................     matx[2][1] = reading3in; 
....................     matx[0][2] = reading1in*reading1in; 
....................     matx[1][2] = reading2in*reading2in; 
....................     matx[2][2] = reading3in*reading3in; 
....................  
....................     det1 = FindTheDetermint(); 
....................     tempa1 = det1 / det; //  This finds the value for the first a1 
....................  
....................     matx[0][0] = 1.0; 
....................     matx[1][0] = 1.0; 
....................     matx[2][0] = 1.0; 
....................     matx[0][1] = temp1in; 
....................     matx[1][1] = temp2in; 
....................     matx[2][1] = temp3in; 
....................     matx[0][2] = reading1in*reading1in; 
....................     matx[1][2] = reading2in*reading2in; 
....................     matx[2][2] = reading3in*reading3in; 
....................  
....................  
....................     det2 = FindTheDetermint(); 
....................     tempa2 = det2 / det; //  This finds the value for the first a2 
....................  
....................  
....................  
....................     matx[0][0] = 1.0; 
....................     matx[1][0] = 1.0; 
....................     matx[2][0] = 1.0; 
....................     matx[0][1] = reading1in; 
....................     matx[1][1] = reading2in; 
....................     matx[2][1] = reading3in; 
....................     matx[0][2] = temp1in; 
....................     matx[1][2] = temp2in; 
....................     matx[2][2] = temp3in; 
....................  
....................     det3 = FindTheDetermint(); 
....................     tempa3 = det3 / det; //  This finds the value for the first a2 
....................  
....................  
.................... } 
....................  
....................  
.................... //***************************************************************** 
.................... // Created Nov. 6, 2012 
.................... // Converts the ADC number on a scale of 5 volts minus some for Op-amp issues 
.................... // The numerical convertion is conveted into degrees C. 
.................... // The returned value in C degrees. 
.................... //  Ths interm convertion is to Kalvin and will later be switched over to Kalvin scale. 
.................... //***************************************************************** 
....................  
.................... float ConvertADCToKalvin(int ADCInputNumber) { 
....................     int16 ReturnedADC; 
....................     float32 ADCVoltageIn, Kelvin, tempfloater; 
....................     ReturnedADC = GetADCValue(ADCInputNumber); //This gets the current ADC convertion for the channel number. 
....................     //    ADCVoltageIn = ReturnedADC * 5.0 / 1024.0;  //Recycled the same float variable.  This is for the 5 volts version. 
....................     tempfloater = (float) ReturnedADC; 
....................     // ADCVoltageIn = (float) ReturnedADC * 3.3 / 1024.0;  //Recycled the same float variable.  This converts the input into scaling 
....................     ADCVoltageIn = (float) ReturnedADC * 5.0 / 1024.0; //Recycled the same float variable.  This converts the input into scaling 
....................  
....................     //Added May 18, 2015  - The current/last thermister is RL0503-7.56K-96-MS  it's a 30K thermister. 
....................  
....................     //	ADCVoltageIn = 5100.0*ADCVoltageIn/(3.3 - ADCVoltageIn);  // Calulate the thermister reistance over a voltage divider.  It's at the bottom of a 0 to 5 volts divider.  The resistance is 4.999K 
....................  
....................     //ADCVoltageIn = 4999.0*ADCVoltageIn/(3.3 - ADCVoltageIn);  // Calculate the thermister reistance over a voltage divider.  It's at the bottom of a 0 to 5 volts divider.  The resistance is 4.999K 
....................     ADCVoltageIn = 5100.0 * ADCVoltageIn / (5.0 - ADCVoltageIn); // Calculate the thermister reistance over a voltage divider.  It's at the bottom of a 0 to 5 volts divider.  The resistance is 4.999K 
....................  
....................  
....................  
....................     DetermineTempCoef(); 
....................  
....................     //Kelvin = (1/(tempa1 + tempa2*(log(ADCVoltageIn)) + tempa3*(log(ADCVoltageIn)*log(ADCVoltageIn))))-273.15;   //This is the old line of code used to find the thermister temperature 
....................     Kelvin = (1 / (tempa1 + tempa2 * (log(ADCVoltageIn)) + tempa3 * (log(ADCVoltageIn) * log(ADCVoltageIn)))) - 273.15; 
....................     return (Kelvin); 
.................... } 
....................  
....................  
....................  
.................... //********************************************************************* 
.................... // Created June 25, 2015 
.................... // This routine calls the water temperature program and averages together twenty points.  Twenty two points are 
.................... // collected and the high and low reading is thrown out.   
.................... // There is no input needed in this routine.  The result is returned as a float. 
.................... //********************************************************************* 
....................  
.................... float WaterTemperature(void) { 
....................     float temparray[42], tempval; 
....................  
....................     int switchflag, x; //This is used in the ordering routine to indicate if two numbers have been switched.  If not, then the array is in numerical order. 
....................  
....................     for (x = 0; x < 42; x++) // Get all of the readings and save them in an array. 
....................     { 
....................         temparray[x] = ConvertADCToKalvin(1); //This called current thermisting reading routine. It returns a temperature reading in C. 
....................     } 
....................  
....................     //  Place the numbers in order in the array from the lowest reading at the high numbers indexs and the hightest readings at the low indexes. 
....................  
....................     do { 
....................         switchflag = 0; //Set it to zero indicating everything is in order. 
....................         for (x = 0; x < 41; x++) { 
....................             if (temparray[x] < temparray[x + 1]) { 
....................                 tempval = temparray[x]; 
....................                 temparray[x] = temparray[x + 1]; 
....................                 temparray[x + 1] = tempval; 
....................                 // Since this case is true, then switch the numbers in the array and set the not completed flag to 1. 
....................                 switchflag = 1; //  Indicate are reversal needed to be done. 
....................             } 
....................         } 
....................     } while (switchflag == 1); //If the value is zero, the array is in order. 
....................  
....................  
....................     //  Average the numbers between 1 and 21.  This will kick out the hightest and lowest readings. 
....................     tempval = 0; //recycled the varaible used for averaging the readings together. 
....................     for (x = 1; x < 41; x++) { 
....................         tempval = tempval + temparray[x]; 
....................     } 
....................     tempval = tempval / 40.0; //Divide the added number by 20 which is the number of values added together. 
....................  
....................  
....................     return (tempval); 
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created October 17, 2016 
.................... // This is a check sum for the data sent through the I2C back to the master.  The numbers are split and put into the 
.................... // last two locations of the upload send_buffer[]. 
.................... //  Returns a 0 if there is no problem, It returns a 1 if there is a problem 
.................... //****************************************************************************** 
....................  
.................... int CalculateCRC(void) { 
....................     unsigned int16 checksum; 
....................     unsigned int8 checksumhigh, checksumlow, x; 
....................     for (x = 0; x < 98; x++) { 
....................         checksum = checksum + rec_buffer[x]; 
....................     } 
....................     //seperate the numbers into high and low 
....................     checksumlow = 0x00FF & checksum; 
....................     //  place the numbers in the array 
....................     checksumhigh = (0xFF00 & checksum) >> 8; 
....................     if ((checksumlow == rec_buffer[98]) && (checksumlow == rec_buffer[99])) { 
....................         return (0); // no problem and the checksum matches 
....................     } else { 
....................         return (1); // someplace has an error and the checksum does not match. 
....................     } 
.................... } 
....................  
....................  
....................  
.................... #INT_RDA 
....................  
.................... void RDA_isr() { 
....................     int8 tbt; 
....................  
....................     BTbuffer[BTnext_in] = fgetc(BT); 
*
00FB2:  MOVLW  26
00FB4:  MOVLB  6
00FB6:  ADDWF  x22,W
00FB8:  MOVWF  FE9
00FBA:  MOVLW  06
00FBC:  ADDWFC x23,W
00FBE:  MOVWF  FEA
00FC0:  BTFSS  F9E.5
00FC2:  BRA    0FC0
00FC4:  MOVFF  FAE,FEF
....................     tbt = BTnext_in; 
00FC8:  MOVFF  622,7F3
....................     // putc(tbt,BT); 
....................     //writeChar(tbt); 
....................     BTnext_in = (BTnext_in + 1) % sizeof (BTbuffer); 
00FCC:  MOVLW  01
00FCE:  ADDWF  x22,W
00FD0:  MOVLB  7
00FD2:  MOVWF  xF4
00FD4:  MOVLW  00
00FD6:  MOVLB  6
00FD8:  ADDWFC x23,W
00FDA:  MOVLB  7
00FDC:  MOVF   xF4,W
00FDE:  ANDLW  3F
00FE0:  MOVLB  6
00FE2:  MOVWF  x22
00FE4:  CLRF   x23
....................     if (BTnext_in == BTnext_out) { 
00FE6:  MOVF   x24,W
00FE8:  SUBWF  x22,W
00FEA:  BNZ   0FF8
00FEC:  MOVF   x25,W
00FEE:  SUBWF  x23,W
00FF0:  BNZ   0FF8
....................         BTnext_in = tbt; // Buffer full !! 
00FF2:  CLRF   x23
00FF4:  MOVFF  7F3,622
....................     } 
....................     //ADDED Crap 
....................     if (BTnext_in == BT_BUFF_SIZE) { 
00FF8:  MOVF   x22,W
00FFA:  SUBLW  40
00FFC:  BNZ   1006
00FFE:  MOVF   x23,F
01000:  BNZ   1006
....................         BTnext_in = 0; 
01002:  CLRF   x23
01004:  CLRF   x22
....................     } 
....................     //ADDED Crap 
....................     if (BTnext_out == BT_BUFF_SIZE) { 
01006:  MOVF   x24,W
01008:  SUBLW  40
0100A:  BNZ   1014
0100C:  MOVF   x25,F
0100E:  BNZ   1014
....................         BTnext_out = 0; 
01010:  CLRF   x25
01012:  CLRF   x24
....................     } 
....................  
01014:  BCF    F9E.5
01016:  MOVLB  0
01018:  GOTO   0060
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Febuary 12, 2017 
.................... // Get the version of the device.  This is used for checking if the device is plugged into the unit 
.................... // Command 0x40   It has been changed from 0x66 because of memory buffer size 
.................... // The correct returned value is 0xA9 
.................... int GetAnalogDONHFourVersion(int lightsensor) 
.................... 	{ 
.................... int version,returned,x; 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
*
038C6:  MOVFF  7AF,7B4
038CA:  RCALL  3608
....................  
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
.................... 	i2c_start(PH_LIGHT); 
038CC:  BSF    F93.0
038CE:  MOVLW  50
038D0:  MOVWF  00
038D2:  DECFSZ 00,F
038D4:  BRA    38D2
038D6:  BSF    F93.1
038D8:  MOVLW  51
038DA:  MOVWF  00
038DC:  DECFSZ 00,F
038DE:  BRA    38DC
038E0:  BCF    F8A.0
038E2:  BCF    F93.0
038E4:  MOVLW  50
038E6:  MOVWF  00
038E8:  DECFSZ 00,F
038EA:  BRA    38E8
038EC:  BCF    F8A.1
038EE:  BCF    F93.1
....................  //       delay_ms(10); 
....................     returned=i2c_write(PH_LIGHT,0xa0);  //Move the address number left on and add a zero. 
038F0:  MOVLW  A0
038F2:  MOVLB  7
038F4:  MOVWF  xB4
038F6:  MOVLB  0
038F8:  RCALL  364C
038FA:  MOVFF  01,7B1
....................     if (returned == 0x01) 
038FE:  MOVLB  7
03900:  DECFSZ xB1,W
03902:  BRA    392A
....................     { 
....................     i2c_stop(PH_LIGHT);   // perhaps a delay here 
03904:  BCF    F93.0
03906:  NOP   
03908:  BSF    F93.1
0390A:  BTFSS  F81.1
0390C:  BRA    390A
0390E:  MOVLW  50
03910:  MOVWF  00
03912:  DECFSZ 00,F
03914:  BRA    3912
03916:  BRA    3918
03918:  NOP   
0391A:  BSF    F93.0
0391C:  MOVLW  50
0391E:  MOVWF  00
03920:  DECFSZ 00,F
03922:  BRA    3920
....................     return(0x1A); 
03924:  MOVLW  1A
03926:  MOVWF  01
03928:  BRA    3A4E
....................     }  
....................  //   delay_ms(10); 
....................     returned=i2c_write(PH_LIGHT,0x40);  //Send the command for reading the version 
0392A:  MOVLW  40
0392C:  MOVWF  xB4
0392E:  MOVLB  0
03930:  RCALL  364C
03932:  MOVFF  01,7B1
.................... if (returned == 0x01) 
03936:  MOVLB  7
03938:  DECFSZ xB1,W
0393A:  BRA    3962
....................     { 
....................     i2c_stop(PH_LIGHT);   // perhaps a delay here 
0393C:  BCF    F93.0
0393E:  NOP   
03940:  BSF    F93.1
03942:  BTFSS  F81.1
03944:  BRA    3942
03946:  MOVLW  50
03948:  MOVWF  00
0394A:  DECFSZ 00,F
0394C:  BRA    394A
0394E:  BRA    3950
03950:  NOP   
03952:  BSF    F93.0
03954:  MOVLW  50
03956:  MOVWF  00
03958:  DECFSZ 00,F
0395A:  BRA    3958
....................     return(0x1B); 
0395C:  MOVLW  1B
0395E:  MOVWF  01
03960:  BRA    3A4E
....................     }  
....................    
....................  
.................... returned=i2c_write(PH_LIGHT,0x01);  //Set the register to one to ask for the version number. 
03962:  MOVLW  01
03964:  MOVWF  xB4
03966:  MOVLB  0
03968:  RCALL  364C
0396A:  MOVFF  01,7B1
.................... if (returned == 0x01)  
0396E:  MOVLB  7
03970:  DECFSZ xB1,W
03972:  BRA    399A
....................     { 
....................     i2c_stop(PH_LIGHT);   // perhaps a delay here 
03974:  BCF    F93.0
03976:  NOP   
03978:  BSF    F93.1
0397A:  BTFSS  F81.1
0397C:  BRA    397A
0397E:  MOVLW  50
03980:  MOVWF  00
03982:  DECFSZ 00,F
03984:  BRA    3982
03986:  BRA    3988
03988:  NOP   
0398A:  BSF    F93.0
0398C:  MOVLW  50
0398E:  MOVWF  00
03990:  DECFSZ 00,F
03992:  BRA    3990
....................     return(0x1C); 
03994:  MOVLW  1C
03996:  MOVWF  01
03998:  BRA    3A4E
....................     } 
.................... //delay_ms(15); 
.................... 	i2c_stop(PH_LIGHT);   // perhaps a delay here 
0399A:  BCF    F93.0
0399C:  NOP   
0399E:  BSF    F93.1
039A0:  BTFSS  F81.1
039A2:  BRA    39A0
039A4:  MOVLW  50
039A6:  MOVWF  00
039A8:  DECFSZ 00,F
039AA:  BRA    39A8
039AC:  BRA    39AE
039AE:  NOP   
039B0:  BSF    F93.0
039B2:  MOVLW  50
039B4:  MOVWF  00
039B6:  DECFSZ 00,F
039B8:  BRA    39B6
....................  
....................     i2c_start(PH_LIGHT); 
039BA:  BSF    F93.0
039BC:  MOVLW  50
039BE:  MOVWF  00
039C0:  DECFSZ 00,F
039C2:  BRA    39C0
039C4:  BSF    F93.1
039C6:  MOVLW  51
039C8:  MOVWF  00
039CA:  DECFSZ 00,F
039CC:  BRA    39CA
039CE:  BCF    F8A.0
039D0:  BCF    F93.0
039D2:  MOVLW  50
039D4:  MOVWF  00
039D6:  DECFSZ 00,F
039D8:  BRA    39D6
039DA:  BCF    F8A.1
039DC:  BCF    F93.1
....................  
....................  
.................... returned=i2c_write(PH_LIGHT,0xa1);  //Move the address number left on and add a one to make is a read command. 
039DE:  MOVLW  A1
039E0:  MOVWF  xB4
039E2:  MOVLB  0
039E4:  RCALL  364C
039E6:  MOVFF  01,7B1
.................... if (returned == 0x01)  
039EA:  MOVLB  7
039EC:  DECFSZ xB1,W
039EE:  BRA    3A16
....................     { 
....................     i2c_stop(PH_LIGHT);   // perhaps a delay here 
039F0:  BCF    F93.0
039F2:  NOP   
039F4:  BSF    F93.1
039F6:  BTFSS  F81.1
039F8:  BRA    39F6
039FA:  MOVLW  50
039FC:  MOVWF  00
039FE:  DECFSZ 00,F
03A00:  BRA    39FE
03A02:  BRA    3A04
03A04:  NOP   
03A06:  BSF    F93.0
03A08:  MOVLW  50
03A0A:  MOVWF  00
03A0C:  DECFSZ 00,F
03A0E:  BRA    3A0C
....................     return(0x1D); 
03A10:  MOVLW  1D
03A12:  MOVWF  01
03A14:  BRA    3A4E
....................     } 
....................   
....................     delay_ms(75); 
03A16:  MOVLW  4B
03A18:  MOVWF  xC1
03A1A:  MOVLB  0
03A1C:  CALL   1202
.................... 	version = i2c_read(PH_LIGHT,FALSE); 
03A20:  CLRF   00
03A22:  RCALL  36C2
03A24:  MOVFF  01,7B0
....................   
.................... i2c_stop(PH_LIGHT);   // perhaps a delay here 
03A28:  BCF    F93.0
03A2A:  NOP   
03A2C:  BSF    F93.1
03A2E:  BTFSS  F81.1
03A30:  BRA    3A2E
03A32:  MOVLW  50
03A34:  MOVWF  00
03A36:  DECFSZ 00,F
03A38:  BRA    3A36
03A3A:  BRA    3A3C
03A3C:  NOP   
03A3E:  BSF    F93.0
03A40:  MOVLW  50
03A42:  MOVWF  00
03A44:  DECFSZ 00,F
03A46:  BRA    3A44
.................... //return(0x88); 
.................... 	return(version); 
03A48:  MOVLB  7
03A4A:  MOVFF  7B0,01
03A4E:  MOVLB  0
03A50:  RETURN 0
.................... 	} 
....................  
....................  
....................  
.................... //******************************************************************** 
.................... // Created March 19, 2013 
.................... // Added to this routine Jan 24, 2017 
.................... // Get the version of the device.  This  routine is used for testing I2C. 
.................... // Command 0x04 
.................... // This routine returns the version of the light chip.  
.................... //********************************************************************* 
.................... int getTAOSVersion(int lightsensor) 
.................... 	{ 
.................... int version; 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
*
03808:  MOVFF  7AF,7B4
0380C:  RCALL  3608
....................  
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
....................  
.................... 	i2c_start(PH_LIGHT); 
0380E:  BSF    F93.0
03810:  MOVLW  50
03812:  MOVWF  00
03814:  DECFSZ 00,F
03816:  BRA    3814
03818:  BSF    F93.1
0381A:  MOVLW  51
0381C:  MOVWF  00
0381E:  DECFSZ 00,F
03820:  BRA    381E
03822:  BCF    F8A.0
03824:  BCF    F93.0
03826:  MOVLW  50
03828:  MOVWF  00
0382A:  DECFSZ 00,F
0382C:  BRA    382A
0382E:  BCF    F8A.1
03830:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
03832:  MOVLW  72
03834:  MOVLB  7
03836:  MOVWF  xB4
03838:  MOVLB  0
0383A:  RCALL  364C
.................... 	i2c_write(PH_LIGHT,0x84);  //Send the command for reading the version 
0383C:  MOVLW  84
0383E:  MOVLB  7
03840:  MOVWF  xB4
03842:  MOVLB  0
03844:  RCALL  364C
.................... 	i2c_stop(PH_LIGHT); 
03846:  BCF    F93.0
03848:  NOP   
0384A:  BSF    F93.1
0384C:  BTFSS  F81.1
0384E:  BRA    384C
03850:  MOVLW  50
03852:  MOVWF  00
03854:  DECFSZ 00,F
03856:  BRA    3854
03858:  BRA    385A
0385A:  NOP   
0385C:  BSF    F93.0
0385E:  MOVLW  50
03860:  MOVWF  00
03862:  DECFSZ 00,F
03864:  BRA    3862
....................     i2c_start(PH_LIGHT,0); 
03866:  BSF    F93.0
03868:  MOVLW  50
0386A:  MOVWF  00
0386C:  DECFSZ 00,F
0386E:  BRA    386C
03870:  BSF    F93.1
03872:  MOVLW  51
03874:  MOVWF  00
03876:  DECFSZ 00,F
03878:  BRA    3876
0387A:  BCF    F8A.0
0387C:  BCF    F93.0
0387E:  MOVLW  50
03880:  MOVWF  00
03882:  DECFSZ 00,F
03884:  BRA    3882
03886:  BCF    F8A.1
03888:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
0388A:  MOVLW  73
0388C:  MOVLB  7
0388E:  MOVWF  xB4
03890:  MOVLB  0
03892:  RCALL  364C
.................... 	version = i2c_read(PH_LIGHT,0); 
03894:  CLRF   00
03896:  RCALL  36C2
03898:  MOVFF  01,7B0
.................... 	i2c_stop(PH_LIGHT); 
0389C:  BCF    F93.0
0389E:  NOP   
038A0:  BSF    F93.1
038A2:  BTFSS  F81.1
038A4:  BRA    38A2
038A6:  MOVLW  50
038A8:  MOVWF  00
038AA:  DECFSZ 00,F
038AC:  BRA    38AA
038AE:  BRA    38B0
038B0:  NOP   
038B2:  BSF    F93.0
038B4:  MOVLW  50
038B6:  MOVWF  00
038B8:  DECFSZ 00,F
038BA:  BRA    38B8
....................  
.................... 	return(version); 
038BC:  MOVLB  7
038BE:  MOVFF  7B0,01
038C2:  MOVLB  0
038C4:  RETURN 0
.................... 	} 
....................  
....................  
.................... //********************************************************************** 
.................... // Created March 19, 2013 
.................... // Power up light chip 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the room 
.................... //  Updated December 8, 2015 
.................... //  StartupATOS is used for all six sensors.  The number of the sensor needs to be provided. 
.................... //********************************************************************** 
.................... void StartUpTAOS(int lightsensor) 
.................... 	{ 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
*
046AE:  MOVFF  791,7B4
046B2:  CALL   3608
....................  
.................... // then send the command down to the sensor.  All of the communication is done through the I2C on PH_LIGHT. 
....................  
.................... 	i2c_start(PH_LIGHT); 
046B6:  BSF    F93.0
046B8:  MOVLW  50
046BA:  MOVWF  00
046BC:  DECFSZ 00,F
046BE:  BRA    46BC
046C0:  BSF    F93.1
046C2:  MOVLW  51
046C4:  MOVWF  00
046C6:  DECFSZ 00,F
046C8:  BRA    46C6
046CA:  BCF    F8A.0
046CC:  BCF    F93.0
046CE:  MOVLW  50
046D0:  MOVWF  00
046D2:  DECFSZ 00,F
046D4:  BRA    46D2
046D6:  BCF    F8A.1
046D8:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
046DA:  MOVLW  72
046DC:  MOVLB  7
046DE:  MOVWF  xB4
046E0:  MOVLB  0
046E2:  CALL   364C
.................... 	i2c_write(PH_LIGHT,0x80);  //Send the command for reading the version 
046E6:  MOVLW  80
046E8:  MOVLB  7
046EA:  MOVWF  xB4
046EC:  MOVLB  0
046EE:  CALL   364C
.................... 	i2c_write(PH_LIGHT,0x03);  //Send the command for reading the version 
046F2:  MOVLW  03
046F4:  MOVLB  7
046F6:  MOVWF  xB4
046F8:  MOVLB  0
046FA:  CALL   364C
.................... 	i2c_stop(PH_LIGHT); 
046FE:  BCF    F93.0
04700:  NOP   
04702:  BSF    F93.1
04704:  BTFSS  F81.1
04706:  BRA    4704
04708:  MOVLW  50
0470A:  MOVWF  00
0470C:  DECFSZ 00,F
0470E:  BRA    470C
04710:  BRA    4712
04712:  NOP   
04714:  BSF    F93.0
04716:  MOVLW  50
04718:  MOVWF  00
0471A:  DECFSZ 00,F
0471C:  BRA    471A
0471E:  GOTO   4D7A (RETURN)
.................... 	 
....................  
.................... 	} 
....................  
....................  
.................... //*********************************************************************** 
.................... // Created March 20, 2013 
.................... // This routine changes the exposure time for each sample. 
.................... //  There are three modes of intigration or exposure time per sample. 
.................... // 0 for 12ms 
.................... // 1 for 100 ms 
.................... // 2 for 400 ms 
.................... //*********************************************************************** 
.................... void ExposureTimeTAOS(byte integration, byte lightsensor) 
.................... 	{ 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
*
0463E:  MOVFF  792,7B4
04642:  CALL   3608
....................  
.................... // then send the command down to the sensor.  All of the communication is done through the I2C on PH_LIGHT. 
....................  
....................  
.................... 	i2c_start(PH_LIGHT); 
04646:  BSF    F93.0
04648:  MOVLW  50
0464A:  MOVWF  00
0464C:  DECFSZ 00,F
0464E:  BRA    464C
04650:  BSF    F93.1
04652:  MOVLW  51
04654:  MOVWF  00
04656:  DECFSZ 00,F
04658:  BRA    4656
0465A:  BCF    F8A.0
0465C:  BCF    F93.0
0465E:  MOVLW  50
04660:  MOVWF  00
04662:  DECFSZ 00,F
04664:  BRA    4662
04666:  BCF    F8A.1
04668:  BCF    F93.1
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
0466A:  MOVLW  72
0466C:  MOVLB  7
0466E:  MOVWF  xB4
04670:  MOVLB  0
04672:  CALL   364C
.................... 	i2c_write(PH_LIGHT,0x81);  //Send the command for reading the Timing Register 
04676:  MOVLW  81
04678:  MOVLB  7
0467A:  MOVWF  xB4
0467C:  MOVLB  0
0467E:  CALL   364C
.................... 	i2c_write(PH_LIGHT,integration);  //Send the command for reading the version 
04682:  MOVFF  791,7B4
04686:  CALL   364C
.................... 	i2c_stop(PH_LIGHT); 
0468A:  BCF    F93.0
0468C:  NOP   
0468E:  BSF    F93.1
04690:  BTFSS  F81.1
04692:  BRA    4690
04694:  MOVLW  50
04696:  MOVWF  00
04698:  DECFSZ 00,F
0469A:  BRA    4698
0469C:  BRA    469E
0469E:  NOP   
046A0:  BSF    F93.0
046A2:  MOVLW  50
046A4:  MOVWF  00
046A6:  DECFSZ 00,F
046A8:  BRA    46A6
046AA:  GOTO   4D70 (RETURN)
....................  
.................... 	}  
....................  
....................  
....................  
.................... //****************************************************************** 
.................... //Created March 17, 2013 
.................... // This routine reads the all four inputs and returns the 16 bit value for that color. 
.................... // The value for color is as follows: 
.................... // 1:red 
.................... // 2:greem 
.................... // 3:blue 
.................... // 4:clear 
.................... // The retuened value is measured value. 
.................... //  This measurement is influnenced by the scalling factor for each ADC. 
.................... //  The two numbers are returned through tow global varibles. 
.................... //  The variables are colorlow and colorhigh. 
.................... // Added Oct 20, 2014 - Multi I2C lines can be used for each light sensor 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the room 
.................... //****************************************************************** 
.................... void ReadColorTAOS(int selectedcolor, int lightsensor) 
.................... 	{ 
....................  
.................... 	switch(selectedcolor) 
*
04722:  MOVLB  7
04724:  MOVF   x91,W
04726:  XORLW  02
04728:  MOVLB  0
0472A:  BZ    4740
0472C:  XORLW  03
0472E:  BTFSC  FD8.2
04730:  BRA    48AE
04732:  XORLW  02
04734:  BTFSC  FD8.2
04736:  BRA    4A1C
04738:  XORLW  07
0473A:  BTFSC  FD8.2
0473C:  BRA    4B8A
0473E:  BRA    4CF8
.................... 		{ 
.................... 		case 2:   //green 
.................... 			i2c_start(PH_LIGHT); 
04740:  BSF    F93.0
04742:  MOVLW  50
04744:  MOVWF  00
04746:  DECFSZ 00,F
04748:  BRA    4746
0474A:  BSF    F93.1
0474C:  MOVLW  51
0474E:  MOVWF  00
04750:  DECFSZ 00,F
04752:  BRA    4750
04754:  BCF    F8A.0
04756:  BCF    F93.0
04758:  MOVLW  50
0475A:  MOVWF  00
0475C:  DECFSZ 00,F
0475E:  BRA    475C
04760:  BCF    F8A.1
04762:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04764:  MOVLW  72
04766:  MOVLB  7
04768:  MOVWF  xB4
0476A:  MOVLB  0
0476C:  CALL   364C
.................... 			i2c_write(PH_LIGHT,0x90);  //Send the command for reading the version 
04770:  MOVLW  90
04772:  MOVLB  7
04774:  MOVWF  xB4
04776:  MOVLB  0
04778:  CALL   364C
.................... 			i2c_stop(PH_LIGHT); 
0477C:  BCF    F93.0
0477E:  NOP   
04780:  BSF    F93.1
04782:  BTFSS  F81.1
04784:  BRA    4782
04786:  MOVLW  50
04788:  MOVWF  00
0478A:  DECFSZ 00,F
0478C:  BRA    478A
0478E:  BRA    4790
04790:  NOP   
04792:  BSF    F93.0
04794:  MOVLW  50
04796:  MOVWF  00
04798:  DECFSZ 00,F
0479A:  BRA    4798
....................  
....................     		i2c_start(PH_LIGHT); 
0479C:  BSF    F93.0
0479E:  MOVLW  50
047A0:  MOVWF  00
047A2:  DECFSZ 00,F
047A4:  BRA    47A2
047A6:  BSF    F93.1
047A8:  MOVLW  51
047AA:  MOVWF  00
047AC:  DECFSZ 00,F
047AE:  BRA    47AC
047B0:  BCF    F8A.0
047B2:  BCF    F93.0
047B4:  MOVLW  50
047B6:  MOVWF  00
047B8:  DECFSZ 00,F
047BA:  BRA    47B8
047BC:  BCF    F8A.1
047BE:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
047C0:  MOVLW  73
047C2:  MOVLB  7
047C4:  MOVWF  xB4
047C6:  MOVLB  0
047C8:  CALL   364C
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
047CC:  CLRF   00
047CE:  CALL   36C2
047D2:  MOVFF  01,727
.................... 			i2c_stop(PH_LIGHT); 
047D6:  BCF    F93.0
047D8:  NOP   
047DA:  BSF    F93.1
047DC:  BTFSS  F81.1
047DE:  BRA    47DC
047E0:  MOVLW  50
047E2:  MOVWF  00
047E4:  DECFSZ 00,F
047E6:  BRA    47E4
047E8:  BRA    47EA
047EA:  NOP   
047EC:  BSF    F93.0
047EE:  MOVLW  50
047F0:  MOVWF  00
047F2:  DECFSZ 00,F
047F4:  BRA    47F2
....................  
.................... 			i2c_start(PH_LIGHT); 
047F6:  BSF    F93.0
047F8:  MOVLW  50
047FA:  MOVWF  00
047FC:  DECFSZ 00,F
047FE:  BRA    47FC
04800:  BSF    F93.1
04802:  MOVLW  51
04804:  MOVWF  00
04806:  DECFSZ 00,F
04808:  BRA    4806
0480A:  BCF    F8A.0
0480C:  BCF    F93.0
0480E:  MOVLW  50
04810:  MOVWF  00
04812:  DECFSZ 00,F
04814:  BRA    4812
04816:  BCF    F8A.1
04818:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
0481A:  MOVLW  72
0481C:  MOVLB  7
0481E:  MOVWF  xB4
04820:  MOVLB  0
04822:  CALL   364C
.................... 			i2c_write(PH_LIGHT,0x91);  //Send the command for reading the version 
04826:  MOVLW  91
04828:  MOVLB  7
0482A:  MOVWF  xB4
0482C:  MOVLB  0
0482E:  CALL   364C
.................... 			i2c_stop(PH_LIGHT); 
04832:  BCF    F93.0
04834:  NOP   
04836:  BSF    F93.1
04838:  BTFSS  F81.1
0483A:  BRA    4838
0483C:  MOVLW  50
0483E:  MOVWF  00
04840:  DECFSZ 00,F
04842:  BRA    4840
04844:  BRA    4846
04846:  NOP   
04848:  BSF    F93.0
0484A:  MOVLW  50
0484C:  MOVWF  00
0484E:  DECFSZ 00,F
04850:  BRA    484E
....................  
....................     		i2c_start(PH_LIGHT); 
04852:  BSF    F93.0
04854:  MOVLW  50
04856:  MOVWF  00
04858:  DECFSZ 00,F
0485A:  BRA    4858
0485C:  BSF    F93.1
0485E:  MOVLW  51
04860:  MOVWF  00
04862:  DECFSZ 00,F
04864:  BRA    4862
04866:  BCF    F8A.0
04868:  BCF    F93.0
0486A:  MOVLW  50
0486C:  MOVWF  00
0486E:  DECFSZ 00,F
04870:  BRA    486E
04872:  BCF    F8A.1
04874:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
04876:  MOVLW  73
04878:  MOVLB  7
0487A:  MOVWF  xB4
0487C:  MOVLB  0
0487E:  CALL   364C
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
04882:  CLRF   00
04884:  CALL   36C2
04888:  MOVFF  01,728
.................... 			i2c_stop(PH_LIGHT); 
0488C:  BCF    F93.0
0488E:  NOP   
04890:  BSF    F93.1
04892:  BTFSS  F81.1
04894:  BRA    4892
04896:  MOVLW  50
04898:  MOVWF  00
0489A:  DECFSZ 00,F
0489C:  BRA    489A
0489E:  BRA    48A0
048A0:  NOP   
048A2:  BSF    F93.0
048A4:  MOVLW  50
048A6:  MOVWF  00
048A8:  DECFSZ 00,F
048AA:  BRA    48A8
.................... 			break; 
048AC:  BRA    4CF8
....................  
....................  
.................... 		case 1:   //red 
.................... 			i2c_start(PH_LIGHT); 
048AE:  BSF    F93.0
048B0:  MOVLW  50
048B2:  MOVWF  00
048B4:  DECFSZ 00,F
048B6:  BRA    48B4
048B8:  BSF    F93.1
048BA:  MOVLW  51
048BC:  MOVWF  00
048BE:  DECFSZ 00,F
048C0:  BRA    48BE
048C2:  BCF    F8A.0
048C4:  BCF    F93.0
048C6:  MOVLW  50
048C8:  MOVWF  00
048CA:  DECFSZ 00,F
048CC:  BRA    48CA
048CE:  BCF    F8A.1
048D0:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
048D2:  MOVLW  72
048D4:  MOVLB  7
048D6:  MOVWF  xB4
048D8:  MOVLB  0
048DA:  CALL   364C
.................... 			i2c_write(PH_LIGHT,0x92);  //Send the command for reading the version 
048DE:  MOVLW  92
048E0:  MOVLB  7
048E2:  MOVWF  xB4
048E4:  MOVLB  0
048E6:  CALL   364C
.................... 			i2c_stop(PH_LIGHT); 
048EA:  BCF    F93.0
048EC:  NOP   
048EE:  BSF    F93.1
048F0:  BTFSS  F81.1
048F2:  BRA    48F0
048F4:  MOVLW  50
048F6:  MOVWF  00
048F8:  DECFSZ 00,F
048FA:  BRA    48F8
048FC:  BRA    48FE
048FE:  NOP   
04900:  BSF    F93.0
04902:  MOVLW  50
04904:  MOVWF  00
04906:  DECFSZ 00,F
04908:  BRA    4906
....................  
....................     		i2c_start(PH_LIGHT); 
0490A:  BSF    F93.0
0490C:  MOVLW  50
0490E:  MOVWF  00
04910:  DECFSZ 00,F
04912:  BRA    4910
04914:  BSF    F93.1
04916:  MOVLW  51
04918:  MOVWF  00
0491A:  DECFSZ 00,F
0491C:  BRA    491A
0491E:  BCF    F8A.0
04920:  BCF    F93.0
04922:  MOVLW  50
04924:  MOVWF  00
04926:  DECFSZ 00,F
04928:  BRA    4926
0492A:  BCF    F8A.1
0492C:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
0492E:  MOVLW  73
04930:  MOVLB  7
04932:  MOVWF  xB4
04934:  MOVLB  0
04936:  CALL   364C
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
0493A:  CLRF   00
0493C:  CALL   36C2
04940:  MOVFF  01,727
.................... 			i2c_stop(PH_LIGHT); 
04944:  BCF    F93.0
04946:  NOP   
04948:  BSF    F93.1
0494A:  BTFSS  F81.1
0494C:  BRA    494A
0494E:  MOVLW  50
04950:  MOVWF  00
04952:  DECFSZ 00,F
04954:  BRA    4952
04956:  BRA    4958
04958:  NOP   
0495A:  BSF    F93.0
0495C:  MOVLW  50
0495E:  MOVWF  00
04960:  DECFSZ 00,F
04962:  BRA    4960
....................  
.................... 			i2c_start(PH_LIGHT); 
04964:  BSF    F93.0
04966:  MOVLW  50
04968:  MOVWF  00
0496A:  DECFSZ 00,F
0496C:  BRA    496A
0496E:  BSF    F93.1
04970:  MOVLW  51
04972:  MOVWF  00
04974:  DECFSZ 00,F
04976:  BRA    4974
04978:  BCF    F8A.0
0497A:  BCF    F93.0
0497C:  MOVLW  50
0497E:  MOVWF  00
04980:  DECFSZ 00,F
04982:  BRA    4980
04984:  BCF    F8A.1
04986:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04988:  MOVLW  72
0498A:  MOVLB  7
0498C:  MOVWF  xB4
0498E:  MOVLB  0
04990:  CALL   364C
.................... 			i2c_write(PH_LIGHT,0x93);  //Send the command for reading the version 
04994:  MOVLW  93
04996:  MOVLB  7
04998:  MOVWF  xB4
0499A:  MOVLB  0
0499C:  CALL   364C
.................... 			i2c_stop(PH_LIGHT); 
049A0:  BCF    F93.0
049A2:  NOP   
049A4:  BSF    F93.1
049A6:  BTFSS  F81.1
049A8:  BRA    49A6
049AA:  MOVLW  50
049AC:  MOVWF  00
049AE:  DECFSZ 00,F
049B0:  BRA    49AE
049B2:  BRA    49B4
049B4:  NOP   
049B6:  BSF    F93.0
049B8:  MOVLW  50
049BA:  MOVWF  00
049BC:  DECFSZ 00,F
049BE:  BRA    49BC
....................  
....................     		i2c_start(PH_LIGHT); 
049C0:  BSF    F93.0
049C2:  MOVLW  50
049C4:  MOVWF  00
049C6:  DECFSZ 00,F
049C8:  BRA    49C6
049CA:  BSF    F93.1
049CC:  MOVLW  51
049CE:  MOVWF  00
049D0:  DECFSZ 00,F
049D2:  BRA    49D0
049D4:  BCF    F8A.0
049D6:  BCF    F93.0
049D8:  MOVLW  50
049DA:  MOVWF  00
049DC:  DECFSZ 00,F
049DE:  BRA    49DC
049E0:  BCF    F8A.1
049E2:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
049E4:  MOVLW  73
049E6:  MOVLB  7
049E8:  MOVWF  xB4
049EA:  MOVLB  0
049EC:  CALL   364C
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
049F0:  CLRF   00
049F2:  CALL   36C2
049F6:  MOVFF  01,728
.................... 			i2c_stop(PH_LIGHT); 
049FA:  BCF    F93.0
049FC:  NOP   
049FE:  BSF    F93.1
04A00:  BTFSS  F81.1
04A02:  BRA    4A00
04A04:  MOVLW  50
04A06:  MOVWF  00
04A08:  DECFSZ 00,F
04A0A:  BRA    4A08
04A0C:  BRA    4A0E
04A0E:  NOP   
04A10:  BSF    F93.0
04A12:  MOVLW  50
04A14:  MOVWF  00
04A16:  DECFSZ 00,F
04A18:  BRA    4A16
.................... 			break; 
04A1A:  BRA    4CF8
....................  
.................... 		case 3:   //blue 
.................... 			i2c_start(PH_LIGHT); 
04A1C:  BSF    F93.0
04A1E:  MOVLW  50
04A20:  MOVWF  00
04A22:  DECFSZ 00,F
04A24:  BRA    4A22
04A26:  BSF    F93.1
04A28:  MOVLW  51
04A2A:  MOVWF  00
04A2C:  DECFSZ 00,F
04A2E:  BRA    4A2C
04A30:  BCF    F8A.0
04A32:  BCF    F93.0
04A34:  MOVLW  50
04A36:  MOVWF  00
04A38:  DECFSZ 00,F
04A3A:  BRA    4A38
04A3C:  BCF    F8A.1
04A3E:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04A40:  MOVLW  72
04A42:  MOVLB  7
04A44:  MOVWF  xB4
04A46:  MOVLB  0
04A48:  CALL   364C
.................... 			i2c_write(PH_LIGHT,0x94);  //Send the command for reading the version 
04A4C:  MOVLW  94
04A4E:  MOVLB  7
04A50:  MOVWF  xB4
04A52:  MOVLB  0
04A54:  CALL   364C
.................... 			i2c_stop(PH_LIGHT); 
04A58:  BCF    F93.0
04A5A:  NOP   
04A5C:  BSF    F93.1
04A5E:  BTFSS  F81.1
04A60:  BRA    4A5E
04A62:  MOVLW  50
04A64:  MOVWF  00
04A66:  DECFSZ 00,F
04A68:  BRA    4A66
04A6A:  BRA    4A6C
04A6C:  NOP   
04A6E:  BSF    F93.0
04A70:  MOVLW  50
04A72:  MOVWF  00
04A74:  DECFSZ 00,F
04A76:  BRA    4A74
....................  
....................     		i2c_start(PH_LIGHT); 
04A78:  BSF    F93.0
04A7A:  MOVLW  50
04A7C:  MOVWF  00
04A7E:  DECFSZ 00,F
04A80:  BRA    4A7E
04A82:  BSF    F93.1
04A84:  MOVLW  51
04A86:  MOVWF  00
04A88:  DECFSZ 00,F
04A8A:  BRA    4A88
04A8C:  BCF    F8A.0
04A8E:  BCF    F93.0
04A90:  MOVLW  50
04A92:  MOVWF  00
04A94:  DECFSZ 00,F
04A96:  BRA    4A94
04A98:  BCF    F8A.1
04A9A:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
04A9C:  MOVLW  73
04A9E:  MOVLB  7
04AA0:  MOVWF  xB4
04AA2:  MOVLB  0
04AA4:  CALL   364C
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
04AA8:  CLRF   00
04AAA:  CALL   36C2
04AAE:  MOVFF  01,727
.................... 			i2c_stop(PH_LIGHT); 
04AB2:  BCF    F93.0
04AB4:  NOP   
04AB6:  BSF    F93.1
04AB8:  BTFSS  F81.1
04ABA:  BRA    4AB8
04ABC:  MOVLW  50
04ABE:  MOVWF  00
04AC0:  DECFSZ 00,F
04AC2:  BRA    4AC0
04AC4:  BRA    4AC6
04AC6:  NOP   
04AC8:  BSF    F93.0
04ACA:  MOVLW  50
04ACC:  MOVWF  00
04ACE:  DECFSZ 00,F
04AD0:  BRA    4ACE
....................  
.................... 			i2c_start(PH_LIGHT); 
04AD2:  BSF    F93.0
04AD4:  MOVLW  50
04AD6:  MOVWF  00
04AD8:  DECFSZ 00,F
04ADA:  BRA    4AD8
04ADC:  BSF    F93.1
04ADE:  MOVLW  51
04AE0:  MOVWF  00
04AE2:  DECFSZ 00,F
04AE4:  BRA    4AE2
04AE6:  BCF    F8A.0
04AE8:  BCF    F93.0
04AEA:  MOVLW  50
04AEC:  MOVWF  00
04AEE:  DECFSZ 00,F
04AF0:  BRA    4AEE
04AF2:  BCF    F8A.1
04AF4:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04AF6:  MOVLW  72
04AF8:  MOVLB  7
04AFA:  MOVWF  xB4
04AFC:  MOVLB  0
04AFE:  CALL   364C
.................... 			i2c_write(PH_LIGHT,0x95);  //Send the command for reading the version 
04B02:  MOVLW  95
04B04:  MOVLB  7
04B06:  MOVWF  xB4
04B08:  MOVLB  0
04B0A:  CALL   364C
.................... 			i2c_stop(PH_LIGHT); 
04B0E:  BCF    F93.0
04B10:  NOP   
04B12:  BSF    F93.1
04B14:  BTFSS  F81.1
04B16:  BRA    4B14
04B18:  MOVLW  50
04B1A:  MOVWF  00
04B1C:  DECFSZ 00,F
04B1E:  BRA    4B1C
04B20:  BRA    4B22
04B22:  NOP   
04B24:  BSF    F93.0
04B26:  MOVLW  50
04B28:  MOVWF  00
04B2A:  DECFSZ 00,F
04B2C:  BRA    4B2A
....................  
....................     		i2c_start(PH_LIGHT); 
04B2E:  BSF    F93.0
04B30:  MOVLW  50
04B32:  MOVWF  00
04B34:  DECFSZ 00,F
04B36:  BRA    4B34
04B38:  BSF    F93.1
04B3A:  MOVLW  51
04B3C:  MOVWF  00
04B3E:  DECFSZ 00,F
04B40:  BRA    4B3E
04B42:  BCF    F8A.0
04B44:  BCF    F93.0
04B46:  MOVLW  50
04B48:  MOVWF  00
04B4A:  DECFSZ 00,F
04B4C:  BRA    4B4A
04B4E:  BCF    F8A.1
04B50:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
04B52:  MOVLW  73
04B54:  MOVLB  7
04B56:  MOVWF  xB4
04B58:  MOVLB  0
04B5A:  CALL   364C
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
04B5E:  CLRF   00
04B60:  CALL   36C2
04B64:  MOVFF  01,728
.................... 			i2c_stop(PH_LIGHT); 
04B68:  BCF    F93.0
04B6A:  NOP   
04B6C:  BSF    F93.1
04B6E:  BTFSS  F81.1
04B70:  BRA    4B6E
04B72:  MOVLW  50
04B74:  MOVWF  00
04B76:  DECFSZ 00,F
04B78:  BRA    4B76
04B7A:  BRA    4B7C
04B7C:  NOP   
04B7E:  BSF    F93.0
04B80:  MOVLW  50
04B82:  MOVWF  00
04B84:  DECFSZ 00,F
04B86:  BRA    4B84
.................... 			break; 
04B88:  BRA    4CF8
....................  
.................... 		case 4:   //clear 
.................... 			i2c_start(PH_LIGHT); 
04B8A:  BSF    F93.0
04B8C:  MOVLW  50
04B8E:  MOVWF  00
04B90:  DECFSZ 00,F
04B92:  BRA    4B90
04B94:  BSF    F93.1
04B96:  MOVLW  51
04B98:  MOVWF  00
04B9A:  DECFSZ 00,F
04B9C:  BRA    4B9A
04B9E:  BCF    F8A.0
04BA0:  BCF    F93.0
04BA2:  MOVLW  50
04BA4:  MOVWF  00
04BA6:  DECFSZ 00,F
04BA8:  BRA    4BA6
04BAA:  BCF    F8A.1
04BAC:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04BAE:  MOVLW  72
04BB0:  MOVLB  7
04BB2:  MOVWF  xB4
04BB4:  MOVLB  0
04BB6:  CALL   364C
.................... 			i2c_write(PH_LIGHT,0x96);  //Send the command for reading the version 
04BBA:  MOVLW  96
04BBC:  MOVLB  7
04BBE:  MOVWF  xB4
04BC0:  MOVLB  0
04BC2:  CALL   364C
.................... 			i2c_stop(PH_LIGHT); 
04BC6:  BCF    F93.0
04BC8:  NOP   
04BCA:  BSF    F93.1
04BCC:  BTFSS  F81.1
04BCE:  BRA    4BCC
04BD0:  MOVLW  50
04BD2:  MOVWF  00
04BD4:  DECFSZ 00,F
04BD6:  BRA    4BD4
04BD8:  BRA    4BDA
04BDA:  NOP   
04BDC:  BSF    F93.0
04BDE:  MOVLW  50
04BE0:  MOVWF  00
04BE2:  DECFSZ 00,F
04BE4:  BRA    4BE2
....................  
....................     		i2c_start(PH_LIGHT); 
04BE6:  BSF    F93.0
04BE8:  MOVLW  50
04BEA:  MOVWF  00
04BEC:  DECFSZ 00,F
04BEE:  BRA    4BEC
04BF0:  BSF    F93.1
04BF2:  MOVLW  51
04BF4:  MOVWF  00
04BF6:  DECFSZ 00,F
04BF8:  BRA    4BF6
04BFA:  BCF    F8A.0
04BFC:  BCF    F93.0
04BFE:  MOVLW  50
04C00:  MOVWF  00
04C02:  DECFSZ 00,F
04C04:  BRA    4C02
04C06:  BCF    F8A.1
04C08:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
04C0A:  MOVLW  73
04C0C:  MOVLB  7
04C0E:  MOVWF  xB4
04C10:  MOVLB  0
04C12:  CALL   364C
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
04C16:  CLRF   00
04C18:  CALL   36C2
04C1C:  MOVFF  01,727
.................... 			i2c_stop(PH_LIGHT); 
04C20:  BCF    F93.0
04C22:  NOP   
04C24:  BSF    F93.1
04C26:  BTFSS  F81.1
04C28:  BRA    4C26
04C2A:  MOVLW  50
04C2C:  MOVWF  00
04C2E:  DECFSZ 00,F
04C30:  BRA    4C2E
04C32:  BRA    4C34
04C34:  NOP   
04C36:  BSF    F93.0
04C38:  MOVLW  50
04C3A:  MOVWF  00
04C3C:  DECFSZ 00,F
04C3E:  BRA    4C3C
....................  
.................... 			i2c_start(PH_LIGHT); 
04C40:  BSF    F93.0
04C42:  MOVLW  50
04C44:  MOVWF  00
04C46:  DECFSZ 00,F
04C48:  BRA    4C46
04C4A:  BSF    F93.1
04C4C:  MOVLW  51
04C4E:  MOVWF  00
04C50:  DECFSZ 00,F
04C52:  BRA    4C50
04C54:  BCF    F8A.0
04C56:  BCF    F93.0
04C58:  MOVLW  50
04C5A:  MOVWF  00
04C5C:  DECFSZ 00,F
04C5E:  BRA    4C5C
04C60:  BCF    F8A.1
04C62:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
04C64:  MOVLW  72
04C66:  MOVLB  7
04C68:  MOVWF  xB4
04C6A:  MOVLB  0
04C6C:  CALL   364C
.................... 			i2c_write(PH_LIGHT,0x97);  //Send the command for reading the version 
04C70:  MOVLW  97
04C72:  MOVLB  7
04C74:  MOVWF  xB4
04C76:  MOVLB  0
04C78:  CALL   364C
.................... 			i2c_stop(PH_LIGHT); 
04C7C:  BCF    F93.0
04C7E:  NOP   
04C80:  BSF    F93.1
04C82:  BTFSS  F81.1
04C84:  BRA    4C82
04C86:  MOVLW  50
04C88:  MOVWF  00
04C8A:  DECFSZ 00,F
04C8C:  BRA    4C8A
04C8E:  BRA    4C90
04C90:  NOP   
04C92:  BSF    F93.0
04C94:  MOVLW  50
04C96:  MOVWF  00
04C98:  DECFSZ 00,F
04C9A:  BRA    4C98
....................  
....................     		i2c_start(PH_LIGHT); 
04C9C:  BSF    F93.0
04C9E:  MOVLW  50
04CA0:  MOVWF  00
04CA2:  DECFSZ 00,F
04CA4:  BRA    4CA2
04CA6:  BSF    F93.1
04CA8:  MOVLW  51
04CAA:  MOVWF  00
04CAC:  DECFSZ 00,F
04CAE:  BRA    4CAC
04CB0:  BCF    F8A.0
04CB2:  BCF    F93.0
04CB4:  MOVLW  50
04CB6:  MOVWF  00
04CB8:  DECFSZ 00,F
04CBA:  BRA    4CB8
04CBC:  BCF    F8A.1
04CBE:  BCF    F93.1
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
04CC0:  MOVLW  73
04CC2:  MOVLB  7
04CC4:  MOVWF  xB4
04CC6:  MOVLB  0
04CC8:  CALL   364C
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
04CCC:  CLRF   00
04CCE:  CALL   36C2
04CD2:  MOVFF  01,728
.................... 			i2c_stop(PH_LIGHT); 
04CD6:  BCF    F93.0
04CD8:  NOP   
04CDA:  BSF    F93.1
04CDC:  BTFSS  F81.1
04CDE:  BRA    4CDC
04CE0:  MOVLW  50
04CE2:  MOVWF  00
04CE4:  DECFSZ 00,F
04CE6:  BRA    4CE4
04CE8:  BRA    4CEA
04CEA:  NOP   
04CEC:  BSF    F93.0
04CEE:  MOVLW  50
04CF0:  MOVWF  00
04CF2:  DECFSZ 00,F
04CF4:  BRA    4CF2
.................... 			break; 
04CF6:  BRA    4CF8
....................  
.................... 		default:	 
.................... 			break; 
.................... 	} 
04CF8:  RETURN 0
....................  
.................... } 
....................  
.................... #include <FindConnectedDevice.c> 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Febuary 20, 2017 
.................... // This table shows the returned results for board used to IDing through the I2C 
.................... // Board Name            Returned ID 
.................... // Digital Board             0x39 
.................... // RH/Temp                   0x1050 
.................... // Light Chip                0x22 
.................... // Analog DO & NH4           0xa9 
.................... // CO2                       0xd9 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Jan 23, 2017 
.................... // This routine searches for a plugged in device for any port.  It is a general purpose used for osmobot for finding whih i2c is plugged in. 
.................... // The returned value is the device ID number used by osmobot.  
.................... // The the returned value is a 1, that means nothing is plugged in or it's not working. (communicating) 
.................... //****************************************************************************** 
.................... int FindRJ45Device(int portnumber,int deviceid) 
.................... { 
....................      
....................      
....................  
....................     int16 returnedvalue;  // this is the dummy returned value from checking I2C connections 
....................     int struuu; 
....................     float nhthree,NHCalHigh,NHCalLow,NHReadingLow,NHReadingHigh,wtemper,b,phtemper,nhslope; 
....................     int16 ReturnedADC;  // this is the returned value from the Vernier Sensor 
....................     char teststr4[20]; 
....................     if (deviceid==0x02) 
*
03A52:  MOVLB  7
03A54:  MOVF   x71,W
03A56:  SUBLW  02
03A58:  BNZ   3A8E
....................     { 
....................     clearDisplay(); 
03A5A:  MOVLB  0
03A5C:  CALL   131E
....................     sprintf(teststr4,"Identifying"); 
03A60:  MOVLW  07
03A62:  MOVLB  2
03A64:  MOVWF  x32
03A66:  MOVLW  9B
03A68:  MOVWF  x31
03A6A:  MOVLW  1C
03A6C:  MOVWF  FF6
03A6E:  MOVLW  10
03A70:  MOVWF  FF7
03A72:  MOVLB  0
03A74:  CALL   1C76
....................      writeString(0, 0, teststr4); 
03A78:  MOVLB  7
03A7A:  CLRF   xC0
03A7C:  CLRF   xC1
03A7E:  MOVLW  07
03A80:  MOVWF  xC3
03A82:  MOVLW  9B
03A84:  MOVWF  xC2
03A86:  MOVLB  0
03A88:  CALL   134A
03A8C:  MOVLB  7
....................     } 
....................  
....................  
....................     //************************************************************************* 
....................     // Created March 14, 2017 
....................     // This sections reads the Vernier Sensor and displays it on the bottom. 
....................     // The sensor is connected to the back of the used using the British RJ45 connection (right handed) 
....................     //*************************************************************************) 
....................      
....................     // read the sensor  ADC sAN3 off pin 5. 
....................     ReturnedADC = GetADCValue(3); //This gets the current ADC convertion for the channel number. 
03A8E:  MOVLW  03
03A90:  MOVWF  xAF
03A92:  MOVLB  0
03A94:  GOTO   1C96
03A98:  MOVFF  02,79A
03A9C:  MOVFF  01,799
....................     // show the result all the time a devices is not being accessed. 
....................      
....................     //************************************************************************** 
....................     // Created March 14, 2017 
....................     // This is the first attempt at seperating the NH3 and NH4 from the reading. 
....................     //  Neede varaibles 
....................     //  Total (NH3+NH4)-Nitrogen Concentration (mg/L)    (NitConcentration) 
....................     // pH                     sysOutput.pH 
....................     // temperature in C       sysOutput.wTemp 
....................     //  Free NH3 in (mg/L) 
....................     //  form.product.value = Number(form.one.value)/(1+Math.pow(10,(0.0902-Number(form.two.value)+(2730/(273.2+Number(form.three.value)))))); 
.................... //  (mg/L NH3) = NitConcentration/(1 + 10^(0.0902-sysOutput.pH +(2730/(273.2+sysOutput.wTemp))) 
....................      
....................      
....................     NHCalHigh = 100.0; 
03AA0:  MOVLB  7
03AA2:  CLRF   x7C
03AA4:  CLRF   x7B
03AA6:  MOVLW  48
03AA8:  MOVWF  x7A
03AAA:  MOVLW  85
03AAC:  MOVWF  x79
....................     NHCalLow = 1.0; 
03AAE:  CLRF   x80
03AB0:  CLRF   x7F
03AB2:  CLRF   x7E
03AB4:  MOVLW  7F
03AB6:  MOVWF  x7D
....................     NHReadingHigh = 25.0; 
03AB8:  CLRF   x88
03ABA:  CLRF   x87
03ABC:  MOVLW  48
03ABE:  MOVWF  x86
03AC0:  MOVLW  83
03AC2:  MOVWF  x85
....................     NHReadingLow = 6.0; 
03AC4:  CLRF   x84
03AC6:  CLRF   x83
03AC8:  MOVLW  40
03ACA:  MOVWF  x82
03ACC:  MOVLW  81
03ACE:  MOVWF  x81
....................     wtemper = 19.0; 
03AD0:  CLRF   x8C
03AD2:  CLRF   x8B
03AD4:  MOVLW  18
03AD6:  MOVWF  x8A
03AD8:  MOVLW  83
03ADA:  MOVWF  x89
....................     phtemper= 7.0; 
03ADC:  CLRF   x94
03ADE:  CLRF   x93
03AE0:  MOVLW  60
03AE2:  MOVWF  x92
03AE4:  MOVLW  81
03AE6:  MOVWF  x91
....................      
....................     nhslope = ((NHCalHigh - NHCalLow)/(NHReadingHigh-NHReadingLow)); 
03AE8:  BSF    FD8.1
03AEA:  MOVFF  77C,7E6
03AEE:  MOVFF  77B,7E5
03AF2:  MOVFF  77A,7E4
03AF6:  MOVFF  779,7E3
03AFA:  MOVFF  780,7EA
03AFE:  MOVFF  77F,7E9
03B02:  MOVFF  77E,7E8
03B06:  MOVFF  77D,7E7
03B0A:  MOVLB  0
03B0C:  CALL   1CF2
03B10:  MOVFF  03,7B2
03B14:  MOVFF  02,7B1
03B18:  MOVFF  01,7B0
03B1C:  MOVFF  00,7AF
03B20:  BSF    FD8.1
03B22:  MOVFF  788,7E6
03B26:  MOVFF  787,7E5
03B2A:  MOVFF  786,7E4
03B2E:  MOVFF  785,7E3
03B32:  MOVFF  784,7EA
03B36:  MOVFF  783,7E9
03B3A:  MOVFF  782,7E8
03B3E:  MOVFF  781,7E7
03B42:  CALL   1CF2
03B46:  MOVFF  7B2,7DB
03B4A:  MOVFF  7B1,7DA
03B4E:  MOVFF  7B0,7D9
03B52:  MOVFF  7AF,7D8
03B56:  MOVFF  03,7DF
03B5A:  MOVFF  02,7DE
03B5E:  MOVFF  01,7DD
03B62:  MOVFF  00,7DC
03B66:  CALL   1F6A
03B6A:  MOVFF  03,798
03B6E:  MOVFF  02,797
03B72:  MOVFF  01,796
03B76:  MOVFF  00,795
....................     b = NHCalHigh - nhslope * NHReadingHigh; 
03B7A:  MOVFF  798,7E2
03B7E:  MOVFF  797,7E1
03B82:  MOVFF  796,7E0
03B86:  MOVFF  795,7DF
03B8A:  MOVFF  788,7E6
03B8E:  MOVFF  787,7E5
03B92:  MOVFF  786,7E4
03B96:  MOVFF  785,7E3
03B9A:  CALL   20C8
03B9E:  BSF    FD8.1
03BA0:  MOVFF  77C,7E6
03BA4:  MOVFF  77B,7E5
03BA8:  MOVFF  77A,7E4
03BAC:  MOVFF  779,7E3
03BB0:  MOVFF  03,7EA
03BB4:  MOVFF  02,7E9
03BB8:  MOVFF  01,7E8
03BBC:  MOVFF  00,7E7
03BC0:  CALL   1CF2
03BC4:  MOVFF  03,790
03BC8:  MOVFF  02,78F
03BCC:  MOVFF  01,78E
03BD0:  MOVFF  00,78D
....................     nhthree = (float) ReturnedADC; 
03BD4:  MOVFF  79A,7E4
03BD8:  MOVFF  799,7E3
03BDC:  CALL   21BE
03BE0:  MOVFF  03,778
03BE4:  MOVFF  02,777
03BE8:  MOVFF  01,776
03BEC:  MOVFF  00,775
....................      
....................     // find the number from the slope equation 
....................     nhthree = nhslope*nhthree + b;  // this is the calculated NH4 and NH3 
03BF0:  MOVFF  798,7E2
03BF4:  MOVFF  797,7E1
03BF8:  MOVFF  796,7E0
03BFC:  MOVFF  795,7DF
03C00:  MOVFF  778,7E6
03C04:  MOVFF  777,7E5
03C08:  MOVFF  776,7E4
03C0C:  MOVFF  775,7E3
03C10:  CALL   20C8
03C14:  MOVFF  03,7B2
03C18:  MOVFF  02,7B1
03C1C:  MOVFF  01,7B0
03C20:  MOVFF  00,7AF
03C24:  BCF    FD8.1
03C26:  MOVFF  03,7E6
03C2A:  MOVFF  02,7E5
03C2E:  MOVFF  01,7E4
03C32:  MOVFF  00,7E3
03C36:  MOVFF  790,7EA
03C3A:  MOVFF  78F,7E9
03C3E:  MOVFF  78E,7E8
03C42:  MOVFF  78D,7E7
03C46:  CALL   1CF2
03C4A:  MOVFF  03,778
03C4E:  MOVFF  02,777
03C52:  MOVFF  01,776
03C56:  MOVFF  00,775
....................      
....................      
....................     nhthree = nhthree/(1 + pow(10,(0.0902-phtemper +(2730/(273.2+wtemper))))); 
03C5A:  BSF    FD8.1
03C5C:  MOVLW  C7
03C5E:  MOVLB  7
03C60:  MOVWF  xE6
03C62:  MOVLW  BA
03C64:  MOVWF  xE5
03C66:  MOVLW  38
03C68:  MOVWF  xE4
03C6A:  MOVLW  7B
03C6C:  MOVWF  xE3
03C6E:  MOVFF  794,7EA
03C72:  MOVFF  793,7E9
03C76:  MOVFF  792,7E8
03C7A:  MOVFF  791,7E7
03C7E:  MOVLB  0
03C80:  CALL   1CF2
03C84:  MOVFF  03,7B2
03C88:  MOVFF  02,7B1
03C8C:  MOVFF  01,7B0
03C90:  MOVFF  00,7AF
03C94:  BCF    FD8.1
03C96:  MOVLW  9A
03C98:  MOVLB  7
03C9A:  MOVWF  xE6
03C9C:  MOVLW  99
03C9E:  MOVWF  xE5
03CA0:  MOVLW  08
03CA2:  MOVWF  xE4
03CA4:  MOVLW  87
03CA6:  MOVWF  xE3
03CA8:  MOVFF  78C,7EA
03CAC:  MOVFF  78B,7E9
03CB0:  MOVFF  78A,7E8
03CB4:  MOVFF  789,7E7
03CB8:  MOVLB  0
03CBA:  CALL   1CF2
03CBE:  MOVLB  7
03CC0:  CLRF   xDB
03CC2:  MOVLW  A0
03CC4:  MOVWF  xDA
03CC6:  MOVLW  2A
03CC8:  MOVWF  xD9
03CCA:  MOVLW  8A
03CCC:  MOVWF  xD8
03CCE:  MOVFF  03,7DF
03CD2:  MOVFF  02,7DE
03CD6:  MOVFF  01,7DD
03CDA:  MOVFF  00,7DC
03CDE:  MOVLB  0
03CE0:  CALL   1F6A
03CE4:  BCF    FD8.1
03CE6:  MOVFF  7B2,7E6
03CEA:  MOVFF  7B1,7E5
03CEE:  MOVFF  7B0,7E4
03CF2:  MOVFF  7AF,7E3
03CF6:  MOVFF  03,7EA
03CFA:  MOVFF  02,7E9
03CFE:  MOVFF  01,7E8
03D02:  MOVFF  00,7E7
03D06:  CALL   1CF2
03D0A:  MOVFF  03,7B2
03D0E:  MOVFF  02,7B1
03D12:  MOVFF  01,7B0
03D16:  MOVFF  00,7AF
03D1A:  MOVLB  7
03D1C:  CLRF   xB6
03D1E:  CLRF   xB5
03D20:  MOVLW  20
03D22:  MOVWF  xB4
03D24:  MOVLW  82
03D26:  MOVWF  xB3
03D28:  MOVFF  03,7BA
03D2C:  MOVFF  02,7B9
03D30:  MOVFF  01,7B8
03D34:  MOVFF  00,7B7
03D38:  MOVLB  0
03D3A:  GOTO   2F78
03D3E:  MOVFF  FEA,7B0
03D42:  MOVFF  FE9,7AF
03D46:  BCF    FD8.1
03D48:  MOVLB  7
03D4A:  CLRF   xE6
03D4C:  CLRF   xE5
03D4E:  CLRF   xE4
03D50:  MOVLW  7F
03D52:  MOVWF  xE3
03D54:  MOVFF  03,7EA
03D58:  MOVFF  02,7E9
03D5C:  MOVFF  01,7E8
03D60:  MOVFF  00,7E7
03D64:  MOVLB  0
03D66:  CALL   1CF2
03D6A:  MOVFF  7B0,FEA
03D6E:  MOVFF  7AF,FE9
03D72:  MOVFF  778,7DB
03D76:  MOVFF  777,7DA
03D7A:  MOVFF  776,7D9
03D7E:  MOVFF  775,7D8
03D82:  MOVFF  03,7DF
03D86:  MOVFF  02,7DE
03D8A:  MOVFF  01,7DD
03D8E:  MOVFF  00,7DC
03D92:  CALL   1F6A
03D96:  MOVFF  03,778
03D9A:  MOVFF  02,777
03D9E:  MOVFF  01,776
03DA2:  MOVFF  00,775
....................      
....................     sprintf(teststr4,"Vernier %Lu NH3 %f  ",ReturnedADC,nhthree); 
03DA6:  MOVLW  07
03DA8:  MOVLB  2
03DAA:  MOVWF  x32
03DAC:  MOVLW  9B
03DAE:  MOVWF  x31
03DB0:  MOVLW  28
03DB2:  MOVWF  FF6
03DB4:  MOVLW  10
03DB6:  MOVWF  FF7
03DB8:  MOVLW  08
03DBA:  MOVLB  7
03DBC:  MOVWF  xAF
03DBE:  MOVLB  0
03DC0:  CALL   3290
03DC4:  MOVLW  10
03DC6:  MOVWF  FE9
03DC8:  MOVFF  79A,7B0
03DCC:  MOVFF  799,7AF
03DD0:  CALL   32BA
03DD4:  MOVLW  33
03DD6:  MOVWF  FF6
03DD8:  MOVLW  10
03DDA:  MOVWF  FF7
03DDC:  MOVLW  05
03DDE:  MOVLB  7
03DE0:  MOVWF  xAF
03DE2:  MOVLB  0
03DE4:  CALL   3290
03DE8:  MOVLW  89
03DEA:  MOVWF  FE9
03DEC:  MOVFF  778,7B2
03DF0:  MOVFF  777,7B1
03DF4:  MOVFF  776,7B0
03DF8:  MOVFF  775,7AF
03DFC:  MOVLW  02
03DFE:  MOVLB  7
03E00:  MOVWF  xB3
03E02:  MOVLB  0
03E04:  CALL   3458
03E08:  MOVLW  20
03E0A:  MOVLB  7
03E0C:  MOVWF  xBC
03E0E:  MOVLB  0
03E10:  CALL   1C54
03E14:  MOVLW  20
03E16:  MOVLB  7
03E18:  MOVWF  xBC
03E1A:  MOVLB  0
03E1C:  CALL   1C54
....................      writeString(0, 3, teststr4); 
03E20:  MOVLB  7
03E22:  CLRF   xC0
03E24:  MOVLW  03
03E26:  MOVWF  xC1
03E28:  MOVLW  07
03E2A:  MOVWF  xC3
03E2C:  MOVLW  9B
03E2E:  MOVWF  xC2
03E30:  MOVLB  0
03E32:  CALL   134A
....................       
....................    // selectsensor(portnumber);  // this sets the SCL to the right I2C device. 
....................      
....................  
....................          
....................         // check for 1050 
....................         returnedvalue = GetHDC1080Version(0x01); 
03E36:  MOVLW  01
03E38:  MOVLB  7
03E3A:  MOVWF  xAF
03E3C:  MOVLB  0
03E3E:  RCALL  372C
03E40:  MOVFF  02,773
03E44:  MOVFF  01,772
....................         if (returnedvalue == 0x1050) 
03E48:  MOVLB  7
03E4A:  MOVF   x72,W
03E4C:  SUBLW  50
03E4E:  BNZ   3E5C
03E50:  MOVF   x73,W
03E52:  SUBLW  10
03E54:  BNZ   3E5C
....................         { 
....................               // this is the TO rH and temp sensor 
....................             return(0x22); 
03E56:  MOVLW  22
03E58:  MOVWF  01
03E5A:  BRA    3EAC
....................         } 
....................          
....................         // this finds the light sensor version and then tests the device. 
....................         struuu = getTAOSVersion(0x01); 
03E5C:  MOVLW  01
03E5E:  MOVWF  xAF
03E60:  MOVLB  0
03E62:  RCALL  3808
03E64:  MOVFF  01,774
....................         if (struuu == 0x11) 
03E68:  MOVLB  7
03E6A:  MOVF   x74,W
03E6C:  SUBLW  11
03E6E:  BNZ   3E76
....................         { 
....................               // this is the number for the light sensor/PAR, 
....................             return(0x23);  // returns a 23 for the light sensor test. 
03E70:  MOVLW  23
03E72:  MOVWF  01
03E74:  BRA    3EAC
....................         }         
....................          
....................         struuu = GetAnalogDONHFourVersion(0x01); 
03E76:  MOVLW  01
03E78:  MOVWF  xAF
03E7A:  MOVLB  0
03E7C:  RCALL  38C6
03E7E:  MOVFF  01,774
....................         if (struuu == 0xA9)  //  this is the code for the Analog DO and NH4 sensor 
03E82:  MOVLB  7
03E84:  MOVF   x74,W
03E86:  SUBLW  A9
03E88:  BNZ   3E90
....................         { 
....................               // this is the Analog DO, Temperature and NH4 sensor 
....................             return(0x24); 
03E8A:  MOVLW  24
03E8C:  MOVWF  01
03E8E:  BRA    3EAC
....................         }       
....................         if (struuu == 0x39)  //  this is the code for the Digital DO and NH4 sensor 
03E90:  MOVF   x74,W
03E92:  SUBLW  39
03E94:  BNZ   3E9C
....................         { 
....................               // this is the Digital DO, Temperature and NH4 sensor 
....................             return(0x25); 
03E96:  MOVLW  25
03E98:  MOVWF  01
03E9A:  BRA    3EAC
....................         }          
....................          if (struuu == 0xd9)  //  this is the code for the CO2, RH and Temp sensor 
03E9C:  MOVF   x74,W
03E9E:  SUBLW  D9
03EA0:  BNZ   3EA8
....................         { 
....................               // this is the CO2, RH and Temp sensor 
....................             return(0x26); 
03EA2:  MOVLW  26
03EA4:  MOVWF  01
03EA6:  BRA    3EAC
....................         }          
....................     //clear display and put up display searching for plugged in device. 
....................      
....................     // loop through all of version and device IDs that are provided by the manufacturer. 
....................     
....................     // If a result is one of the known devices, return the device index number.  
....................      
....................     //  The device is then tested by another routine. 
....................      
....................     return(0x01); 
03EA8:  MOVLW  01
03EAA:  MOVWF  01
03EAC:  MOVLB  0
03EAE:  GOTO   9046 (RETURN)
.................... } 
....................  
....................  
.................... //***************************************************************************** 
.................... // Create January 23, 2017 
.................... // This routine is used to test the TI 1050 chip on the optical board. 
.................... // It clears the display and sends the raw and calculated data to the display in real time. 
.................... // when the cable is pulled out, there is an error with the version number and then it releases back 
.................... // to the operating system to check for the next connection. 
.................... //  Returns nothing. 
.................... //***************************************************************************** 
.................... int TestRHTemp(void) 
.................... { 
....................      
....................     int16 returnedvalue,returnedresult; 
....................     float returnedresultit,titemp; 
....................      
....................     clearDisplay(); 
*
0437E:  CALL   131E
....................     char teststr4[20]; 
....................     sprintf(teststr4,"TI 1015 RH/Temp"); 
04382:  MOVLW  07
04384:  MOVLB  2
04386:  MOVWF  x32
04388:  MOVLW  7C
0438A:  MOVWF  x31
0438C:  MOVLW  3E
0438E:  MOVWF  FF6
04390:  MOVLW  10
04392:  MOVWF  FF7
04394:  MOVLB  0
04396:  CALL   1C76
....................     writeString(0, 0, teststr4); 
0439A:  MOVLB  7
0439C:  CLRF   xC0
0439E:  CLRF   xC1
043A0:  MOVLW  07
043A2:  MOVWF  xC3
043A4:  MOVLW  7C
043A6:  MOVWF  xC2
043A8:  MOVLB  0
043AA:  CALL   134A
....................     while(1) 
....................     { 
....................         returnedvalue = GetHDC1080Version(0x01); 
043AE:  MOVLW  01
043B0:  MOVLB  7
043B2:  MOVWF  xAF
043B4:  MOVLB  0
043B6:  CALL   372C
043BA:  MOVFF  02,771
043BE:  MOVFF  01,770
....................         if (returnedvalue == 0x1050) 
043C2:  MOVLB  7
043C4:  MOVF   x70,W
043C6:  SUBLW  50
043C8:  BTFSS  FD8.2
043CA:  BRA    462C
043CC:  MOVF   x71,W
043CE:  SUBLW  10
043D0:  BTFSS  FD8.2
043D2:  BRA    462C
....................         { 
.................... // this means the device is still plugged in.  Get the real-time temp and RH. 
....................     //    returnedvalue = GetHDC1080RHTemp(0x01); 
....................              
....................    returnedresultit = GetHDC1080RHTemp(0x01); 
043D4:  MOVLW  01
043D6:  MOVWF  x90
043D8:  MOVLB  0
043DA:  BRA    3F3A
043DC:  MOVFF  03,777
043E0:  MOVFF  02,776
043E4:  MOVFF  01,775
043E8:  MOVFF  00,774
....................     
....................    readlineararray(); 
043EC:  BRA    4210
....................    returnedresult = th; 
043EE:  MOVFF  22A,773
043F2:  MOVFF  229,772
....................    returnedresult = tl; 
043F6:  MOVFF  22C,773
043FA:  MOVFF  22B,772
....................    titemp = (float) (th << 8 | tl);     
043FE:  MOVFF  229,792
04402:  MOVLB  7
04404:  CLRF   x91
04406:  MOVF   x91,W
04408:  MOVLB  2
0440A:  IORWF  x2B,W
0440C:  MOVWF  00
0440E:  MOVLB  7
04410:  MOVF   x92,W
04412:  MOVLB  2
04414:  IORWF  x2C,W
04416:  MOVWF  03
04418:  MOVFF  00,7E3
0441C:  MOVLB  7
0441E:  MOVWF  xE4
04420:  MOVLB  0
04422:  CALL   21BE
04426:  MOVFF  03,77B
0442A:  MOVFF  02,77A
0442E:  MOVFF  01,779
04432:  MOVFF  00,778
....................     titemp = titemp * 165.0 / 65536.0 - 40.0; 
04436:  MOVFF  77B,7E2
0443A:  MOVFF  77A,7E1
0443E:  MOVFF  779,7E0
04442:  MOVFF  778,7DF
04446:  MOVLB  7
04448:  CLRF   xE6
0444A:  CLRF   xE5
0444C:  MOVLW  25
0444E:  MOVWF  xE4
04450:  MOVLW  86
04452:  MOVWF  xE3
04454:  MOVLB  0
04456:  CALL   20C8
0445A:  MOVFF  03,793
0445E:  MOVFF  02,792
04462:  MOVFF  01,791
04466:  MOVFF  00,790
0446A:  MOVFF  03,7DB
0446E:  MOVFF  02,7DA
04472:  MOVFF  01,7D9
04476:  MOVFF  00,7D8
0447A:  MOVLB  7
0447C:  CLRF   xDF
0447E:  CLRF   xDE
04480:  CLRF   xDD
04482:  MOVLW  8F
04484:  MOVWF  xDC
04486:  MOVLB  0
04488:  CALL   1F6A
0448C:  MOVFF  03,793
04490:  MOVFF  02,792
04494:  MOVFF  01,791
04498:  MOVFF  00,790
0449C:  BSF    FD8.1
0449E:  MOVFF  03,7E6
044A2:  MOVFF  02,7E5
044A6:  MOVFF  01,7E4
044AA:  MOVFF  00,7E3
044AE:  MOVLB  7
044B0:  CLRF   xEA
044B2:  CLRF   xE9
044B4:  MOVLW  20
044B6:  MOVWF  xE8
044B8:  MOVLW  84
044BA:  MOVWF  xE7
044BC:  MOVLB  0
044BE:  CALL   1CF2
044C2:  MOVFF  03,77B
044C6:  MOVFF  02,77A
044CA:  MOVFF  01,779
044CE:  MOVFF  00,778
....................      sprintf(teststr4,"Temp %f",titemp);    
044D2:  MOVLW  07
044D4:  MOVLB  2
044D6:  MOVWF  x32
044D8:  MOVLW  7C
044DA:  MOVWF  x31
044DC:  MOVLW  4E
044DE:  MOVWF  FF6
044E0:  MOVLW  10
044E2:  MOVWF  FF7
044E4:  MOVLW  05
044E6:  MOVLB  7
044E8:  MOVWF  xAF
044EA:  MOVLB  0
044EC:  CALL   3290
044F0:  MOVLW  89
044F2:  MOVWF  FE9
044F4:  MOVFF  77B,7B2
044F8:  MOVFF  77A,7B1
044FC:  MOVFF  779,7B0
04500:  MOVFF  778,7AF
04504:  MOVLW  02
04506:  MOVLB  7
04508:  MOVWF  xB3
0450A:  MOVLB  0
0450C:  CALL   3458
....................     writeString(0, 3, teststr4); 
04510:  MOVLB  7
04512:  CLRF   xC0
04514:  MOVLW  03
04516:  MOVWF  xC1
04518:  MOVLW  07
0451A:  MOVWF  xC3
0451C:  MOVLW  7C
0451E:  MOVWF  xC2
04520:  MOVLB  0
04522:  CALL   134A
....................  
....................     returnedresult = hh; 
04526:  MOVFF  22E,773
0452A:  MOVFF  22D,772
....................    returnedresult = hl; 
0452E:  MOVFF  230,773
04532:  MOVFF  22F,772
....................    titemp = (float) (hh << 8 | hl);     
04536:  MOVFF  22D,792
0453A:  MOVLB  7
0453C:  CLRF   x91
0453E:  MOVF   x91,W
04540:  MOVLB  2
04542:  IORWF  x2F,W
04544:  MOVWF  00
04546:  MOVLB  7
04548:  MOVF   x92,W
0454A:  MOVLB  2
0454C:  IORWF  x30,W
0454E:  MOVWF  03
04550:  MOVFF  00,7E3
04554:  MOVLB  7
04556:  MOVWF  xE4
04558:  MOVLB  0
0455A:  CALL   21BE
0455E:  MOVFF  03,77B
04562:  MOVFF  02,77A
04566:  MOVFF  01,779
0456A:  MOVFF  00,778
....................    titemp = titemp * 100.0 / 65536.0; 
0456E:  MOVFF  77B,7E2
04572:  MOVFF  77A,7E1
04576:  MOVFF  779,7E0
0457A:  MOVFF  778,7DF
0457E:  MOVLB  7
04580:  CLRF   xE6
04582:  CLRF   xE5
04584:  MOVLW  48
04586:  MOVWF  xE4
04588:  MOVLW  85
0458A:  MOVWF  xE3
0458C:  MOVLB  0
0458E:  CALL   20C8
04592:  MOVFF  03,793
04596:  MOVFF  02,792
0459A:  MOVFF  01,791
0459E:  MOVFF  00,790
045A2:  MOVFF  03,7DB
045A6:  MOVFF  02,7DA
045AA:  MOVFF  01,7D9
045AE:  MOVFF  00,7D8
045B2:  MOVLB  7
045B4:  CLRF   xDF
045B6:  CLRF   xDE
045B8:  CLRF   xDD
045BA:  MOVLW  8F
045BC:  MOVWF  xDC
045BE:  MOVLB  0
045C0:  CALL   1F6A
045C4:  MOVFF  03,77B
045C8:  MOVFF  02,77A
045CC:  MOVFF  01,779
045D0:  MOVFF  00,778
....................   //    titemp = titemp * 100.0 / 32768.0; 
....................      sprintf(teststr4,"RH %f",titemp);  
045D4:  MOVLW  07
045D6:  MOVLB  2
045D8:  MOVWF  x32
045DA:  MOVLW  7C
045DC:  MOVWF  x31
045DE:  MOVLW  56
045E0:  MOVWF  FF6
045E2:  MOVLW  10
045E4:  MOVWF  FF7
045E6:  MOVLW  03
045E8:  MOVLB  7
045EA:  MOVWF  xAF
045EC:  MOVLB  0
045EE:  CALL   3290
045F2:  MOVLW  89
045F4:  MOVWF  FE9
045F6:  MOVFF  77B,7B2
045FA:  MOVFF  77A,7B1
045FE:  MOVFF  779,7B0
04602:  MOVFF  778,7AF
04606:  MOVLW  02
04608:  MOVLB  7
0460A:  MOVWF  xB3
0460C:  MOVLB  0
0460E:  CALL   3458
....................         writeString(0, 2, teststr4);         
04612:  MOVLB  7
04614:  CLRF   xC0
04616:  MOVLW  02
04618:  MOVWF  xC1
0461A:  MOVLW  07
0461C:  MOVWF  xC3
0461E:  MOVLW  7C
04620:  MOVWF  xC2
04622:  MOVLB  0
04624:  CALL   134A
....................         } 
04628:  BRA    4634
0462A:  MOVLB  7
....................         else 
....................         { 
....................         return(0x02);    // exit the routine when the chip is not installed. 
0462C:  MOVLW  02
0462E:  MOVWF  01
04630:  BRA    4638
04632:  MOVLB  0
....................         } 
04634:  BRA    43AE
04636:  MOVLB  7
....................     }    
04638:  MOVLB  0
0463A:  GOTO   905C (RETURN)
.................... } 
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Create January 24, 2017 
.................... // This routine is used to test the PAR chip on the optical board. 
.................... // It clears the display and sends the raw and calculated data to the display in real time. 
.................... // when the cable is pulled out, there is an error with the version number and then it releases back 
.................... // to the operating system to check for the next connection. 
.................... //  Returns nothing. 
.................... //***************************************************************************** 
.................... int TestPARchip(void) 
.................... { 
....................      
....................     int16 returnedvalue,returnedresult; 
....................     float returnedresultit,titemp; 
....................     int struuu; 
....................      
....................     clearDisplay(); 
*
04D1C:  CALL   131E
....................     char teststr4[20]; 
....................     sprintf(teststr4,"       TAOS 3414"); 
04D20:  MOVLW  07
04D22:  MOVLB  2
04D24:  MOVWF  x32
04D26:  MOVLW  7D
04D28:  MOVWF  x31
04D2A:  MOVLW  5C
04D2C:  MOVWF  FF6
04D2E:  MOVLW  10
04D30:  MOVWF  FF7
04D32:  MOVLB  0
04D34:  CALL   1C76
....................     writeString(0, 0, teststr4); 
04D38:  MOVLB  7
04D3A:  CLRF   xC0
04D3C:  CLRF   xC1
04D3E:  MOVLW  07
04D40:  MOVWF  xC3
04D42:  MOVLW  7D
04D44:  MOVWF  xC2
04D46:  MOVLB  0
04D48:  CALL   134A
....................     while(1) 
....................     { 
....................         struuu = getTAOSVersion(0x01); 
04D4C:  MOVLW  01
04D4E:  MOVLB  7
04D50:  MOVWF  xAF
04D52:  MOVLB  0
04D54:  CALL   3808
04D58:  MOVFF  01,77C
....................         if (struuu == 0x11) 
04D5C:  MOVLB  7
04D5E:  MOVF   x7C,W
04D60:  SUBLW  11
04D62:  BTFSS  FD8.2
04D64:  BRA    4EFA
....................         { 
.................... // this means the device is still plugged in.  Get the real-time temp and RH. 
....................       ExposureTimeTAOS(0x00, 0x01); 
04D66:  CLRF   x91
04D68:  MOVLW  01
04D6A:  MOVWF  x92
04D6C:  MOVLB  0
04D6E:  BRA    463E
....................       StartUpTAOS(0x01); 
04D70:  MOVLW  01
04D72:  MOVLB  7
04D74:  MOVWF  x91
04D76:  MOVLB  0
04D78:  BRA    46AE
....................        
.................... 		ReadColorTAOS(2,0x01);  //green 
04D7A:  MOVLW  02
04D7C:  MOVLB  7
04D7E:  MOVWF  x91
04D80:  MOVLW  01
04D82:  MOVWF  x92
04D84:  MOVLB  0
04D86:  RCALL  4722
.................... 		green = colorlow + colorhigh * 256; 
04D88:  MOVLB  7
04D8A:  CLRF   xB5
04D8C:  MOVFF  728,7B4
04D90:  MOVLW  01
04D92:  MOVWF  xB7
04D94:  CLRF   xB6
04D96:  MOVLB  0
04D98:  RCALL  4CFA
04D9A:  MOVF   01,W
04D9C:  MOVLB  7
04D9E:  ADDWF  x27,W
04DA0:  MOVWF  x2B
04DA2:  MOVLW  00
04DA4:  ADDWFC 02,W
04DA6:  MOVWF  x2C
....................  
.................... 		ReadColorTAOS(1,0x01);  //red 
04DA8:  MOVLW  01
04DAA:  MOVWF  x91
04DAC:  MOVWF  x92
04DAE:  MOVLB  0
04DB0:  RCALL  4722
.................... 		red = colorlow + colorhigh * 256; 
04DB2:  MOVLB  7
04DB4:  CLRF   xB5
04DB6:  MOVFF  728,7B4
04DBA:  MOVLW  01
04DBC:  MOVWF  xB7
04DBE:  CLRF   xB6
04DC0:  MOVLB  0
04DC2:  RCALL  4CFA
04DC4:  MOVF   01,W
04DC6:  MOVLB  7
04DC8:  ADDWF  x27,W
04DCA:  MOVWF  x29
04DCC:  MOVLW  00
04DCE:  ADDWFC 02,W
04DD0:  MOVWF  x2A
....................  
.................... 		ReadColorTAOS(4,0x01);  //clear 
04DD2:  MOVLW  04
04DD4:  MOVWF  x91
04DD6:  MOVLW  01
04DD8:  MOVWF  x92
04DDA:  MOVLB  0
04DDC:  RCALL  4722
.................... 		clear = colorlow + colorhigh * 256; 
04DDE:  MOVLB  7
04DE0:  CLRF   xB5
04DE2:  MOVFF  728,7B4
04DE6:  MOVLW  01
04DE8:  MOVWF  xB7
04DEA:  CLRF   xB6
04DEC:  MOVLB  0
04DEE:  RCALL  4CFA
04DF0:  MOVF   01,W
04DF2:  MOVLB  7
04DF4:  ADDWF  x27,W
04DF6:  MOVWF  x2F
04DF8:  MOVLW  00
04DFA:  ADDWFC 02,W
04DFC:  MOVWF  x30
....................  
.................... 		ReadColorTAOS(3,0x01);  //blue 
04DFE:  MOVLW  03
04E00:  MOVWF  x91
04E02:  MOVLW  01
04E04:  MOVWF  x92
04E06:  MOVLB  0
04E08:  RCALL  4722
.................... 		blue = colorlow + colorhigh * 256; 
04E0A:  MOVLB  7
04E0C:  CLRF   xB5
04E0E:  MOVFF  728,7B4
04E12:  MOVLW  01
04E14:  MOVWF  xB7
04E16:  CLRF   xB6
04E18:  MOVLB  0
04E1A:  RCALL  4CFA
04E1C:  MOVF   01,W
04E1E:  MOVLB  7
04E20:  ADDWF  x27,W
04E22:  MOVWF  x2D
04E24:  MOVLW  00
04E26:  ADDWFC 02,W
04E28:  MOVWF  x2E
....................        
....................        
....................        
....................      sprintf(teststr4,"red %Lu",red);    
04E2A:  MOVLW  07
04E2C:  MOVLB  2
04E2E:  MOVWF  x32
04E30:  MOVLW  7D
04E32:  MOVWF  x31
04E34:  MOVLW  6E
04E36:  MOVWF  FF6
04E38:  MOVLW  10
04E3A:  MOVWF  FF7
04E3C:  MOVLW  04
04E3E:  MOVLB  7
04E40:  MOVWF  xAF
04E42:  MOVLB  0
04E44:  CALL   3290
04E48:  MOVLW  10
04E4A:  MOVWF  FE9
04E4C:  MOVFF  72A,7B0
04E50:  MOVFF  729,7AF
04E54:  CALL   32BA
....................     writeString(0, 1, teststr4); 
04E58:  MOVLB  7
04E5A:  CLRF   xC0
04E5C:  MOVLW  01
04E5E:  MOVWF  xC1
04E60:  MOVLW  07
04E62:  MOVWF  xC3
04E64:  MOVLW  7D
04E66:  MOVWF  xC2
04E68:  MOVLB  0
04E6A:  CALL   134A
....................      sprintf(teststr4,"green %Lu",green);    
04E6E:  MOVLW  07
04E70:  MOVLB  2
04E72:  MOVWF  x32
04E74:  MOVLW  7D
04E76:  MOVWF  x31
04E78:  MOVLW  76
04E7A:  MOVWF  FF6
04E7C:  MOVLW  10
04E7E:  MOVWF  FF7
04E80:  MOVLW  06
04E82:  MOVLB  7
04E84:  MOVWF  xAF
04E86:  MOVLB  0
04E88:  CALL   3290
04E8C:  MOVLW  10
04E8E:  MOVWF  FE9
04E90:  MOVFF  72C,7B0
04E94:  MOVFF  72B,7AF
04E98:  CALL   32BA
....................     writeString(0, 2, teststr4); 
04E9C:  MOVLB  7
04E9E:  CLRF   xC0
04EA0:  MOVLW  02
04EA2:  MOVWF  xC1
04EA4:  MOVLW  07
04EA6:  MOVWF  xC3
04EA8:  MOVLW  7D
04EAA:  MOVWF  xC2
04EAC:  MOVLB  0
04EAE:  CALL   134A
....................       sprintf(teststr4,"blue %Lu",blue);    
04EB2:  MOVLW  07
04EB4:  MOVLB  2
04EB6:  MOVWF  x32
04EB8:  MOVLW  7D
04EBA:  MOVWF  x31
04EBC:  MOVLW  80
04EBE:  MOVWF  FF6
04EC0:  MOVLW  10
04EC2:  MOVWF  FF7
04EC4:  MOVLW  05
04EC6:  MOVLB  7
04EC8:  MOVWF  xAF
04ECA:  MOVLB  0
04ECC:  CALL   3290
04ED0:  MOVLW  10
04ED2:  MOVWF  FE9
04ED4:  MOVFF  72E,7B0
04ED8:  MOVFF  72D,7AF
04EDC:  CALL   32BA
....................     writeString(0, 3, teststr4);       
04EE0:  MOVLB  7
04EE2:  CLRF   xC0
04EE4:  MOVLW  03
04EE6:  MOVWF  xC1
04EE8:  MOVLW  07
04EEA:  MOVWF  xC3
04EEC:  MOVLW  7D
04EEE:  MOVWF  xC2
04EF0:  MOVLB  0
04EF2:  CALL   134A
....................         } 
04EF6:  BRA    4F02
04EF8:  MOVLB  7
....................         else 
....................         { 
....................         return(0x02);    // exit the routine when the chip is not installed. 
04EFA:  MOVLW  02
04EFC:  MOVWF  01
04EFE:  BRA    4F06
04F00:  MOVLB  0
....................         } 
04F02:  BRA    4D4C
04F04:  MOVLB  7
....................     }    
04F06:  MOVLB  0
04F08:  GOTO   9072 (RETURN)
.................... } 
....................  
....................  
.................... //***************************************************************************** 
.................... // Create Fabuary 12, 2017 
.................... // This routine is used to test the AnalogDO and NH4 board. 
.................... // It clears the display and sends the raw and calculated data to the display in real time. 
.................... // when the cable is pulled out, there is an error with the version number and then it releases back 
.................... // to the operating system to check for the next connection. 
.................... //  Returns no data other than the flag if nothing is connected 
.................... //***************************************************************************** 
.................... int TestAnalogDONHFourBoard(void) 
.................... { 
....................      
....................     int16 returnedvalue,returnedresult; 
....................     float returnedresultit,titemp; 
....................     int struuu; 
....................      
....................     clearDisplay(); 
*
07F04:  CALL   131E
....................     char teststr4[20]; 
....................     sprintf(teststr4," Analog DO and NH4  "); 
07F08:  MOVLW  07
07F0A:  MOVLB  2
07F0C:  MOVWF  x32
07F0E:  MOVLW  7D
07F10:  MOVWF  x31
07F12:  MOVLW  8A
07F14:  MOVWF  FF6
07F16:  MOVLW  10
07F18:  MOVWF  FF7
07F1A:  MOVLB  0
07F1C:  CALL   1C76
....................     writeString(0, 0, teststr4); 
07F20:  MOVLB  7
07F22:  CLRF   xC0
07F24:  CLRF   xC1
07F26:  MOVLW  07
07F28:  MOVWF  xC3
07F2A:  MOVLW  7D
07F2C:  MOVWF  xC2
07F2E:  MOVLB  0
07F30:  CALL   134A
....................     while(1) 
....................     { 
....................         struuu = GetAnalogDONHFourVersion(0x01); 
07F34:  MOVLW  01
07F36:  MOVLB  7
07F38:  MOVWF  xAF
07F3A:  MOVLB  0
07F3C:  CALL   38C6
07F40:  MOVFF  01,77C
....................         if (struuu == 0xa9) 
07F44:  MOVLB  7
07F46:  MOVF   x7C,W
07F48:  SUBLW  A9
07F4A:  BTFSS  FD8.2
07F4C:  BRA    80A2
....................         { 
.................... // this means the device is still plugged in.  Get the real-time temp and RH. 
....................              
....................         ReadRemoteDevice(0x01); // this selects the Top connector RJ45 device 
07F4E:  MOVLW  01
07F50:  MOVWF  x91
07F52:  MOVLB  0
07F54:  RCALL  784E
....................         moveReceivedData(0x00); 
07F56:  MOVLB  7
07F58:  CLRF   x91
07F5A:  MOVLB  0
07F5C:  RCALL  7968
....................          
....................      sprintf(teststr4,"WT %f  Raw %Lu  ",sysOutput.wTemp,WTraw);    
07F5E:  MOVLW  07
07F60:  MOVLB  2
07F62:  MOVWF  x32
07F64:  MOVLW  7D
07F66:  MOVWF  x31
07F68:  MOVLW  A0
07F6A:  MOVWF  FF6
07F6C:  MOVLW  10
07F6E:  MOVWF  FF7
07F70:  MOVLW  03
07F72:  MOVLB  7
07F74:  MOVWF  xAF
07F76:  MOVLB  0
07F78:  CALL   3290
07F7C:  MOVLW  89
07F7E:  MOVWF  FE9
07F80:  MOVFF  1D2,7B2
07F84:  MOVFF  1D1,7B1
07F88:  MOVFF  1D0,7B0
07F8C:  MOVFF  1CF,7AF
07F90:  MOVLW  02
07F92:  MOVLB  7
07F94:  MOVWF  xB3
07F96:  MOVLB  0
07F98:  CALL   3458
07F9C:  MOVLW  A5
07F9E:  MOVWF  FF6
07FA0:  MOVLW  10
07FA2:  MOVWF  FF7
07FA4:  MOVLW  06
07FA6:  MOVLB  7
07FA8:  MOVWF  xAF
07FAA:  MOVLB  0
07FAC:  CALL   3290
07FB0:  MOVLW  10
07FB2:  MOVWF  FE9
07FB4:  MOVFF  1B0,7B0
07FB8:  MOVFF  1AF,7AF
07FBC:  CALL   32BA
07FC0:  MOVLW  20
07FC2:  MOVLB  7
07FC4:  MOVWF  xBC
07FC6:  MOVLB  0
07FC8:  CALL   1C54
07FCC:  MOVLW  20
07FCE:  MOVLB  7
07FD0:  MOVWF  xBC
07FD2:  MOVLB  0
07FD4:  CALL   1C54
....................     writeString(0, 1, teststr4); 
07FD8:  MOVLB  7
07FDA:  CLRF   xC0
07FDC:  MOVLW  01
07FDE:  MOVWF  xC1
07FE0:  MOVLW  07
07FE2:  MOVWF  xC3
07FE4:  MOVLW  7D
07FE6:  MOVWF  xC2
07FE8:  MOVLB  0
07FEA:  CALL   134A
....................      sprintf(teststr4,"NH4 %Lu   ",NH4Raw);    
07FEE:  MOVLW  07
07FF0:  MOVLB  2
07FF2:  MOVWF  x32
07FF4:  MOVLW  7D
07FF6:  MOVWF  x31
07FF8:  MOVLW  B2
07FFA:  MOVWF  FF6
07FFC:  MOVLW  10
07FFE:  MOVWF  FF7
08000:  MOVLW  04
08002:  MOVLB  7
08004:  MOVWF  xAF
08006:  MOVLB  0
08008:  CALL   3290
0800C:  MOVLW  10
0800E:  MOVWF  FE9
08010:  MOVFF  1B2,7B0
08014:  MOVFF  1B1,7AF
08018:  CALL   32BA
0801C:  MOVLW  B9
0801E:  MOVWF  FF6
08020:  MOVLW  10
08022:  MOVWF  FF7
08024:  MOVLW  03
08026:  MOVLB  7
08028:  MOVWF  xAF
0802A:  MOVLB  0
0802C:  CALL   3290
....................     writeString(0, 2, teststr4); 
08030:  MOVLB  7
08032:  CLRF   xC0
08034:  MOVLW  02
08036:  MOVWF  xC1
08038:  MOVLW  07
0803A:  MOVWF  xC3
0803C:  MOVLW  7D
0803E:  MOVWF  xC2
08040:  MOVLB  0
08042:  CALL   134A
....................       sprintf(teststr4,"DO %Lu   ",DOraw);    
08046:  MOVLW  07
08048:  MOVLB  2
0804A:  MOVWF  x32
0804C:  MOVLW  7D
0804E:  MOVWF  x31
08050:  MOVLW  BE
08052:  MOVWF  FF6
08054:  MOVLW  10
08056:  MOVWF  FF7
08058:  MOVLW  03
0805A:  MOVLB  7
0805C:  MOVWF  xAF
0805E:  MOVLB  0
08060:  CALL   3290
08064:  MOVLW  10
08066:  MOVWF  FE9
08068:  MOVFF  1AE,7B0
0806C:  MOVFF  1AD,7AF
08070:  CALL   32BA
08074:  MOVLW  C4
08076:  MOVWF  FF6
08078:  MOVLW  10
0807A:  MOVWF  FF7
0807C:  MOVLW  03
0807E:  MOVLB  7
08080:  MOVWF  xAF
08082:  MOVLB  0
08084:  CALL   3290
....................     writeString(0, 3, teststr4);       
08088:  MOVLB  7
0808A:  CLRF   xC0
0808C:  MOVLW  03
0808E:  MOVWF  xC1
08090:  MOVLW  07
08092:  MOVWF  xC3
08094:  MOVLW  7D
08096:  MOVWF  xC2
08098:  MOVLB  0
0809A:  CALL   134A
....................         } 
0809E:  BRA    80AA
080A0:  MOVLB  7
....................         else 
....................         { 
....................         return(0x02);    // exit the routine when the chip is not installed. 
080A2:  MOVLW  02
080A4:  MOVWF  01
080A6:  BRA    80AE
080A8:  MOVLB  0
....................         } 
080AA:  BRA    7F34
080AC:  MOVLB  7
....................     }    
080AE:  MOVLB  0
080B0:  GOTO   9088 (RETURN)
.................... } 
....................  
.................... //***************************************************************************** 
.................... // Create Fabuary 16, 2017 
.................... // This routine is used to test the  Digital DO and NH4 board. 
.................... // It clears the display and sends the raw and calculated data to the display in real time. 
.................... // when the cable is pulled out, there is an error with the version number and then it releases back 
.................... // to the operating system to check for the next connection. 
.................... //  Returns no data other than the flag if nothing is connected 
.................... //***************************************************************************** 
.................... int TestDigitalDONHFourBoard(void) 
.................... { 
....................      
....................     int16 returnedvalue,returnedresult; 
....................     float returnedresultit,titemp; 
....................     int struuu; 
....................      
....................     clearDisplay(); 
080B4:  CALL   131E
....................     char teststr4[20]; 
....................  //   sprintf(teststr4,"Digital DO and NH4   "); 
....................  //   writeString(0, 0, teststr4); 
....................     while(1) 
....................     { 
....................         struuu = GetAnalogDONHFourVersion(0x01); 
080B8:  MOVLW  01
080BA:  MOVLB  7
080BC:  MOVWF  xAF
080BE:  MOVLB  0
080C0:  CALL   38C6
080C4:  MOVFF  01,77C
....................         if ((struuu == 0x39) && (!startupdate)) 
080C8:  MOVLB  7
080CA:  MOVF   x7C,W
080CC:  SUBLW  39
080CE:  BTFSS  FD8.2
080D0:  BRA    847C
080D2:  MOVLB  2
080D4:  MOVF   x28,F
080D6:  BTFSC  FD8.2
080D8:  BRA    80DE
080DA:  MOVLB  7
080DC:  BRA    847C
....................         { 
.................... // this means the device is still plugged in.  Get the real-time temp and RH. 
....................            //DpHredRaw,DpHGreenRaw,DpHBlueRaw,DpHWhiteRaw  
....................         ReadRemoteDevice(0x01); // this selects the Top connector RJ45 device 
080DE:  MOVLW  01
080E0:  MOVLB  7
080E2:  MOVWF  x91
080E4:  MOVLB  0
080E6:  CALL   784E
....................         moveReceivedData(0x00); 
080EA:  MOVLB  7
080EC:  CLRF   x91
080EE:  MOVLB  0
080F0:  RCALL  7968
....................          
....................      sprintf(teststr4,"WT %f  Raw %Lu  ",sysOutput.wTemp,WTraw);    
080F2:  MOVLW  07
080F4:  MOVLB  2
080F6:  MOVWF  x32
080F8:  MOVLW  7D
080FA:  MOVWF  x31
080FC:  MOVLW  C8
080FE:  MOVWF  FF6
08100:  MOVLW  10
08102:  MOVWF  FF7
08104:  MOVLW  03
08106:  MOVLB  7
08108:  MOVWF  xAF
0810A:  MOVLB  0
0810C:  CALL   3290
08110:  MOVLW  89
08112:  MOVWF  FE9
08114:  MOVFF  1D2,7B2
08118:  MOVFF  1D1,7B1
0811C:  MOVFF  1D0,7B0
08120:  MOVFF  1CF,7AF
08124:  MOVLW  02
08126:  MOVLB  7
08128:  MOVWF  xB3
0812A:  MOVLB  0
0812C:  CALL   3458
08130:  MOVLW  CD
08132:  MOVWF  FF6
08134:  MOVLW  10
08136:  MOVWF  FF7
08138:  MOVLW  06
0813A:  MOVLB  7
0813C:  MOVWF  xAF
0813E:  MOVLB  0
08140:  CALL   3290
08144:  MOVLW  10
08146:  MOVWF  FE9
08148:  MOVFF  1B0,7B0
0814C:  MOVFF  1AF,7AF
08150:  CALL   32BA
08154:  MOVLW  20
08156:  MOVLB  7
08158:  MOVWF  xBC
0815A:  MOVLB  0
0815C:  CALL   1C54
08160:  MOVLW  20
08162:  MOVLB  7
08164:  MOVWF  xBC
08166:  MOVLB  0
08168:  CALL   1C54
....................     writeString(0, 0, teststr4); 
0816C:  MOVLB  7
0816E:  CLRF   xC0
08170:  CLRF   xC1
08172:  MOVLW  07
08174:  MOVWF  xC3
08176:  MOVLW  7D
08178:  MOVWF  xC2
0817A:  MOVLB  0
0817C:  CALL   134A
....................      sprintf(teststr4,"%Lu %Lu %Lu %Lu  ",NHRedRaw,NHGreenRaw,NHBlueRaw,NHWhiteRaw);    
08180:  MOVLW  07
08182:  MOVLB  2
08184:  MOVWF  x32
08186:  MOVLW  7D
08188:  MOVWF  x31
0818A:  MOVLW  10
0818C:  MOVWF  FE9
0818E:  MOVFF  2B7,7B0
08192:  MOVFF  2B6,7AF
08196:  MOVLB  0
08198:  CALL   32BA
0819C:  MOVLW  20
0819E:  MOVLB  7
081A0:  MOVWF  xBC
081A2:  MOVLB  0
081A4:  CALL   1C54
081A8:  MOVLW  10
081AA:  MOVWF  FE9
081AC:  MOVFF  2B9,7B0
081B0:  MOVFF  2B8,7AF
081B4:  CALL   32BA
081B8:  MOVLW  20
081BA:  MOVLB  7
081BC:  MOVWF  xBC
081BE:  MOVLB  0
081C0:  CALL   1C54
081C4:  MOVLW  10
081C6:  MOVWF  FE9
081C8:  MOVFF  2BB,7B0
081CC:  MOVFF  2BA,7AF
081D0:  CALL   32BA
081D4:  MOVLW  20
081D6:  MOVLB  7
081D8:  MOVWF  xBC
081DA:  MOVLB  0
081DC:  CALL   1C54
081E0:  MOVLW  10
081E2:  MOVWF  FE9
081E4:  MOVFF  2BD,7B0
081E8:  MOVFF  2BC,7AF
081EC:  CALL   32BA
081F0:  MOVLW  20
081F2:  MOVLB  7
081F4:  MOVWF  xBC
081F6:  MOVLB  0
081F8:  CALL   1C54
081FC:  MOVLW  20
081FE:  MOVLB  7
08200:  MOVWF  xBC
08202:  MOVLB  0
08204:  CALL   1C54
....................     writeString(0, 1, teststr4); 
08208:  MOVLB  7
0820A:  CLRF   xC0
0820C:  MOVLW  01
0820E:  MOVWF  xC1
08210:  MOVLW  07
08212:  MOVWF  xC3
08214:  MOVLW  7D
08216:  MOVWF  xC2
08218:  MOVLB  0
0821A:  CALL   134A
....................       sprintf(teststr4,"DO Raw %Lu    ",DOraw);    
0821E:  MOVLW  07
08220:  MOVLB  2
08222:  MOVWF  x32
08224:  MOVLW  7D
08226:  MOVWF  x31
08228:  MOVLW  DA
0822A:  MOVWF  FF6
0822C:  MOVLW  10
0822E:  MOVWF  FF7
08230:  MOVLW  07
08232:  MOVLB  7
08234:  MOVWF  xAF
08236:  MOVLB  0
08238:  CALL   3290
0823C:  MOVLW  10
0823E:  MOVWF  FE9
08240:  MOVFF  1AE,7B0
08244:  MOVFF  1AD,7AF
08248:  CALL   32BA
0824C:  MOVLW  E4
0824E:  MOVWF  FF6
08250:  MOVLW  10
08252:  MOVWF  FF7
08254:  MOVLW  04
08256:  MOVLB  7
08258:  MOVWF  xAF
0825A:  MOVLB  0
0825C:  CALL   3290
....................     writeString(0, 2, teststr4);  
08260:  MOVLB  7
08262:  CLRF   xC0
08264:  MOVLW  02
08266:  MOVWF  xC1
08268:  MOVLW  07
0826A:  MOVWF  xC3
0826C:  MOVLW  7D
0826E:  MOVWF  xC2
08270:  MOVLB  0
08272:  CALL   134A
....................     sprintf(teststr4,"%Lu %Lu %Lu %Lu  ",DpHRedRaw,DpHGreenRaw,DpHBlueRaw,DpHWhiteRaw);     
08276:  MOVLW  07
08278:  MOVLB  2
0827A:  MOVWF  x32
0827C:  MOVLW  7D
0827E:  MOVWF  x31
08280:  MOVLW  10
08282:  MOVWF  FE9
08284:  MOVFF  2BF,7B0
08288:  MOVFF  2BE,7AF
0828C:  MOVLB  0
0828E:  CALL   32BA
08292:  MOVLW  20
08294:  MOVLB  7
08296:  MOVWF  xBC
08298:  MOVLB  0
0829A:  CALL   1C54
0829E:  MOVLW  10
082A0:  MOVWF  FE9
082A2:  MOVFF  2C1,7B0
082A6:  MOVFF  2C0,7AF
082AA:  CALL   32BA
082AE:  MOVLW  20
082B0:  MOVLB  7
082B2:  MOVWF  xBC
082B4:  MOVLB  0
082B6:  CALL   1C54
082BA:  MOVLW  10
082BC:  MOVWF  FE9
082BE:  MOVFF  2C3,7B0
082C2:  MOVFF  2C2,7AF
082C6:  CALL   32BA
082CA:  MOVLW  20
082CC:  MOVLB  7
082CE:  MOVWF  xBC
082D0:  MOVLB  0
082D2:  CALL   1C54
082D6:  MOVLW  10
082D8:  MOVWF  FE9
082DA:  MOVFF  2C5,7B0
082DE:  MOVFF  2C4,7AF
082E2:  CALL   32BA
082E6:  MOVLW  20
082E8:  MOVLB  7
082EA:  MOVWF  xBC
082EC:  MOVLB  0
082EE:  CALL   1C54
082F2:  MOVLW  20
082F4:  MOVLB  7
082F6:  MOVWF  xBC
082F8:  MOVLB  0
082FA:  CALL   1C54
....................     writeString(0, 3, teststr4);     
082FE:  MOVLB  7
08300:  CLRF   xC0
08302:  MOVLW  03
08304:  MOVWF  xC1
08306:  MOVLW  07
08308:  MOVWF  xC3
0830A:  MOVLW  7D
0830C:  MOVWF  xC2
0830E:  MOVLB  0
08310:  CALL   134A
....................     fprintf(BT,"NH4-DO RGBW,%Lu,%Lu,%Lu,%Lu,DO Red,%Lu,WT,%f,Raw,%Lu,Dph-RGBW,%Lu,%Lu,%Lu,%Lu\n\r",NHRedRaw,NHGreenRaw,NHBlueRaw,NHWhiteRaw,DOraw,sysOutput.wTemp,WTraw,DpHRedRaw,DpHGreenRaw,DpHBlueRaw,DpHWhiteRaw); 
08314:  MOVLW  EA
08316:  MOVWF  FF6
08318:  MOVLW  10
0831A:  MOVWF  FF7
0831C:  MOVLW  0C
0831E:  MOVLB  7
08320:  MOVWF  xA8
08322:  MOVLB  0
08324:  CALL   5654
08328:  MOVLW  10
0832A:  MOVWF  FE9
0832C:  MOVFF  2B7,7A9
08330:  MOVFF  2B6,7A8
08334:  CALL   5A5E
08338:  MOVLW  2C
0833A:  BTFSS  F9E.4
0833C:  BRA    833A
0833E:  MOVWF  FAD
08340:  MOVLW  10
08342:  MOVWF  FE9
08344:  MOVFF  2B9,7A9
08348:  MOVFF  2B8,7A8
0834C:  CALL   5A5E
08350:  MOVLW  2C
08352:  BTFSS  F9E.4
08354:  BRA    8352
08356:  MOVWF  FAD
08358:  MOVLW  10
0835A:  MOVWF  FE9
0835C:  MOVFF  2BB,7A9
08360:  MOVFF  2BA,7A8
08364:  CALL   5A5E
08368:  MOVLW  2C
0836A:  BTFSS  F9E.4
0836C:  BRA    836A
0836E:  MOVWF  FAD
08370:  MOVLW  10
08372:  MOVWF  FE9
08374:  MOVFF  2BD,7A9
08378:  MOVFF  2BC,7A8
0837C:  CALL   5A5E
08380:  MOVLW  05
08382:  MOVWF  FF6
08384:  MOVLW  11
08386:  MOVWF  FF7
08388:  MOVLW  08
0838A:  MOVLB  7
0838C:  MOVWF  xA8
0838E:  MOVLB  0
08390:  CALL   5654
08394:  MOVLW  10
08396:  MOVWF  FE9
08398:  MOVFF  1AE,7A9
0839C:  MOVFF  1AD,7A8
083A0:  CALL   5A5E
083A4:  MOVLW  10
083A6:  MOVWF  FF6
083A8:  MOVLW  11
083AA:  MOVWF  FF7
083AC:  MOVLW  04
083AE:  MOVLB  7
083B0:  MOVWF  xA8
083B2:  MOVLB  0
083B4:  CALL   5654
083B8:  MOVLW  89
083BA:  MOVWF  FE9
083BC:  MOVFF  1D2,7AB
083C0:  MOVFF  1D1,7AA
083C4:  MOVFF  1D0,7A9
083C8:  MOVFF  1CF,7A8
083CC:  MOVLW  02
083CE:  MOVLB  7
083D0:  MOVWF  xAC
083D2:  MOVLB  0
083D4:  CALL   567E
083D8:  MOVLW  16
083DA:  MOVWF  FF6
083DC:  MOVLW  11
083DE:  MOVWF  FF7
083E0:  MOVLW  05
083E2:  MOVLB  7
083E4:  MOVWF  xA8
083E6:  MOVLB  0
083E8:  CALL   5654
083EC:  MOVLW  10
083EE:  MOVWF  FE9
083F0:  MOVFF  1B0,7A9
083F4:  MOVFF  1AF,7A8
083F8:  CALL   5A5E
083FC:  MOVLW  1E
083FE:  MOVWF  FF6
08400:  MOVLW  11
08402:  MOVWF  FF7
08404:  MOVLW  0A
08406:  MOVLB  7
08408:  MOVWF  xA8
0840A:  MOVLB  0
0840C:  CALL   5654
08410:  MOVLW  10
08412:  MOVWF  FE9
08414:  MOVFF  2BF,7A9
08418:  MOVFF  2BE,7A8
0841C:  CALL   5A5E
08420:  MOVLW  2C
08422:  BTFSS  F9E.4
08424:  BRA    8422
08426:  MOVWF  FAD
08428:  MOVLW  10
0842A:  MOVWF  FE9
0842C:  MOVFF  2C1,7A9
08430:  MOVFF  2C0,7A8
08434:  CALL   5A5E
08438:  MOVLW  2C
0843A:  BTFSS  F9E.4
0843C:  BRA    843A
0843E:  MOVWF  FAD
08440:  MOVLW  10
08442:  MOVWF  FE9
08444:  MOVFF  2C3,7A9
08448:  MOVFF  2C2,7A8
0844C:  CALL   5A5E
08450:  MOVLW  2C
08452:  BTFSS  F9E.4
08454:  BRA    8452
08456:  MOVWF  FAD
08458:  MOVLW  10
0845A:  MOVWF  FE9
0845C:  MOVFF  2C5,7A9
08460:  MOVFF  2C4,7A8
08464:  CALL   5A5E
08468:  MOVLW  0A
0846A:  BTFSS  F9E.4
0846C:  BRA    846A
0846E:  MOVWF  FAD
08470:  MOVLW  0D
08472:  BTFSS  F9E.4
08474:  BRA    8472
08476:  MOVWF  FAD
....................         } 
08478:  BRA    8484
0847A:  MOVLB  7
....................         else 
....................         { 
....................         return(0x02);    // exit the routine when the chip is not installed. 
0847C:  MOVLW  02
0847E:  MOVWF  01
08480:  BRA    8488
08482:  MOVLB  0
....................         } 
08484:  BRA    80B8
08486:  MOVLB  7
....................     }    
08488:  MOVLB  0
0848A:  GOTO   909E (RETURN)
.................... } 
....................  
....................  
.................... //***************************************************************************** 
.................... // Create Fabuary 20, 2017 
.................... // This routine is used to test the CO2 board. 
.................... // It clears the display and sends the raw and calculated data to the display in real time. 
.................... // when the cable is pulled out, there is an error with the version number and then it releases back 
.................... // to the operating system to check for the next connection. 
.................... //  Returns no data other than the flag if nothing is connected 
.................... //***************************************************************************** 
.................... int TestCO2Board(void) 
.................... { 
....................      
....................     int16 returnedvalue,returnedresult; 
....................     float returnedresultit,titemp; 
....................     int struuu; 
....................      
....................     clearDisplay(); 
0848E:  CALL   131E
....................     char teststr4[20]; 
....................     sprintf(teststr4,"  CO2/RH/Temp   "); 
08492:  MOVLW  07
08494:  MOVLB  2
08496:  MOVWF  x32
08498:  MOVLW  7D
0849A:  MOVWF  x31
0849C:  MOVLW  3A
0849E:  MOVWF  FF6
084A0:  MOVLW  11
084A2:  MOVWF  FF7
084A4:  MOVLB  0
084A6:  CALL   1C76
....................     writeString(0, 0, teststr4); 
084AA:  MOVLB  7
084AC:  CLRF   xC0
084AE:  CLRF   xC1
084B0:  MOVLW  07
084B2:  MOVWF  xC3
084B4:  MOVLW  7D
084B6:  MOVWF  xC2
084B8:  MOVLB  0
084BA:  CALL   134A
....................     while(1) 
....................     { 
....................         struuu = GetAnalogDONHFourVersion(0x01);   // this same routine is used for finding the ID code for all of the made boards.  The returned number is what makes it different. 
084BE:  MOVLW  01
084C0:  MOVLB  7
084C2:  MOVWF  xAF
084C4:  MOVLB  0
084C6:  CALL   38C6
084CA:  MOVFF  01,77C
....................         if (struuu == 0xd9) 
084CE:  MOVLB  7
084D0:  MOVF   x7C,W
084D2:  SUBLW  D9
084D4:  BTFSS  FD8.2
084D6:  BRA    85E8
....................         { 
.................... // this means the device is still plugged in.  Get the real-time temp and RH. 
....................              
....................         ReadRemoteDevice(0x01); // this selects the Top connector RJ45 device 
084D8:  MOVLW  01
084DA:  MOVWF  x91
084DC:  MOVLB  0
084DE:  CALL   784E
....................         moveReceivedData(0x00); 
084E2:  MOVLB  7
084E4:  CLRF   x91
084E6:  MOVLB  0
084E8:  CALL   7968
....................          
....................      sprintf(teststr4,"AT %f  RH  %f  ",sysOutput.aTemp,sysOutput.rH);    
084EC:  MOVLW  07
084EE:  MOVLB  2
084F0:  MOVWF  x32
084F2:  MOVLW  7D
084F4:  MOVWF  x31
084F6:  MOVLW  4C
084F8:  MOVWF  FF6
084FA:  MOVLW  11
084FC:  MOVWF  FF7
084FE:  MOVLW  03
08500:  MOVLB  7
08502:  MOVWF  xAF
08504:  MOVLB  0
08506:  CALL   3290
0850A:  MOVLW  89
0850C:  MOVWF  FE9
0850E:  MOVFF  211,7B2
08512:  MOVFF  210,7B1
08516:  MOVFF  20F,7B0
0851A:  MOVFF  20E,7AF
0851E:  MOVLW  02
08520:  MOVLB  7
08522:  MOVWF  xB3
08524:  MOVLB  0
08526:  CALL   3458
0852A:  MOVLW  51
0852C:  MOVWF  FF6
0852E:  MOVLW  11
08530:  MOVWF  FF7
08532:  MOVLW  06
08534:  MOVLB  7
08536:  MOVWF  xAF
08538:  MOVLB  0
0853A:  CALL   3290
0853E:  MOVLW  89
08540:  MOVWF  FE9
08542:  MOVFF  209,7B2
08546:  MOVFF  208,7B1
0854A:  MOVFF  207,7B0
0854E:  MOVFF  206,7AF
08552:  MOVLW  02
08554:  MOVLB  7
08556:  MOVWF  xB3
08558:  MOVLB  0
0855A:  CALL   3458
0855E:  MOVLW  20
08560:  MOVLB  7
08562:  MOVWF  xBC
08564:  MOVLB  0
08566:  CALL   1C54
0856A:  MOVLW  20
0856C:  MOVLB  7
0856E:  MOVWF  xBC
08570:  MOVLB  0
08572:  CALL   1C54
....................     writeString(0, 1, teststr4); 
08576:  MOVLB  7
08578:  CLRF   xC0
0857A:  MOVLW  01
0857C:  MOVWF  xC1
0857E:  MOVLW  07
08580:  MOVWF  xC3
08582:  MOVLW  7D
08584:  MOVWF  xC2
08586:  MOVLB  0
08588:  CALL   134A
....................       sprintf(teststr4,"CO2 %Lu    ",sysOutput.cO2);    
0858C:  MOVLW  07
0858E:  MOVLB  2
08590:  MOVWF  x32
08592:  MOVLW  7D
08594:  MOVWF  x31
08596:  MOVLW  5C
08598:  MOVWF  FF6
0859A:  MOVLW  11
0859C:  MOVWF  FF7
0859E:  MOVLW  04
085A0:  MOVLB  7
085A2:  MOVWF  xAF
085A4:  MOVLB  0
085A6:  CALL   3290
085AA:  MOVLW  10
085AC:  MOVWF  FE9
085AE:  MOVFF  213,7B0
085B2:  MOVFF  212,7AF
085B6:  CALL   32BA
085BA:  MOVLW  63
085BC:  MOVWF  FF6
085BE:  MOVLW  11
085C0:  MOVWF  FF7
085C2:  MOVLW  04
085C4:  MOVLB  7
085C6:  MOVWF  xAF
085C8:  MOVLB  0
085CA:  CALL   3290
....................     writeString(0, 3, teststr4);       
085CE:  MOVLB  7
085D0:  CLRF   xC0
085D2:  MOVLW  03
085D4:  MOVWF  xC1
085D6:  MOVLW  07
085D8:  MOVWF  xC3
085DA:  MOVLW  7D
085DC:  MOVWF  xC2
085DE:  MOVLB  0
085E0:  CALL   134A
....................         } 
085E4:  BRA    85F0
085E6:  MOVLB  7
....................         else 
....................         { 
....................         return(0x02);    // exit the routine when the chip is not installed. 
085E8:  MOVLW  02
085EA:  MOVWF  01
085EC:  BRA    85F4
085EE:  MOVLB  0
....................         } 
085F0:  BRA    84BE
085F2:  MOVLB  7
....................     }    
085F4:  MOVLB  0
085F6:  GOTO   90B4 (RETURN)
.................... } 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Feb 18, 2017 
.................... // This routine inits all of the levels for the linear array chip to measure the mercury theomoeter 
.................... // Returns nothing 
.................... //****************************************************************************** 
.................... void linearinit(void) 
.................... { 
....................      
....................     //  Set up the output for the controls Si and CLK 
....................     output_low(PIN_A4); 
*
011E2:  BCF    F92.4
011E4:  BCF    F89.4
....................     // set up the output for the clock 
....................     output_low(PIN_A5); 
011E6:  BCF    F92.5
011E8:  BCF    F89.5
011EA:  GOTO   8FBE (RETURN)
....................      
....................      
....................      
.................... } 
....................  
.................... //****************************************************************************** 
.................... // Created Feb 18, 2017 
.................... // this routine makes the exposure for the linear array and then places a reading in  
.................... // an array for comparing to the scaling.  It also does level detention and scaling for high 
.................... // and low levels. 
.................... // It returns 0 if there is no problem 
.................... // A 1 is returned if there is a fault 
.................... //***************************************************************************** 
.................... int readlineararray(void) 
*
04210:  MOVLB  7
04212:  CLRF   x92
04214:  CLRF   x91
04216:  MOVLW  04
04218:  MOVWF  x94
0421A:  CLRF   x93
.................... { 
....................     int x; 
....................     unsigned int16 maxvalue = 0; 
....................     unsigned int16 minvalue = 1024; 
....................     char teststr2[20]; 
....................     
....................     set_adc_channel(0x01); 
0421C:  MOVWF  01
0421E:  MOVF   FC2,W
04220:  ANDLW  83
04222:  IORWF  01,W
04224:  MOVWF  FC2
....................         delay_us(10); 
04226:  MOVLW  10
04228:  MOVWF  00
0422A:  DECFSZ 00,F
0422C:  BRA    422A
0422E:  NOP   
....................         output_high(PIN_A4);  // SI 
04230:  BCF    F92.4
04232:  BSF    F89.4
....................         output_high(PIN_A5);  // clock 
04234:  BCF    F92.5
04236:  BSF    F89.5
....................         delay_us(10);//delay 
04238:  MOVLW  10
0423A:  MOVWF  00
0423C:  DECFSZ 00,F
0423E:  BRA    423C
04240:  NOP   
....................         output_low(PIN_A4);  // SI 
04242:  BCF    F92.4
04244:  BCF    F89.4
....................     for (x=0; x < 128; x++)  // loop through all of the clock cycles and recored the ADV from AN1 value 
04246:  CLRF   x90
04248:  MOVF   x90,W
0424A:  SUBLW  7F
0424C:  BNC   4278
....................     { 
....................         output_low(PIN_A5); 
0424E:  BCF    F92.5
04250:  BCF    F89.5
....................          reading[x]= read_adc(); // Read adc channel 1   
04252:  BCF    FD8.0
04254:  RLCF   x90,W
04256:  CLRF   03
04258:  ADDLW  A6
0425A:  MOVWF  FE9
0425C:  MOVLW  00
0425E:  ADDWFC 03,W
04260:  MOVWF  FEA
04262:  BSF    FC2.1
04264:  BTFSC  FC2.1
04266:  BRA    4264
04268:  MOVFF  FC3,FEF
0426C:  MOVFF  FC4,FEC
....................         //delay_us(5);  // delay for exposure? 
....................         output_high(PIN_A5); 
04270:  BCF    F92.5
04272:  BSF    F89.5
04274:  INCF   x90,F
04276:  BRA    4248
....................     } 
....................         output_low(PIN_A4);  // when done, set low 
04278:  BCF    F92.4
0427A:  BCF    F89.4
....................         output_low(PIN_A5);    // when done, set low     
0427C:  BCF    F92.5
0427E:  BCF    F89.5
....................      
....................          
.................... // Find the min and max value in the array. 
....................         for (x=0; x < 128; x++) 
04280:  CLRF   x90
04282:  MOVF   x90,W
04284:  SUBLW  7F
04286:  BNC   4310
....................         { 
....................             if (reading[x] < minvalue) 
04288:  BCF    FD8.0
0428A:  RLCF   x90,W
0428C:  CLRF   03
0428E:  ADDLW  A6
04290:  MOVWF  FE9
04292:  MOVLW  00
04294:  ADDWFC 03,W
04296:  MOVWF  FEA
04298:  MOVFF  FEC,7AA
0429C:  MOVF   FED,F
0429E:  MOVFF  FEF,7A9
042A2:  MOVF   xAA,W
042A4:  SUBWF  x94,W
042A6:  BNC   42CA
042A8:  BNZ   42B0
042AA:  MOVF   x93,W
042AC:  SUBWF  xA9,W
042AE:  BC    42CA
....................                 minvalue = reading[x];  // then new min value is set 
042B0:  BCF    FD8.0
042B2:  RLCF   x90,W
042B4:  CLRF   03
042B6:  ADDLW  A6
042B8:  MOVWF  FE9
042BA:  MOVLW  00
042BC:  ADDWFC 03,W
042BE:  MOVWF  FEA
042C0:  MOVFF  FEC,794
042C4:  MOVF   FED,F
042C6:  MOVFF  FEF,793
....................               if (reading[x] > maxvalue) 
042CA:  BCF    FD8.0
042CC:  RLCF   x90,W
042CE:  CLRF   03
042D0:  ADDLW  A6
042D2:  MOVWF  FE9
042D4:  MOVLW  00
042D6:  ADDWFC 03,W
042D8:  MOVWF  FEA
042DA:  MOVFF  FEC,7AA
042DE:  MOVF   FED,F
042E0:  MOVFF  FEF,7A9
042E4:  MOVF   x92,W
042E6:  SUBWF  xAA,W
042E8:  BNC   430C
042EA:  BNZ   42F2
042EC:  MOVF   xA9,W
042EE:  SUBWF  x91,W
042F0:  BC    430C
....................                 maxvalue = reading[x];  // then new min value is set           
042F2:  BCF    FD8.0
042F4:  RLCF   x90,W
042F6:  CLRF   03
042F8:  ADDLW  A6
042FA:  MOVWF  FE9
042FC:  MOVLW  00
042FE:  ADDWFC 03,W
04300:  MOVWF  FEA
04302:  MOVFF  FEC,792
04306:  MOVF   FED,F
04308:  MOVFF  FEF,791
0430C:  INCF   x90,F
0430E:  BRA    4282
....................         } 
....................   //     sprintf(teststr2,"%Lu   %Lu    ",maxvalue,minvalue); 
....................  //      writeString(0, 3, teststr2);         
....................         //remove the minvalue from the whole array 
....................         for (x=0; x < 128; x++) 
04310:  CLRF   x90
04312:  MOVF   x90,W
04314:  SUBLW  7F
04316:  BNC   4362
....................         { 
....................             reading[x] = reading[x] - minvalue; 
04318:  BCF    FD8.0
0431A:  RLCF   x90,W
0431C:  CLRF   03
0431E:  ADDLW  A6
04320:  MOVWF  01
04322:  MOVLW  00
04324:  ADDWFC 03,F
04326:  MOVFF  03,7AA
0432A:  BCF    FD8.0
0432C:  RLCF   x90,W
0432E:  CLRF   03
04330:  ADDLW  A6
04332:  MOVWF  FE9
04334:  MOVLW  00
04336:  ADDWFC 03,W
04338:  MOVWF  FEA
0433A:  MOVFF  FEC,7AC
0433E:  MOVF   FED,F
04340:  MOVFF  FEF,7AB
04344:  MOVF   x93,W
04346:  SUBWF  xAB,W
04348:  MOVWF  00
0434A:  MOVF   x94,W
0434C:  SUBWFB xAC,W
0434E:  MOVFF  7AA,FEA
04352:  MOVFF  01,FE9
04356:  MOVWF  FEC
04358:  MOVF   FED,F
0435A:  MOVFF  00,FEF
0435E:  INCF   x90,F
04360:  BRA    4312
....................         }     
....................         maxvalue = (maxvalue - minvalue); 
04362:  MOVF   x93,W
04364:  SUBWF  x91,F
04366:  MOVF   x94,W
04368:  SUBWFB x92,F
....................          
....................  //      sprintf(teststr2,"%Lu   ",maxvalue); 
....................  //      writeString(0, 2, teststr2);  
....................         
....................         
....................         displaybar(maxvalue, 2); 
0436A:  MOVFF  791,7A9
0436E:  MOVLW  02
04370:  MOVWF  xAA
04372:  MOVLB  0
04374:  BRA    4192
....................          
....................      
....................          
....................     return(0); 
04376:  MOVLW  00
04378:  MOVWF  01
0437A:  GOTO   43EE (RETURN)
.................... } 
....................  
.................... void main(void) { 
*
08CB8:  CLRF   FF8
08CBA:  BCF    FD0.7
08CBC:  BSF    07.7
08CBE:  MOVLB  1
08CC0:  CLRF   xA6
08CC2:  CLRF   xA7
08CC4:  BCF    xA8.0
08CC6:  CLRF   xA9
08CC8:  CLRF   xAA
08CCA:  BSF    FB8.3
08CCC:  MOVLW  08
08CCE:  MOVWF  FAF
08CD0:  MOVLW  02
08CD2:  MOVWF  FB0
08CD4:  MOVLW  A6
08CD6:  MOVWF  FAC
08CD8:  MOVLW  90
08CDA:  MOVWF  FAB
08CDC:  MOVLB  2
08CDE:  CLRF   x28
08CE0:  CLRF   x32
08CE2:  CLRF   x31
08CE4:  CLRF   xC6
08CE6:  MOVLB  4
08CE8:  CLRF   x52
08CEA:  CLRF   x53
08CEC:  MOVLB  6
08CEE:  CLRF   x23
08CF0:  CLRF   x22
08CF2:  CLRF   x25
08CF4:  CLRF   x24
08CF6:  CLRF   x72
08CF8:  CLRF   x71
08CFA:  MOVLW  20
08CFC:  MOVWF  x70
08CFE:  MOVLW  84
08D00:  MOVWF  x6F
08D02:  CLRF   x76
08D04:  MOVLW  A0
08D06:  MOVWF  x75
08D08:  MOVLW  20
08D0A:  MOVWF  x74
08D0C:  MOVLW  8B
08D0E:  MOVWF  x73
08D10:  CLRF   x7A
08D12:  CLRF   x79
08D14:  MOVLW  20
08D16:  MOVWF  x78
08D18:  MOVLW  83
08D1A:  MOVWF  x77
08D1C:  CLRF   x7E
08D1E:  MOVLW  D0
08D20:  MOVWF  x7D
08D22:  MOVLW  36
08D24:  MOVWF  x7C
08D26:  MOVLW  8C
08D28:  MOVWF  x7B
08D2A:  CLRF   x82
08D2C:  CLRF   x81
08D2E:  MOVLW  40
08D30:  MOVWF  x80
08D32:  MOVLW  81
08D34:  MOVWF  x7F
08D36:  CLRF   x86
08D38:  MOVLW  B4
08D3A:  MOVWF  x85
08D3C:  MOVLW  28
08D3E:  MOVWF  x84
08D40:  MOVLW  8D
08D42:  MOVWF  x83
08D44:  MOVLB  F
08D46:  CLRF   x38
08D48:  CLRF   x39
08D4A:  CLRF   x3A
08D4C:  CLRF   x3B
08D4E:  CLRF   x3C
08D50:  MOVLB  1
08D52:  CLRF   x88
08D54:  CLRF   F77
08D56:  CLRF   F78
08D58:  CLRF   F79
08D5A:  BRA    8EFC
08D5C:  DATA 02,00
08D5E:  DATA 19,00
08D60:  DATA 00,01
08D62:  DATA 04,54
08D64:  DATA 3F,0A
08D66:  DATA C0,00
08D68:  DATA 07,80
08D6A:  DATA 64,69
08D6C:  DATA 73,70
08D6E:  DATA 6C,61
08D70:  DATA 79,04
08D72:  DATA C0,00
08D74:  DATA 03,80
08D76:  DATA 73,65
08D78:  DATA 74,08
08D7A:  DATA C0,00
08D7C:  DATA 07,80
08D7E:  DATA 64,65
08D80:  DATA 66,61
08D82:  DATA 75,6C
08D84:  DATA 74,04
08D86:  DATA C0,00
08D88:  DATA 1C,80
08D8A:  DATA 73,68
08D8C:  DATA 6F,77
08D8E:  DATA 63,6F
08D90:  DATA 6E,66
08D92:  DATA 69,67
08D94:  DATA 00,73
08D96:  DATA 61,76
08D98:  DATA 65,63
08D9A:  DATA 6F,6E
08D9C:  DATA 66,69
08D9E:  DATA 67,00
08DA0:  DATA 75,70
08DA2:  DATA 64,61
08DA4:  DATA 74,65
08DA6:  DATA 05,C0
08DA8:  DATA 00,04
08DAA:  DATA 80,72
08DAC:  DATA 73,74
08DAE:  DATA 00,03
08DB0:  DATA 04,AC
08DB2:  DATA 70,70
08DB4:  DATA 68,08
08DB6:  DATA C0,00
08DB8:  DATA 02,80
08DBA:  DATA 61,74
08DBC:  DATA 09,C0
08DBE:  DATA 00,02
08DC0:  DATA 80,64
08DC2:  DATA 6F,09
08DC4:  DATA C0,00
08DC6:  DATA 02,80
08DC8:  DATA 70,68
08DCA:  DATA 09,C0
08DCC:  DATA 00,02
08DCE:  DATA 80,77
08DD0:  DATA 64,09
08DD2:  DATA C0,00
08DD4:  DATA 06,80
08DD6:  DATA 70,68
08DD8:  DATA 62,75
08DDA:  DATA 6C,62
08DDC:  DATA 05,C0
08DDE:  DATA 00,05
08DE0:  DATA 80,63
08DE2:  DATA 6C,65
08DE4:  DATA 61,72
08DE6:  DATA 06,C0
08DE8:  DATA 00,03
08DEA:  DATA 80,6C
08DEC:  DATA 75,78
08DEE:  DATA 08,C0
08DF0:  DATA 00,02
08DF2:  DATA 80,65
08DF4:  DATA 63,09
08DF6:  DATA C0,00
08DF8:  DATA 03,80
08DFA:  DATA 63,6F
08DFC:  DATA 32,08
08DFE:  DATA C0,00
08E00:  DATA 02,80
08E02:  DATA 77,74
08E04:  DATA 09,C0
08E06:  DATA 00,03
08E08:  DATA 80,70
08E0A:  DATA 61,72
08E0C:  DATA 08,C0
08E0E:  DATA 00,03
08E10:  DATA 80,6E
08E12:  DATA 68,34
08E14:  DATA 08,C0
08E16:  DATA 00,07
08E18:  DATA 80,72
08E1A:  DATA 65,74
08E1C:  DATA 6E,68
08E1E:  DATA 34,31
08E20:  DATA 04,C0
08E22:  DATA 00,07
08E24:  DATA 80,72
08E26:  DATA 65,74
08E28:  DATA 6E,68
08E2A:  DATA 34,32
08E2C:  DATA 04,C0
08E2E:  DATA 00,07
08E30:  DATA 80,72
08E32:  DATA 65,74
08E34:  DATA 6E,68
08E36:  DATA 34,33
08E38:  DATA 04,C0
08E3A:  DATA 00,06
08E3C:  DATA 80,6E
08E3E:  DATA 68,34
08E40:  DATA 70,74
08E42:  DATA 31,05
08E44:  DATA C0,00
08E46:  DATA 06,80
08E48:  DATA 6E,68
08E4A:  DATA 34,70
08E4C:  DATA 74,32
08E4E:  DATA 05,C0
08E50:  DATA 00,06
08E52:  DATA 80,6E
08E54:  DATA 68,34
08E56:  DATA 70,74
08E58:  DATA 33,05
08E5A:  DATA C0,00
08E5C:  DATA 06,80
08E5E:  DATA 6E,68
08E60:  DATA 34,70
08E62:  DATA 74,34
08E64:  DATA 05,C0
08E66:  DATA 00,06
08E68:  DATA 80,6E
08E6A:  DATA 68,34
08E6C:  DATA 70,74
08E6E:  DATA 35,05
08E70:  DATA C0,00
08E72:  DATA 06,80
08E74:  DATA 6E,68
08E76:  DATA 34,70
08E78:  DATA 74,36
08E7A:  DATA 05,C0
08E7C:  DATA 00,06
08E7E:  DATA 80,6E
08E80:  DATA 68,34
08E82:  DATA 70,74
08E84:  DATA 37,05
08E86:  DATA C0,00
08E88:  DATA 06,80
08E8A:  DATA 6E,68
08E8C:  DATA 34,70
08E8E:  DATA 74,38
08E90:  DATA 05,C0
08E92:  DATA 00,06
08E94:  DATA 80,6E
08E96:  DATA 68,34
08E98:  DATA 70,74
08E9A:  DATA 39,05
08E9C:  DATA C0,00
08E9E:  DATA 05,80
08EA0:  DATA 44,4F
08EA2:  DATA 70,74
08EA4:  DATA 31,06
08EA6:  DATA C0,00
08EA8:  DATA 05,80
08EAA:  DATA 44,4F
08EAC:  DATA 70,74
08EAE:  DATA 32,06
08EB0:  DATA C0,00
08EB2:  DATA 05,80
08EB4:  DATA 44,4F
08EB6:  DATA 70,74
08EB8:  DATA 33,06
08EBA:  DATA C0,00
08EBC:  DATA 05,80
08EBE:  DATA 44,4F
08EC0:  DATA 70,74
08EC2:  DATA 34,06
08EC4:  DATA C0,00
08EC6:  DATA 05,80
08EC8:  DATA 44,4F
08ECA:  DATA 70,74
08ECC:  DATA 35,06
08ECE:  DATA C0,00
08ED0:  DATA 05,80
08ED2:  DATA 44,4F
08ED4:  DATA 70,74
08ED6:  DATA 36,06
08ED8:  DATA C0,00
08EDA:  DATA 05,80
08EDC:  DATA 44,4F
08EDE:  DATA 70,74
08EE0:  DATA 37,06
08EE2:  DATA C0,00
08EE4:  DATA 05,80
08EE6:  DATA 44,4F
08EE8:  DATA 70,74
08EEA:  DATA 38,06
08EEC:  DATA C0,00
08EEE:  DATA 06,80
08EF0:  DATA 44,4F
08EF2:  DATA 70,74
08EF4:  DATA 39,00
08EF6:  DATA 01,06
08EF8:  DATA 66,00
08EFA:  DATA 00,00
08EFC:  MOVLW  00
08EFE:  MOVWF  FF8
08F00:  MOVLW  8D
08F02:  MOVWF  FF7
08F04:  MOVLW  5C
08F06:  MOVWF  FF6
08F08:  TBLRD*+
08F0A:  MOVF   FF5,W
08F0C:  MOVWF  00
08F0E:  XORLW  00
08F10:  BZ    8F38
08F12:  TBLRD*+
08F14:  MOVF   FF5,W
08F16:  MOVWF  01
08F18:  BTFSC  FE8.7
08F1A:  BRA    8F26
08F1C:  ANDLW  0F
08F1E:  MOVWF  FEA
08F20:  TBLRD*+
08F22:  MOVFF  FF5,FE9
08F26:  BTFSC  01.6
08F28:  TBLRD*+
08F2A:  BTFSS  01.6
08F2C:  TBLRD*+
08F2E:  MOVFF  FF5,FEE
08F32:  DCFSNZ 00,F
08F34:  BRA    8F08
08F36:  BRA    8F2A
08F38:  CLRF   FF8
....................     //i2c_init(TRUE); 
....................  
....................     int8 adcStrCntr; 
....................     char teststr2[10]; 
....................     int8 deviceid,deviceidreturn;  // this is device ID that indicates what's plugged in.  A 1 means no device is plugged in. 
....................     float tempvar; 
....................     int16 tempvarint; 
....................     BTnext_in = 0; 
08F3A:  MOVLB  6
08F3C:  CLRF   x23
08F3E:  CLRF   x22
....................     BTnext_out = 0; 
08F40:  CLRF   x25
08F42:  CLRF   x24
....................  
....................  
....................     sysInput.eccal1x = 4000.0; //  This the EC data point  Added July 18, 2016 
08F44:  MOVLB  2
08F46:  CLRF   x90
08F48:  CLRF   x8F
08F4A:  MOVLW  7A
08F4C:  MOVWF  x8E
08F4E:  MOVLW  8A
08F50:  MOVWF  x8D
....................     sysInput.eccal2x = 1100.0; //  This the EC data point  Added July 18, 2016 
08F52:  CLRF   x94
08F54:  MOVLW  80
08F56:  MOVWF  x93
08F58:  MOVLW  09
08F5A:  MOVWF  x92
08F5C:  MOVLW  89
08F5E:  MOVWF  x91
....................     sysInput.eccal3x = 200.0; //  This the EC data point  Added July 18, 2016 
08F60:  CLRF   x98
08F62:  CLRF   x97
08F64:  MOVLW  48
08F66:  MOVWF  x96
08F68:  MOVLW  86
08F6A:  MOVWF  x95
....................     sysInput.eccal1y = 150.0; //  This the EC data point  Added July 18, 2016 
08F6C:  CLRF   x9C
08F6E:  CLRF   x9B
08F70:  MOVLW  16
08F72:  MOVWF  x9A
08F74:  MOVLW  86
08F76:  MOVWF  x99
....................     sysInput.eccal2y = 603.0; //  This the EC data point  Added July 18, 2016 
08F78:  CLRF   xA0
08F7A:  MOVLW  C0
08F7C:  MOVWF  x9F
08F7E:  MOVLW  16
08F80:  MOVWF  x9E
08F82:  MOVLW  88
08F84:  MOVWF  x9D
....................     sysInput.eccal3y = 10000.0; //  This the EC data point  Added July 18, 2016 
08F86:  CLRF   xA4
08F88:  MOVLW  40
08F8A:  MOVWF  xA3
08F8C:  MOVLW  1C
08F8E:  MOVWF  xA2
08F90:  MOVLW  8C
08F92:  MOVWF  xA1
....................  
....................     sysInput.phcallow = 250; 
08F94:  CLRF   x36
08F96:  CLRF   x35
08F98:  MOVLW  7A
08F9A:  MOVWF  x34
08F9C:  MOVLW  86
08F9E:  MOVWF  x33
....................     sysInput.phcalhigh = 500; 
08FA0:  CLRF   x3A
08FA2:  CLRF   x39
08FA4:  MOVLW  7A
08FA6:  MOVWF  x38
08FA8:  MOVLW  87
08FAA:  MOVWF  x37
....................     sysInput.phnumberupper = 10; 
08FAC:  CLRF   x3E
08FAE:  CLRF   x3D
08FB0:  MOVLW  20
08FB2:  MOVWF  x3C
08FB4:  MOVLW  82
08FB6:  MOVWF  x3B
....................  
....................     linearinit(); 
08FB8:  MOVLB  0
08FBA:  GOTO   11E2
....................     initDispIO(); 
08FBE:  GOTO   11EE
....................     delay_ms(2000);    /// delay the display from coming up or the CPU will not stay booted. 
08FC2:  MOVLW  08
08FC4:  MOVLB  7
08FC6:  MOVWF  x70
08FC8:  MOVLW  FA
08FCA:  MOVWF  xC1
08FCC:  MOVLB  0
08FCE:  CALL   1202
08FD2:  MOVLB  7
08FD4:  DECFSZ x70,F
08FD6:  BRA    8FC8
....................     initDisplay();     
08FD8:  MOVLB  0
08FDA:  GOTO   12C0
....................     splash(); 
08FDE:  GOTO   13BA
....................  
....................     //************************************************** 
....................     // Created Nov 22, 2106 
....................     // Get the saved configurations from the EEPROM and put them in local variables. 
....................     //************************************************** 
....................     selectitem = getlocalconfigurations(); // this gets the items for local configuration 
08FE2:  GOTO   1538
08FE6:  MOVFF  02,225
08FEA:  MOVFF  01,224
....................     LoadConfigurations(); 
08FEE:  GOTO   15F2
....................     fprintf(BT, "Command Line Processor\r\n>"); 
08FF2:  MOVLW  68
08FF4:  MOVWF  FF6
08FF6:  MOVLW  11
08FF8:  MOVWF  FF7
08FFA:  CALL   1C32
....................     fprintf(BT, "Press ? and CR for a list of commands\r\n>"); 
08FFE:  MOVLW  82
09000:  MOVWF  FF6
09002:  MOVLW  11
09004:  MOVWF  FF7
09006:  CALL   1C32
....................       
....................     setup_adc_ports(sAN0|sAN1|sAN2|sAN3|VSS_VDD);   // AN1 is the linear array 
0900A:  MOVF   FC1,W
0900C:  ANDLW  F0
0900E:  MOVWF  FC1
09010:  MOVLW  0F
09012:  MOVLB  F
09014:  MOVWF  x38
09016:  MOVLW  00
09018:  MOVWF  x3C
0901A:  MOVWF  x39
0901C:  MOVWF  x3A
0901E:  MOVWF  x3B
....................     setup_adc(ADC_CLOCK_INTERNAL); 
09020:  MOVF   FC0,W
09022:  ANDLW  C0
09024:  IORLW  07
09026:  MOVWF  FC0
09028:  BSF    FC0.7
0902A:  BSF    FC2.0
....................     enable_interrupts(GLOBAL); 
0902C:  MOVLW  C0
0902E:  IORWF  FF2,F
....................     enable_interrupts(INT_RDA); //This starts up s the Blue tooth module enterupt for taking in charters.  Added July 8, 2015 
09030:  BSF    F9D.5
....................  
....................      
....................    //************************************************************************ 
....................    // Added Jan 23, 2017 
....................    // This routine cycles through all of the possible i2c devices to determine which one is plugged in. 
....................    //************************************************************************ 
....................    deviceidreturn=0x02; 
09032:  MOVLW  02
09034:  MOVLB  7
09036:  MOVWF  x69
....................     
....................   // this is used for debugging and building new routines 
....................  //  while(1) 
....................  //  { 
....................  //       readlineararray(); 
....................        // sprintf(teststr2,"%x",deviceid); 
....................        // writeString(0, 0, teststr2); 
....................      //   delay_ms(100); 
....................          
....................  //  } 
....................    
....................     
....................    while(1)    
....................    { 
....................     deviceid = FindRJ45Device(0x01,deviceidreturn); 
09038:  MOVLW  01
0903A:  MOVWF  x70
0903C:  MOVFF  769,771
09040:  MOVLB  0
09042:  GOTO   3A52
09046:  MOVFF  01,768
....................     deviceidreturn = deviceid; 
0904A:  MOVFF  768,769
....................     if (deviceid==0x22) 
0904E:  MOVLB  7
09050:  MOVF   x68,W
09052:  SUBLW  22
09054:  BNZ   9066
....................     {  
....................        deviceid = TestRHTemp(); 
09056:  MOVLB  0
09058:  GOTO   437E
0905C:  MOVFF  01,768
....................        deviceidreturn = deviceid; 
09060:  MOVFF  768,769
09064:  MOVLB  7
....................     } 
....................      
....................     if (deviceid==0x23) 
09066:  MOVF   x68,W
09068:  SUBLW  23
0906A:  BNZ   907C
....................     { 
....................        deviceid = TestPARchip(); 
0906C:  MOVLB  0
0906E:  GOTO   4D1C
09072:  MOVFF  01,768
....................        deviceidreturn = deviceid; 
09076:  MOVFF  768,769
0907A:  MOVLB  7
....................     } 
....................      
....................     if (deviceid==0x24)  // this is for Analog DO and NH4 
0907C:  MOVF   x68,W
0907E:  SUBLW  24
09080:  BNZ   9092
....................     { 
....................        deviceid = TestAnalogDONHFourBoard(); 
09082:  MOVLB  0
09084:  GOTO   7F04
09088:  MOVFF  01,768
....................        deviceidreturn = deviceid; 
0908C:  MOVFF  768,769
09090:  MOVLB  7
....................     } 
....................     if (deviceid==0x25)  // this is for Analog DO and NH4 
09092:  MOVF   x68,W
09094:  SUBLW  25
09096:  BNZ   90A8
....................     { 
....................        deviceid = TestDigitalDONHFourBoard(); 
09098:  MOVLB  0
0909A:  GOTO   80B4
0909E:  MOVFF  01,768
....................        deviceidreturn = deviceid; 
090A2:  MOVFF  768,769
090A6:  MOVLB  7
....................     } 
....................     if (deviceid==0x26)  // this is for Analog DO and NH4 
090A8:  MOVF   x68,W
090AA:  SUBLW  26
090AC:  BNZ   90BE
....................     { 
....................        deviceid = TestCO2Board(); 
090AE:  MOVLB  0
090B0:  GOTO   848E
090B4:  MOVFF  01,768
....................        deviceidreturn = deviceid; 
090B8:  MOVFF  768,769
090BC:  MOVLB  7
....................     } 
....................     BTTestEvent(); // check for the data coming back to display    
090BE:  MOVLB  0
090C0:  CALL   77B4
....................     BTTestEvent(); // check for the data coming back to display  
090C4:  CALL   77B4
....................     BTTestEvent(); // check for the data coming back to display    
090C8:  CALL   77B4
....................     BTTestEvent(); // check for the data coming back to display  
090CC:  CALL   77B4
....................     BTTestEvent(); // check for the data coming back to display    
090D0:  CALL   77B4
....................     BTTestEvent(); // check for the data coming back to display  
090D4:  CALL   77B4
....................      
....................      
....................     //************************************************************************** 
....................     // Update Feb 11, 2017 
....................     // This section takes the global flag for startupdate and sends the lateset varaibel configuration to the remote devie. 
....................     // There needs to be an added check the remote device is attached. 
....................     //  It needs to be read back and confirmed after sending it to the remote device, saving it in EEPROM, re-read from EEPROM and sent back to this host. 
....................     //  1  Send data to remote device 
....................     //  2  Save varaible data in remote EEPROM device 
....................     //  3  re-read the data from the EEPROM in the remote device 
....................     //  4  send it back to this host 
....................     //  5  Compare it with the orginal data 
....................     //  6  Send an error if there is a difference. 
....................     //************************************************************************** 
....................         if (startupdate) 
090D8:  MOVLB  2
090DA:  MOVF   x28,F
090DC:  BZ    9112
....................         { 
....................           //  while(1) 
....................          //   { 
....................                 stuffit = 1069; 
090DE:  MOVLW  04
090E0:  MOVWF  x27
090E2:  MOVLW  2D
090E4:  MOVWF  x26
....................                 startupdate = 0;  // this sets the flag to do an update to the remote unit when all data polling is completed. 
090E6:  CLRF   x28
....................                 fprintf(BT,"Sending Updated Configurations\n\r"); 
090E8:  MOVLW  AC
090EA:  MOVWF  FF6
090EC:  MOVLW  11
090EE:  MOVWF  FF7
090F0:  MOVLB  0
090F2:  CALL   1C32
....................                 sendConfigData(0x01, 0x03);   //device 1 or the top connector 
090F6:  MOVLW  01
090F8:  MOVLB  7
090FA:  MOVWF  x70
090FC:  MOVLW  03
090FE:  MOVWF  x71
09100:  MOVLB  0
09102:  GOTO   85FA
....................                 fprintf(BT,"Update Completed\r\n"); 
09106:  MOVLW  CE
09108:  MOVWF  FF6
0910A:  MOVLW  11
0910C:  MOVWF  FF7
0910E:  CALL   1C32
....................          //   } 
....................         } 
09112:  MOVLB  7
09114:  BRA    9038
....................      
....................    } 
....................      
.................... } 
09116:  BRA    9116

Configuration Fuses:
   Word  1: E200   HSH NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 3C19   NOPUT NOBROWNOUT BORV19 NOWDT WDT32768
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0000   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
