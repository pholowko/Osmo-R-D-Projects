CCS PCD C Compiler, Version 5.071, 35992               06-Apr-17 06:52

               Filename:   G:\OsmobotDigitalSensorBoard\OsmobotDigitalSensorBoard.X\build\default\debug\_ext\1472\main.lst

               ROM used:   8326 bytes (37%)
                           Largest free fragment is 14202
               RAM used:   1550 (79%) at main() level
                           1946 (99%) worst case
               Stack used: 84 locations (44 in main + 40 for interrupts)
               Stack size: 176

*
0000:  GOTO    1B74
*
0076:  DATA    38,02,00
.................... // Digital DO and NH4 Probes -  Main.c file                                                                                                                                                                                                                                                        // DO and NH4 Patch Sensor Main.c file 
.................... #include <24FV32KA302.h> 
.................... //////////// Standard Header file for the PIC24FV32KA302 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FV32KA302 
*
0466:  MOV     W5,[W15++]
0468:  MOV     #C,W5
046A:  REPEAT  #3
046C:  MOV     [W5++],[W15++]
046E:  MUL.UU  W0,W2,W4
0470:  BTSS    W3.F
0472:  BRA     478
0474:  MUL.SS  W0,W3,W6
0476:  BRA     47A
0478:  MUL.UU  W0,W3,W6
047A:  BCLR.B  42.0
047C:  ADD     W6,W5,W5
047E:  ADDC    W7,#0,W8
0480:  BTSS    W1.F
0482:  BRA     488
0484:  MUL.SS  W1,W2,W6
0486:  BRA     48A
0488:  MUL.UU  W1,W2,W6
048A:  ADDC    W6,W5,W5
048C:  ADDC    W7,W8,W8
048E:  ADDC    #0,W9
0490:  MUL.SS  W1,W3,W6
0492:  ADDC    W6,W8,W8
0494:  ADDC    W9,W7,W7
0496:  MOV     W7,W3
0498:  MOV     W8,W2
049A:  MOV     W5,W1
049C:  MOV     W4,W0
049E:  MOV     #12,W5
04A0:  REPEAT  #3
04A2:  MOV     [--W15],[W5--]
04A4:  MOV     [--W15],W5
04A6:  RETURN  
04A8:  MOV     #FE00,W1
04AA:  ADD     W1,W3,W3
04AC:  MOV     #7F,W1
04AE:  ADDC    W1,#0,W1
04B0:  MOV     W1,32
04B2:  BCLR    W5.0
04B4:  CP0     W5
04B6:  BRA     Z,4BE
04B8:  TBLRDL  [W3++],[W4++]
04BA:  DEC2    W5,W5
04BC:  BRA     NZ,4B6
04BE:  RETURN  
*
050C:  MOV     W0,W2
050E:  MOV     W1,W3
0510:  MOV.B   W1L,W0L
0512:  SWAP    W0
0514:  BSET    W0.F
0516:  RLC     W1,W1
0518:  SWAP    W1
051A:  ZE      W1,W1
051C:  MOV     #8E,W4
051E:  SUB.B   W4L,W1L,W1L
0520:  BRA     Z,52E
0522:  CP0     W0
0524:  BRA     Z,52E
0526:  BCLR.B  42.0
0528:  RRC     W0,W0
052A:  DEC     W1,W1
052C:  BRA     NZ,522
052E:  BTSS    W3.F
0530:  BRA     536
0532:  NEG     W0,W0
0534:  BRA     536
0536:  RETURN  
*
0A40:  MOV     W5,[W15++]
0A42:  MOV     #C,W5
0A44:  REPEAT  #3
0A46:  MOV     [W5++],[W15++]
0A48:  MUL.UU  W0,W2,W4
0A4A:  MUL.UU  W0,W3,W6
0A4C:  BCLR.B  42.0
0A4E:  ADD     W6,W5,W5
0A50:  ADDC    W7,#0,W8
0A52:  MUL.UU  W1,W2,W6
0A54:  ADDC    W6,W5,W5
0A56:  ADDC    W7,W8,W8
0A58:  MUL.UU  W1,W3,W6
0A5A:  ADD     W6,W8,W8
0A5C:  ADDC    #0,W7
0A5E:  MOV     W7,W3
0A60:  MOV     W8,W2
0A62:  MOV     W5,W1
0A64:  MOV     W4,W0
0A66:  MOV     #12,W5
0A68:  REPEAT  #3
0A6A:  MOV     [--W15],[W5--]
0A6C:  MOV     [--W15],W5
0A6E:  RETURN  
*
0BE4:  MOV     W5,[W15++]
0BE6:  MOV     W6,[W15++]
0BE8:  MOV     #8E,W1
0BEA:  BCLR    W6.0
0BEC:  BTSS    W0.F
0BEE:  BRA     BF6
0BF0:  BSET    W6.0
0BF2:  NEG     W0,W0
0BF4:  BRA     BF6
0BF6:  CP0     W0
0BF8:  BRA     Z,C22
0BFA:  BTSC    W0.F
0BFC:  BRA     C06
0BFE:  BCLR.B  42.0
0C00:  RLC     W0,W0
0C02:  DEC     W1,W1
0C04:  BRA     BFA
0C06:  SWAP    W1
0C08:  BCLR.B  42.0
0C0A:  RRC     W1,W1
0C0C:  BCLR    W0.F
0C0E:  SWAP    W0
0C10:  XOR.B   W0L,W1L,W1L
0C12:  AND.B   #0,W0L
0C14:  BTSC    W6.0
0C16:  BSET    W1.F
0C18:  BRA     C28
0C1A:  MOV.B   W1L,W0L
0C1C:  BSET    W1.7
0C1E:  AND.B   #0,W1L
0C20:  BRA     C28
0C22:  CLR     W0
0C24:  CLR     W1
0C26:  BRA     C28
0C28:  MOV     [--W15],W6
0C2A:  MOV     [--W15],W5
0C2C:  RETURN  
0C2E:  MOV     W5,[W15++]
0C30:  MOV     #C,W5
0C32:  REPEAT  #4
0C34:  MOV     [W5++],[W15++]
0C36:  MOV     W0,W4
0C38:  MOV     W1,W5
0C3A:  MOV     W3,W7
0C3C:  MOV     W2,W6
0C3E:  BCLR.B  42.0
0C40:  BCLR.B  42.1
0C42:  RLC     W1,W1
0C44:  SWAP    W1
0C46:  AND     #FF,W1
0C48:  CP0     W1
0C4A:  BRA     Z,CE2
0C4C:  BCLR.B  42.0
0C4E:  BCLR.B  42.1
0C50:  RLC     W3,W3
0C52:  SWAP    W3
0C54:  AND     #FF,W3
0C56:  CP0     W3
0C58:  BRA     Z,CE2
0C5A:  ZE      W0,W0
0C5C:  ADD.B   W3L,W1L,W0L
0C5E:  BRA     C,C68
0C60:  SUB     #7F,W0
0C62:  BRA     Z,CE2
0C64:  BRA     NC,CE2
0C66:  BRA     C6C
0C68:  ADD.B   #81,W0L
0C6A:  BRA     C,CE2
0C6C:  XOR     W5,W7,W10
0C6E:  BCLR.B  42.0
0C70:  BCLR.B  42.1
0C72:  AND     #FF,W5
0C74:  BSET    W5.7
0C76:  BCLR.B  42.0
0C78:  AND     #FF,W7
0C7A:  BSET    W7.7
0C7C:  MUL.UU  W4,W6,W2
0C7E:  MUL.UU  W5,W6,W8
0C80:  ADDC    W8,W3,W3
0C82:  MOV     W9,W1
0C84:  BTSC.B  42.0
0C86:  INC     W1,W1
0C88:  BCLR.B  42.0
0C8A:  MUL.UU  W7,W4,W8
0C8C:  ADDC    W8,W3,W3
0C8E:  ADDC    W9,W1,W1
0C90:  MUL.UU  W5,W7,W8
0C92:  ADDC    W8,W1,W1
0C94:  INC     W0,W0
0C96:  CP0     W1
0C98:  BTSC.B  42.1
0C9A:  BRA     C9E
0C9C:  BRA     CA4
0C9E:  CP0     W3
0CA0:  BTSC.B  42.1
0CA2:  BRA     CAE
0CA4:  BTSC    W1.F
0CA6:  BRA     CAE
0CA8:  RLC     W3,W3
0CAA:  RLC     W1,W1
0CAC:  DEC     W0,W0
0CAE:  MOV     W1,W2
0CB0:  BCLR.B  42.0
0CB2:  BTSS    W3.7
0CB4:  BRA     CC8
0CB6:  MOV     #FF00,W7
0CB8:  AND     W3,W7,W3
0CBA:  ADD     #100,W3
0CBC:  ADDC    W2,#0,W2
0CBE:  CP0     W2
0CC0:  BRA     NZ,CC8
0CC2:  CP0     W3
0CC4:  BRA     NZ,CC8
0CC6:  INC     W0,W0
0CC8:  SWAP    W0
0CCA:  BCLR.B  42.0
0CCC:  BCLR.B  42.1
0CCE:  RRC     W0,W1
0CD0:  BTSC    W10.F
0CD2:  BSET    W1.F
0CD4:  BCLR    W2.F
0CD6:  SWAP    W2
0CD8:  XOR.B   W2L,W1L,W1L
0CDA:  SWAP    W3
0CDC:  MOV.B   W3L,W2L
0CDE:  MOV     W2,W0
0CE0:  BRA     CE8
0CE2:  MOV     #0,W0
0CE4:  MOV     #0,W1
0CE6:  BRA     CE8
0CE8:  MOV     #14,W5
0CEA:  REPEAT  #4
0CEC:  MOV     [--W15],[W5--]
0CEE:  MOV     [--W15],W5
0CF0:  RETURN  
0CF2:  MOV     W5,[W15++]
0CF4:  MOV     #C,W5
0CF6:  REPEAT  #4
0CF8:  MOV     [W5++],[W15++]
0CFA:  CLR     W9
0CFC:  XOR     W1,W3,W9
0CFE:  MOV     W1,W6
0D00:  MOV     W0,W5
0D02:  MOV     W3,W8
0D04:  MOV     W2,W7
0D06:  RLC     W1,W1
0D08:  SWAP    W1
0D0A:  ZE      W1,W1
0D0C:  CP0     W1
0D0E:  BRA     Z,DAC
0D10:  RLC     W3,W3
0D12:  SWAP    W3
0D14:  ZE      W3,W3
0D16:  CP0     W3
0D18:  BRA     Z,DAC
0D1A:  CLR     W0
0D1C:  SUB.B   W1L,W3L,W0L
0D1E:  BRA     NC,D26
0D20:  ADD.B   #7F,W0L
0D22:  BRA     C,DAC
0D24:  BRA     D2C
0D26:  SUB.B   #81,W0L
0D28:  BRA     NC,DAC
0D2A:  BRA     Z,DAC
0D2C:  MOV     W5,W1
0D2E:  MOV     W6,W2
0D30:  BSET    W2.7
0D32:  AND     #FF,W2
0D34:  AND     #FF,W8
0D36:  BSET    W8.7
0D38:  MOV     #19,W10
0D3A:  CLR     W3
0D3C:  CLR     W4
0D3E:  SUB     W1,W7,W1
0D40:  SUBB    W2,W8,W2
0D42:  BRA     N,D48
0D44:  BRA     C,D4E
0D46:  BRA     NZ,D50
0D48:  ADD     W1,W7,W1
0D4A:  ADDC    W2,W8,W2
0D4C:  BRA     D50
0D4E:  BSET    W4.0
0D50:  DEC     W10,W10
0D52:  BRA     Z,D62
0D54:  BCLR.B  42.0
0D56:  RLC     W1,W1
0D58:  RLC     W2,W2
0D5A:  BCLR.B  42.0
0D5C:  RLC     W4,W4
0D5E:  RLC     W3,W3
0D60:  BRA     D3E
0D62:  CLR     W10
0D64:  BTSC    W3.8
0D66:  BRA     D6A
0D68:  BRA     D76
0D6A:  BCLR.B  42.0
0D6C:  RRC     W3,W3
0D6E:  BCLR    W3.7
0D70:  RRC     W4,W4
0D72:  RLC     W10,W10
0D74:  BRA     D7A
0D76:  DEC     W0,W0
0D78:  BRA     Z,DAC
0D7A:  BTSC    W10.F
0D7C:  BRA     NC,D88
0D7E:  RLC     W1,W1
0D80:  RLC     W2,W2
0D82:  SUB     W1,W7,W1
0D84:  SUBB    W2,W8,W2
0D86:  BRA     NC,D9A
0D88:  INC     W4,W4
0D8A:  BRA     NZ,D9A
0D8C:  INC     W3,W3
0D8E:  BRA     NZ,D9A
0D90:  INC     W0,W0
0D92:  BRA     Z,DAC
0D94:  BRA     D9A
0D96:  DEC     W0,W0
0D98:  BRA     Z,DAC
0D9A:  SWAP    W0
0D9C:  RRC     W0,W1
0D9E:  BSET    W1.F
0DA0:  BTSS    W9.F
0DA2:  BCLR    W1.F
0DA4:  BCLR    W3.7
0DA6:  XOR.B   W3L,W1L,W1L
0DA8:  MOV     W4,W0
0DAA:  BRA     DB2
0DAC:  MOV     #0,W0
0DAE:  MOV     #0,W1
0DB0:  BRA     DB2
0DB2:  MOV     #14,W5
0DB4:  REPEAT  #4
0DB6:  MOV     [--W15],[W5--]
0DB8:  MOV     [--W15],W5
0DBA:  RETURN  
0DBC:  MOV     W5,[W15++]
0DBE:  MOV     #C,W5
0DC0:  REPEAT  #3
0DC2:  MOV     [W5++],[W15++]
0DC4:  CLR     W9
0DC6:  MOV     #8000,W8
0DC8:  BTSC.B  43.0
0DCA:  XOR     W8,W3,W3
0DCC:  CP0     W0
0DCE:  BRA     NZ,DD6
0DD0:  MOV     #7FFF,W10
0DD2:  AND     W1,W10,W10
0DD4:  BTSS.B  42.1
0DD6:  MOV     W1,W10
0DD8:  XOR     W3,W10,W11
0DDA:  MOV     W1,W6
0DDC:  MOV     W3,W7
0DDE:  MOV     W3,W12
0DE0:  BCLR.B  42.1
0DE2:  BCLR.B  42.0
0DE4:  RLC     W6,W6
0DE6:  SWAP    W6
0DE8:  AND     #FF,W6
0DEA:  CP0     W6
0DEC:  BRA     Z,F30
0DEE:  BCLR.B  42.1
0DF0:  BCLR.B  42.0
0DF2:  RLC     W7,W7
0DF4:  SWAP    W7
0DF6:  AND     #FF,W7
0DF8:  CP0     W7
0DFA:  BRA     Z,F3A
0DFC:  BCLR.B  42.1
0DFE:  BCLR.B  42.0
0E00:  CP      W7,W6
0E02:  BRA     Z,F3C
0E04:  BRA     N,F4C
0E06:  BCLR    W9.0
0E08:  BSET    W9.1
0E0A:  SUB     W7,W6,W8
0E0C:  MOV     W7,W6
0E0E:  AND     #FF,W1
0E10:  BSET    W1.7
0E12:  AND     #FF,W3
0E14:  BSET    W3.7
0E16:  MOV     #28,W7
0E18:  CP      W7,W8
0E1A:  BRA     N,E3E
0E1C:  BCLR.B  42.1
0E1E:  BCLR.B  42.0
0E20:  RRC     W1,W1
0E22:  RRC     W0,W0
0E24:  DEC     W8,W8
0E26:  BRA     NZ,E1C
0E28:  BRA     E44
0E2A:  MOV     #28,W7
0E2C:  CP      W7,W8
0E2E:  BRA     N,E42
0E30:  BCLR.B  42.1
0E32:  BCLR.B  42.0
0E34:  RRC     W3,W3
0E36:  RRC     W2,W2
0E38:  DEC     W8,W8
0E3A:  BRA     NZ,E30
0E3C:  BRA     E5C
0E3E:  MOV     W2,W0
0E40:  MOV     W3,W1
0E42:  BRA     ECA
0E44:  BTSS    W11.F
0E46:  BRA     E6A
0E48:  BTSC    W9.4
0E4A:  MOV     W12,W11
0E4C:  NEG     W0,W0
0E4E:  BRA     Z,E54
0E50:  COM.B   W1L,W1L
0E52:  BRA     E56
0E54:  NEG     W1,W1
0E56:  BTSC    W9.4
0E58:  BRA     EB0
0E5A:  BRA     E6A
0E5C:  BTSS    W11.F
0E5E:  BRA     E6A
0E60:  NEG     W2,W2
0E62:  BRA     Z,E68
0E64:  COM.B   W3L,W3L
0E66:  BRA     E6A
0E68:  NEG     W3,W3
0E6A:  AND     #FF,W5
0E6C:  BCLR.B  42.1
0E6E:  BCLR.B  42.0
0E70:  ADD     W0,W2,W0
0E72:  ADDC.B  W1L,W3L,W1L
0E74:  BTSC.B  42.0
0E76:  BSET    W9.3
0E78:  BTSC    W9.0
0E7A:  BRA     E8E
0E7C:  BTSC    W9.1
0E7E:  BRA     E82
0E80:  BRA     E98
0E82:  BTSC    W11.F
0E84:  BRA     EB0
0E86:  BTSC    W9.3
0E88:  BRA     EDC
0E8A:  BSET    W9.6
0E8C:  BRA     ECA
0E8E:  BTSC    W11.F
0E90:  BRA     EB0
0E92:  BTSC    W9.3
0E94:  BRA     EDC
0E96:  BRA     ECA
0E98:  BCLR    W9.2
0E9A:  BTSC    W11.F
0E9C:  BRA     EA6
0E9E:  MOV     W10,W11
0EA0:  BTSC    W9.3
0EA2:  BRA     EDC
0EA4:  BRA     F12
0EA6:  BSET    W9.4
0EA8:  XOR.B   #80,W1L
0EAA:  BTSC    W1.7
0EAC:  BRA     E48
0EAE:  MOV     W10,W11
0EB0:  AND     #FF,W1
0EB2:  IOR      W0,  W1,W7
0EB4:  BRA     Z,ECA
0EB6:  BTSC    W1.7
0EB8:  BRA     ECA
0EBA:  BCLR.B  42.1
0EBC:  BCLR.B  42.0
0EBE:  RLC     W0,W0
0EC0:  RLC     W1,W1
0EC2:  DEC     W6,W6
0EC4:  BTSC.B  42.1
0EC6:  BRA     F2A
0EC8:  BRA     EB6
0ECA:  BTSC    W9.0
0ECC:  MOV     W10,W11
0ECE:  BTSC    W9.1
0ED0:  MOV     W12,W11
0ED2:  BTSS    W9.5
0ED4:  BRA     F0A
0ED6:  BTSC    W10.F
0ED8:  BSET    W0.8
0EDA:  BRA     F12
0EDC:  BSET.B  42.0
0EDE:  RRC.B   W1L,W1L
0EE0:  RRC     W0,W0
0EE2:  BTSC.B  42.0
0EE4:  BSET    W9.5
0EE6:  INC     W6,W6
0EE8:  BRA     Z,F2A
0EEA:  BTSS    W9.5
0EEC:  BRA     EFE
0EEE:  INC     W0,W0
0EF0:  BRA     NZ,EFE
0EF2:  INC.B   W1L,W1L
0EF4:  BRA     NZ,EFE
0EF6:  RRC.B   W1L,W1L
0EF8:  RRC     W0,W0
0EFA:  INC     W6,W6
0EFC:  BRA     Z,F2A
0EFE:  BTSC    W9.0
0F00:  MOV     W10,W11
0F02:  BTSC    W9.1
0F04:  MOV     W12,W11
0F06:  BTSC.B  42.1
0F08:  BRA     F2A
0F0A:  BTSC    W9.6
0F0C:  MOV     W10,W11
0F0E:  BTSC    W9.7
0F10:  MOV     W12,W11
0F12:  IOR      W0,  W1,W2
0F14:  BRA     Z,F5C
0F16:  BCLR    W1.7
0F18:  SWAP    W6
0F1A:  BCLR.B  42.1
0F1C:  BCLR.B  42.0
0F1E:  RRC     W6,W6
0F20:  XOR     W6,W1,W1
0F22:  BSET    W1.F
0F24:  BTSS    W11.F
0F26:  BCLR    W1.F
0F28:  BRA     F5C
0F2A:  MOV     #0,W0
0F2C:  MOV     #0,W1
0F2E:  BRA     F5C
0F30:  BTSC    W10.F
0F32:  XOR     W8,W3,W3
0F34:  MOV     W2,W0
0F36:  MOV     W3,W1
0F38:  BRA     F5C
0F3A:  BRA     F5C
0F3C:  AND     #FF,W3
0F3E:  BSET    W3.7
0F40:  AND     #FF,W1
0F42:  BSET    W1.7
0F44:  BTSC    W11.F
0F46:  BCLR    W3.7
0F48:  BSET    W9.2
0F4A:  BRA     E5C
0F4C:  SUB     W6,W7,W8
0F4E:  AND     #FF,W1
0F50:  BSET    W1.7
0F52:  AND     #FF,W3
0F54:  BSET    W3.7
0F56:  BCLR    W9.1
0F58:  BSET    W9.0
0F5A:  BRA     E2A
0F5C:  MOV     #12,W5
0F5E:  REPEAT  #3
0F60:  MOV     [--W15],[W5--]
0F62:  MOV     [--W15],W5
0F64:  RETURN  
0F66:  MOV     W5,[W15++]
0F68:  MOV     W6,[W15++]
0F6A:  MOV     W7,[W15++]
0F6C:  XOR     W1,W3,W4
0F6E:  BTSS    W4.F
0F70:  BRA     F7E
0F72:  BCLR.B  42.0
0F74:  BCLR.B  42.1
0F76:  BTSS    W1.F
0F78:  BRA     FC6
0F7A:  BSET.B  42.0
0F7C:  BRA     FC6
0F7E:  MOV     W1,W4
0F80:  MOV     W0,W5
0F82:  MOV     W3,W6
0F84:  MOV     W2,W7
0F86:  RLC     W1,W1
0F88:  SWAP    W1
0F8A:  RLC     W3,W3
0F8C:  SWAP    W3
0F8E:  SUB.B   W3L,W1L,W1L
0F90:  BRA     Z,F9C
0F92:  BTSS    W4.F
0F94:  BRA     FC6
0F96:  MOV     #1,W0
0F98:  XOR.B   42
0F9A:  BRA     FC6
0F9C:  MOV.B   W4L,W1L
0F9E:  MOV.B   W6L,W3L
0FA0:  BCLR    W1.7
0FA2:  BCLR    W3.7
0FA4:  SUB.B   W3L,W1L,W1L
0FA6:  BRA     Z,FB2
0FA8:  BTSS    W4.F
0FAA:  BRA     FC6
0FAC:  MOV     #1,W0
0FAE:  XOR.B   42
0FB0:  BRA     FC6
0FB2:  SUB     W7,W5,W1
0FB4:  BRA     Z,FC0
0FB6:  BTSS    W4.F
0FB8:  BRA     FC6
0FBA:  MOV     #1,W0
0FBC:  XOR.B   42
0FBE:  BRA     FC6
0FC0:  BCLR.B  42.0
0FC2:  BRA     FC6
0FC4:  BRA     FC6
0FC6:  MOV     [--W15],W7
0FC8:  MOV     [--W15],W6
0FCA:  MOV     [--W15],W5
0FCC:  RETURN  
*
1784:  MOV     W5,[W15++]
1786:  MOV     W6,[W15++]
1788:  MOV     W0,W4
178A:  MOV     W1,W5
178C:  CLR     W0
178E:  CLR     W1
1790:  BCLR    W6.0
1792:  BTSS    W5.F
1794:  BRA     17A2
1796:  BSET    W6.0
1798:  NEG     W4,W4
179A:  BRA     Z,17A0
179C:  COM     W5,W5
179E:  BRA     17A2
17A0:  NEG     W5,W5
17A2:  IOR      W4,  W5,W3
17A4:  BRA     Z,17CC
17A6:  CLR     W2
17A8:  MOV     #B6,W1
17AA:  BTSC    W2.7
17AC:  BRA     17BC
17AE:  BCLR.B  42.0
17B0:  RLC     W4,W4
17B2:  RLC     W5,W5
17B4:  RLC     W0,W0
17B6:  RLC     W2,W2
17B8:  DEC     W1,W1
17BA:  BRA     NZ,17AA
17BC:  SWAP    W1
17BE:  BCLR.B  42.0
17C0:  RRC     W1,W1
17C2:  BCLR    W1.F
17C4:  BCLR    W2.7
17C6:  XOR.B   W2L,W1L,W1L
17C8:  BTSC    W6.0
17CA:  BSET    W1.F
17CC:  MOV     [--W15],W6
17CE:  MOV     [--W15],W5
17D0:  RETURN  
17D2:  MOV     W5,[W15++]
17D4:  MOV     W1,W5
17D6:  MOV     W0,W2
17D8:  MOV     #B6,W4
17DA:  RLC     W1,W1
17DC:  SWAP    W1
17DE:  AND     #FF,W1
17E0:  SUB.B   W4L,W1L,W4L
17E2:  MOV.B   W5L,W3L
17E4:  BSET    W3.7
17E6:  AND     #FF,W3
17E8:  CLR     W0
17EA:  CLR     W1
17EC:  CP      W4,#18
17EE:  BRA     N,180E
17F0:  BCLR.B  42.0
17F2:  RRC     W3,W3
17F4:  RRC     W2,W2
17F6:  RRC     W1,W1
17F8:  RRC     W0,W0
17FA:  DEC     W4,W4
17FC:  BRA     NZ,17F0
17FE:  BTSS    W5.F
1800:  BRA     180E
1802:  NEG     W0,W0
1804:  BRA     Z,180A
1806:  COM     W1,W1
1808:  BRA     180E
180A:  NEG     W1,W1
180C:  BRA     180E
180E:  MOV     [--W15],W5
1810:  RETURN  
....................  
.................... #list 
....................  
.................... #DEVICE ICD=1 
.................... #device ADC=10 
.................... #define PIC24 1 
.................... #device PASS_STRINGS = IN_RAM 
.................... #device PSV=16 
.................... #device CONST=READ_ONLY 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
*
0FCE:  MOV     W5,[W15++]
0FD0:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
0FD2:  PUSH    EAC
0FD4:  POP     EB0
0FD6:  PUSH    EAE
0FD8:  POP     EB2
....................  
....................    if (y != 1.0) 
0FDA:  MOV     EB0,W0
0FDC:  MOV     EB2,W1
0FDE:  MOV     #0,W2
0FE0:  MOV     #3F80,W3
0FE2:  CALL    F66
0FE6:  BRA     Z,114C
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
0FE8:  MOV     #EB3,W0
0FEA:  MOV     W0,[W15++]
0FEC:  MOV.B   [W0],W0L
0FEE:  MOV.B   W0L,EA9
0FF0:  MOV     [--W15],W0
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
0FF2:  MOV     #EB3,W5
0FF4:  MOV.B   #3F,W0L
0FF6:  MOV.B   W0L,[W5]
....................    data1 = *(((unsigned int8 *)(&y))+2); 
0FF8:  MOV     #EB2,W0
0FFA:  MOV     EA8,W4
0FFC:  MOV.B   [W0+#0],W4L
0FFE:  MOV     W4,EA8
....................    bit_clear(data1,7); 
1000:  BCLR.B  EA8.7
....................    *(((unsigned int8 *)(&y))+2) = data1; 
1002:  MOV     #EB2,W5
1004:  MOV     EA8,W0
1006:  MOV.B   W0L,[W5+#0]
....................    if(bit_test(data2,7)) 
1008:  BTSS.B  EA9.7
100A:  BRA     1018
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
100C:  MOV     #EB0,W5
100E:  ADD     W5,#3,W0
1010:  MOV     W0,W5
1012:  MOV.B   [W5],W4L
1014:  IOR.B   #80,W4L
1016:  MOV.B   W4L,[W5+#0]
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
1018:  BSET.B  43.0
101A:  MOV     EB0,W0
101C:  MOV     EB2,W1
101E:  MOV     #0,W2
1020:  MOV     #3F80,W3
1022:  CALL    DBC
1026:  MOV     W0,W5
1028:  MOV     W1,W6
102A:  BCLR.B  43.0
102C:  MOV     EB0,W0
102E:  MOV     EB2,W1
1030:  MOV     #0,W2
1032:  MOV     #3F80,W3
1034:  CALL    DBC
1038:  MOV     W0,W2
103A:  MOV     W1,W3
103C:  MOV     W5,W0
103E:  MOV     W6,W1
1040:  CALL    CF2
1044:  MOV     W0,EB0
1046:  MOV     W1,EB2
....................  
....................       y2=y*y; 
1048:  MOV     EB0,W0
104A:  MOV     EB2,W1
104C:  MOV     EB0,W2
104E:  MOV     EB2,W3
1050:  CALL    C2E
1054:  MOV     W0,EBC
1056:  MOV     W1,EBE
....................  
....................       res = pl[0]*y2 + pl[1]; 
1058:  MOV     8D8,W0
105A:  MOV     8DA,W1
105C:  MOV     EBC,W2
105E:  MOV     EBE,W3
1060:  CALL    C2E
1064:  MOV     W0,W5
1066:  MOV     W1,W6
1068:  BCLR.B  43.0
106A:  MOV     W5,W0
106C:  MOV     W6,W1
106E:  MOV     8DC,W2
1070:  MOV     8DE,W3
1072:  CALL    DBC
1076:  MOV     W0,EB4
1078:  MOV     W1,EB6
....................  
....................       r = ql[0]*y2 + ql[1]; 
107A:  MOV     8E8,W0
107C:  MOV     8EA,W1
107E:  MOV     EBC,W2
1080:  MOV     EBE,W3
1082:  CALL    C2E
1086:  MOV     W0,W5
1088:  MOV     W1,W6
108A:  BCLR.B  43.0
108C:  MOV     W5,W0
108E:  MOV     W6,W1
1090:  MOV     8EC,W2
1092:  MOV     8EE,W3
1094:  CALL    DBC
1098:  MOV     W0,EB8
109A:  MOV     W1,EBA
....................       r = r*y2 + 1.0; 
109C:  MOV     EB8,W0
109E:  MOV     EBA,W1
10A0:  MOV     EBC,W2
10A2:  MOV     EBE,W3
10A4:  CALL    C2E
10A8:  MOV     W0,W5
10AA:  MOV     W1,W6
10AC:  BCLR.B  43.0
10AE:  MOV     W5,W0
10B0:  MOV     W6,W1
10B2:  MOV     #0,W2
10B4:  MOV     #3F80,W3
10B6:  CALL    DBC
10BA:  MOV     W0,EB8
10BC:  MOV     W1,EBA
....................  
....................       res = y*res/r; 
10BE:  MOV     EB0,W0
10C0:  MOV     EB2,W1
10C2:  MOV     EB4,W2
10C4:  MOV     EB6,W3
10C6:  CALL    C2E
10CA:  MOV     W0,W5
10CC:  MOV     W1,W6
10CE:  MOV     W5,W0
10D0:  MOV     W6,W1
10D2:  MOV     EB8,W2
10D4:  MOV     EBA,W3
10D6:  CALL    CF2
10DA:  MOV     W0,EB4
10DC:  MOV     W1,EB6
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
10DE:  MOV     #EAF,W0
10E0:  MOV     EA8,W4
10E2:  MOV.B   [W0+#0],W4L
10E4:  MOV     W4,EA8
....................     rotate_left(&data1,1); 
10E6:  MOV     #EA8,W1
10E8:  RLNC.B  [W1],[W1++]
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
10EA:  MOV     #EAE,W0
10EC:  MOV     W0,[W15++]
10EE:  MOV.B   [W0],W0L
10F0:  MOV.B   W0L,EA9
10F2:  MOV     [--W15],W0
....................     if(bit_test (data2,7)) 
10F4:  BTSS.B  EA9.7
10F6:  BRA     10FA
....................       bit_set(data1,0); 
10F8:  BSET.B  EA8.0
....................     n = data1 - 0x7E; 
10FA:  MOV     EA8,W4
10FC:  CLR.B   9
10FE:  MOV     #7E,W3
1100:  SUB     W4,W3,W0
1102:  MOV.B   W0L,EAA
.................... #endif 
....................  
....................       if (n<0)  
1104:  MOV.B   EAA,W0L
1106:  SE      W0,W0
1108:  CP      W0,#0
110A:  BRA     GE,1120
....................          r = -(float32)-n; 
110C:  MOV     #0,W4
110E:  MOV     EAA,W3
1110:  SUB.B   W4L,W3L,W0L
1112:  SE      W0,W0
1114:  CALL    BE4
1118:  MOV     W0,EB8
111A:  MOV     W1,EBA
111C:  BTG.B   EBB.7
111E:  BRA     112C
....................       else 
....................          r = (float32)n; 
1120:  MOV.B   EAA,W0L
1122:  SE      W0,W0
1124:  CALL    BE4
1128:  MOV     W0,EB8
112A:  MOV     W1,EBA
....................  
....................       res += r*LN2; 
112C:  MOV     EB8,W0
112E:  MOV     EBA,W1
1130:  MOV     #7218,W2
1132:  MOV     #3F31,W3
1134:  CALL    C2E
1138:  BCLR.B  43.0
113A:  MOV     W0,W2
113C:  MOV     W1,W3
113E:  MOV     EB4,W0
1140:  MOV     EB6,W1
1142:  CALL    DBC
1146:  MOV     W0,EB4
1148:  MOV     W1,EB6
....................    } 
114A:  BRA     1150
....................  
....................    else 
....................       res = 0.0; 
114C:  CLR     EB4
114E:  CLR     EB6
....................  
....................    return(res); 
1150:  MOV     EB4,W0
1152:  MOV     EB6,W1
1154:  MOV     [--W15],W6
1156:  MOV     [--W15],W5
1158:  RETURN  
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define SENSORBOARDA PIN_B15 
.................... #define SENSORBOARDB PIN_B14 
....................  
....................  
.................... #fuses  NOWDT, NOBROWNOUT, NOPROTECT, PUT 
.................... #use delay(crystal=8mhz, clock=32mhz) 
*
0356:  CP0     W0
0358:  BTSC.B  42.1
035A:  BRA     364
035C:  REPEAT  #3E7B
035E:  NOP     
0360:  DEC     W0,W0
0362:  BRA     NZ,35C
0364:  RETURN  
....................  
.................... #define SDAPIN PIN_B2 
.................... #define SCLPIN PIN_B3 
....................  
.................... #use I2C(stream=SENSOR, SLAVE, sda=SDAPIN,scl=SCLPIN, I2C2, address=0xa0)   // this is I2C 1 
*
0200:  MOV     #FFFF,W0
0202:  BTSS.B  218.3
0204:  BRA     202
0206:  BTSC.B  219.1
0208:  BRA     212
020A:  BTSS.B  217.2
020C:  BRA     212
020E:  BTSS.B  219.0
0210:  BRA     202
0212:  BTSS.B  218.1
0214:  BRA     212
0216:  MOV     210,W0
0218:  BTSC.B  218.6
021A:  BCLR.B  218.6
021C:  BSET.B  217.4
021E:  RETURN  
0220:  MOV     #FFFF,W0
0222:  BTSS.B  218.3
0224:  BRA     236
0226:  BTSS.B  218.2
0228:  BRA     236
022A:  BTSS.B  217.2
022C:  BRA     232
022E:  BTSS.B  219.0
0230:  BRA     236
0232:  MOV     W1,212
0234:  BSET.B  217.4
0236:  RETURN  
.................... #use I2C(stream=PH_LIGHT, MASTER, sda=PIN_B9, scl=PIN_B8)    // this is the master I2c for talking with removote sensor boards.  There is only one I2c on this chip. 
*
03EE:  MOV     #FFFF,W0
03F0:  BTSS.B  208.3
03F2:  BRA     3FE
03F4:  BTSC.B  209.6
03F6:  BRA     3F4
03F8:  MOV     W1,202
03FA:  BTSC.B  209.6
03FC:  BRA     3FA
03FE:  MOV     #0,W0
0400:  BTSC.B  209.7
0402:  INC     W0,W0
0404:  RETURN  
*
0716:  MOV     #FFFF,W0
0718:  BTSS.B  208.3
071A:  BRA     73E
071C:  MOV     206,W2
071E:  AND     W2,#1F,W2
0720:  BRA     NZ,71C
0722:  BSET.B  206.3
0724:  BTSC    W1.0
0726:  BCLR.B  206.5
0728:  BTSS    W1.0
072A:  BSET.B  206.5
072C:  MOV     206,W2
072E:  AND     W2,#1F,W2
0730:  BRA     NZ,72C
0732:  BSET.B  206.4
0734:  BTSS.B  208.1
0736:  BRA     734
0738:  MOV     200,W0
073A:  BTSC.B  208.6
073C:  BCLR.B  208.6
073E:  RETURN  
....................  
.................... #define SLAVE 1 
.................... #define SENSORNUMBER 0x39   // this means it is a Digital patch DO and NH4 board. 
.................... #define TESTER 
.................... //include this file.  Only edit this file because it changes all other remote digital boards. 
....................  
....................  
.................... typedef struct outputDataStruct{ 
.................... char deviceID[16]; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int8 taosVersion; 
.................... float dOxy; 
.................... float wTemp; 
.................... float pH; 
.................... float pHLow; 
.................... float WhiteBalance; 
.................... float tdsLevel; 
.................... float wLevel; 
.................... float lLevelX; 
.................... float lLevelY; 
....................  
.................... int32 lLevelRed; 
.................... int32 lLevelGreen; 
.................... int32 lLevelBlue; 
.................... int32 lLevelClear; 
.................... int8 time; 
.................... int16 date; 
....................  
....................  
.................... float lLevelScale; 
.................... float rH,averagepH; 
.................... float aTemp; 
.................... int16 cO2; 
.................... float nh3; 
.................... float dPoint; 
.................... char DIEHARD[8]; 
.................... }outputData; 
....................  
....................  
.................... outputData sysOutput; 
.................... /* 
.................... // This is added for the retrieval of the configuration data from the host master I2C 
....................  
.................... typedef struct inputDataStruct{ 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... float eccal1x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal1y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3y;    //  This the EC data point  Added July 18, 2016 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
.................... }inputData; 
.................... inputData sysInput;  */ 
....................  
.................... #include <LightSensorForDigitalBoard.c> 
....................  
....................  
.................... #ifndef byte 
.................... #define byte int8 
.................... #endif 
.................... #define COLOR_SENSOR_ADDR  0x39//the I2C address for the color sensor  
.................... #define REG_CTL 0x80 
.................... #define REG_TIMING 0x81 
.................... #define REG_INT 0x82 
.................... #define REG_INT_SOURCE 0x83 
.................... #define REG_ID 0x84 
.................... #define REG_GAIN 0x87 
.................... #define REG_LOW_THRESH_LOW_BYTE 0x88 
.................... #define REG_LOW_THRESH_HIGH_BYTE 0x89 
.................... #define REG_HIGH_THRESH_LOW_BYTE 0x8A 
.................... #define REG_HIGH_THRESH_HIGH_BYTE 0x8B 
.................... #define REG_BLOCK_READ 0xCF 
.................... #define REG_GREEN_LOW 0xD0 
.................... #define REG_GREEN_HIGH 0xD1 
.................... #define REG_RED_LOW 0xD2 
.................... #define REG_RED_HIGH 0xD3 
.................... #define REG_BLUE_LOW 0xD4 
.................... #define REG_BLUE_HIGH 0xD5 
.................... #define REG_CLEAR_LOW 0xD6 
.................... #define REG_CLEAR_HIGH 0xD7 
.................... #define CTL_DAT_INIITIATE 0x03 
.................... #define CLR_INT 0xE0 
.................... //Timing Register 
.................... #define SYNC_EDGE 0x40 
.................... #define INTEG_MODE_FREE 0x00 
.................... #define INTEG_MODE_MANUAL 0x10 
.................... #define INTEG_MODE_SYN_SINGLE 0x20 
.................... #define INTEG_MODE_SYN_MULTI 0x30 
....................   
.................... #define INTEG_PARAM_PULSE_COUNT1 0x00 
.................... #define INTEG_PARAM_PULSE_COUNT2 0x01 
.................... #define INTEG_PARAM_PULSE_COUNT4 0x02 
.................... #define INTEG_PARAM_PULSE_COUNT8 0x03 
....................  
.................... #define GAIN_1 0x00 
.................... #define GAIN_4 0x10 
.................... #define GAIN_16 0x20 
.................... #define GANI_64 0x30 
.................... #define PRESCALER_1 0x00 
.................... #define PRESCALER_2 0x01 
.................... #define PRESCALER_4 0x02 
.................... #define PRESCALER_8 0x03 
.................... #define PRESCALER_16 0x04 
.................... #define PRESCALER_32 0x05 
.................... #define PRESCALER_64 0x06 
....................  
.................... float tempa1, tempa2, tempa3;   //Addded May 15, 2014 These are the coefecents for thermister calculation 
.................... void selectsensor(int number); 
.................... float FindpHEquation(void); 
.................... int colorlow, colorhigh;   // gain, scale;  //This is the pair of bytes used to return the current selected color. 
.................... unsigned int16 red,green,blue,clear; 
.................... //int32 scaledred, scaledgreen, scaledblue;   // Added May 6, 2014  These are large number to hold the gain of the intensity 
....................  
.................... //************************************************************************************* 
.................... //Created March 4, 2015 
.................... // The Exposurescale is used for the preprocessor to scale down the ADC.  Each light sensor has a different scaling. 
.................... // Below is a table showing the values for each exposure scale down for the ADC. 
.................... //  000            Divide by 1 
.................... //  001            Divide by 2 
.................... //  010            Divide by 4 
.................... //  011            Divide by 8 
.................... //  100            Divide by 16 
.................... //  101            Divide by 32 
.................... //  110            Divide by 64 
.................... //  111            Does not exist and is not used. 
.................... //************************************************************************************ 
....................  
.................... byte ExposurescaleDO = 0;   //This is the global variable used for prescaler for the ADC 
.................... byte ExposurescalepH = 0;   //This is the global variable used for prescaler for the ADC  
.................... byte ExposurescaleLight = 2;   //  This used to be 2.  This is the global variable used for prescaler for the ADC   Three is used to divide by 4 
.................... float x,y,z;  //Color chart positions,coored. 
....................  
.................... //************************************************************ 
.................... //Define the 3X4 matrix for solving three unknown equations. 
.................... float matx[3][3];  //This is the global diffinition of solving a 3X3 matrix equation. This is a scrach pad matrix used to pass arrays between functions. Added May 13, 2013 
.................... float matrixequation[3][3]; //  Added May 13, 2013  This is the array used for setting up the eqaution for solving a 3X3 equation. 
.................... float fourbyfourmatrix[4][4]; 
.................... float matrixequals[3];  
.................... // Added April 27, 2014   
.................... // Matrixequals is used for place the results of all three equations. 
.................... // This is used to subsitue into the 3X3 matrix for finding the DET. 
.................... float MatrixSolution[3];  
.................... // Added April 27, 2014  This matrix saves the 
.................... // result for the 3X3 unknown solution. 
.................... float TempCalmatrix[4][3];  //This matrix holds the temperatures and K1, K2 and Iohhh values. 
.................... float pk, slope;  //these are the varaibles used for ph calcualtions 
.................... float lastphreading = -0.1;   //This is the last compare start up.  It's negative to start the current reading. 
.................... //************************************************************** 
....................  
....................  
.................... //****************************************************************** 
.................... // Added Dec 8, 2014 
.................... // These varaibles are used for optical offsets for ph and DO. 
.................... //****************************************************************** 
.................... signed int32		AmbientOxyRed; 
.................... signed int32		AmbientOxyGreen; 
.................... signed int32		AmbientOxyBlue; 
.................... signed int32		AmbientOxyClear; 
.................... signed int32		AmbientPHRed; 
.................... signed int32		AmbientPHGreen; 
.................... signed int32		AmbientPHBlue;  
.................... signed int32		AmbientPHClear;  
.................... signed int32		Ambientnh3Red; 
.................... signed int32		Ambientnh3Green; 
.................... signed int32		Ambientnh3Blue;  
.................... signed int32		Ambientnh3Clear;  
....................  
.................... //************************************************************************ 
.................... //Added December 12, 2014 
.................... // These varaibles are used for each color absolute.  These numbers combined with the gain. 
.................... //  They are 32 bits long 
.................... //************************************************************************ 
.................... signed int32 redABS; 
.................... signed int32 blueABS; 
.................... signed int32 greenABS; 
.................... signed int32 clearABS; 
....................  
....................  
.................... //****************************************************************** 
.................... // K1 and K2 are two constants caluclated from calibration constants saved in EEPROM. 
.................... // The rest of the constants are used for calculating K1, K2 and Iohhh against temperature. 
.................... //  Added April 27, 2014 
.................... //****************************************************************** 
.................... float K1, K2, K1Temp,K2Temp;   // Added April 6, 2015  These are all of the K values for DO temperature and non temperature compensation. 
.................... float RatioI, RatioII, Iohhh; 
.................... float atwo, btwo, ctwo;   //no Temp compensated DO 
....................  
.................... //**************************************************************** 
.................... // Created/Moved May 20, 2015 
.................... // These varabbles are moved here to be global. 
.................... //  They are all for the DO only. 
.................... //**************************************************************** 
.................... int debugnumber = 0;  //Added July 13, 2015.  It keeps the current state of the debug routine calls.  Default is zero; or not in debug/calibration mode. 
....................  
....................  
....................  
....................      
....................     float wTemp = 20.0; 
....................  
....................  
....................  
.................... //********************************************************************************* 
.................... // The defs below are for pH 
.................... //************************************************************************************ 
.................... 	float pHHigh, pHMiddle, pHLower; 
....................     float pHHighCalibration,pHMiddleCalibration,pHLowerCalibration; 
....................  
.................... //********************************************************************************* 
.................... // Added May 21, 2015 
.................... // This is the calibrations for temperature on the thermister for water 
.................... //********************************************************************************* 
....................  
.................... 	float temp1,reading1,temp2,reading2,temp3,reading3; 
.................... 	int32 BlueLimit,WhiteLimit;  //This is the limit variable off the SD Card for the desiged light intesity. 
.................... 	float StartWaterTemperature;  //This is the varaible used to keep track of the init water temperature for hose air expansion. 
....................  
....................  
....................  
.................... //************************************************************ 
.................... // Added December 1, 2014 
.................... // These variables will keep the last intensity 
.................... unsigned int16 PWMDOIntensity; 
.................... unsigned int16 PWMPHIntensity; 
.................... unsigned int16 PWMnh3Intensity; 
.................... int32 DOreadingrange = 250;    //These are the starting values for the tolorance ranges for DO and pH  Added July 27, 2015 
.................... int32 pHreadingrange = 200; 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created May 13, 2013 
.................... // This routine returns the determinent for a given 3X3 mastrix passed through the funtion stack as a pointer to address. 
.................... // The Deteminete is returned at the end of the funtion call. 
.................... // This method for solving equations is called Cramer's rule 
.................... //****************************************************************************** 
.................... float FindTheDetermint(void) 
*
115A:  MOV     W5,[W15++]
115C:  MOV     W6,[W15++]
115E:  MOV     W7,[W15++]
1160:  MOV     W8,[W15++]
.................... 	{ 
.................... 	float det,part1,part2;  //Define the determint as float. 
....................  
....................     part1=matx[0][0]*matx[1][1]*matx[2][2]; 
1162:  MOV     ABC,W0
1164:  MOV     ABE,W1
1166:  MOV     ACC,W2
1168:  MOV     ACE,W3
116A:  CALL    C2E
116E:  MOV     W0,W5
1170:  MOV     W1,W6
1172:  MOV     W5,W0
1174:  MOV     W6,W1
1176:  MOV     ADC,W2
1178:  MOV     ADE,W3
117A:  CALL    C2E
117E:  MOV     W0,EAC
1180:  MOV     W1,EAE
....................  
.................... 	det = (part1 + matx[1][0]*matx[2][1]*matx[0][2] + matx[2][0]*matx[0][1]*matx[1][2]);  
1182:  MOV     AC8,W0
1184:  MOV     ACA,W1
1186:  MOV     AD8,W2
1188:  MOV     ADA,W3
118A:  CALL    C2E
118E:  MOV     W0,W5
1190:  MOV     W1,W6
1192:  MOV     W5,W0
1194:  MOV     W6,W1
1196:  MOV     AC4,W2
1198:  MOV     AC6,W3
119A:  CALL    C2E
119E:  BCLR.B  43.0
11A0:  MOV     W0,W2
11A2:  MOV     W1,W3
11A4:  MOV     EAC,W0
11A6:  MOV     EAE,W1
11A8:  CALL    DBC
11AC:  MOV     W0,W5
11AE:  MOV     W1,W6
11B0:  MOV     AD4,W0
11B2:  MOV     AD6,W1
11B4:  MOV     AC0,W2
11B6:  MOV     AC2,W3
11B8:  CALL    C2E
11BC:  MOV     W0,W7
11BE:  MOV     W1,W8
11C0:  MOV     W7,W0
11C2:  MOV     W8,W1
11C4:  MOV     AD0,W2
11C6:  MOV     AD2,W3
11C8:  CALL    C2E
11CC:  BCLR.B  43.0
11CE:  MOV     W0,W2
11D0:  MOV     W1,W3
11D2:  MOV     W5,W0
11D4:  MOV     W6,W1
11D6:  CALL    DBC
11DA:  MOV     W0,EA8
11DC:  MOV     W1,EAA
....................     part2 = (matx[0][2]*matx[1][1]*matx[2][0] + matx[1][2]*matx[2][1]*matx[0][0] + matx[2][2]*matx[0][1]*matx[1][0]); 
11DE:  MOV     AC4,W0
11E0:  MOV     AC6,W1
11E2:  MOV     ACC,W2
11E4:  MOV     ACE,W3
11E6:  CALL    C2E
11EA:  MOV     W0,W5
11EC:  MOV     W1,W6
11EE:  MOV     W5,W0
11F0:  MOV     W6,W1
11F2:  MOV     AD4,W2
11F4:  MOV     AD6,W3
11F6:  CALL    C2E
11FA:  MOV     W0,W5
11FC:  MOV     W1,W6
11FE:  MOV     AD0,W0
1200:  MOV     AD2,W1
1202:  MOV     AD8,W2
1204:  MOV     ADA,W3
1206:  CALL    C2E
120A:  MOV     W0,W7
120C:  MOV     W1,W8
120E:  MOV     W7,W0
1210:  MOV     W8,W1
1212:  MOV     ABC,W2
1214:  MOV     ABE,W3
1216:  CALL    C2E
121A:  BCLR.B  43.0
121C:  MOV     W0,W2
121E:  MOV     W1,W3
1220:  MOV     W5,W0
1222:  MOV     W6,W1
1224:  CALL    DBC
1228:  MOV     W0,W5
122A:  MOV     W1,W6
122C:  MOV     ADC,W0
122E:  MOV     ADE,W1
1230:  MOV     AC0,W2
1232:  MOV     AC2,W3
1234:  CALL    C2E
1238:  MOV     W0,W7
123A:  MOV     W1,W8
123C:  MOV     W7,W0
123E:  MOV     W8,W1
1240:  MOV     AC8,W2
1242:  MOV     ACA,W3
1244:  CALL    C2E
1248:  BCLR.B  43.0
124A:  MOV     W0,W2
124C:  MOV     W1,W3
124E:  MOV     W5,W0
1250:  MOV     W6,W1
1252:  CALL    DBC
1256:  MOV     W0,EB0
1258:  MOV     W1,EB2
.................... 	det = det - (matx[0][2]*matx[1][1]*matx[2][0] + matx[1][2]*matx[2][1]*matx[0][0] + matx[2][2]*matx[0][1]*matx[1][0]); 
125A:  MOV     AC4,W0
125C:  MOV     AC6,W1
125E:  MOV     ACC,W2
1260:  MOV     ACE,W3
1262:  CALL    C2E
1266:  MOV     W0,W5
1268:  MOV     W1,W6
126A:  MOV     W5,W0
126C:  MOV     W6,W1
126E:  MOV     AD4,W2
1270:  MOV     AD6,W3
1272:  CALL    C2E
1276:  MOV     W0,W5
1278:  MOV     W1,W6
127A:  MOV     AD0,W0
127C:  MOV     AD2,W1
127E:  MOV     AD8,W2
1280:  MOV     ADA,W3
1282:  CALL    C2E
1286:  MOV     W0,W7
1288:  MOV     W1,W8
128A:  MOV     W7,W0
128C:  MOV     W8,W1
128E:  MOV     ABC,W2
1290:  MOV     ABE,W3
1292:  CALL    C2E
1296:  BCLR.B  43.0
1298:  MOV     W0,W2
129A:  MOV     W1,W3
129C:  MOV     W5,W0
129E:  MOV     W6,W1
12A0:  CALL    DBC
12A4:  MOV     W0,W5
12A6:  MOV     W1,W6
12A8:  MOV     ADC,W0
12AA:  MOV     ADE,W1
12AC:  MOV     AC0,W2
12AE:  MOV     AC2,W3
12B0:  CALL    C2E
12B4:  MOV     W0,W7
12B6:  MOV     W1,W8
12B8:  MOV     W7,W0
12BA:  MOV     W8,W1
12BC:  MOV     AC8,W2
12BE:  MOV     ACA,W3
12C0:  CALL    C2E
12C4:  BCLR.B  43.0
12C6:  MOV     W0,W2
12C8:  MOV     W1,W3
12CA:  MOV     W5,W0
12CC:  MOV     W6,W1
12CE:  CALL    DBC
12D2:  BSET.B  43.0
12D4:  MOV     W0,W2
12D6:  MOV     W1,W3
12D8:  MOV     EA8,W0
12DA:  MOV     EAA,W1
12DC:  CALL    DBC
12E0:  MOV     W0,EA8
12E2:  MOV     W1,EAA
....................  
.................... 	return(det); 
12E4:  MOV     EA8,W0
12E6:  MOV     EAA,W1
12E8:  MOV     [--W15],W8
12EA:  MOV     [--W15],W7
12EC:  MOV     [--W15],W6
12EE:  MOV     [--W15],W5
12F0:  RETURN  
.................... 	} 
....................  
.................... //****************************************************************************** 
.................... // Created May 13, 2013 
.................... // This routine is a general purpose solution for three unknowns given the coefficents of all three equations and what they eqaul. 
.................... // The coefficents are given as a matrix of 3X3 in an 3X3 array of floats starting with 0 to 2.  The results are placed in the last colomum of of the 3X3 matrix. 
.................... // The routines uses a series of deteminets to solve the problems. 
.................... //****************************************************************************** 
.................... void ThreeByThreeSolution(void) 
.................... 	{ 
....................  
.................... 	float det, detx, dety, detz; 
.................... 	int x, y; 
....................  
.................... // this finds the common det for the whole matrix 
.................... //  Move the exisitng array into the scratch pad marix  matx 
.................... 	for (x=0; x < 3; x++) 
.................... 		{ 
.................... 		for (y=0; y < 3; y++) 
.................... 			{ 
.................... 			matx[x][y] = matrixequation[x][y];   //Move this element into the scrach matrix. 
.................... 			} 
.................... 		} 
.................... /* 
.................... 	matx[0][0] = 1.0;  //this for testing the deteminte routine. 
.................... 	matx[1][0] = 0.0;  // remove all of this when completed. 
.................... 	matx[2][0] = 3.0;    // Example  
.................... 	matx[0][1] = 2.0;    //  1.0  0.0  3.0 
.................... 	matx[1][1] = 1.0;    //  2.0  1.0  0.0 
.................... 	matx[2][1] = 0.0;    //  4.0  1.0  0.0 
.................... 	matx[0][2] = 4.0; 
.................... 	matx[1][2] = 1.0; 
.................... 	matx[2][2] = 0.0; 
.................... */ 
.................... 	det = FindTheDetermint(); 
....................  
....................  
.................... //  Move the exisitng array into the scratch pad matrix  matrix 
.................... 	for (x=0; x < 3; x++) 
.................... 		{ 
.................... 		for (y=0; y < 3; y++) 
.................... 			{ 
.................... 			matx[x][y] = matrixequation[x][y];   //Move this element into the scrach matrix. 
.................... 			} 
.................... 		} 
.................... 		for (y=0; y < 3; y++) //move the first colunm into the x 
.................... 			{ 
....................                  matx[0][y] = matrixequals[y]; 
.................... 			} 
....................  
.................... 	detx = FindTheDetermint(); //find the detmeinent 
....................       MatrixSolution[0] = detx/det; //Stuff the results in the x location 
....................  
.................... //  Move the exisitng array into the scratch pad matrix  matrix 
.................... 	for (x=0; x < 3; x++) 
.................... 		{ 
.................... 		for (y=0; y < 3; y++) 
.................... 			{ 
.................... 			matx[x][y] = matrixequation[x][y];   //Move this element into the scrach matrix. 
.................... 			} 
.................... 		} 
.................... 		for (y=0; y < 3; y++) //move the first colunm into the x 
.................... 			{ 
....................                  matx[1][y] = matrixequals[y]; 
.................... 			} 
....................  
.................... 	dety = FindTheDetermint(); //find the detmeinent 
....................       MatrixSolution[1] = dety/det; //Stuff the results in the x location 
....................  
....................  
.................... //  Move the exisitng array into the scratch pad matrix  matrix 
.................... 	for (x=0; x < 3; x++) 
.................... 		{ 
.................... 		for (y=0; y < 3; y++) 
.................... 			{ 
.................... 			matx[x][y] = matrixequation[x][y];   //Move this element into the scrach matrix. 
.................... 			} 
.................... 		} 
.................... 		for (y=0; y < 3; y++) //move the first colunm into the x 
.................... 			{ 
....................                  matx[2][y] = matrixequals[y];  // replace the colunm 
.................... 			} 
....................  
.................... 	detz = FindTheDetermint(); //find the detmeinent 
....................       MatrixSolution[2] = detz/det; //Stuff the results in the x location 
....................  
.................... 	} 
....................  
.................... #ifdef TESTER 
....................  
.................... //*************************************************************************** 
.................... // Created December 2, 2015 
.................... // Changed for the digital sensor board Oct 13, 2016 
.................... // This routine sets the encoder to select where the I2C clock signal goes to. 
.................... // It returns nothing. 
.................... // The input is number for 0 to 5;  each one selecting a sensor. 
.................... // Added March 17, 2016 
.................... //  SENSORBOARDA    0       1      0         1 
.................... //  SENSORBOARDB    0       0      1         1 
.................... //                in unit   top   bot Rj45   nothing 
.................... //*************************************************************************** 
.................... void selectsensor(int number) 
.................... 	{ 
.................... //fprintf(BT,"Device Number Selected %i\n\r",sensor number); 
.................... 	if (number > 3)   // Set the high bit 
*
03AA:  MOV     DE0,W4
03AC:  CP      W4,#3
03AE:  BRA     LE,3B6
.................... 		{ 
.................... 		number = number - 4;    // Remove the offset so the bottom part of the byte can be accessed 
03B0:  MOV     DE0,W4
03B2:  SUB     W4,#4,W0
03B4:  MOV     W0,DE0
.................... 		} 
....................  
.................... 	if (number == 0)   // Set the lower bits. 
03B6:  CP0     DE0
03B8:  BRA     NZ,3C2
.................... 		{ 
.................... 		output_low(SENSORBOARDA);   // This is connected to the input for the A on both 74139 chips. 
03BA:  BCLR.B  2C9.7
03BC:  BCLR.B  2CD.7
.................... 		output_low(SENSORBOARDB);   // This is connected to the input for the B on both 74139 chips. 
03BE:  BCLR.B  2C9.6
03C0:  BCLR.B  2CD.6
.................... 		} 
....................  
.................... 	if (number == 1) 
03C2:  MOV     DE0,W4
03C4:  CP      W4,#1
03C6:  BRA     NZ,3D0
.................... 		{ 
.................... 		output_high(SENSORBOARDA);   // This is connected to the input for the A on both 74139 chips. 
03C8:  BCLR.B  2C9.7
03CA:  BSET.B  2CD.7
.................... 		output_low(SENSORBOARDB);   // This is connected to the input for the B on both 74139 chips. 
03CC:  BCLR.B  2C9.6
03CE:  BCLR.B  2CD.6
.................... 		} 
.................... 	if (number == 2) 
03D0:  MOV     DE0,W4
03D2:  CP      W4,#2
03D4:  BRA     NZ,3DE
.................... 		{ 
.................... 		output_low(SENSORBOARDA);   // This is connected to the input for the A on both 74139 chips. 
03D6:  BCLR.B  2C9.7
03D8:  BCLR.B  2CD.7
.................... 		output_high(SENSORBOARDB);   // This is connected to the input for the B on both 74139 chips. 
03DA:  BCLR.B  2C9.6
03DC:  BSET.B  2CD.6
.................... 		} 
.................... 	if (number == 3) 
03DE:  MOV     DE0,W4
03E0:  CP      W4,#3
03E2:  BRA     NZ,3EC
.................... 		{ 
.................... 		output_high(SENSORBOARDA);   // This is connected to the input for the A on both 74139 chips. 
03E4:  BCLR.B  2C9.7
03E6:  BSET.B  2CD.7
.................... 		output_high(SENSORBOARDB);   // This is connected to the input for the B on both 74139 chips. 
03E8:  BCLR.B  2C9.6
03EA:  BSET.B  2CD.6
.................... 		} 
03EC:  RETURN  
....................  
.................... 	} 
....................  
.................... #endif 
....................  
....................  
....................  
.................... //****************************************************************** 
.................... //Created March 17, 2013 
.................... // This routine reads the all four inputs and returns the 16 bit value for that color. 
.................... // The value for color is as follows: 
.................... // 1:red 
.................... // 2:greem 
.................... // 3:blue 
.................... // 4:clear 
.................... // The retuened value is measured value. 
.................... //  This measurement is influnenced by the scalling factor for each ADC. 
.................... //  The two numbers are returned through tow global varibles. 
.................... //  The variables are colorlow and colorhigh. 
.................... // Added Oct 20, 2014 - Multi I2C lines can be used for each light sensor 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the room 
.................... //****************************************************************** 
.................... void ReadColorTAOS(int selectedcolor, int lightsensor) 
.................... 	{ 
....................  
.................... 	switch(selectedcolor) 
*
0740:  MOV     DDA,W0
0742:  XOR     #2,W0
0744:  BRA     Z,754
0746:  XOR     #3,W0
0748:  BRA     Z,80E
074A:  XOR     #2,W0
074C:  BRA     Z,8C8
074E:  XOR     #7,W0
0750:  BRA     Z,982
0752:  BRA     A3C
.................... 		{ 
.................... 		case 2:   //green 
.................... 			i2c_start(PH_LIGHT); 
0754:  BTSS.B  208.3
0756:  BRA     760
0758:  BSET.B  206.1
075A:  BTSC.B  206.1
075C:  BRA     75A
075E:  BRA     766
0760:  BSET.B  206.0
0762:  BTSC.B  206.0
0764:  BRA     762
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
0766:  MOV.B   #72,W1L
0768:  CALL    3EE
.................... 			i2c_write(PH_LIGHT,0x90);  //Send the command for reading the version 
076C:  MOV.B   #90,W1L
076E:  CALL    3EE
.................... 			i2c_stop(PH_LIGHT); 
0772:  MOV     #1F,W0
0774:  AND     206,W0
0776:  BRA     NZ,772
0778:  BSET.B  206.2
077A:  BTSC.B  206.2
077C:  BRA     77A
....................  
....................     		i2c_start(PH_LIGHT); 
077E:  BTSS.B  208.3
0780:  BRA     78A
0782:  BSET.B  206.1
0784:  BTSC.B  206.1
0786:  BRA     784
0788:  BRA     790
078A:  BSET.B  206.0
078C:  BTSC.B  206.0
078E:  BRA     78C
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
0790:  MOV.B   #73,W1L
0792:  CALL    3EE
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
0796:  MOV     #0,W1
0798:  MOV     W1,[W15++]
079A:  MOV     [--W15],W1
079C:  CALL    716
07A0:  MOV.B   W0L,AA0
07A2:  CLR.B   AA1
.................... 			i2c_stop(PH_LIGHT); 
07A4:  MOV     #1F,W0
07A6:  AND     206,W0
07A8:  BRA     NZ,7A4
07AA:  BSET.B  206.2
07AC:  BTSC.B  206.2
07AE:  BRA     7AC
....................  
.................... 			i2c_start(PH_LIGHT); 
07B0:  BTSS.B  208.3
07B2:  BRA     7BC
07B4:  BSET.B  206.1
07B6:  BTSC.B  206.1
07B8:  BRA     7B6
07BA:  BRA     7C2
07BC:  BSET.B  206.0
07BE:  BTSC.B  206.0
07C0:  BRA     7BE
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
07C2:  MOV.B   #72,W1L
07C4:  CALL    3EE
.................... 			i2c_write(PH_LIGHT,0x91);  //Send the command for reading the version 
07C8:  MOV.B   #91,W1L
07CA:  CALL    3EE
.................... 			i2c_stop(PH_LIGHT); 
07CE:  MOV     #1F,W0
07D0:  AND     206,W0
07D2:  BRA     NZ,7CE
07D4:  BSET.B  206.2
07D6:  BTSC.B  206.2
07D8:  BRA     7D6
....................  
....................     		i2c_start(PH_LIGHT); 
07DA:  BTSS.B  208.3
07DC:  BRA     7E6
07DE:  BSET.B  206.1
07E0:  BTSC.B  206.1
07E2:  BRA     7E0
07E4:  BRA     7EC
07E6:  BSET.B  206.0
07E8:  BTSC.B  206.0
07EA:  BRA     7E8
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
07EC:  MOV.B   #73,W1L
07EE:  CALL    3EE
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
07F2:  MOV     #0,W1
07F4:  MOV     W1,[W15++]
07F6:  MOV     [--W15],W1
07F8:  CALL    716
07FC:  MOV.B   W0L,AA2
07FE:  CLR.B   AA3
.................... 			i2c_stop(PH_LIGHT); 
0800:  MOV     #1F,W0
0802:  AND     206,W0
0804:  BRA     NZ,800
0806:  BSET.B  206.2
0808:  BTSC.B  206.2
080A:  BRA     808
.................... 			break; 
080C:  BRA     A3E
....................  
....................  
.................... 		case 1:   //red 
.................... 			i2c_start(PH_LIGHT); 
080E:  BTSS.B  208.3
0810:  BRA     81A
0812:  BSET.B  206.1
0814:  BTSC.B  206.1
0816:  BRA     814
0818:  BRA     820
081A:  BSET.B  206.0
081C:  BTSC.B  206.0
081E:  BRA     81C
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
0820:  MOV.B   #72,W1L
0822:  CALL    3EE
.................... 			i2c_write(PH_LIGHT,0x92);  //Send the command for reading the version 
0826:  MOV.B   #92,W1L
0828:  CALL    3EE
.................... 			i2c_stop(PH_LIGHT); 
082C:  MOV     #1F,W0
082E:  AND     206,W0
0830:  BRA     NZ,82C
0832:  BSET.B  206.2
0834:  BTSC.B  206.2
0836:  BRA     834
....................  
....................     		i2c_start(PH_LIGHT); 
0838:  BTSS.B  208.3
083A:  BRA     844
083C:  BSET.B  206.1
083E:  BTSC.B  206.1
0840:  BRA     83E
0842:  BRA     84A
0844:  BSET.B  206.0
0846:  BTSC.B  206.0
0848:  BRA     846
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
084A:  MOV.B   #73,W1L
084C:  CALL    3EE
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
0850:  MOV     #0,W1
0852:  MOV     W1,[W15++]
0854:  MOV     [--W15],W1
0856:  CALL    716
085A:  MOV.B   W0L,AA0
085C:  CLR.B   AA1
.................... 			i2c_stop(PH_LIGHT); 
085E:  MOV     #1F,W0
0860:  AND     206,W0
0862:  BRA     NZ,85E
0864:  BSET.B  206.2
0866:  BTSC.B  206.2
0868:  BRA     866
....................  
.................... 			i2c_start(PH_LIGHT); 
086A:  BTSS.B  208.3
086C:  BRA     876
086E:  BSET.B  206.1
0870:  BTSC.B  206.1
0872:  BRA     870
0874:  BRA     87C
0876:  BSET.B  206.0
0878:  BTSC.B  206.0
087A:  BRA     878
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
087C:  MOV.B   #72,W1L
087E:  CALL    3EE
.................... 			i2c_write(PH_LIGHT,0x93);  //Send the command for reading the version 
0882:  MOV.B   #93,W1L
0884:  CALL    3EE
.................... 			i2c_stop(PH_LIGHT); 
0888:  MOV     #1F,W0
088A:  AND     206,W0
088C:  BRA     NZ,888
088E:  BSET.B  206.2
0890:  BTSC.B  206.2
0892:  BRA     890
....................  
....................     		i2c_start(PH_LIGHT); 
0894:  BTSS.B  208.3
0896:  BRA     8A0
0898:  BSET.B  206.1
089A:  BTSC.B  206.1
089C:  BRA     89A
089E:  BRA     8A6
08A0:  BSET.B  206.0
08A2:  BTSC.B  206.0
08A4:  BRA     8A2
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
08A6:  MOV.B   #73,W1L
08A8:  CALL    3EE
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
08AC:  MOV     #0,W1
08AE:  MOV     W1,[W15++]
08B0:  MOV     [--W15],W1
08B2:  CALL    716
08B6:  MOV.B   W0L,AA2
08B8:  CLR.B   AA3
.................... 			i2c_stop(PH_LIGHT); 
08BA:  MOV     #1F,W0
08BC:  AND     206,W0
08BE:  BRA     NZ,8BA
08C0:  BSET.B  206.2
08C2:  BTSC.B  206.2
08C4:  BRA     8C2
.................... 			break; 
08C6:  BRA     A3E
....................  
.................... 		case 3:   //blue 
.................... 			i2c_start(PH_LIGHT); 
08C8:  BTSS.B  208.3
08CA:  BRA     8D4
08CC:  BSET.B  206.1
08CE:  BTSC.B  206.1
08D0:  BRA     8CE
08D2:  BRA     8DA
08D4:  BSET.B  206.0
08D6:  BTSC.B  206.0
08D8:  BRA     8D6
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
08DA:  MOV.B   #72,W1L
08DC:  CALL    3EE
.................... 			i2c_write(PH_LIGHT,0x94);  //Send the command for reading the version 
08E0:  MOV.B   #94,W1L
08E2:  CALL    3EE
.................... 			i2c_stop(PH_LIGHT); 
08E6:  MOV     #1F,W0
08E8:  AND     206,W0
08EA:  BRA     NZ,8E6
08EC:  BSET.B  206.2
08EE:  BTSC.B  206.2
08F0:  BRA     8EE
....................  
....................     		i2c_start(PH_LIGHT); 
08F2:  BTSS.B  208.3
08F4:  BRA     8FE
08F6:  BSET.B  206.1
08F8:  BTSC.B  206.1
08FA:  BRA     8F8
08FC:  BRA     904
08FE:  BSET.B  206.0
0900:  BTSC.B  206.0
0902:  BRA     900
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
0904:  MOV.B   #73,W1L
0906:  CALL    3EE
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
090A:  MOV     #0,W1
090C:  MOV     W1,[W15++]
090E:  MOV     [--W15],W1
0910:  CALL    716
0914:  MOV.B   W0L,AA0
0916:  CLR.B   AA1
.................... 			i2c_stop(PH_LIGHT); 
0918:  MOV     #1F,W0
091A:  AND     206,W0
091C:  BRA     NZ,918
091E:  BSET.B  206.2
0920:  BTSC.B  206.2
0922:  BRA     920
....................  
.................... 			i2c_start(PH_LIGHT); 
0924:  BTSS.B  208.3
0926:  BRA     930
0928:  BSET.B  206.1
092A:  BTSC.B  206.1
092C:  BRA     92A
092E:  BRA     936
0930:  BSET.B  206.0
0932:  BTSC.B  206.0
0934:  BRA     932
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
0936:  MOV.B   #72,W1L
0938:  CALL    3EE
.................... 			i2c_write(PH_LIGHT,0x95);  //Send the command for reading the version 
093C:  MOV.B   #95,W1L
093E:  CALL    3EE
.................... 			i2c_stop(PH_LIGHT); 
0942:  MOV     #1F,W0
0944:  AND     206,W0
0946:  BRA     NZ,942
0948:  BSET.B  206.2
094A:  BTSC.B  206.2
094C:  BRA     94A
....................  
....................     		i2c_start(PH_LIGHT); 
094E:  BTSS.B  208.3
0950:  BRA     95A
0952:  BSET.B  206.1
0954:  BTSC.B  206.1
0956:  BRA     954
0958:  BRA     960
095A:  BSET.B  206.0
095C:  BTSC.B  206.0
095E:  BRA     95C
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
0960:  MOV.B   #73,W1L
0962:  CALL    3EE
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
0966:  MOV     #0,W1
0968:  MOV     W1,[W15++]
096A:  MOV     [--W15],W1
096C:  CALL    716
0970:  MOV.B   W0L,AA2
0972:  CLR.B   AA3
.................... 			i2c_stop(PH_LIGHT); 
0974:  MOV     #1F,W0
0976:  AND     206,W0
0978:  BRA     NZ,974
097A:  BSET.B  206.2
097C:  BTSC.B  206.2
097E:  BRA     97C
.................... 			break; 
0980:  BRA     A3E
....................  
.................... 		case 4:   //clear 
.................... 			i2c_start(PH_LIGHT); 
0982:  BTSS.B  208.3
0984:  BRA     98E
0986:  BSET.B  206.1
0988:  BTSC.B  206.1
098A:  BRA     988
098C:  BRA     994
098E:  BSET.B  206.0
0990:  BTSC.B  206.0
0992:  BRA     990
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
0994:  MOV.B   #72,W1L
0996:  CALL    3EE
.................... 			i2c_write(PH_LIGHT,0x96);  //Send the command for reading the version 
099A:  MOV.B   #96,W1L
099C:  CALL    3EE
.................... 			i2c_stop(PH_LIGHT); 
09A0:  MOV     #1F,W0
09A2:  AND     206,W0
09A4:  BRA     NZ,9A0
09A6:  BSET.B  206.2
09A8:  BTSC.B  206.2
09AA:  BRA     9A8
....................  
....................     		i2c_start(PH_LIGHT); 
09AC:  BTSS.B  208.3
09AE:  BRA     9B8
09B0:  BSET.B  206.1
09B2:  BTSC.B  206.1
09B4:  BRA     9B2
09B6:  BRA     9BE
09B8:  BSET.B  206.0
09BA:  BTSC.B  206.0
09BC:  BRA     9BA
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
09BE:  MOV.B   #73,W1L
09C0:  CALL    3EE
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
09C4:  MOV     #0,W1
09C6:  MOV     W1,[W15++]
09C8:  MOV     [--W15],W1
09CA:  CALL    716
09CE:  MOV.B   W0L,AA0
09D0:  CLR.B   AA1
.................... 			i2c_stop(PH_LIGHT); 
09D2:  MOV     #1F,W0
09D4:  AND     206,W0
09D6:  BRA     NZ,9D2
09D8:  BSET.B  206.2
09DA:  BTSC.B  206.2
09DC:  BRA     9DA
....................  
.................... 			i2c_start(PH_LIGHT); 
09DE:  BTSS.B  208.3
09E0:  BRA     9EA
09E2:  BSET.B  206.1
09E4:  BTSC.B  206.1
09E6:  BRA     9E4
09E8:  BRA     9F0
09EA:  BSET.B  206.0
09EC:  BTSC.B  206.0
09EE:  BRA     9EC
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
09F0:  MOV.B   #72,W1L
09F2:  CALL    3EE
.................... 			i2c_write(PH_LIGHT,0x97);  //Send the command for reading the version 
09F6:  MOV.B   #97,W1L
09F8:  CALL    3EE
.................... 			i2c_stop(PH_LIGHT); 
09FC:  MOV     #1F,W0
09FE:  AND     206,W0
0A00:  BRA     NZ,9FC
0A02:  BSET.B  206.2
0A04:  BTSC.B  206.2
0A06:  BRA     A04
....................  
....................     		i2c_start(PH_LIGHT); 
0A08:  BTSS.B  208.3
0A0A:  BRA     A14
0A0C:  BSET.B  206.1
0A0E:  BTSC.B  206.1
0A10:  BRA     A0E
0A12:  BRA     A1A
0A14:  BSET.B  206.0
0A16:  BTSC.B  206.0
0A18:  BRA     A16
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
0A1A:  MOV.B   #73,W1L
0A1C:  CALL    3EE
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
0A20:  MOV     #0,W1
0A22:  MOV     W1,[W15++]
0A24:  MOV     [--W15],W1
0A26:  CALL    716
0A2A:  MOV.B   W0L,AA2
0A2C:  CLR.B   AA3
.................... 			i2c_stop(PH_LIGHT); 
0A2E:  MOV     #1F,W0
0A30:  AND     206,W0
0A32:  BRA     NZ,A2E
0A34:  BSET.B  206.2
0A36:  BTSC.B  206.2
0A38:  BRA     A36
.................... 			break; 
0A3A:  BRA     A3E
....................  
.................... 		default:	 
.................... 			break; 
0A3C:  BRA     A3E
.................... 	} 
0A3E:  RETURN  
....................  
.................... } 
....................  
....................  
.................... //********************************************************************** 
.................... // Created March 19, 2013 
.................... // Power up light chip 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the room 
.................... //  Updated December 8, 2015 
.................... //  StartupATOS is used for all six sensors.  The number of the sensor needs to be provided. 
.................... //********************************************************************** 
.................... void StartUpTAOS(int lightsensor) 
.................... 	{ 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
*
06DC:  PUSH    DDA
06DE:  POP     DE0
06E0:  CALL    3AA
.................... // then send the command down to the sensor.  All of the communication is done through the I2C on PH_LIGHT. 
.................... 	i2c_start(PH_LIGHT); 
06E4:  BTSS.B  208.3
06E6:  BRA     6F0
06E8:  BSET.B  206.1
06EA:  BTSC.B  206.1
06EC:  BRA     6EA
06EE:  BRA     6F6
06F0:  BSET.B  206.0
06F2:  BTSC.B  206.0
06F4:  BRA     6F2
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
06F6:  MOV.B   #72,W1L
06F8:  CALL    3EE
.................... 	i2c_write(PH_LIGHT,0x80);  //Send the command for reading the version 
06FC:  MOV.B   #80,W1L
06FE:  CALL    3EE
.................... 	i2c_write(PH_LIGHT,0x03);  //Send the command for reading the version 
0702:  MOV.B   #3,W1L
0704:  CALL    3EE
.................... 	i2c_stop(PH_LIGHT); 
0708:  MOV     #1F,W0
070A:  AND     206,W0
070C:  BRA     NZ,708
070E:  BSET.B  206.2
0710:  BTSC.B  206.2
0712:  BRA     710
0714:  RETURN  
.................... 	} 
....................  
....................  
....................  
.................... //******************************************************************** 
.................... // Created March 17, 2013 
.................... // This routine changes the gain/scaling routine for each color/ADC. 
.................... // The passed varaible is the gain for the ADC.  All colors get the same gain. 
.................... //  AnalogGain is a value between 0 to 3.   
.................... //  0 is 1X 
.................... //  1 is 4X 
.................... //  2 is 16X 
.................... //  3 is 64X 
.................... //Prescaler are values between 0 and 6.  0 is div by 1; 6 is divide by 64. 
.................... // Added Oct 20, 2014 
.................... //  The lightsensor is added to select which sensor we want to use 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the ROOM 
.................... //******************************************************************** 
.................... void setTAOSGain(byte AnalogGain, int lightsensor) 
*
0666:  MOV     W5,[W15++]
.................... 	{ 
.................... byte controlword,PrescalerGain; 
....................  
.................... controlword = 0; 
0668:  CLR.B   DDB
.................... PrescalerGain = 0;   // set it to this value if nothing else takes it. 
066A:  CLR.B   DDC
....................  
.................... if (lightsensor==3)   // changed March 23, 2016.  The passing number is the true sensor number, not the index   Used to be 1 
066C:  MOV     DDE,W4
066E:  CP      W4,#3
0670:  BRA     NZ,676
.................... 	{ 
....................     PrescalerGain = 3; 
0672:  MOV.B   #3,W0L
0674:  MOV.B   W0L,DDC
.................... 	//PrescalerGain = ExposurescaleDO; 
.................... 	} 
....................  
.................... if (lightsensor==1)  // changed March 23, 2016.  The passing number is the true sensor number, not the index   Used to be 2 
0676:  MOV     DDE,W4
0678:  CP      W4,#1
067A:  BRA     NZ,680
.................... 	{ 
.................... 	//PrescalerGain = ExposurescalepH; 
....................     PrescalerGain = 3; 
067C:  MOV.B   #3,W0L
067E:  MOV.B   W0L,DDC
.................... 	} 
....................  
.................... if (lightsensor==0)   // This is now for NH4 
0680:  CP0     DDE
0682:  BRA     NZ,688
.................... 	{ 
....................     //PrescalerGain = ExposurescaleLight; 
.................... 	PrescalerGain = 3; 
0684:  MOV.B   #3,W0L
0686:  MOV.B   W0L,DDC
.................... 	} 
....................  
....................  
.................... if (AnalogGain > 3) 
0688:  MOV     DDA,W4
068A:  CP.B    W4L,#3
068C:  BRA     LEU,692
.................... 	{ 
.................... 	AnalogGain = 3; 
068E:  MOV.B   #3,W0L
0690:  MOV.B   W0L,DDA
.................... 	} 
....................  
.................... // Concatinate the control byte. 
.................... controlword = AnalogGain*16 + PrescalerGain;  //This is the offset for gain to placeinto the chip.  Added March 4, 2015 
0692:  MOV.B   DDA,W0L
0694:  CLR.B   1
0696:  SL      W0,#4,W5
0698:  MOV     W5,W0
069A:  ADD.B   DDC,W0L
069C:  MOV.B   W0L,DDB
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
069E:  PUSH    DDE
06A0:  POP     DE0
06A2:  CALL    3AA
....................  
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
.................... 	i2c_start(PH_LIGHT); 
06A6:  BTSS.B  208.3
06A8:  BRA     6B2
06AA:  BSET.B  206.1
06AC:  BTSC.B  206.1
06AE:  BRA     6AC
06B0:  BRA     6B8
06B2:  BSET.B  206.0
06B4:  BTSC.B  206.0
06B6:  BRA     6B4
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
06B8:  MOV.B   #72,W1L
06BA:  CALL    3EE
.................... 	i2c_write(PH_LIGHT,0x87);  //The 0x80 is used to tell it's a command.  This is for register 0x07. 
06BE:  MOV.B   #87,W1L
06C0:  CALL    3EE
.................... 	i2c_write(PH_LIGHT,controlword);  //Move the address number left on and add a zero. 
06C4:  MOV.B   DDB,W0L
06C6:  MOV.B   W0L,W1L
06C8:  CALL    3EE
.................... 	i2c_stop(PH_LIGHT); 
06CC:  MOV     #1F,W0
06CE:  AND     206,W0
06D0:  BRA     NZ,6CC
06D2:  BSET.B  206.2
06D4:  BTSC.B  206.2
06D6:  BRA     6D4
06D8:  MOV     [--W15],W5
06DA:  RETURN  
.................... 	 
.................... 	} 
....................  
.................... //****************************************************************************************** 
.................... // Created April 26, 2014 
.................... // This routine finds the color light for any of four spectrum devices.  The inputs for GainIn are as follows: 
.................... //  4:  Determine the gain for what ND to use where all of the colors are not saturated. 
.................... //  0 is 1X 
.................... //  1 is 4X 
.................... //  2 is 16X 
.................... //  3 is 64X 
.................... //  These are the same numbers used by the chip 
.................... //  The returned result of the function is always the gain used.  For instance if a predetemined gain is used, that gain 
.................... // is returned.  If the automatic gain is used, the detemine gain is returned, not the number 4. 
.................... //  All colors are returned as global varaibles for other routines to use. 
.................... // ********************* 
.................... // The inputs for the chip select is as follows: 
.................... // 0: Number 1 
.................... // 1: Number 2 
.................... // 2: Number 3 
.................... // 3: Number 4  - this number does not exist on the Osmobot as is because thing is connected to it. 
.................... // The colors are returned in the global variables as follows: 
.................... // green, red, blue and clear 
.................... //  When a device is not selected correctly, the number 0xFF is returned as an error on the I2C. 
.................... //****************************************************************************************** 
....................  
.................... int8 GetCurrentColor(int8 GainIn, int8 DeviceSelect) 
*
0A70:  MOV     W5,[W15++]
0A72:  MOV     W6,[W15++]
.................... 	{ 
....................  
.................... //  Set the device to be processed 
....................  
.................... unsigned int gainMultiplyer; 
....................  
.................... 		setTAOSGain(GainIn,DeviceSelect); //Gain and then scale 
0A74:  MOV.B   DD6,W0L
0A76:  MOV.B   W0L,DDA
0A78:  MOV.B   DD7,W0L
0A7A:  MOV.B   W0L,W4L
0A7C:  SE      W4,W3
0A7E:  MOV     W3,DDE
0A80:  CALL    666
.................... 		StartUpTAOS(DeviceSelect); 
0A84:  MOV.B   DD7,W0L
0A86:  MOV.B   W0L,W4L
0A88:  SE      W4,W3
0A8A:  MOV     W3,DDA
0A8C:  CALL    6DC
....................         delay_ms(200); 
0A90:  MOV     #C8,W0
0A92:  CALL    356
.................... 		ReadColorTAOS(2,DeviceSelect);  //green 
0A96:  MOV.B   DD7,W0L
0A98:  MOV.B   W0L,W4L
0A9A:  SE      W4,W3
0A9C:  MOV     W3,DDC
0A9E:  MOV     #2,W3
0AA0:  MOV     W3,DDA
0AA2:  CALL    740
....................  
.................... 		green = colorlow + colorhigh * 256; 
0AA6:  MOV     AA2,W4
0AA8:  MOV     #100,W3
0AAA:  MUL.SS  W4,W3,W0
0AAC:  MOV     AA0,W4
0AAE:  ADD     W0,W4,W0
0AB0:  MOV     W0,AA6
....................  
.................... 		ReadColorTAOS(1,DeviceSelect);  //red 
0AB2:  MOV.B   DD7,W0L
0AB4:  MOV.B   W0L,W4L
0AB6:  SE      W4,W3
0AB8:  MOV     W3,DDC
0ABA:  MOV     #1,W3
0ABC:  MOV     W3,DDA
0ABE:  CALL    740
.................... 		red = colorlow + colorhigh * 256; 
0AC2:  MOV     AA2,W4
0AC4:  MOV     #100,W3
0AC6:  MUL.SS  W4,W3,W0
0AC8:  MOV     AA0,W4
0ACA:  ADD     W0,W4,W0
0ACC:  MOV     W0,AA4
....................  
.................... 		ReadColorTAOS(4,DeviceSelect);  //clear 
0ACE:  MOV.B   DD7,W0L
0AD0:  MOV.B   W0L,W4L
0AD2:  SE      W4,W3
0AD4:  MOV     W3,DDC
0AD6:  MOV     #4,W3
0AD8:  MOV     W3,DDA
0ADA:  CALL    740
.................... 		clear = colorlow + colorhigh * 256; 
0ADE:  MOV     AA2,W4
0AE0:  MOV     #100,W3
0AE2:  MUL.SS  W4,W3,W0
0AE4:  MOV     AA0,W4
0AE6:  ADD     W0,W4,W0
0AE8:  MOV     W0,AAA
....................  
.................... 		ReadColorTAOS(3,DeviceSelect);  //blue 
0AEA:  MOV.B   DD7,W0L
0AEC:  MOV.B   W0L,W4L
0AEE:  SE      W4,W3
0AF0:  MOV     W3,DDC
0AF2:  MOV     #3,W3
0AF4:  MOV     W3,DDA
0AF6:  CALL    740
.................... 		blue = colorlow + colorhigh * 256; 
0AFA:  MOV     AA2,W4
0AFC:  MOV     #100,W3
0AFE:  MUL.SS  W4,W3,W0
0B00:  MOV     AA0,W4
0B02:  ADD     W0,W4,W0
0B04:  MOV     W0,AA8
....................  
.................... //***************************************************************** 
.................... // Created December 12, 2014 
.................... // This section changes each color to an ABS color using the gainIn scales 
.................... //***************************************************************** 
....................  
.................... 		if (GainIn == 0) 
0B06:  MOV.B   DD6,W0L
0B08:  SE      W0,W0
0B0A:  CP0     W0
0B0C:  BRA     NZ,B12
.................... 			{ 
.................... 			gainMultiplyer =  1; 
0B0E:  MOV     #1,W4
0B10:  MOV     W4,DD8
.................... 			} 
.................... 		if (GainIn == 1) 
0B12:  MOV.B   DD6,W0L
0B14:  SE      W0,W0
0B16:  CP      W0,#1
0B18:  BRA     NZ,B1E
.................... 			{ 
.................... 			gainMultiplyer =  4; 
0B1A:  MOV     #4,W4
0B1C:  MOV     W4,DD8
.................... 			} 
.................... 		if (GainIn == 2) 
0B1E:  MOV.B   DD6,W0L
0B20:  SE      W0,W0
0B22:  CP      W0,#2
0B24:  BRA     NZ,B2A
.................... 			{ 
.................... 			gainMultiplyer =  16; 
0B26:  MOV     #10,W4
0B28:  MOV     W4,DD8
.................... 			} 
.................... 		if (GainIn == 3) 
0B2A:  MOV.B   DD6,W0L
0B2C:  SE      W0,W0
0B2E:  CP      W0,#3
0B30:  BRA     NZ,B36
.................... 			{ 
.................... 			gainMultiplyer =  64; 
0B32:  MOV     #40,W4
0B34:  MOV     W4,DD8
.................... 			} 
.................... 		redABS = (unsigned int32) red * (unsigned int32) gainMultiplyer; 
0B36:  MOV     AA4,W5
0B38:  MOV     #0,W6
0B3A:  MOV     DD8,W0
0B3C:  MOV     #0,W1
0B3E:  MOV     W0,W2
0B40:  MOV     W1,W3
0B42:  MOV     W5,W0
0B44:  MOV     W6,W1
0B46:  CALL    A40
0B4A:  MOV     W0,BC8
0B4C:  MOV     W1,BCA
.................... 		greenABS = (unsigned int32) green * (unsigned int32) gainMultiplyer; 
0B4E:  MOV     AA6,W5
0B50:  MOV     #0,W6
0B52:  MOV     DD8,W0
0B54:  MOV     #0,W1
0B56:  MOV     W0,W2
0B58:  MOV     W1,W3
0B5A:  MOV     W5,W0
0B5C:  MOV     W6,W1
0B5E:  CALL    A40
0B62:  MOV     W0,BD0
0B64:  MOV     W1,BD2
.................... 		blueABS = (unsigned int32) blue * (unsigned int32) gainMultiplyer; 
0B66:  MOV     AA8,W5
0B68:  MOV     #0,W6
0B6A:  MOV     DD8,W0
0B6C:  MOV     #0,W1
0B6E:  MOV     W0,W2
0B70:  MOV     W1,W3
0B72:  MOV     W5,W0
0B74:  MOV     W6,W1
0B76:  CALL    A40
0B7A:  MOV     W0,BCC
0B7C:  MOV     W1,BCE
.................... 		clearABS = (unsigned int32) clear * (unsigned int32) gainMultiplyer; 
0B7E:  MOV     AAA,W5
0B80:  MOV     #0,W6
0B82:  MOV     DD8,W0
0B84:  MOV     #0,W1
0B86:  MOV     W0,W2
0B88:  MOV     W1,W3
0B8A:  MOV     W5,W0
0B8C:  MOV     W6,W1
0B8E:  CALL    A40
0B92:  MOV     W0,BD4
0B94:  MOV     W1,BD6
.................... 		return(GainIn); 
0B96:  MOV.B   DD6,W0L
0B98:  MOV.B   W0L,0
0B9A:  MOV     [--W15],W6
0B9C:  MOV     [--W15],W5
0B9E:  RETURN  
....................  
.................... 		} 
....................  
....................  
.................... //******************************************************************************************* 
.................... // Created Nov 23, 2014 
.................... //  This takes several color readings and then averages them together.  This is a direct drop in 
.................... // for the current "int8 GetCurrentColor(int8 GainIn, int8 DeviceSelect)" 
.................... // Returns the gain and the returned value is in the global varaibles called 
.................... // red, green , blue and clear. 
.................... //  Changed May 18, 2015   
.................... // The below routine is changed from 20 samples to 200 to get the stability down 
.................... //******************************************************************************************* 
.................... int8 GetCurrentColorAVG(int8 GainIn, int8 DeviceSelect) 
*
1812:  MOV     W5,[W15++]
1814:  MOV     W6,[W15++]
1816:  MOV     #A,W4
1818:  MOV     W4,DD2
.................... 	{ 
.................... float tempred, tempblue, tempgreen, tempclear, ageraging;   //These are the averaging varaibles used for internal to the averaging calculations 
.................... int x,GainOut,averagesamples = 10; 
.................... unsigned int gainMultiplyer; 
....................  
....................  
....................  
.................... if (DeviceSelect == 3)   //If this is for DO and the light sensor 
181A:  MOV.B   DB9,W0L
181C:  SE      W0,W0
181E:  CP      W0,#3
1820:  BRA     NZ,1834
.................... 	{ 
.................... 	averagesamples = 5; 
1822:  MOV     #5,W4
1824:  MOV     W4,DD2
.................... 	ageraging = 5.0; 
1826:  CLR     DCA
1828:  MOV     #40A0,W4
182A:  MOV     W4,DCC
....................     selectsensor(3); 
182C:  MOV     #3,W4
182E:  MOV     W4,DE0
1830:  CALL    3AA
....................  
.................... 	} 
....................  
.................... if (DeviceSelect == 0)   //If this is for NH4 and the light sensor 
1834:  MOV.B   DB9,W0L
1836:  SE      W0,W0
1838:  CP0     W0
183A:  BRA     NZ,184C
.................... 	{ 
.................... 	averagesamples = 5; 
183C:  MOV     #5,W4
183E:  MOV     W4,DD2
.................... 	ageraging = 5.0; 
1840:  CLR     DCA
1842:  MOV     #40A0,W4
1844:  MOV     W4,DCC
....................     selectsensor(0); 
1846:  CLR     DE0
1848:  CALL    3AA
....................  
.................... 	} 
.................... if (DeviceSelect == 1)   //If this is for NH4 and the light sensor 
184C:  MOV.B   DB9,W0L
184E:  SE      W0,W0
1850:  CP      W0,#1
1852:  BRA     NZ,1866
.................... 	{ 
.................... 	averagesamples = 5; 
1854:  MOV     #5,W4
1856:  MOV     W4,DD2
.................... 	ageraging = 5.0; 
1858:  CLR     DCA
185A:  MOV     #40A0,W4
185C:  MOV     W4,DCC
....................     selectsensor(1); 
185E:  MOV     #1,W4
1860:  MOV     W4,DE0
1862:  CALL    3AA
....................  
.................... 	} 
....................  
.................... 	tempred = 0.0; 
1866:  CLR     DBA
1868:  CLR     DBC
.................... 	tempblue = 0.0; 
186A:  CLR     DBE
186C:  CLR     DC0
.................... 	tempgreen = 0.0; 
186E:  CLR     DC2
1870:  CLR     DC4
.................... 	tempclear = 0.0; 
1872:  CLR     DC6
1874:  CLR     DC8
.................... 	for (x = 0; x < averagesamples; x++) 
1876:  CLR     DCE
1878:  MOV     DCE,W0
187A:  MOV     DD2,W4
187C:  CP      W4,W0
187E:  BRA     LE,1982
.................... 		{ 
.................... 		GainOut = GetCurrentColor(GainIn, DeviceSelect); 
1880:  MOV.B   DB8,W0L
1882:  MOV.B   W0L,DD6
1884:  MOV.B   DB9,W0L
1886:  MOV.B   W0L,DD7
1888:  CALL    A70
188C:  SE      W0,W0
188E:  MOV     W0,DD0
....................  
.................... //fprintf(BT,"Raw Unaveraged 1 Red,%Lu,Green,%Lu,Blue,%Lu,Clear,%Lu\n\r",redABS,greenABS,blueABS,clearABS); 
.................... //***************************************************************** 
.................... // Created December 12, 2014 
.................... // This section changes each color to an ABS color using the gainIn scales 
.................... //***************************************************************** 
....................  
.................... 		if (GainOut == 3) 
1890:  MOV     DD0,W4
1892:  CP      W4,#3
1894:  BRA     NZ,189A
.................... 			{ 
.................... 			gainMultiplyer =  1; 
1896:  MOV     #1,W4
1898:  MOV     W4,DD4
.................... 			} 
.................... 		if (GainOut == 2) 
189A:  MOV     DD0,W4
189C:  CP      W4,#2
189E:  BRA     NZ,18A4
.................... 			{ 
.................... 			gainMultiplyer =  4; 
18A0:  MOV     #4,W4
18A2:  MOV     W4,DD4
.................... 			} 
.................... 		if (GainOut == 1) 
18A4:  MOV     DD0,W4
18A6:  CP      W4,#1
18A8:  BRA     NZ,18AE
.................... 			{ 
.................... 			gainMultiplyer =  16; 
18AA:  MOV     #10,W4
18AC:  MOV     W4,DD4
.................... 			} 
.................... 		if (GainOut == 0) 
18AE:  CP0     DD0
18B0:  BRA     NZ,18B6
.................... 			{ 
.................... 			gainMultiplyer =  64; 
18B2:  MOV     #40,W4
18B4:  MOV     W4,DD4
.................... 			} 
....................  
....................  
.................... 		redABS = (unsigned int32) red * (unsigned int32) gainMultiplyer; 
18B6:  MOV     AA4,W5
18B8:  MOV     #0,W6
18BA:  MOV     DD4,W0
18BC:  MOV     #0,W1
18BE:  MOV     W0,W2
18C0:  MOV     W1,W3
18C2:  MOV     W5,W0
18C4:  MOV     W6,W1
18C6:  CALL    A40
18CA:  MOV     W0,BC8
18CC:  MOV     W1,BCA
.................... 		greenABS = (unsigned int32) green * (unsigned int32) gainMultiplyer; 
18CE:  MOV     AA6,W5
18D0:  MOV     #0,W6
18D2:  MOV     DD4,W0
18D4:  MOV     #0,W1
18D6:  MOV     W0,W2
18D8:  MOV     W1,W3
18DA:  MOV     W5,W0
18DC:  MOV     W6,W1
18DE:  CALL    A40
18E2:  MOV     W0,BD0
18E4:  MOV     W1,BD2
.................... 		blueABS = (unsigned int32) blue * (unsigned int32) gainMultiplyer; 
18E6:  MOV     AA8,W5
18E8:  MOV     #0,W6
18EA:  MOV     DD4,W0
18EC:  MOV     #0,W1
18EE:  MOV     W0,W2
18F0:  MOV     W1,W3
18F2:  MOV     W5,W0
18F4:  MOV     W6,W1
18F6:  CALL    A40
18FA:  MOV     W0,BCC
18FC:  MOV     W1,BCE
.................... 		clearABS = (unsigned int32) clear * (unsigned int32) gainMultiplyer; 
18FE:  MOV     AAA,W5
1900:  MOV     #0,W6
1902:  MOV     DD4,W0
1904:  MOV     #0,W1
1906:  MOV     W0,W2
1908:  MOV     W1,W3
190A:  MOV     W5,W0
190C:  MOV     W6,W1
190E:  CALL    A40
1912:  MOV     W0,BD4
1914:  MOV     W1,BD6
....................  
....................  
....................  
.................... 		tempred = tempred + (float) redABS; 
1916:  MOV     BC8,W0
1918:  MOV     BCA,W1
191A:  CALL    1784
191E:  BCLR.B  43.0
1920:  MOV     W0,W2
1922:  MOV     W1,W3
1924:  MOV     DBA,W0
1926:  MOV     DBC,W1
1928:  CALL    DBC
192C:  MOV     W0,DBA
192E:  MOV     W1,DBC
.................... 		tempblue = tempblue + (float) blueABS; 
1930:  MOV     BCC,W0
1932:  MOV     BCE,W1
1934:  CALL    1784
1938:  BCLR.B  43.0
193A:  MOV     W0,W2
193C:  MOV     W1,W3
193E:  MOV     DBE,W0
1940:  MOV     DC0,W1
1942:  CALL    DBC
1946:  MOV     W0,DBE
1948:  MOV     W1,DC0
.................... 		tempgreen = tempgreen + (float) greenABS; 
194A:  MOV     BD0,W0
194C:  MOV     BD2,W1
194E:  CALL    1784
1952:  BCLR.B  43.0
1954:  MOV     W0,W2
1956:  MOV     W1,W3
1958:  MOV     DC2,W0
195A:  MOV     DC4,W1
195C:  CALL    DBC
1960:  MOV     W0,DC2
1962:  MOV     W1,DC4
.................... 		tempclear = tempclear + (float) clearABS; 
1964:  MOV     BD4,W0
1966:  MOV     BD6,W1
1968:  CALL    1784
196C:  BCLR.B  43.0
196E:  MOV     W0,W2
1970:  MOV     W1,W3
1972:  MOV     DC6,W0
1974:  MOV     DC8,W1
1976:  CALL    DBC
197A:  MOV     W0,DC6
197C:  MOV     W1,DC8
197E:  INC     0DCE
1980:  BRA     1878
.................... 		} 
.................... 	tempred = tempred/ageraging; 
1982:  MOV     DBA,W0
1984:  MOV     DBC,W1
1986:  MOV     DCA,W2
1988:  MOV     DCC,W3
198A:  CALL    CF2
198E:  MOV     W0,DBA
1990:  MOV     W1,DBC
.................... 	tempblue = tempblue/ageraging; 
1992:  MOV     DBE,W0
1994:  MOV     DC0,W1
1996:  MOV     DCA,W2
1998:  MOV     DCC,W3
199A:  CALL    CF2
199E:  MOV     W0,DBE
19A0:  MOV     W1,DC0
.................... 	tempgreen = tempgreen/ageraging; 
19A2:  MOV     DC2,W0
19A4:  MOV     DC4,W1
19A6:  MOV     DCA,W2
19A8:  MOV     DCC,W3
19AA:  CALL    CF2
19AE:  MOV     W0,DC2
19B0:  MOV     W1,DC4
.................... 	tempclear = tempclear/ageraging; 
19B2:  MOV     DC6,W0
19B4:  MOV     DC8,W1
19B6:  MOV     DCA,W2
19B8:  MOV     DCC,W3
19BA:  CALL    CF2
19BE:  MOV     W0,DC6
19C0:  MOV     W1,DC8
.................... 	redABS = (unsigned int32) tempred; 
19C2:  MOV     DBA,W0
19C4:  MOV     DBC,W1
19C6:  CALL    17D2
19CA:  MOV     W0,BC8
19CC:  MOV     W1,BCA
.................... 	blueABS = (unsigned int32) tempblue; 
19CE:  MOV     DBE,W0
19D0:  MOV     DC0,W1
19D2:  CALL    17D2
19D6:  MOV     W0,BCC
19D8:  MOV     W1,BCE
.................... 	greenABS = (unsigned int32) tempgreen; 
19DA:  MOV     DC2,W0
19DC:  MOV     DC4,W1
19DE:  CALL    17D2
19E2:  MOV     W0,BD0
19E4:  MOV     W1,BD2
.................... 	clearABS = (unsigned int32) tempclear; 
19E6:  MOV     DC6,W0
19E8:  MOV     DC8,W1
19EA:  CALL    17D2
19EE:  MOV     W0,BD4
19F0:  MOV     W1,BD6
.................... //fprintf(BT,"Raw Unaveraged 3 Red,%Lu,Green,%Lu,Blue,%Lu,Clear,%Lu\n\r",redABS,greenABS,blueABS,clearABS); 
.................... //fprintf(BT,"Blue %Lu  Gain %i ",blueABS, GainOut); 
....................  
.................... 	return(GainOut); 
19F2:  MOV.B   DD0,W0L
19F4:  MOV.B   W0L,0
19F6:  MOV     [--W15],W6
19F8:  MOV     [--W15],W5
19FA:  RETURN  
.................... 	} 
....................  
....................  
.................... //*************************************************************************************** 
.................... // Created Dec. 8, 2014 
.................... // This routine find the ambiant light and saves it as global variables for ph and DO routines to use. 
.................... //  The input is the selected sensor with the LED turned off.  The results are saved. 
.................... // Changed December 12, 2014 
.................... //  Removed the averaging part of the program and used the GetCurrentColorABS program instead 
.................... //  It has twice as many reading for averaging. 
.................... //*************************************************************************************** 
.................... void FindAmbientLight(int DeviceSelect) 
.................... 	{ 
.................... 		GetCurrentColorAVG(3,DeviceSelect); 
....................  
.................... 	if (DeviceSelect == 1)   //Setup the OXyegen offsets. 
.................... 		{ 
.................... 		AmbientOxyRed = redABS; 
.................... 		AmbientOxyGreen = greenABS; 
.................... 		AmbientOxyBlue = blueABS; 
.................... 		AmbientOxyClear = clearABS; 
.................... 		} 
....................  
.................... 	if (DeviceSelect == 2)  //Setup the PH offsets. 
.................... 		{ 
.................... 		AmbientPHRed = redABS; 
.................... 		AmbientPHGreen = greenABS; 
.................... 		AmbientPHBlue = blueABS; 
.................... 		AmbientPHClear = clearABS; 
.................... 		} 
....................          
....................        if (DeviceSelect == 9)  //Setup the PH offsets. 
.................... 		{ 
.................... 		Ambientnh3Red = redABS; 
.................... 		Ambientnh3Green = greenABS; 
.................... 		Ambientnh3Blue = blueABS; 
.................... 		Ambientnh3Clear = clearABS; 
.................... 		} 
....................  
.................... 	} 
....................  
....................  
....................  
....................  
.................... //******************************************************************** 
.................... // Created March 19, 2013 
.................... // Get the version of the device.  This  routine is used for testing I2C. 
.................... // Command 0x04 
.................... // This routine returns the version of the light chip.  
.................... //********************************************************************* 
.................... int getTAOSVersion(int lightsensor) 
.................... 	{ 
.................... int8 version; 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
....................  
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
....................  
.................... 	i2c_start(PH_LIGHT); 
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
.................... 	i2c_write(PH_LIGHT,0x84);  //Send the command for reading the version 
.................... 	i2c_stop(PH_LIGHT); 
....................     i2c_start(PH_LIGHT,0); 
.................... 	i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
.................... 	version = i2c_read(PH_LIGHT,0); 
.................... 	i2c_stop(PH_LIGHT); 
....................  
.................... 	return(version); 
.................... 	} 
....................  
....................  
.................... //*********************************************************************** 
.................... // Created March 20, 2013 
.................... // This routine changes the exposure time for each sample. 
.................... //  There are three modes of intigration or exposure time per sample. 
.................... // 0 for 12ms 
.................... // 1 for 100 ms 
.................... // 2 for 400 ms 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the room 
.................... //*********************************************************************** 
.................... void ExposureTimeTAOS(byte integration, byte lightsensor) 
.................... 	{ 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
*
0406:  MOV.B   DBB,W0L
0408:  MOV.B   W0L,DE0
040A:  CLR.B   DE1
040C:  CALL    3AA
....................  
.................... // then send the command down to the sensor.  All of the communication is done through the I2C on PH_LIGHT. 
.................... 	i2c_start(PH_LIGHT); 
0410:  BTSS.B  208.3
0412:  BRA     41C
0414:  BSET.B  206.1
0416:  BTSC.B  206.1
0418:  BRA     416
041A:  BRA     422
041C:  BSET.B  206.0
041E:  BTSC.B  206.0
0420:  BRA     41E
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
0422:  MOV.B   #72,W1L
0424:  CALL    3EE
.................... 	i2c_write(PH_LIGHT,0x81);  //Send the command for reading the Timing Register 
0428:  MOV.B   #81,W1L
042A:  CALL    3EE
.................... 	i2c_write(PH_LIGHT,integration);  //Send the command for reading the version 
042E:  MOV.B   DBA,W0L
0430:  MOV.B   W0L,2
0432:  CALL    3EE
.................... 	i2c_stop(PH_LIGHT); 
0436:  MOV     #1F,W0
0438:  AND     206,W0
043A:  BRA     NZ,436
043C:  BSET.B  206.2
043E:  BTSC.B  206.2
0440:  BRA     43E
0442:  RETURN  
....................  
.................... 	}  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************************** 
.................... // Created April 27, 2014 
.................... //This routine inits all of the slave I2C where they have a gain of 1 and start with no ND filteration 
.................... //***************************************************************************************** 
.................... void InitTAOS(void) 
.................... { 
....................  
.................... int8 x; 
....................  
....................  
....................  
.................... //setTAOSGain(1,0); //Gain and then scale 
.................... //setTAOSGain(gain,1); //Gain and then scale 
.................... //setTAOSGain(1,2); //Gain and then scale 
.................... //setTAOSGain(gain,3); //Gain and then scale 
.................... //setTAOSGain(1,4); //Gain and then scale 
.................... //setTAOSGain(gain,5); //Gain and then scale 
....................  
.................... ExposureTimeTAOS(1,0);   // this is for Dph   intigration time of 400ms at number 2 
0444:  MOV.B   #1,W0L
0446:  MOV.B   W0L,DBA
0448:  CLR.B   DBB
044A:  CALL    406
.................... ExposureTimeTAOS(0,1);   //This is for the DO  // Changed to 400ms exposure and then more light.   
044E:  CLR.B   DBA
0450:  MOV.B   #1,W0L
0452:  MOV.B   W0L,DBB
0454:  CALL    406
.................... ExposureTimeTAOS(1,3);   //This is for the NH4  //  
0458:  MOV.B   #1,W0L
045A:  MOV.B   W0L,DBA
045C:  MOV.B   #3,W0L
045E:  MOV.B   W0L,DBB
0460:  CALL    406
0464:  RETURN  
....................  
.................... /* 
.................... for (x=0; x < 4; x++)	    // This runs through all of the sensors and starts them up.  Updated December 8, 2015 
.................... 	{ 
.................... 	StartUpTAOS(x); 
.................... 	} 
.................... */ 
....................  
....................  
.................... } 
....................  
....................  
....................  
.................... //************************************************************************* 
.................... // Created November 14, 2016 
.................... // This routine runs the self test for all of the LEDs on the board. 
.................... // The routine returns nothing. 
.................... //************************************************************************* 
.................... void LEDtest(void) 
.................... { 
....................     //  turn off all LEDs 
....................     output_low(PIN_B12);    // turn off the blue light 
*
0366:  BCLR.B  2C9.4
0368:  BCLR.B  2CD.4
....................      
....................     output_low(PIN_B5);  // turn off orange DpH LED 
036A:  BCLR.B  2C8.5
036C:  BCLR.B  2CC.5
....................     output_high(PIN_B11);  // turn off blue 
036E:  BCLR.B  2C9.3
0370:  BSET.B  2CD.3
....................     output_high(PIN_B10);  // turn off red 
0372:  BCLR.B  2C9.2
0374:  BSET.B  2CD.2
....................   
....................      
....................     output_high(PIN_B5);  // turn on white DpH LED 
0376:  BCLR.B  2C8.5
0378:  BSET.B  2CC.5
....................     delay_ms(250); 
037A:  MOV     #FA,W0
037C:  CALL    356
....................     output_low(PIN_B5);  // turn off orange DpH LED 
0380:  BCLR.B  2C8.5
0382:  BCLR.B  2CC.5
....................     output_high(PIN_B12);  // turn on blue for DO    
0384:  BCLR.B  2C9.4
0386:  BSET.B  2CD.4
....................      delay_ms(250); 
0388:  MOV     #FA,W0
038A:  CALL    356
....................     output_low(PIN_B12);  // turn off blue DO 
038E:  BCLR.B  2C9.4
0390:  BCLR.B  2CD.4
....................     output_low(PIN_B10);  // turn on red    
0392:  BCLR.B  2C9.2
0394:  BCLR.B  2CD.2
....................     delay_ms(250); 
0396:  MOV     #FA,W0
0398:  CALL    356
....................  
....................  
....................     output_high(PIN_B11);  // turn off blue 
039C:  BCLR.B  2C9.3
039E:  BSET.B  2CD.3
....................     output_high(PIN_B10);  // turn off red 
03A0:  BCLR.B  2C9.2
03A2:  BSET.B  2CD.2
....................     output_low(PIN_B5);  // turn off red for p  
03A4:  BCLR.B  2C8.5
03A6:  BCLR.B  2CC.5
03A8:  RETURN  
.................... } 
....................  
.................... #include "C:\Aquarium Software\Debug Monitor\CommonPassedDataFromMaterToSlave.h" 
.................... //********************************************************************************************** 
.................... // Created November 23, 2016 
.................... //these are the calibration varibles so far on the tester.   
.................... //********************************************************************************************** 
....................  
.................... typedef struct { 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
.................... float eccal1x; 
.................... float eccal2x; 
.................... float eccal3x; 
.................... float eccal1y; 
.................... float eccal2y; 
.................... float eccal3y; 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... }Calstuff; 
.................... Calstuff sysInput;  
.................... /* 
....................  
.................... typedef struct inputDataStruct{ 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... float eccal1x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal1y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3y;    //  This the EC data point  Added July 18, 2016 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... }inputData; 
.................... inputData sysInput; 
....................  
.................... */ 
....................  
.................... #ifdef SLAVE 
....................  
.................... float Temp1DOOne; 
.................... float Temp1DOTwo; 
.................... float Temp1DOThree; 
.................... float Temp2DOOne; 
.................... float Temp2DOTwo; 
.................... float Temp2DOThree; 
.................... float Temp3DOOne; 
.................... float Temp3DOTwo; 
.................... float Temp3DOThree; 
.................... float Temp1ReadingOne; 
.................... float Temp1ReadingTwo; 
.................... float Temp1ReadingThree; 
.................... float Temp2ReadingOne; 
.................... float Temp2ReadingTwo; 
.................... float Temp2ReadingThree; 
.................... float Temp3ReadingOne; 
.................... float Temp3ReadingTwo; 
.................... float Temp3ReadingThree; 
....................  
.................... unsigned int16 TempOne; 
.................... unsigned int16 TempTwo; 
.................... unsigned int16 TempThree; 
....................  
.................... #endif 
....................  
.................... #include "..\OsomobotCarbonDioxideDigitalSensor\OsomobotCarbonDioxideDigitalSensor.X\ITwoSeeGeneralCommunicationSlave.c"     // this is included to connect to the master Osmobot. 
.................... //*************************************************************************************** 
.................... // Created October 16, 2016 
.................... // This file is included in project to make this unit a slave for the Osmobot. 
.................... // include this in the top of the project and update the data array with the data wanting to be returned. 
.................... //************************************************************************************** 
.................... //#define SDAPIN PIN_B2 
.................... //#define SCLPIN PIN_B3 
....................  
.................... //#use I2C(stream=SENSOR, SLAVE, sda=SDAPIN,scl=SCLPIN, FORCE_HW, address=0xa0, NO_STRETCH)   // this is I2C 1 
....................  
.................... char send_buffer[65];   // this is filled by this unit for sending data. 
.................... unsigned int8 rcv_buffer[65];   // this is the received data from the master  
.................... unsigned  int8 address, streamCntr=0;  
....................  
....................  
.................... //*************************************************************************** 
.................... // Created Oct 7, 2016 
.................... // Updated Oct 16, 2016  -- Added CO2 structure for sending data.  -- Changed the number of registers to 100 from 20. 
.................... // This routine sets the protocal for communicating to a remote custom I2c device. 
.................... // The frames and commands are as follows: 
.................... // Address 0x12  for this device. 
.................... // write a command to the command register before reading or writing to the device 
.................... // Command Register  :    01    // A one for R reads all data points from the unit   //  A one for W writes calibration numbers for all instruments 
.................... //      MSB                  LSB 
.................... //       7  6  5  4  3  2  1  0 
.................... //       X  X  X  X  X  X  R  W 
.................... // There are 20 registers (bytes) for reading data from the unit 
.................... // There are 40 registers (bytes) for writing data to the unit 
.................... // Reading frame definition     --  has to be done in sequence each time. 
.................... // 1: HN4  whole number portion of reading 
.................... // 2: NH4  fraction of the reading 
.................... // 3: DO  whole number portion of reading 
.................... // 4: DO  fraction of the reading 
.................... // 5: Water Temperature  whole number portion of reading 
.................... // 6: Water Temperature  fraction of the reading 
.................... // 7: CO2 High byte    Updated Oct 16, 2016 
.................... // 8: CO2 Low Byte   Updated Oct 16, 2016 
.................... // 9: Air Temperature whole number    Updated Oct 24, 2016 
.................... // 10: Air Temperature fractional part   Updated Oct 24, 2016 
.................... // 11: Air RH  whole number   Updated Oct 24, 2016 
.................... // 12: Air RH fractional part    Updated Oct 24, 2016 
.................... // 13: Water Temperature High Byte raw data   Updated Feb 15, 2017 
.................... // 14: Water Temperature Low Byte raw data   Updated Feb 15, 2017 
.................... // 15: DO  RawData High Byte 
.................... // 16: DO  RawData Low Byte 
.................... // 17: NH4 RawData High Byte 
.................... // 18: NH4 RawData Low Byte 
....................         // Added Fab 26, 2017 
....................         // these items are the raw numbers for NH4 
.................... // 19: NH4 Patch RED RawData High Byte 
.................... // 20: NH4 Patch RED RawData Low Byte 
.................... // 21: NH4 Patch GREEN RawData High Byte 
.................... // 22: NH4 Patch GREEN RawData Low Byte 
.................... // 23: NH4 Patch BLUE RawData High Byte 
.................... // 24: NH4 Patch blue RawData Low Byte 
.................... // 25: NH4 Patch WHITE RawData High Byte 
.................... // 26: NH4 Patch WHITE RawData Low Byte 
.................... // 27: DpH  Digital Red RawData High Byte 
.................... // 28: DpH  Digital Red RawData Low Byte 
.................... // 29:  DpH Reading  whole number  updated March 30, 2017 
.................... // 30:  DpH fractional part  updated March 30, 2017 
.................... // 31: DpH  Digital Green RawData High Byte   updated April 3, 2017 
.................... // 32: DpH  Digital Green RawData Low Byte   updated April 3, 2017 
.................... // 33: DpH  Digital Blue RawData High Byte   updated April 3, 2017 
.................... // 34: DpH  Digital Blue RawData Low Byte   updated April 3, 2017 
.................... // 35: DpH  Digital White RawData High Byte   updated April 3, 2017 
.................... // 36: DpH  Digital White RawData Low Byte   updated April 3, 2017 
.................... // XX:  TBD 
....................  
....................  
.................... /* 
....................  unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... float eccal1x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal1y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3y;    //  This the EC data point  Added July 18, 2016 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
....................  */ 
....................  
....................  
....................  
....................  
....................  
.................... // Writing frame definition  --  has to be done in sequence each time. 
.................... // 1: HN4  whole number portion of HN4 calibration for point 1 
.................... // 2: NH4  fraction of the reading of HN4 calibration for point 1 
.................... // 3: HN4  whole number portion of HN4 calibration for point 2 
.................... // 4: NH4  fraction of the reading of HN4 calibration for point 2 
.................... // 5: HN4  whole number returned value of HN4 calibration for point 1 
.................... // 6: NH4  fraction of the returned value of HN4 calibration for point 1 
.................... // 7: HN4  whole number returned value of HN4 calibration for point 2 
.................... // 8: NH4  fraction of the returned value of HN4 calibration for point 2 
.................... // 9: TBD   all zeros 
.................... // 10: TBD 
.................... // 11: TBD 
.................... // 12: TBD 
.................... // 13: TBD 
.................... // 14: TBD 
.................... // 15: TBD 
.................... // 16: TBD 
.................... // 17: TBD 
.................... // 18: TBD 
.................... // 19: TBD 
.................... // 20: TBD 
.................... //  ...... 
.................... // 99: checksum high byte 
.................... // 100: checksum low byte 
.................... // returns a 1 if the checksum is OK and it receives data 
.................... //****************************************************************************** 
....................  
....................  
.................... //******************************************************************************* 
.................... // Create November 2, 2016 
.................... // Save this float into eeprom 
.................... // returns nothing. 
.................... //  give the pointer to the number, the location in eeprom and length 
.................... //****************************************************************************** 
.................... void eeprom_write_block(int16 *ptr, unsigned int8 addr, unsigned char len) 
.................... { 
....................   unsigned int16 *data = ptr; 
....................     unsigned int16 bufferin[4]; 
....................     unsigned int8 stuffit = addr; 
....................     len=len>>1;    // Since we are using 16 bits, two bytes are used at a time because of defs. 
....................     addr=addr<<1;   //mult by two offset to the correct location. 
....................  
....................     //read back the data 
....................    while (len--) { 
....................         write_eeprom(addr, *data++); 
....................         addr=addr+2;  // need to skip two bytes since this is a 16 bit CPU   
....................     }  
.................... //    bufferin[0] = read_eeprom[0]; 
....................  //   bufferin[1] = read_eeprom[2];        
....................  stuffit= stuffit+1;     
.................... } 
....................  
....................  
....................  
....................  
.................... float READ_FLOAT_EEPROM(long int n)  
*
04C0:  MOV     W5,[W15++]
04C2:  MOV     W6,[W15++]
04C4:  MOV     W7,[W15++]
.................... {  
....................    int i;  
....................    float data; 
....................  
....................    for (i = 0; i < 2; i++)  
04C6:  CLR     DC0
04C8:  MOV     DC0,W4
04CA:  CP      W4,#2
04CC:  BRA     GE,500
....................       *((int16*)&data + i) = read_eeprom(2*i + 2*n); 
04CE:  MOV     #DC2,W5
04D0:  MOV     DC0,W4
04D2:  MUL.UU  W4,#2,W0
04D4:  ADD     W0,W5,W0
04D6:  MOV     W0,W5
04D8:  MOV     DC0,W4
04DA:  MUL.UU  W4,#2,W6
04DC:  MOV     #2,W0
04DE:  MOV     #0,W1
04E0:  MOV     DBC,W2
04E2:  MOV     DBE,W3
04E4:  CALL    466
04E8:  ADD     W0,W6,W6
04EA:  ADDC    W1,#0,W7
04EC:  MOV     W5,[W15++]
04EE:  MOV     W6,W3
04F0:  MOV     #0,W4
04F2:  MOV     #2,W5
04F4:  CALL    4A8
04F8:  MOV     [--W15],W5
04FA:  MOV     W0,[W5]
04FC:  INC     0DC0
04FE:  BRA     4C8
....................  
....................    return(data);  
0500:  MOV     DC2,W0
0502:  MOV     DC4,W1
0504:  MOV     [--W15],W7
0506:  MOV     [--W15],W6
0508:  MOV     [--W15],W5
050A:  RETURN  
.................... } 
....................  
.................... //****************************************************************************** 
.................... // Documented Febuary 12, 2017 
.................... // This is the call for slave operation for a sensor board. 
.................... // It does the following functions: 
.................... // 1  Receives incoming data from the host 
.................... // 2  Sets the command register for sending back this modules ID 
.................... // 3 
.................... //****************************************************************************** 
.................... /* 
.................... #INT_SI2C2 
....................  
.................... void si2c2_interrupt() 
....................     { 
....................  
.................... unsigned int8  incoming, state; 
....................  
....................         state=i2c_isr_state(SENSOR); 
....................  
....................    if(state <= 0x80)                      //Master is sending data 
....................    { 
....................       incoming = i2c_read(SENSOR,1);  
....................       if(state == 1)                     //First received byte is address  
....................       {//First received byte is address 
....................          address = incoming; 
....................          streamCntr=0; 
....................       } 
....................       if(state == 2)                     //Second received byte is data  
....................           {   
....................           rcv_buffer[address] = incoming;  
....................           streamCntr=0; 
....................           } 
....................        
....................       if(state == 1)                      //First received byte is address 
....................          address = incoming; 
....................       else if(state >= 2 && state != 0x80)   //Received byte is data auto from the master 
....................            { 
....................             rcv_buffer[address++] = incoming; 
....................             streamCntr=0; 
....................             } 
....................    } 
....................  
....................    if((state >= 0x80) & (rcv_buffer[0x66] != 0x01))               //Master is requesting data 
....................    { 
....................       i2c_write(SENSOR,send_buffer[streamCntr++]); 
....................    } 
....................       if((state >= 0x80) & (rcv_buffer[0x66] == 0x01))               //Master is requesting data 
....................    { 
....................       i2c_write(SENSOR,SENSORNUMBER); 
....................       rcv_buffer[0x66]=0x00; 
....................    } 
.................... 	} 
....................  
....................   */   
....................      
.................... //****************************************************************************** 
.................... // Created October 17, 2016 
.................... // This is a check sum for the data sent through the I2C back to the master.  The numbers are split and put into the 
.................... // last two locations of the upload send_buffer[]. 
.................... //  Nothing is returned, but the data is updated in this function. 
.................... //****************************************************************************** 
.................... void CalculateCRC(void) 
.................... { 
....................     unsigned int16 checksum; 
....................     unsigned int8 checksumhigh, checksumlow, x; 
....................     for (x=0; x < 98; x++) 
....................     { 
....................     checksum = checksum + send_buffer[x]; 
....................     } 
....................     //seperate the numbers into high and low 
....................     checksumlow = 0x00FF & checksum; 
....................     //  place the numbers in the array 
....................     checksumhigh = (0xFF00 & checksum)>>8; 
....................     send_buffer[98]=checksumhigh; 
....................     send_buffer[99]=checksumlow; 
.................... }     
....................      
.................... //****************************************************************************** 
.................... // Created Oct. 16, 2016 
.................... // this routine clears the data in the return buffer to all 0xFF.  This means if the data is 0xFF, there is no sensor data avaible and is ignored by the 
.................... // master CPU.  That means the main CPU master needs to go through all of the returned data and check to see if it is not 0xFF for all sets of bytes. 
.................... //****************************************************************************** 
....................  
....................     void initTransMitBuffer(void) 
*
033A:  MOV     W5,[W15++]
....................     { 
....................         // there are 100 points in the transmit buffer. 
....................         int x; 
....................         for (x = 0; x < 65; x++)   // set all of the returned data to 0xFF.  If there is data to be returned, it will change it to non 0xFF 
033C:  CLR     DB8
033E:  MOV     DB8,W4
0340:  MOV     #41,W3
0342:  CP      W3,W4
0344:  BRA     LE,352
....................         { 
....................             send_buffer[x] = 0xFF; 
0346:  MOV     #D20,W4
0348:  MOV     DB8,W3
034A:  ADD     W3,W4,W5
034C:  SETM.B  [W5]
034E:  INC     0DB8
0350:  BRA     33E
....................         } 
0352:  MOV     [--W15],W5
0354:  RETURN  
....................        
....................     } 
....................        
....................      
.................... //***************************************************************** 
.................... //Created November 2, 2016 
.................... //  This is the eeprom read function to load all of the calibration data from the eeprom 
.................... // This routine can be triggered from the program and from one of the commands from the I2C 
.................... // It returns all of the data read from the internal data eeprom 
.................... //****************************************************************** 
.................... int LoadConfiguration(void) 
.................... { 
....................     float checkvalue;   // this is used for returning the value and checking to see if it took. 
....................      
....................    /* 
....................     float Temp1DOOne = 9.5;            //These are the set points where we want to read these numbers at temperature 1 
.................... 	float Temp1DOTwo = 4.0;            //This is at 10 degrees 
.................... 	float Temp1DOThree = 0.0; 
.................... */  
....................     Temp1DOOne = READ_FLOAT_EEPROM(0); 
*
0538:  CLR     DBC
053A:  CLR     DBE
053C:  CALL    4C0
0540:  MOV     W0,CD2
0542:  MOV     W1,CD4
....................     Temp1DOTwo = READ_FLOAT_EEPROM(1); 
0544:  MOV     #1,W4
0546:  MOV     W4,DBC
0548:  CLR     DBE
054A:  CALL    4C0
054E:  MOV     W0,CD6
0550:  MOV     W1,CD8
....................     Temp1DOThree = READ_FLOAT_EEPROM(2); 
0552:  MOV     #2,W4
0554:  MOV     W4,DBC
0556:  CLR     DBE
0558:  CALL    4C0
055C:  MOV     W0,CDA
055E:  MOV     W1,CDC
....................     /* 
....................  
.................... 	float Temp2DOOne = 7.5;            //These are the set points where we want to read these numbers at temperature 2 
.................... 	float Temp2DOTwo = 4.0;				//This is at 20 degrees 
.................... 	float Temp2DOThree = 0.0; 
....................  
....................      */ 
....................     Temp2DOOne = READ_FLOAT_EEPROM(3); 
0560:  MOV     #3,W4
0562:  MOV     W4,DBC
0564:  CLR     DBE
0566:  CALL    4C0
056A:  MOV     W0,CDE
056C:  MOV     W1,CE0
....................     Temp2DOTwo = READ_FLOAT_EEPROM(4); 
056E:  MOV     #4,W4
0570:  MOV     W4,DBC
0572:  CLR     DBE
0574:  CALL    4C0
0578:  MOV     W0,CE2
057A:  MOV     W1,CE4
....................     Temp2DOThree = READ_FLOAT_EEPROM(5); 
057C:  MOV     #5,W4
057E:  MOV     W4,DBC
0580:  CLR     DBE
0582:  CALL    4C0
0586:  MOV     W0,CE6
0588:  MOV     W1,CE8
....................     /* 
.................... 	float Temp3DOOne = 6.7;            //These are the set points where we want to read these numbers temperature 3 
.................... 	float Temp3DOTwo = 4.0;            //This is at 25 degrees 
.................... 	float Temp3DOThree = 0.0;   
....................  */ 
....................     Temp3DOOne = READ_FLOAT_EEPROM(6); 
058A:  MOV     #6,W4
058C:  MOV     W4,DBC
058E:  CLR     DBE
0590:  CALL    4C0
0594:  MOV     W0,CEA
0596:  MOV     W1,CEC
....................     Temp3DOTwo = READ_FLOAT_EEPROM(7); 
0598:  MOV     #7,W4
059A:  MOV     W4,DBC
059C:  CLR     DBE
059E:  CALL    4C0
05A2:  MOV     W0,CEE
05A4:  MOV     W1,CF0
....................     Temp3DOThree = READ_FLOAT_EEPROM(8); 
05A6:  MOV     #8,W4
05A8:  MOV     W4,DBC
05AA:  CLR     DBE
05AC:  CALL    4C0
05B0:  MOV     W0,CF2
05B2:  MOV     W1,CF4
....................     /* 
....................       
....................     float Temp1ReadingOne = 10752.0;       //Readings for Temp3  10 degrees C 
.................... 	float Temp1ReadingTwo = 11000.0;      //Readings for Temp3 
.................... 	float Temp1ReadingThree = 12000.0;    //Readings for DOOne    this is no DO. 
....................       
....................      */ 
....................     Temp1ReadingOne = READ_FLOAT_EEPROM(9); 
05B4:  MOV     #9,W4
05B6:  MOV     W4,DBC
05B8:  CLR     DBE
05BA:  CALL    4C0
05BE:  MOV     W0,CF6
05C0:  MOV     W1,CF8
....................     Temp1ReadingTwo = READ_FLOAT_EEPROM(10); 
05C2:  MOV     #A,W4
05C4:  MOV     W4,DBC
05C6:  CLR     DBE
05C8:  CALL    4C0
05CC:  MOV     W0,CFA
05CE:  MOV     W1,CFC
....................     Temp1ReadingThree = READ_FLOAT_EEPROM(11); 
05D0:  MOV     #B,W4
05D2:  MOV     W4,DBC
05D4:  CLR     DBE
05D6:  CALL    4C0
05DA:  MOV     W0,CFE
05DC:  MOV     W1,D00
....................      /*  
....................       
.................... 	float Temp2ReadingOne = 11266.0;       //Readings for Temp3    20 degrees C 
.................... 	float Temp2ReadingTwo = 12000.0;      //Readings for Temp3 
.................... 	float Temp2ReadingThree = 13000.0;    //Readings for DOOne 
.................... */ 
....................     Temp2ReadingOne = READ_FLOAT_EEPROM(12); 
05DE:  MOV     #C,W4
05E0:  MOV     W4,DBC
05E2:  CLR     DBE
05E4:  CALL    4C0
05E8:  MOV     W0,D02
05EA:  MOV     W1,D04
....................     Temp2ReadingTwo = READ_FLOAT_EEPROM(13); 
05EC:  MOV     #D,W4
05EE:  MOV     W4,DBC
05F0:  CLR     DBE
05F2:  CALL    4C0
05F6:  MOV     W0,D06
05F8:  MOV     W1,D08
....................     Temp2ReadingThree = READ_FLOAT_EEPROM(14); 
05FA:  MOV     #E,W4
05FC:  MOV     W4,DBC
05FE:  CLR     DBE
0600:  CALL    4C0
0604:  MOV     W0,D0A
0606:  MOV     W1,D0C
....................     /* 
.................... 	float Temp3ReadingOne = 12425.0;       //Readings for Temp3   25 degrees C 
.................... 	float Temp3ReadingTwo = 13000.0;      //Readings for Temp3 
.................... 	float Temp3ReadingThree = 14000.0;    //Readings for DOOne 
.................... */ 
....................     Temp3ReadingOne = READ_FLOAT_EEPROM(15); 
0608:  MOV     #F,W4
060A:  MOV     W4,DBC
060C:  CLR     DBE
060E:  CALL    4C0
0612:  MOV     W0,D0E
0614:  MOV     W1,D10
....................     Temp3ReadingTwo = READ_FLOAT_EEPROM(16); 
0616:  MOV     #10,W4
0618:  MOV     W4,DBC
061A:  CLR     DBE
061C:  CALL    4C0
0620:  MOV     W0,D12
0622:  MOV     W1,D14
....................     Temp3ReadingThree = READ_FLOAT_EEPROM(17); 
0624:  MOV     #11,W4
0626:  MOV     W4,DBC
0628:  CLR     DBE
062A:  CALL    4C0
062E:  MOV     W0,D16
0630:  MOV     W1,D18
....................     /* 
....................     
.................... 	float TempOne = 10.0;       //Calibration temperatures for DO   Added April 7, 2015 
....................  	float TempTwo =  20.0;      //Calibration temperatures for DO  Added April 7, 2015 
.................... 	float TempThree =  25.0;     //Calibration temperatures for DO  Added April 7, 2015 
....................  
....................      */ 
....................     TempOne = READ_FLOAT_EEPROM(18); 
0632:  MOV     #12,W4
0634:  MOV     W4,DBC
0636:  CLR     DBE
0638:  CALL    4C0
063C:  CALL    50C
0640:  MOV     W0,D1A
....................     TempTwo = READ_FLOAT_EEPROM(19); 
0642:  MOV     #13,W4
0644:  MOV     W4,DBC
0646:  CLR     DBE
0648:  CALL    4C0
064C:  CALL    50C
0650:  MOV     W0,D1C
....................     TempThree = READ_FLOAT_EEPROM(20); 
0652:  MOV     #14,W4
0654:  MOV     W4,DBC
0656:  CLR     DBE
0658:  CALL    4C0
065C:  CALL    50C
0660:  MOV     W0,D1E
....................      
....................     return(0);   // if it makes it to here, everything is ok. 
0662:  CLR     0
0664:  RETURN  
.................... } 
....................  
.................... //******************************************************************************* 
.................... // Create November 2, 2016 
.................... // Save this float into eeprom 
.................... // returns nothing. 
.................... //  give the pointer to the number, the location in eeprom and length 
.................... //****************************************************************************** 
.................... void eeprom_write_blocktest(int16 *ptr, unsigned int8 addr, unsigned char len) 
.................... { 
....................   unsigned int16 *data = ptr; 
....................     unsigned int16 bufferin[4]; 
....................     unsigned int8 stuff = addr; 
....................     len=len>>1;    // Since we are using 16 bits, two bytes are used at a time because of defs. 
....................     addr=addr<<1;   //mult by two offset to the correct location. 
....................  
....................     //read back the data 
....................    while (len--) { 
....................         write_eeprom(addr, *data++); 
....................         addr=addr+2;  // need to skip two bytes since this is a 16 bit CPU   
....................     }  
....................  //   bufferin[0] = read_eeprom[stuff]; 
....................  //   bufferin[1] = read_eeprom[stuff+2];        
....................  stuff= stuff+1;     
.................... } 
....................  
....................  
....................  
.................... //***************************************************************** 
.................... //Created Oct. 19, 2016 
.................... //  This is the eeprom write function to save all of the calibration data to the eeprom 
.................... // This routine can be triggered from the program and from one of the commands from the I2C 
.................... // It returns a 0 if everything is OK,  A 1 is returned when it failed. 
.................... //  It does a write and reads back the data to make it made it. 
.................... //****************************************************************** 
.................... int SaveConfiguration(void) 
.................... { 
....................     float checkvalue;   // this is used for returning the value and checking to see if it took. 
....................      
....................    /* 
....................     float Temp1DOOne = 9.5;            //These are the set points where we want to read these numbers at temperature 1 
.................... 	float Temp1DOTwo = 4.0;            //This is at 10 degrees 
.................... 	float Temp1DOThree = 0.0; 
.................... */  
....................     eeprom_write_blocktest(&Temp1DOOne, 0, sizeof Temp1DOOne); 
....................     checkvalue = READ_FLOAT_EEPROM(0); 
....................     if (Temp1DOOne != checkvalue) 
....................         return(1);    // return this error 
....................     eeprom_write_blocktest(&Temp1DOTwo, 1, sizeof Temp1DOTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(1); 
....................     if (Temp1DOTwo != checkvalue) 
....................         return(2);    // return this error 
....................      eeprom_write_blocktest(&Temp1DOThree, 2, sizeof Temp1DOThree); 
....................     checkvalue = READ_FLOAT_EEPROM(2); 
....................     if (Temp1DOThree != checkvalue) 
....................         return(3);    // return this error 
....................      
....................     // this routine saves the data for the NH4, EC, DO and temperature 
....................     /* 
....................  
.................... 	float Temp2DOOne = 7.5;            //These are the set points where we want to read these numbers at temperature 2 
.................... 	float Temp2DOTwo = 4.0;				//This is at 20 degrees 
.................... 	float Temp2DOThree = 0.0; 
....................  
....................      */ 
....................     eeprom_write_block(&Temp2DOOne, 3, sizeof Temp2DOOne); 
....................     checkvalue = READ_FLOAT_EEPROM(3); 
....................     if (Temp2DOOne != checkvalue) 
....................         return(4);    // return this error 
....................     eeprom_write_block(&Temp2DOTwo, 4, sizeof Temp2DOTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(4); 
....................     if (Temp2DOTwo != checkvalue) 
....................         return(5);    // return this error 
....................      eeprom_write_block(&Temp2DOThree, 5, sizeof Temp2DOThree); 
....................     checkvalue = READ_FLOAT_EEPROM(5); 
....................     if (Temp2DOThree != checkvalue) 
....................         return(6);    // return this error 
....................     
....................     /* 
.................... 	float Temp3DOOne = 6.7;            //These are the set points where we want to read these numbers temperature 3 
.................... 	float Temp3DOTwo = 4.0;            //This is at 25 degrees 
.................... 	float Temp3DOThree = 0.0;   
....................  */ 
....................      
....................     eeprom_write_block(&Temp3DOOne, 6, sizeof Temp3DOOne); 
....................     checkvalue = READ_FLOAT_EEPROM(6); 
....................     if (Temp3DOOne != checkvalue) 
....................         return(7);    // return this error 
....................     eeprom_write_block(&Temp3DOTwo, 7, sizeof Temp3DOTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(7); 
....................     if (Temp3DOTwo != checkvalue) 
....................         return(8);    // return this error 
....................      eeprom_write_block(&Temp3DOThree, 8, sizeof Temp3DOThree); 
....................     checkvalue = READ_FLOAT_EEPROM(8); 
....................     if (Temp3DOThree != checkvalue) 
....................         return(9);    // return this error   
....................     /* 
....................       
....................     float Temp1ReadingOne = 10752.0;       //Readings for Temp3  10 degrees C 
.................... 	float Temp1ReadingTwo = 11000.0;      //Readings for Temp3 
.................... 	float Temp1ReadingThree = 12000.0;    //Readings for DOOne    this is no DO. 
....................       
....................      */ 
....................      
....................     eeprom_write_block(&Temp1ReadingOne, 9, sizeof Temp1ReadingOne); 
....................     checkvalue = READ_FLOAT_EEPROM(9); 
....................     if (Temp1ReadingOne != checkvalue) 
....................         return(10);    // return this error 
....................     eeprom_write_block(&Temp1ReadingTwo, 10, sizeof Temp1ReadingTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(10); 
....................     if (Temp1ReadingTwo != checkvalue) 
....................         return(11);    // return this error 
....................      eeprom_write_block(&Temp1ReadingThree, 11, sizeof Temp1ReadingThree); 
....................     checkvalue = READ_FLOAT_EEPROM(11); 
....................     if (Temp1ReadingThree != checkvalue) 
....................         return(12);    // return this error 
....................      
....................      /*  
....................       
....................  
.................... 	float Temp2ReadingOne = 11266.0;       //Readings for Temp3    20 degrees C 
.................... 	float Temp2ReadingTwo = 12000.0;      //Readings for Temp3 
.................... 	float Temp2ReadingThree = 13000.0;    //Readings for DOOne 
.................... */ 
....................     eeprom_write_block(&Temp2ReadingOne, 12, sizeof Temp2ReadingOne); 
....................     checkvalue = READ_FLOAT_EEPROM(12); 
....................     if (Temp2ReadingOne != checkvalue) 
....................         return(13);    // return this error 
....................     eeprom_write_block(&Temp2ReadingTwo, 13, sizeof Temp2ReadingTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(13); 
....................     if (Temp2ReadingTwo != checkvalue) 
....................         return(14);    // return this error 
....................      eeprom_write_block(&Temp2ReadingThree, 14, sizeof Temp2ReadingThree); 
....................     checkvalue = READ_FLOAT_EEPROM(14); 
....................     if (Temp2ReadingThree != checkvalue) 
....................         return(15);    // return this error 
....................     /* 
.................... 	float Temp3ReadingOne = 12425.0;       //Readings for Temp3   25 degrees C 
.................... 	float Temp3ReadingTwo = 13000.0;      //Readings for Temp3 
.................... 	float Temp3ReadingThree = 14000.0;    //Readings for DOOne 
.................... */ 
....................     eeprom_write_block(&Temp3ReadingOne, 15, sizeof Temp3ReadingOne); 
....................     checkvalue = READ_FLOAT_EEPROM(15); 
....................     if (Temp3ReadingOne != checkvalue) 
....................         return(16);    // return this error 
....................     eeprom_write_block(&Temp3ReadingTwo, 16, sizeof Temp3ReadingTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(16); 
....................     if (Temp3ReadingTwo != checkvalue) 
....................         return(17);    // return this error 
....................      eeprom_write_block(&Temp3ReadingThree, 17, sizeof Temp3ReadingThree); 
....................     checkvalue = READ_FLOAT_EEPROM(17); 
....................     if (Temp3ReadingThree != checkvalue) 
....................         return(18);    // return this error 
....................     /* 
....................     
.................... 	float TempOne = 10.0;       //Calibration temperatures for DO   Added April 7, 2015 
....................  	float TempTwo =  20.0;      //Calibration temperatures for DO  Added April 7, 2015 
.................... 	float TempThree =  25.0;     //Calibration temperatures for DO  Added April 7, 2015 
....................  
....................       
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
....................      */ 
....................      
....................     eeprom_write_block(&sysInput.DOpt1returnednumber, 18, sizeof sysInput.DOpt1returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(18); 
....................     if (sysInput.DOpt1returnednumber != checkvalue) 
....................         return(19);    // return this error 
....................     eeprom_write_block(&sysInput.DOpt2returnednumber, 19, sizeof sysInput.DOpt2returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(19); 
....................     if (sysInput.DOpt2returnednumber != checkvalue) 
....................         return(20);    // return this error 
....................      eeprom_write_block(&sysInput.DOpt3returnednumber, 20, sizeof sysInput.DOpt3returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(20); 
....................     if (sysInput.DOpt3returnednumber != checkvalue) 
....................         return(21);    // return this error 
....................      /* 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
....................     */ 
....................      
....................      
....................     eeprom_write_block(&sysInput.Thermisterpt1cal1of3, 21, sizeof sysInput.Thermisterpt1cal1of3); 
....................     checkvalue = READ_FLOAT_EEPROM(21); 
....................     if (sysInput.Thermisterpt1cal1of3 != checkvalue) 
....................         return(22);    // return this error 
....................     eeprom_write_block(&sysInput.Thermisterpt1cal2of3, 22, sizeof sysInput.Thermisterpt1cal2of3); 
....................     checkvalue = READ_FLOAT_EEPROM(22); 
....................     if (sysInput.Thermisterpt1cal2of3 != checkvalue) 
....................         return(23);    // return this error 
....................      eeprom_write_block(&sysInput.Thermisterpt1cal3of3, 23, sizeof sysInput.Thermisterpt1cal3of3); 
....................     checkvalue = READ_FLOAT_EEPROM(23); 
....................     if (sysInput.Thermisterpt1cal3of3 != checkvalue) 
....................         return(24);    // return this error 
....................      
.................... /* 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
....................   */ 
....................      
....................    eeprom_write_block(&sysInput.Thermisterpt1returnednumber, 24, sizeof sysInput.Thermisterpt1returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(24); 
....................     if (sysInput.Thermisterpt1returnednumber!= checkvalue) 
....................         return(25);    // return this error 
....................     eeprom_write_block(&sysInput.Thermisterpt2returnednumber, 25, sizeof sysInput.Thermisterpt2returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(25); 
....................     if (sysInput.Thermisterpt2returnednumber != checkvalue) 
....................         return(26);    // return this error 
....................      eeprom_write_block(&sysInput.Thermisterpt3returnednumber, 26, sizeof sysInput.Thermisterpt3returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(26); 
....................     if (sysInput.Thermisterpt3returnednumber != checkvalue) 
....................         return(27);    // return this error 
....................       
....................      
....................     return(0);   // if it makes it to here, everything is ok. 
.................... } 
....................  
....................  
....................  
.................... //********************************************************************************************* 
.................... // Created November 28, 2016 
.................... // This moves the data from the recieve buffer into the configuation varaubles. 
.................... // Returns nothing.  This is called when rcv_buffer[2] == 0x01 
.................... //********************************************************************************************* 
.................... void movercvbuffertocolibration(void) 
*
19FC:  MOV     W5,[W15++]
19FE:  MOV     W6,[W15++]
.................... { 
....................   
....................     int8 lowbyte,highbyte; 
....................     unsigned int16 items; 
....................     int i;  
....................    float data; 
....................         
....................     //these are the two byte int16s 
....................     lowbyte = rcv_buffer[3]; 
1A00:  MOV.B   D65,W0L
1A02:  MOV.B   W0L,DB8
....................     highbyte = rcv_buffer[4]; 
1A04:  MOV.B   D66,W0L
1A06:  MOV.B   W0L,DB9
....................     items = (int16) highbyte; 
1A08:  MOV.B   DB9,W0L
1A0A:  SE      W0,W0
1A0C:  MOV     W0,DBA
....................     sysInput.nh4pt1cal1of3 = (items<<8) +  lowbyte;   
1A0E:  MOV.B   DBA,W0L
1A10:  MOV.B   W0L,B
1A12:  CLR.B   W5
1A14:  MOV.B   DB8,W0L
1A16:  SE      W0,W0
1A18:  ADD     W0,W5,W0
1A1A:  MOV     W0,C5C
....................   
....................     lowbyte = rcv_buffer[5]; 
1A1C:  MOV.B   D67,W0L
1A1E:  MOV.B   W0L,DB8
....................     highbyte = rcv_buffer[6]; 
1A20:  MOV.B   D68,W0L
1A22:  MOV.B   W0L,DB9
....................     items = (int16) highbyte; 
1A24:  MOV.B   DB9,W0L
1A26:  SE      W0,W0
1A28:  MOV     W0,DBA
....................     sysInput.nh4pt1cal2of3 = (items<<8) +  lowbyte;   
1A2A:  MOV.B   DBA,W0L
1A2C:  MOV.B   W0L,B
1A2E:  CLR.B   W5
1A30:  MOV.B   DB8,W0L
1A32:  SE      W0,W0
1A34:  ADD     W0,W5,W0
1A36:  MOV     W0,C5E
....................      
....................     lowbyte = rcv_buffer[7]; 
1A38:  MOV.B   D69,W0L
1A3A:  MOV.B   W0L,DB8
....................     highbyte = rcv_buffer[8]; 
1A3C:  MOV.B   D6A,W0L
1A3E:  MOV.B   W0L,DB9
....................     items = (int16) highbyte; 
1A40:  MOV.B   DB9,W0L
1A42:  SE      W0,W0
1A44:  MOV     W0,DBA
....................     sysInput.nh4pt1cal3of3 = (items<<8) +  lowbyte;   
1A46:  MOV.B   DBA,W0L
1A48:  MOV.B   W0L,B
1A4A:  CLR.B   W5
1A4C:  MOV.B   DB8,W0L
1A4E:  SE      W0,W0
1A50:  ADD     W0,W5,W0
1A52:  MOV     W0,C60
....................      
....................          
....................     lowbyte = rcv_buffer[9]; 
1A54:  MOV.B   D6B,W0L
1A56:  MOV.B   W0L,DB8
....................     highbyte = rcv_buffer[10]; 
1A58:  MOV.B   D6C,W0L
1A5A:  MOV.B   W0L,DB9
....................     items = (int16) highbyte; 
1A5C:  MOV.B   DB9,W0L
1A5E:  SE      W0,W0
1A60:  MOV     W0,DBA
....................     sysInput.nh4pt2cal1of3 = (items<<8) +  lowbyte;   
1A62:  MOV.B   DBA,W0L
1A64:  MOV.B   W0L,B
1A66:  CLR.B   W5
1A68:  MOV.B   DB8,W0L
1A6A:  SE      W0,W0
1A6C:  ADD     W0,W5,W0
1A6E:  MOV     W0,C62
....................   
....................     lowbyte = rcv_buffer[11]; 
1A70:  MOV.B   D6D,W0L
1A72:  MOV.B   W0L,DB8
....................     highbyte = rcv_buffer[12]; 
1A74:  MOV.B   D6E,W0L
1A76:  MOV.B   W0L,DB9
....................     items = (int16) highbyte; 
1A78:  MOV.B   DB9,W0L
1A7A:  SE      W0,W0
1A7C:  MOV     W0,DBA
....................     sysInput.nh4pt2cal2of3 = (items<<8) +  lowbyte;   
1A7E:  MOV.B   DBA,W0L
1A80:  MOV.B   W0L,B
1A82:  CLR.B   W5
1A84:  MOV.B   DB8,W0L
1A86:  SE      W0,W0
1A88:  ADD     W0,W5,W0
1A8A:  MOV     W0,C64
....................      
....................     lowbyte = rcv_buffer[13]; 
1A8C:  MOV.B   D6F,W0L
1A8E:  MOV.B   W0L,DB8
....................     highbyte = rcv_buffer[14]; 
1A90:  MOV.B   D70,W0L
1A92:  MOV.B   W0L,DB9
....................     items = (int16) highbyte; 
1A94:  MOV.B   DB9,W0L
1A96:  SE      W0,W0
1A98:  MOV     W0,DBA
....................     sysInput.nh4pt2cal3of3 = (items<<8) +  lowbyte;   
1A9A:  MOV.B   DBA,W0L
1A9C:  MOV.B   W0L,B
1A9E:  CLR.B   W5
1AA0:  MOV.B   DB8,W0L
1AA2:  SE      W0,W0
1AA4:  ADD     W0,W5,W0
1AA6:  MOV     W0,C66
....................              
....................     lowbyte = rcv_buffer[15]; 
1AA8:  MOV.B   D71,W0L
1AAA:  MOV.B   W0L,DB8
....................     highbyte = rcv_buffer[16]; 
1AAC:  MOV.B   D72,W0L
1AAE:  MOV.B   W0L,DB9
....................     items = (int16) highbyte; 
1AB0:  MOV.B   DB9,W0L
1AB2:  SE      W0,W0
1AB4:  MOV     W0,DBA
....................     sysInput.nh4pt3cal1of3 = (items<<8) +  lowbyte;   
1AB6:  MOV.B   DBA,W0L
1AB8:  MOV.B   W0L,B
1ABA:  CLR.B   W5
1ABC:  MOV.B   DB8,W0L
1ABE:  SE      W0,W0
1AC0:  ADD     W0,W5,W0
1AC2:  MOV     W0,C68
....................   
....................     lowbyte = rcv_buffer[17]; 
1AC4:  MOV.B   D73,W0L
1AC6:  MOV.B   W0L,DB8
....................     highbyte = rcv_buffer[18]; 
1AC8:  MOV.B   D74,W0L
1ACA:  MOV.B   W0L,DB9
....................     items = (int16) highbyte; 
1ACC:  MOV.B   DB9,W0L
1ACE:  SE      W0,W0
1AD0:  MOV     W0,DBA
....................     sysInput.nh4pt3cal2of3 = (items<<8) +  lowbyte;   
1AD2:  MOV.B   DBA,W0L
1AD4:  MOV.B   W0L,B
1AD6:  CLR.B   W5
1AD8:  MOV.B   DB8,W0L
1ADA:  SE      W0,W0
1ADC:  ADD     W0,W5,W0
1ADE:  MOV     W0,C6A
....................      
....................     lowbyte = rcv_buffer[19]; 
1AE0:  MOV.B   D75,W0L
1AE2:  MOV.B   W0L,DB8
....................     highbyte = rcv_buffer[20]; 
1AE4:  MOV.B   D76,W0L
1AE6:  MOV.B   W0L,DB9
....................     items = (int16) highbyte; 
1AE8:  MOV.B   DB9,W0L
1AEA:  SE      W0,W0
1AEC:  MOV     W0,DBA
....................     sysInput.nh4pt3cal3of3 = (items<<8) +  lowbyte;   
1AEE:  MOV.B   DBA,W0L
1AF0:  MOV.B   W0L,B
1AF2:  CLR.B   W5
1AF4:  MOV.B   DB8,W0L
1AF6:  SE      W0,W0
1AF8:  ADD     W0,W5,W0
1AFA:  MOV     W0,C6C
....................      
....................     // these are the four byte floats 
....................      
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
1AFC:  CLR     DBC
1AFE:  MOV     DBC,W4
1B00:  CP      W4,#4
1B02:  BRA     GE,1B1A
....................       *((int8*)&data + i) = rcv_buffer[i + 21]; 
1B04:  MOV     #DBE,W5
1B06:  MOV     W5,W0
1B08:  ADD     DBC,W0
1B0A:  MOV     W0,W5
1B0C:  MOV     DBC,W4
1B0E:  ADD     W4,#15,W6
1B10:  MOV     #D62,W4
1B12:  ADD     W6,W4,W0
1B14:  MOV.B   [W0],[W5]
1B16:  INC     0DBC
1B18:  BRA     1AFE
....................     sysInput.nh4pt1returnednumber = data; 
1B1A:  PUSH    DBE
1B1C:  POP     C6E
1B1E:  PUSH    DC0
1B20:  POP     C70
....................  
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
1B22:  CLR     DBC
1B24:  MOV     DBC,W4
1B26:  CP      W4,#4
1B28:  BRA     GE,1B40
....................       *((int8*)&data + i) = rcv_buffer[i + 25]; 
1B2A:  MOV     #DBE,W5
1B2C:  MOV     W5,W0
1B2E:  ADD     DBC,W0
1B30:  MOV     W0,W5
1B32:  MOV     DBC,W4
1B34:  ADD     W4,#19,W6
1B36:  MOV     #D62,W4
1B38:  ADD     W6,W4,W0
1B3A:  MOV.B   [W0],[W5]
1B3C:  INC     0DBC
1B3E:  BRA     1B24
....................     sysInput.nh4pt1returnednumber = data; 
1B40:  PUSH    DBE
1B42:  POP     C6E
1B44:  PUSH    DC0
1B46:  POP     C70
....................  
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
1B48:  CLR     DBC
1B4A:  MOV     DBC,W4
1B4C:  CP      W4,#4
1B4E:  BRA     GE,1B66
....................       *((int8*)&data + i) = rcv_buffer[i + 29]; 
1B50:  MOV     #DBE,W5
1B52:  MOV     W5,W0
1B54:  ADD     DBC,W0
1B56:  MOV     W0,W5
1B58:  MOV     DBC,W4
1B5A:  ADD     W4,#1D,W6
1B5C:  MOV     #D62,W4
1B5E:  ADD     W6,W4,W0
1B60:  MOV.B   [W0],[W5]
1B62:  INC     0DBC
1B64:  BRA     1B4A
....................     sysInput.nh4pt1returnednumber = data;     
1B66:  PUSH    DBE
1B68:  POP     C6E
1B6A:  PUSH    DC0
1B6C:  POP     C70
1B6E:  MOV     [--W15],W6
1B70:  MOV     [--W15],W5
1B72:  RETURN  
....................      
.................... } 
....................  
....................  
.................... #INT_SI2C2 
....................  
.................... void si2c2_interrupt() 
*
0238:  PUSH    42
023A:  PUSH    36
023C:  PUSH    32
023E:  MOV     W0,[W15++]
0240:  MOV     #2,W0
0242:  REPEAT  #C
0244:  MOV     [W0++],[W15++]
....................     { 
....................  
.................... unsigned int8  incoming, state; 
....................  
....................         state=i2c_isr_state(SENSOR); 
0246:  BTSC.B  218.5
0248:  BRA     252
024A:  CLR.B   DA3
024C:  BTSS.B  218.2
024E:  BRA     252
0250:  BSET.B  DA3.7
0252:  MOV.B   DA3,W0L
0254:  CLR.B   1
0256:  INC.B   0DA3
0258:  MOV.B   W0L,F41
....................  
....................    if(state <= 0x80)                      //Master is sending data 
025A:  MOV     F40,W4
025C:  LSR     W4,#8,W4
025E:  MOV     #80,W3
0260:  CP.B    W3L,W4L
0262:  BRA     NC,2C2
....................    { 
....................       incoming = i2c_read(SENSOR,1);  
0264:  MOV     #1,W1
0266:  MOV     W1,[W15++]
0268:  MOV     [--W15],W1
026A:  CALL    200
026E:  MOV.B   W0L,F40
....................       if(state == 1)                     //First received byte is address  
0270:  MOV     F40,W4
0272:  LSR     W4,#8,W4
0274:  CP.B    W4L,#1
0276:  BRA     NZ,27E
....................       {//First received byte is address 
....................          address = incoming; 
0278:  MOV.B   F40,W0L
027A:  MOV.B   W0L,AAF
....................          streamCntr=0; 
027C:  CLR.B   D61
....................       } 
....................       if(state == 2)                     //Second received byte is data  
027E:  MOV     F40,W4
0280:  LSR     W4,#8,W4
0282:  CP.B    W4L,#2
0284:  BRA     NZ,294
....................           {   
....................           rcv_buffer[address] = incoming;  
0286:  MOV     AAE,W4
0288:  LSR     W4,#8,W4
028A:  MOV     #D62,W3
028C:  ADD     W4,W3,W5
028E:  MOV     F40,W0
0290:  MOV.B   W0L,[W5+#0]
....................           streamCntr=0; 
0292:  CLR.B   D61
....................           } 
....................        
....................       if(state == 1)                      //First received byte is address 
0294:  MOV     F40,W4
0296:  LSR     W4,#8,W4
0298:  CP.B    W4L,#1
029A:  BRA     NZ,2A2
....................          address = incoming; 
029C:  MOV.B   F40,W0L
029E:  MOV.B   W0L,AAF
02A0:  BRA     2C2
....................       else if(state >= 2 && state != 0x80)   //Received byte is data auto from the master 
02A2:  MOV     F40,W4
02A4:  LSR     W4,#8,W4
02A6:  CP.B    W4L,#2
02A8:  BRA     NC,2C2
02AA:  MOV     F40,W4
02AC:  LSR     W4,#8,W4
02AE:  XOR.B   #80,W4L
02B0:  BRA     Z,2C2
....................            { 
....................             rcv_buffer[address++] = incoming; 
02B2:  MOV.B   AAF,W0L
02B4:  INC.B   0AAF
02B6:  ZE      W0,W0
02B8:  MOV     #D62,W4
02BA:  ADD     W0,W4,W5
02BC:  MOV     F40,W0
02BE:  MOV.B   W0L,[W5+#0]
....................             streamCntr=0; 
02C0:  CLR.B   D61
....................             } 
....................    } 
....................  
....................    if((state >= 0x80) & (rcv_buffer[0x40] != 0x01))               //Master is requesting data 
02C2:  MOV     F40,W4
02C4:  LSR     W4,#8,W4
02C6:  MOV     #80,W3
02C8:  CP.B    W3L,W4L
02CA:  BRA     GTU,2CE
02CC:  BRA     2D2
02CE:  CLR.B   W0
02D0:  BRA     2D4
02D2:  MOV.B   #1,W0L
02D4:  MOV.B   W0L,W5L
02D6:  MOV     DA2,W4
02D8:  CP.B    W4L,#1
02DA:  BRA     NZ,2E0
02DC:  CLR.B   W0
02DE:  BRA     2E2
02E0:  MOV.B   #1,W0L
02E2:  AND.B   W5L,W0L,W0L
02E4:  CP0.B   W0L
02E6:  BRA     Z,2FA
....................    { 
....................       i2c_write(SENSOR,send_buffer[streamCntr++]); 
02E8:  MOV.B   D61,W0L
02EA:  INC.B   0D61
02EC:  ZE      W0,W0
02EE:  MOV     #D20,W4
02F0:  ADD     W0,W4,W0
02F2:  MOV.B   [W0],W5L
02F4:  MOV.B   W5L,W1L
02F6:  CALL    220
....................    } 
....................       if((state >= 0x80) & (rcv_buffer[0x40] == 0x01))               //Master is requesting data 
02FA:  MOV     F40,W4
02FC:  LSR     W4,#8,W4
02FE:  MOV     #80,W3
0300:  CP.B    W3L,W4L
0302:  BRA     GTU,306
0304:  BRA     30A
0306:  CLR.B   W0
0308:  BRA     30C
030A:  MOV.B   #1,W0L
030C:  MOV.B   W0L,W5L
030E:  MOV     DA2,W4
0310:  CP.B    W4L,#1
0312:  BRA     Z,318
0314:  CLR.B   W0
0316:  BRA     31A
0318:  MOV.B   #1,W0L
031A:  AND.B   W5L,W0L,W0L
031C:  CP0.B   W0L
031E:  BRA     Z,328
....................    { 
....................       i2c_write(SENSOR,SENSORNUMBER); 
0320:  MOV.B   #39,W1L
0322:  CALL    220
....................       rcv_buffer[0x40]=0x00; 
0326:  CLR.B   DA2
....................    } 
0328:  BCLR.B  8A.1
032A:  MOV     #1A,W0
032C:  REPEAT  #C
032E:  MOV     [--W15],[W0--]
0330:  MOV     [--W15],W0
0332:  POP     32
0334:  POP     36
0336:  POP     42
0338:  RETFIE  
.................... 	} 
....................     
....................      
....................  
.................... //*********************************************************** 
.................... //***************************************************************************** 
.................... // Created April 6, 2015 
.................... //  This routine finds the constants K1 and K2 for any four given values of O2 concentration and intensity. 
.................... //  IntensityHighOxy matches up with LowOxyPercentage 
.................... //  IntensityLowOxy matches up with HighOxyPercentage 
.................... //  Updated April 29, 2014 
.................... //  This routine is completed with formula for K1 and K2. 
.................... // Added or changed May 18, 2015.   
.................... //  Switched around reading 3 and reading 1 in the void function statment.  This appears to be backwards and conrfusuing when measureing all nine values for DO and temperatures. 
.................... //  ***************************************************************************** 
.................... void SolveForTempCompK1AndK2(float disolvedOxygen1, float disolvedOxygen2, float disolvedOxygen3, float reading3, float reading2, float reading1) 
.................... 	{ 
....................  
.................... //float disolvedOxygen1,disolvedOxygen2,disolvedOxygen3; 
.................... //float reading1,reading2, reading3; 
.................... 	float32 root1,root2,RatioOfIntensity,IntensityReadingfloat; 
.................... 	int32 IntensityReading; 
....................   
.................... //disolvedOxygen1 = 9.600;  //Percent   this is the highest reading 
.................... //disolvedOxygen2 = 2.00;  //Percent 
.................... //disolvedOxygen3 = 0.0;  //Percent   this is the lowest reading 
....................  
.................... float RatioITemp, RatioIITemp; 
....................  
....................  
.................... //reading3 = 1000.0;    ///This is the reading close to tru O2 20% O2. 
.................... //reading2 = 3880.0;    //This is for 5% of O2  
.................... //reading1 = 9000.0;  //This is for the low O2 reading for close to the axis reading.  This is the hight nummber 
....................  
....................  
.................... //  Find the ratios for all three combinations. 
.................... 	RatioITemp=(reading1/reading3)-1.0;  // I0/I1 - 1.0 
.................... 	RatioIITemp=(reading1/reading2)-1.0;    //  I0/I2 - 1.0 
....................  
....................  
.................... // Find K2  
....................      K2Temp = ((RatioITemp/disolvedOxygen1) - (RatioIITemp/disolvedOxygen2))/(disolvedOxygen1 - disolvedOxygen2); 
....................  
.................... // Find K1 
....................  
....................      K1Temp = (RatioITemp-(K2Temp*disolvedOxygen1*disolvedOxygen1))/disolvedOxygen1; 
....................  
....................  
.................... // Find Iohhh  
....................  
.................... //	Iohhh = RatioITemp;   //This used to be reading1   April 7, 2015  Removed and kept as reference. 
....................  
.................... 	Iohhh = reading1;   //This used to be reading1   May 19, 2015 This is the hightest reading for the lowest DO measyrement. 
....................  
....................  
.................... IntensityReading = 16000; 
.................... //IntensityReading = reading3; 
.................... IntensityReadingfloat = (float) IntensityReading;   // Added May 18, 2015.  This is added to convert the hex number into a float so it can be calculated. 
....................  
.................... RatioOfIntensity = 1.0 - Iohhh/IntensityReadingfloat; 
....................  
.................... 	root1 = sqrt(K1Temp*K1Temp - 4.0*RatioOfIntensity*K2Temp)- K1Temp; 
.................... 	 
.................... 	root1 = (root1)/(2.0*K2Temp);  //This is the plus version of the equation 
.................... 	root2 = (-1.0 * K1Temp - (sqrt((K1Temp*K1Temp)-4.0*(RatioOfIntensity)*K2Temp)))/(2.0*K2Temp);  // This is the negative version of the equation.  Most likely not used? 
....................  
....................  
.................... 	} 
....................  
....................  
.................... //*********************************************************************************************************** 
.................... //Created April 6, 2015 
.................... // This routine finds all of the values for DO temperature Compensation. 
.................... //There are four temperatures DO is calibrated for.  Each one has its own set of coefficents that needs to be calculated from the calibration data.   
.................... // All temperatures are measured and converted into Kalvin. 
.................... // All measurments are seperated into ranges split by the temperature ranges. 
.................... //The temperature ranges are as follows: 
.................... // T1 = 10  degrees C. 
.................... // T2 = 20  degrees C. 
.................... // T3 = 25  degrees C. 
.................... // Three sets of I values at differnt O2 concentrations needs to be measured or guessed. 
.................... // One for each temperature.  The K1 and K2 values are found for each temperature and then a set of coefficents for temperature is found. 
.................... // This routine  
.................... //************************************************************************************************************* 
.................... void CalculateK1andK2WithTempComp(float temperature) 
.................... 	{ 
.................... /*   This is commented out because the varuibles are used globally and are saved on the SD Card. Added May 20, 2015 
.................... 	float Temp1DOOne = 9.5;            //These are the set points where we want to read these numbers at temperature 1 
.................... 	float Temp1DOTwo = 4.0;            //This is at 10 degrees 
.................... 	float Temp1DOThree = 0.0; 
....................  
.................... 	float Temp2DOOne = 7.5;            //These are the set points where we want to read these numbers at temperature 2 
.................... 	float Temp2DOTwo = 4.0;				//This is at 20 degrees 
.................... 	float Temp2DOThree = 0.0; 
....................  
.................... 	float Temp3DOOne = 6.7;            //These are the set points where we want to read these numbers temperature 3 
.................... 	float Temp3DOTwo = 4.0;            //This is at 25 degrees 
.................... 	float Temp3DOThree = 0.0; 
....................  
....................  
.................... 	float Temp1ReadingOne = 10752.0;       //Readings for Temp3  10 degrees C 
.................... 	float Temp1ReadingTwo = 11000.0;      //Readings for Temp3 
.................... 	float Temp1ReadingThree = 12000.0;    //Readings for DOOne    this is no DO. 
....................  
.................... 	float Temp2ReadingOne = 11266.0;       //Readings for Temp3    20 degrees C 
.................... 	float Temp2ReadingTwo = 12000.0;      //Readings for Temp3 
.................... 	float Temp2ReadingThree = 13000.0;    //Readings for DOOne 
....................  
.................... 	float Temp3ReadingOne = 12425.0;       //Readings for Temp3   25 degrees C 
.................... 	float Temp3ReadingTwo = 13000.0;      //Readings for Temp3 
.................... 	float Temp3ReadingThree = 14000.0;    //Readings for DOOne 
.................... */ 
.................... 	float  K1TempOne,K2TempOne, K1TempTwo, K2TempTwo, K1TempThree, K2TempThree, TempOneOut, TempTwoOut, TempThreeOut; 
.................... /* 
.................... 	float TempOne = 10.0;       //Calibration temperatures for DO   Added April 7, 2015 
....................  	float TempTwo =  20.0;      //Calibration temperatures for DO  Added April 7, 2015 
.................... 	float TempThree =  25.0;     //Calibration temperatures for DO  Added April 7, 2015 
....................  
.................... */ 
.................... 	float IohhhTempTwo,IohhhTempThree,IohhhTempOne;   //This is added May 18, 2015 for using the Ioh as part of the temperature compensation rourtines. 
....................  
.................... //Find all of the K values for solving temperature compensation.  There needs to be three equations for three unknows for K1, K2 and I which is the highest reading 
....................  
.................... 	SolveForTempCompK1AndK2(Temp3DOOne, Temp3DOTwo, Temp3DOThree, Temp3ReadingOne, Temp3ReadingTwo, Temp3ReadingThree); 
....................  
.................... //Save the first set of K values for Tempature 3  or 25 degrees 
.................... 	K1TempThree = K1Temp; 
.................... 	K2TempThree = K2Temp; 
.................... 	IohhhTempThree = Iohhh; 
....................  
.................... 	SolveForTempCompK1AndK2(Temp2DOOne, Temp2DOTwo, Temp2DOThree, Temp2ReadingOne, Temp2ReadingTwo, Temp2ReadingThree); 
.................... //Save the first set of K values for Tempature 2 which is at 20 degrees C 
.................... 	K1TempTwo = K1Temp; 
.................... 	K2TempTwo = K2Temp; 
.................... 	IohhhTempTwo = Iohhh; 
....................  
.................... 	SolveForTempCompK1AndK2(Temp1DOOne, Temp1DOTwo, Temp1DOThree, Temp1ReadingOne, Temp1ReadingTwo, Temp1ReadingThree); 
.................... //Save the first set of K values for Tempature 1 which is at 10 degrees C 
.................... 	K1TempOne = K1Temp; 
.................... 	K2TempOne = K2Temp; 
.................... 	IohhhTempOne = Iohhh; 
....................  
.................... //******************************************************************************************************* 
.................... //Solve for K1 and find a,b and c for K1 temperature compensation 
.................... //Created April 7, 2015 
.................... //******************************************************************************************************* 
.................... // The temperature needs to be converted to degrees Kalvin 
....................  
....................  
.................... temperature = temperature + 273.0;   //The conversion from C to K is add 273 to degrees C. 
....................  
.................... TempOneOut = TempOne + 273.0;     //The conversion from C to K is add 273 to degrees C. 
.................... TempTwoOut = TempTwo + 273.0;     //The conversion from C to K is add 273 to degrees C. 
.................... TempThreeOut = TempThree + 273.0;     //The conversion from C to K is add 273 to degrees C. 
....................  
.................... //Find K1 coefficents for T = 5  or 273 +5 = 278 degress K. 
....................  
....................       matrixequation[0][0] = 1; 
....................       matrixequation[1][0] = TempOneOut;  
....................       matrixequation[2][0] = TempOneOut * TempOneOut;  
....................       matrixequals[0] = K1TempOne;  
....................       matrixequation[0][1] = 1; 
....................       matrixequation[1][1] = TempTwoOut;  
....................       matrixequation[2][1] = TempTwoOut * TempTwoOut;  
....................       matrixequals[1] = K1TempTwo;  
....................       matrixequation[0][2] = 1; 
....................       matrixequation[1][2] = TempThreeOut;  
....................       matrixequation[2][2] = TempThreeOut * TempThreeOut;     
....................       matrixequals[2] = K1TempThree; 
....................  
.................... ThreeByThreeSolution();  // Call to solve for coefs for K1 
....................  
....................  
.................... 	atwo = MatrixSolution[0];   //Move the solution into the coefs 
.................... 	btwo = MatrixSolution[1];   //Move the solution into the coefs 
.................... 	ctwo = MatrixSolution[2];   //Move the solution into the coefs 
....................  
....................  
.................... //Found solution coefficenta for K1.  Now take the current temperature and calculate the Current K1 value. 
....................  
.................... K1 = atwo + btwo*temperature + ctwo*temperature*temperature; 
....................  
....................       matrixequation[0][0] = 1; 
....................       matrixequation[1][0] = TempOneOut;  
....................       matrixequation[2][0] = TempOneOut * TempOneOut;  
....................       matrixequals[0] = K2TempOne;  
....................       matrixequation[0][1] = 1; 
....................       matrixequation[1][1] = TempTwoOut;  
....................       matrixequation[2][1] = TempTwoOut * TempTwoOut;  
....................       matrixequals[1] = K2TempTwo;  
....................       matrixequation[0][2] = 1; 
....................       matrixequation[1][2] = TempThreeOut;  
....................       matrixequation[2][2] = TempThreeOut * TempThreeOut;     
....................       matrixequals[2] = K2TempThree; 
....................  
.................... ThreeByThreeSolution();  // Call to solve for coefs for K1 
....................  
....................  
.................... 	atwo = MatrixSolution[0];   //Move the solution into the coefs 
.................... 	btwo = MatrixSolution[1];   //Move the solution into the coefs 
.................... 	ctwo = MatrixSolution[2];   //Move the solution into the coefs 
....................  
.................... K2 = atwo + btwo*temperature + ctwo*temperature*temperature; 
....................  
....................  
.................... //Now we need to find the last ratio for light intenstiry Ioooooooo 
....................  
.................... //************************************************************ 
.................... // Save May 18, 2015.  This saved for reference only.  it's the orginal one 
.................... // Iohhhhs have been added as part of the temperature compensation.  It's a ratio, not only one reading. 
.................... //************************************************************ 
....................  
....................  
....................       matrixequation[0][0] = 1; 
....................       matrixequation[1][0] = TempOneOut;  
....................       matrixequation[2][0] = TempOneOut * TempOneOut;  
....................       matrixequals[0] = IohhhTempOne;  
....................       matrixequation[0][1] = 1; 
....................       matrixequation[1][1] = TempTwoOut;  
....................       matrixequation[2][1] = TempTwoOut * TempTwoOut;  
....................       matrixequals[1] = IohhhTempTwo;  
....................       matrixequation[0][2] = 1; 
....................       matrixequation[1][2] = TempThreeOut;  
....................       matrixequation[2][2] = TempThreeOut * TempThreeOut;     
....................       matrixequals[2] = IohhhTempThree; 
....................  
.................... ThreeByThreeSolution();  // Call to solve for coefs for K1 
....................  
....................  
.................... 	atwo = MatrixSolution[0];   //Move the solution into the coefs 
.................... 	btwo = MatrixSolution[1];   //Move the solution into the coefs 
.................... 	ctwo = MatrixSolution[2];   //Move the solution into the coefs 
....................  
.................... Iohhh = atwo + btwo*temperature + ctwo*temperature*temperature; 
....................  
.................... 	} 
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... // Created May 9, 2013 
.................... // This rouitne uses the current read Intensity, K1 and K2 to determine the currnet percent of O2 
.................... // The calibration calculation routine needs to first be run before this routine works. 
.................... // Later on the temperature is also considered for Do compensation. 
.................... //**************************************************************************** 
.................... float CalcaulateDO(unsigned int32 IntensityReading, float temperature) 
.................... 	{ 
....................  
.................... 	float32 root1,root2,RatioOfIntensity,IntensityReadingfloat; 
....................     float tempcalc,tempinside,tempsquare;  //This is used to calcaulte the intermediate steps for the quadratic equation. 
....................  
.................... //*************** 
.................... // May 1, 2014  
.................... // This is commented out to first test the K1 and K2 equations.  Temp comp is added later. 
.................... //*************** 
....................  
.................... //Iohhh = azero + bzero * temperature + czero * temperature * temperature; 
....................  
.................... //K1 = aone + bone * temperature + cone * temperature * temperature; 
.................... //K2 = atwo + btwo * temperature + ctwo * temperature * temperature; 
.................... //SolveForK1AndK2(int16 IntensityLowOxy, int16 IntensityHighOxy, int16 IntensityMiddleOxy, float LowOxyPercentage, float HighOxyPercentage) 
....................  
....................  
.................... //****************************************************************************** 
.................... // Added April 7, 2015 
.................... //  This is the old non-temperature compensated DO calculations. 
.................... //The routine is left for reference and history. 
.................... //SolveForK1AndK2(); 
....................  
.................... //***************************************************************************** 
.................... //Created April 7, 2015 
.................... // The routine below calculates the K1, K2 and Ihooo for the current temperature.  Tempature must be in degrees C. 
.................... CalculateK1andK2WithTempComp(temperature); 
....................  
.................... //************************************************************** //Added April 27, 2014 
.................... // Before the DO can be calculated, it needs to be temperature  
.................... // compensated.  The values of K2, K1 and Iohhh need to be  
.................... // calculated through the three X three matrix temperature shift. 
.................... // ************************************************************** 
.................... //IntensityReading = 200.0;   //this is the test input reading.  This is commeneted out for the real data Nov. 14, 2014 
....................  
.................... IntensityReadingfloat = (float) IntensityReading;   // Added May 18, 2015.  This is added to convert the hex number into a float so it can be calculated. 
....................  
.................... RatioOfIntensity = 1.0 - Iohhh/IntensityReadingfloat; 
....................  
.................... tempcalc = K1*K1; 
.................... tempinside = 4.0*RatioOfIntensity*K2; 
.................... tempcalc = tempcalc - tempinside; 
.................... tempsquare = sqrt(tempcalc); 
....................  
.................... 	root1 = tempsquare - K1; 
.................... 	root1 = sqrt(K1*K1 - 4.0*RatioOfIntensity*K2)- K1; 
.................... 	 
.................... 	root1 = (root1)/(2.0*K2);  //This is the plus version of the equation 
.................... 	root2 = (-1.0 * K1 - (sqrt((K1*K1)-4.0*(RatioOfIntensity)*K2)))/(2.0*K2);  // This is the negative version of the equation.  Most likely not used? 
....................  
.................... 	return(root1);  //If this root is positive, the return it. 
.................... 	} 
....................  
....................  
.................... void DetermineTempCoef(void) 
.................... { 
.................... //This has been removed and placed in TaosLightSensor.h  May 21, 2015 
.................... //float temp1,reading1,temp2,reading2,temp3,reading3; 
.................... float temp1in,temp2in,temp3in; 
.................... float reading1in,reading2in,reading3in; 
.................... float det, det1, det2, det3;   //These are the other dets for each solution 
.................... // This is the raw data.  Added May 15, 2015 
....................  
.................... temp1 = 40;     
*
12F2:  CLR     C1E
12F4:  MOV     #4220,W4
12F6:  MOV     W4,C20
.................... temp2 = 21; 
12F8:  CLR     C26
12FA:  MOV     #41A8,W4
12FC:  MOV     W4,C28
.................... temp3 = 6;   
12FE:  CLR     C2E
1300:  MOV     #40C0,W4
1302:  MOV     W4,C30
.................... //temp1 = sysInput.Thermisterpt1returnednumber;    //example 40 C 
.................... //temp2 = sysInput.Thermisterpt2returnednumber;   // example 21  C 
.................... //temp3 = sysInput.Thermisterpt3returnednumber;    // example 6  C 
....................  
.................... //*************************************************************************** 
.................... //Added January 13, 2015 
.................... // These are the values used for the 10K reistor stolen from Animatics 
.................... //*************************************************************************** 
.................... reading1 = 5140; 
1304:  MOV     #A000,W4
1306:  MOV     W4,C22
1308:  MOV     #45A0,W4
130A:  MOV     W4,C24
.................... reading2 = 13037; 
130C:  MOV     #B400,W4
130E:  MOV     W4,C2A
1310:  MOV     #464B,W4
1312:  MOV     W4,C2C
.................... reading3 = 27594; 
1314:  MOV     #9400,W4
1316:  MOV     W4,C32
1318:  MOV     #46D7,W4
131A:  MOV     W4,C34
....................  
.................... //reading1 = sysInput.Thermisterpt1cal1of3;   //5140 
.................... //reading2 = sysInput.Thermisterpt1cal2of3;  // 13037; 
.................... //reading3 = sysInput.Thermisterpt1cal3of3;  //  27594; 
.................... //*************************************************************************** 
.................... //Added January 13, 2015 
.................... // These are the values used for the ?K reistor supplied by Rick 
.................... //*************************************************************************** 
....................  
.................... //reading1 = 12000;   //this one is measured at 45 degrees C   // these numbers are for the 30K reistor 
.................... //reading2 = 40000;   //this is measured at 22 C  Checked on May 14, 2015 
.................... //reading3 = 72000;   // this tempature is measured at 12 degrees C 
....................  
....................  
.................... temp1in = 1.0/(temp1 + 273.0); 
131C:  BCLR.B  43.0
131E:  MOV     C1E,W0
1320:  MOV     C20,W1
1322:  MOV     #8000,W2
1324:  MOV     #4388,W3
1326:  CALL    DBC
132A:  MOV     W0,W2
132C:  MOV     W1,W3
132E:  MOV     #0,W0
1330:  MOV     #3F80,W1
1332:  CALL    CF2
1336:  MOV     W0,E80
1338:  MOV     W1,E82
.................... temp2in = 1.0/(temp2 + 273.0); 
133A:  BCLR.B  43.0
133C:  MOV     C26,W0
133E:  MOV     C28,W1
1340:  MOV     #8000,W2
1342:  MOV     #4388,W3
1344:  CALL    DBC
1348:  MOV     W0,W2
134A:  MOV     W1,W3
134C:  MOV     #0,W0
134E:  MOV     #3F80,W1
1350:  CALL    CF2
1354:  MOV     W0,E84
1356:  MOV     W1,E86
.................... temp3in = 1.0/(temp3 + 273.0); 
1358:  BCLR.B  43.0
135A:  MOV     C2E,W0
135C:  MOV     C30,W1
135E:  MOV     #8000,W2
1360:  MOV     #4388,W3
1362:  CALL    DBC
1366:  MOV     W0,W2
1368:  MOV     W1,W3
136A:  MOV     #0,W0
136C:  MOV     #3F80,W1
136E:  CALL    CF2
1372:  MOV     W0,E88
1374:  MOV     W1,E8A
....................  
....................  
.................... reading1in = log(reading1); 
1376:  PUSH    C22
1378:  POP     EAC
137A:  PUSH    C24
137C:  POP     EAE
137E:  CALL    FCE
1382:  MOV     W0,E8C
1384:  MOV     W1,E8E
.................... reading2in = log(reading2); 
1386:  PUSH    C2A
1388:  POP     EAC
138A:  PUSH    C2C
138C:  POP     EAE
138E:  CALL    FCE
1392:  MOV     W0,E90
1394:  MOV     W1,E92
.................... reading3in = log(reading3); 
1396:  PUSH    C32
1398:  POP     EAC
139A:  PUSH    C34
139C:  POP     EAE
139E:  CALL    FCE
13A2:  MOV     W0,E94
13A4:  MOV     W1,E96
....................  
....................  
.................... //  This part solves for tempa1, tempa2, tempa3 4 
.................... // Find the divistion determinent 
....................  
.................... matx[0][0] = 1.0; 
13A6:  CLR     ABC
13A8:  MOV     #3F80,W4
13AA:  MOV     W4,ABE
.................... matx[1][0] = 1.0; 
13AC:  CLR     AC8
13AE:  MOV     #3F80,W4
13B0:  MOV     W4,ACA
.................... matx[2][0] = 1.0; 
13B2:  CLR     AD4
13B4:  MOV     #3F80,W4
13B6:  MOV     W4,AD6
.................... matx[0][1] = reading1in; 
13B8:  PUSH    E8C
13BA:  POP     AC0
13BC:  PUSH    E8E
13BE:  POP     AC2
.................... matx[1][1] = reading2in; 
13C0:  PUSH    E90
13C2:  POP     ACC
13C4:  PUSH    E92
13C6:  POP     ACE
.................... matx[2][1] = reading3in; 
13C8:  PUSH    E94
13CA:  POP     AD8
13CC:  PUSH    E96
13CE:  POP     ADA
.................... matx[0][2] = reading1in*reading1in; 
13D0:  MOV     E8C,W0
13D2:  MOV     E8E,W1
13D4:  MOV     E8C,W2
13D6:  MOV     E8E,W3
13D8:  CALL    C2E
13DC:  MOV     W0,AC4
13DE:  MOV     W1,AC6
.................... matx[1][2] = reading2in*reading2in; 
13E0:  MOV     E90,W0
13E2:  MOV     E92,W1
13E4:  MOV     E90,W2
13E6:  MOV     E92,W3
13E8:  CALL    C2E
13EC:  MOV     W0,AD0
13EE:  MOV     W1,AD2
.................... matx[2][2] = reading3in*reading3in; 
13F0:  MOV     E94,W0
13F2:  MOV     E96,W1
13F4:  MOV     E94,W2
13F6:  MOV     E96,W3
13F8:  CALL    C2E
13FC:  MOV     W0,ADC
13FE:  MOV     W1,ADE
....................  
.................... det = FindTheDetermint(); 
1400:  CALL    115A
1404:  MOV     W0,E98
1406:  MOV     W1,E9A
....................  
.................... //Find the det for tempa1 
....................  
.................... matx[0][0] = temp1in; 
1408:  PUSH    E80
140A:  POP     ABC
140C:  PUSH    E82
140E:  POP     ABE
.................... matx[1][0] = temp2in; 
1410:  PUSH    E84
1412:  POP     AC8
1414:  PUSH    E86
1416:  POP     ACA
.................... matx[2][0] = temp3in; 
1418:  PUSH    E88
141A:  POP     AD4
141C:  PUSH    E8A
141E:  POP     AD6
.................... matx[0][1] = reading1in; 
1420:  PUSH    E8C
1422:  POP     AC0
1424:  PUSH    E8E
1426:  POP     AC2
.................... matx[1][1] = reading2in; 
1428:  PUSH    E90
142A:  POP     ACC
142C:  PUSH    E92
142E:  POP     ACE
.................... matx[2][1] = reading3in; 
1430:  PUSH    E94
1432:  POP     AD8
1434:  PUSH    E96
1436:  POP     ADA
.................... matx[0][2] = reading1in*reading1in; 
1438:  MOV     E8C,W0
143A:  MOV     E8E,W1
143C:  MOV     E8C,W2
143E:  MOV     E8E,W3
1440:  CALL    C2E
1444:  MOV     W0,AC4
1446:  MOV     W1,AC6
.................... matx[1][2] = reading2in*reading2in; 
1448:  MOV     E90,W0
144A:  MOV     E92,W1
144C:  MOV     E90,W2
144E:  MOV     E92,W3
1450:  CALL    C2E
1454:  MOV     W0,AD0
1456:  MOV     W1,AD2
.................... matx[2][2] = reading3in*reading3in; 
1458:  MOV     E94,W0
145A:  MOV     E96,W1
145C:  MOV     E94,W2
145E:  MOV     E96,W3
1460:  CALL    C2E
1464:  MOV     W0,ADC
1466:  MOV     W1,ADE
....................  
.................... det1 = FindTheDetermint(); 
1468:  CALL    115A
146C:  MOV     W0,E9C
146E:  MOV     W1,E9E
.................... tempa1=det1/det;   //  This finds the value for the first a1 
1470:  MOV     E9C,W0
1472:  MOV     E9E,W1
1474:  MOV     E98,W2
1476:  MOV     E9A,W3
1478:  CALL    CF2
147C:  MOV     W0,A94
147E:  MOV     W1,A96
....................  
.................... matx[0][0] = 1.0; 
1480:  CLR     ABC
1482:  MOV     #3F80,W4
1484:  MOV     W4,ABE
.................... matx[1][0] = 1.0; 
1486:  CLR     AC8
1488:  MOV     #3F80,W4
148A:  MOV     W4,ACA
.................... matx[2][0] = 1.0; 
148C:  CLR     AD4
148E:  MOV     #3F80,W4
1490:  MOV     W4,AD6
.................... matx[0][1] = temp1in; 
1492:  PUSH    E80
1494:  POP     AC0
1496:  PUSH    E82
1498:  POP     AC2
.................... matx[1][1] = temp2in; 
149A:  PUSH    E84
149C:  POP     ACC
149E:  PUSH    E86
14A0:  POP     ACE
.................... matx[2][1] = temp3in; 
14A2:  PUSH    E88
14A4:  POP     AD8
14A6:  PUSH    E8A
14A8:  POP     ADA
.................... matx[0][2] = reading1in*reading1in; 
14AA:  MOV     E8C,W0
14AC:  MOV     E8E,W1
14AE:  MOV     E8C,W2
14B0:  MOV     E8E,W3
14B2:  CALL    C2E
14B6:  MOV     W0,AC4
14B8:  MOV     W1,AC6
.................... matx[1][2] = reading2in*reading2in; 
14BA:  MOV     E90,W0
14BC:  MOV     E92,W1
14BE:  MOV     E90,W2
14C0:  MOV     E92,W3
14C2:  CALL    C2E
14C6:  MOV     W0,AD0
14C8:  MOV     W1,AD2
.................... matx[2][2] = reading3in*reading3in; 
14CA:  MOV     E94,W0
14CC:  MOV     E96,W1
14CE:  MOV     E94,W2
14D0:  MOV     E96,W3
14D2:  CALL    C2E
14D6:  MOV     W0,ADC
14D8:  MOV     W1,ADE
....................  
....................  
.................... det2 = FindTheDetermint(); 
14DA:  CALL    115A
14DE:  MOV     W0,EA0
14E0:  MOV     W1,EA2
.................... tempa2=det2/det;   //  This finds the value for the first a2 
14E2:  MOV     EA0,W0
14E4:  MOV     EA2,W1
14E6:  MOV     E98,W2
14E8:  MOV     E9A,W3
14EA:  CALL    CF2
14EE:  MOV     W0,A98
14F0:  MOV     W1,A9A
....................  
....................  
....................  
.................... matx[0][0] = 1.0; 
14F2:  CLR     ABC
14F4:  MOV     #3F80,W4
14F6:  MOV     W4,ABE
.................... matx[1][0] = 1.0; 
14F8:  CLR     AC8
14FA:  MOV     #3F80,W4
14FC:  MOV     W4,ACA
.................... matx[2][0] = 1.0; 
14FE:  CLR     AD4
1500:  MOV     #3F80,W4
1502:  MOV     W4,AD6
.................... matx[0][1] = reading1in; 
1504:  PUSH    E8C
1506:  POP     AC0
1508:  PUSH    E8E
150A:  POP     AC2
.................... matx[1][1] = reading2in; 
150C:  PUSH    E90
150E:  POP     ACC
1510:  PUSH    E92
1512:  POP     ACE
.................... matx[2][1] = reading3in; 
1514:  PUSH    E94
1516:  POP     AD8
1518:  PUSH    E96
151A:  POP     ADA
.................... matx[0][2] = temp1in; 
151C:  PUSH    E80
151E:  POP     AC4
1520:  PUSH    E82
1522:  POP     AC6
.................... matx[1][2] = temp2in; 
1524:  PUSH    E84
1526:  POP     AD0
1528:  PUSH    E86
152A:  POP     AD2
.................... matx[2][2] = temp3in; 
152C:  PUSH    E88
152E:  POP     ADC
1530:  PUSH    E8A
1532:  POP     ADE
....................  
.................... det3 = FindTheDetermint(); 
1534:  CALL    115A
1538:  MOV     W0,EA4
153A:  MOV     W1,EA6
.................... tempa3=det3/det;   //  This finds the value for the first a2 
153C:  MOV     EA4,W0
153E:  MOV     EA6,W1
1540:  MOV     E98,W2
1542:  MOV     E9A,W3
1544:  CALL    CF2
1548:  MOV     W0,A9C
154A:  MOV     W1,A9E
154C:  RETURN  
....................  
....................  
.................... } 
.................... //************************************************************* 
.................... // Created Nov. 6, 2012 
.................... //  This routine reads an ADC and averages 16 samples into one and returns the number. 
.................... // There is no scaling or any signal condition except for a low pass averaging filter. 
.................... //  The input selection is for ADC 1, 2, 3 and 5.  The numbers 0, 1, 2 and 4 are used for selecting the ADC. 
.................... //************************************************************* 
....................  
.................... int16 GetADCValue(int selection) 
.................... 	{ 
.................... 	int16 ReturnedADC, Summer;	 
.................... 	int f; 
.................... 					//setup_adc(ADC_CLOCK_INTERNAL);  //Setup the ADC to run.. 
.................... 					set_adc_channel(selection);  
*
0BA0:  MOV     E80,W1
0BA2:  AND     #1F,W1
0BA4:  MOV     #FF,W2
0BA6:  INC     W2,W2
0BA8:  AND     #7,W2
0BAA:  SL      W2,#5,W2
0BAC:  IOR      W1,  W2,W1
0BAE:  MOV     W1,348
....................                     		delay_ms(10); 
0BB0:  MOV     #A,W0
0BB2:  CALL    356
.................... 					Summer=0; 
0BB6:  CLR     E84
.................... 					for (f=0; f < 32; f++) 
0BB8:  CLR     E86
0BBA:  MOV     E86,W4
0BBC:  MOV     #20,W3
0BBE:  CP      W3,W4
0BC0:  BRA     LE,BD8
.................... 						{ 
.................... 					delay_us(10); 
0BC2:  REPEAT  #9E
0BC4:  NOP     
.................... 					Summer = Summer + read_adc(); // Read adc channel 10  
0BC6:  BCLR.B  340.0
0BC8:  BSET.B  340.1
0BCA:  BTSS.B  340.0
0BCC:  BRA     BCA
0BCE:  MOV     300,W0
0BD0:  LSR     W0,#2,W0
0BD2:  ADD     E84
0BD4:  INC     0E86
0BD6:  BRA     BBA
.................... 						} 
.................... 					ReturnedADC = Summer>>5; 
0BD8:  MOV     E84,W0
0BDA:  LSR     W0,#5,W0
0BDC:  MOV     W0,E82
.................... 	return(ReturnedADC);	 
0BDE:  PUSH    E82
0BE0:  POP     0
0BE2:  RETURN  
.................... 	} 
....................  
....................  
....................  
....................  
.................... //***************************************************************** 
.................... // Created Nov. 6, 2012 
.................... // Converts the ADC number on a scale of 5 volts minus some for Op-amp issues 
.................... // The numerical convertion is conveted into degrees C. 
.................... // The returned value in C degrees. 
.................... //  Ths interm convertion is to Kalvin and will later be switched over to Kalvin scale. 
.................... //***************************************************************** 
....................   
....................  
.................... float ConvertADCToKalvin(int ADCInputNumber) 
*
154E:  MOV     W5,[W15++]
1550:  MOV     W6,[W15++]
1552:  MOV     W7,[W15++]
1554:  MOV     W8,[W15++]
.................... 	{ 
.................... int16 ReturnedADC; 
.................... float32 ADCVoltageIn,Kelvin, tempfloater; 
....................     int8 highbyte, lowbyte; 
....................     int16 returneditem;  // this is the returned item 
.................... 	ReturnedADC = GetADCValue(ADCInputNumber);  //This gets the current ADC convertion for the channel number. 
1556:  PUSH    E6E
1558:  POP     E80
155A:  CALL    BA0
155E:  MOV     W0,E70
.................... //    ADCVoltageIn = ReturnedADC * 5.0 / 1024.0;  //Recycled the same float variable.  This is for the 5 volts version. 
....................   tempfloater = (float) ReturnedADC; 
1560:  MOV     E70,W0
1562:  CALL    BE4
1566:  MOV     W0,E7A
1568:  MOV     W1,E7C
....................   ADCVoltageIn = (float) ReturnedADC * 3.3 / 1024.0;  //Recycled the same float variable.  This converts the input into scaling 
156A:  MOV     E70,W0
156C:  CALL    BE4
1570:  MOV     W0,W5
1572:  MOV     W1,W6
1574:  MOV     W5,W0
1576:  MOV     W6,W1
1578:  MOV     #3333,W2
157A:  MOV     #4053,W3
157C:  CALL    C2E
1580:  MOV     W0,W5
1582:  MOV     W1,W6
1584:  MOV     W5,W0
1586:  MOV     W6,W1
1588:  MOV     #0,W2
158A:  MOV     #4480,W3
158C:  CALL    CF2
1590:  MOV     W0,E72
1592:  MOV     W1,E74
....................   
....................    
....................         lowbyte = 0x00FF & ReturnedADC; 
1594:  MOV     E70,W0
1596:  AND     #FF,W0
1598:  MOV.B   W0L,E6D
....................         returneditem = 0xFF00 & ReturnedADC; 
159A:  PUSH    E70
159C:  POP     E7E
159E:  MOV     #FF00,W0
15A0:  AND     E7E
....................         highbyte = ReturnedADC>8;  // this moves it over to the low part 
15A2:  MOV     E70,W4
15A4:  CP      W4,#8
15A6:  BRA     GT,15AC
15A8:  CLR.B   W0
15AA:  BRA     15AE
15AC:  MOV.B   #1,W0L
15AE:  MOV.B   W0L,E6C
....................         send_buffer[14] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
15B0:  MOV.B   E6D,W0L
15B2:  MOV.B   W0L,D2E
....................         send_buffer[13] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
15B4:  MOV.B   E6C,W0L
15B6:  MOV.B   W0L,D2D
....................  
.................... //Added May 18, 2015  - The current/last thermister is RL0503-7.56K-96-MS  it's a 30K thermister. 
.................... // This is for the thermister to be on the top of the 5K resistor 
....................   
.................... //	ADCVoltageIn = 5100.0*ADCVoltageIn/(3.3 - ADCVoltageIn);  // Calulate the thermister reistance over a voltage divider.  It's at the bottom of a 0 to 5 volts divider.  The resistance is 4.999K 
....................  
.................... //ADCVoltageIn = 4999.0*ADCVoltageIn/(5.0 - ADCVoltageIn);  // Calulate the thermister reistance over a voltage divider.  It's at the bottom of a 0 to 5 volts divider.  The resistance is 4.999K 
.................... //When it is when it's on the bottom....  The resistance becomes different. 
.................... //ADCVoltageIn = ADCVoltageIn/((5.0 - ADCVoltageIn)/4999.0);   // find the thermister resistace 
.................... ADCVoltageIn = ADCVoltageIn/((3.3 - ADCVoltageIn)/5100.0);   // find the thermister resistace 
15B8:  BSET.B  43.0
15BA:  MOV     #3333,W0
15BC:  MOV     #4053,W1
15BE:  MOV     E72,W2
15C0:  MOV     E74,W3
15C2:  CALL    DBC
15C6:  MOV     W0,W5
15C8:  MOV     W1,W6
15CA:  MOV     W5,W0
15CC:  MOV     W6,W1
15CE:  MOV     #6000,W2
15D0:  MOV     #459F,W3
15D2:  CALL    CF2
15D6:  MOV     W0,W2
15D8:  MOV     W1,W3
15DA:  MOV     E72,W0
15DC:  MOV     E74,W1
15DE:  CALL    CF2
15E2:  MOV     W0,E72
15E4:  MOV     W1,E74
....................  
....................  
.................... //ADCVoltageIn=12000.0; 
....................  
.................... DetermineTempCoef(); 
15E6:  CALL    12F2
....................  
.................... //Kelvin = (1/(tempa1 + tempa2*(log(ADCVoltageIn)) + tempa3*(log(ADCVoltageIn)*log(ADCVoltageIn))))-273.15;   //This is the old line of code used to find the thermister temperature 
.................... Kelvin = (1/(tempa1 + tempa2*(log(ADCVoltageIn)) + tempa3*(log(ADCVoltageIn)*log(ADCVoltageIn))))-273.15; 
15EA:  PUSH    E72
15EC:  POP     EAC
15EE:  PUSH    E74
15F0:  POP     EAE
15F2:  CALL    FCE
15F6:  MOV     W0,W2
15F8:  MOV     W1,W3
15FA:  MOV     A98,W0
15FC:  MOV     A9A,W1
15FE:  CALL    C2E
1602:  BCLR.B  43.0
1604:  MOV     W0,W2
1606:  MOV     W1,W3
1608:  MOV     A94,W0
160A:  MOV     A96,W1
160C:  CALL    DBC
1610:  MOV     W0,W5
1612:  MOV     W1,W6
1614:  PUSH    E72
1616:  POP     EAC
1618:  PUSH    E74
161A:  POP     EAE
161C:  CALL    FCE
1620:  MOV     W0,W7
1622:  MOV     W1,W8
1624:  PUSH    E72
1626:  POP     EAC
1628:  PUSH    E74
162A:  POP     EAE
162C:  CALL    FCE
1630:  MOV     W0,W2
1632:  MOV     W1,W3
1634:  MOV     W7,W0
1636:  MOV     W8,W1
1638:  CALL    C2E
163C:  MOV     W0,W2
163E:  MOV     W1,W3
1640:  MOV     A9C,W0
1642:  MOV     A9E,W1
1644:  CALL    C2E
1648:  BCLR.B  43.0
164A:  MOV     W0,W2
164C:  MOV     W1,W3
164E:  MOV     W5,W0
1650:  MOV     W6,W1
1652:  CALL    DBC
1656:  MOV     W0,W2
1658:  MOV     W1,W3
165A:  MOV     #0,W0
165C:  MOV     #3F80,W1
165E:  CALL    CF2
1662:  MOV     W0,W5
1664:  MOV     W1,W6
1666:  BSET.B  43.0
1668:  MOV     W5,W0
166A:  MOV     W6,W1
166C:  MOV     #9333,W2
166E:  MOV     #4388,W3
1670:  CALL    DBC
1674:  MOV     W0,E76
1676:  MOV     W1,E78
.................... 	return(Kelvin); 
1678:  MOV     E76,W0
167A:  MOV     E78,W1
167C:  MOV     [--W15],W8
167E:  MOV     [--W15],W7
1680:  MOV     [--W15],W6
1682:  MOV     [--W15],W5
1684:  RETURN  
.................... 	} 
....................  
....................  
....................  
.................... //********************************************************************* 
.................... // Created June 25, 2015 
.................... // This routine calls the water temperature program and averages together twenty points.  Twenty two points are 
.................... // collected and the high and low reading is thrown out.   
.................... // There is no input needed in this routine.  The result is returned as a float. 
.................... //********************************************************************* 
.................... float WaterTemperature(void) 
1686:  MOV     W5,[W15++]
1688:  MOV     W6,[W15++]
168A:  MOV     W7,[W15++]
.................... 	{ 
.................... float temparray[42], tempval; 
....................  
.................... int  switchflag,x;  //This is used in the ordering routine to indicate if two numbers have been switched.  If not, then the array is in numerical order. 
....................  
.................... for (x=0; x < 42; x++)   // Get all of the readings and save them in an array. 
168C:  CLR     E66
168E:  MOV     E66,W4
1690:  MOV     #2A,W3
1692:  CP      W3,W4
1694:  BRA     LE,16B0
.................... 	{ 
.................... 	temparray[x] = ConvertADCToKalvin(11);   //This called current thermisting reading routine. It returns a temperature reading in C. 
1696:  MOV     E66,W4
1698:  MUL.UU  W4,#4,W0
169A:  MOV     #DB8,W4
169C:  ADD     W0,W4,W5
169E:  MOV     #B,W4
16A0:  MOV     W4,E6E
16A2:  CALL    154E
16A6:  MOV     #0,W4
16A8:  MOV     [W4++],[W5++]
16AA:  MOV     [W4++],[W5++]
16AC:  INC     0E66
16AE:  BRA     168E
.................... 	} 
....................  
.................... //  Place the numbers in order in the array from the lowest reading at the high numbers indexs and the hightest readings at the low indexes. 
....................  
.................... do { 
.................... switchflag =0;  //Set it to zero indicating everything is in order. 
16B0:  CLR     E64
.................... for (x=0; x < 41; x++) 
16B2:  CLR     E66
16B4:  MOV     E66,W4
16B6:  MOV     #29,W3
16B8:  CP      W3,W4
16BA:  BRA     LE,172C
.................... 	{ 
.................... 	if (temparray[x] < temparray[x+1]) 
16BC:  MOV     E66,W4
16BE:  MUL.UU  W4,#4,W0
16C0:  MOV     #DB8,W4
16C2:  ADD     W0,W4,W0
16C4:  MOV     #A,W4
16C6:  MOV     [W0++],[W4++]
16C8:  MOV     [W0++],[W4++]
16CA:  MOV     E66,W4
16CC:  ADD     W4,#1,W7
16CE:  MOV     W7,W4
16D0:  MUL.UU  W4,#4,W0
16D2:  MOV     #DB8,W4
16D4:  ADD     W0,W4,W0
16D6:  MOV     W0,W4
16D8:  MOV     #0,W3
16DA:  MOV     [W4++],[W3++]
16DC:  MOV     [W4++],[W3++]
16DE:  MOV     W0,W2
16E0:  MOV     W1,W3
16E2:  MOV     W5,W0
16E4:  MOV     W6,W1
16E6:  CALL    F66
16EA:  BRA     NC,1728
.................... 		{ 
.................... 		tempval = temparray[x]; 
16EC:  MOV     E66,W4
16EE:  MUL.UU  W4,#4,W0
16F0:  MOV     #DB8,W4
16F2:  ADD     W0,W4,W0
16F4:  MOV     #E60,W4
16F6:  MOV     [W0++],[W4++]
16F8:  MOV     [W0++],[W4++]
.................... 		temparray[x] = temparray[x+1]; 
16FA:  MOV     E66,W4
16FC:  MUL.UU  W4,#4,W0
16FE:  MOV     #DB8,W4
1700:  ADD     W0,W4,W5
1702:  MOV     E66,W4
1704:  ADD     W4,#1,W6
1706:  MOV     W6,W4
1708:  MUL.UU  W4,#4,W0
170A:  MOV     #DB8,W4
170C:  ADD     W0,W4,W0
170E:  MOV     [W0++],[W5++]
1710:  MOV     [W0++],[W5++]
.................... 		temparray[x+1] = tempval; 
1712:  MOV     E66,W4
1714:  ADD     W4,#1,W5
1716:  MOV     W5,W4
1718:  MUL.UU  W4,#4,W0
171A:  MOV     #DB8,W4
171C:  ADD     W0,W4,W5
171E:  MOV     #E60,W4
1720:  MOV     [W4++],[W5++]
1722:  MOV     [W4++],[W5++]
.................... 		// Since this case is true, then switch the numbers in the array and set the not completed flag to 1. 
.................... 		switchflag =1;   //  Indicate are reversal needed to be done. 
1724:  MOV     #1,W4
1726:  MOV     W4,E64
.................... 		} 
1728:  INC     0E66
172A:  BRA     16B4
.................... 	} 
.................... } while(switchflag == 1);   //If the value is zero, the array is in order. 
172C:  MOV     E64,W4
172E:  CP      W4,#1
1730:  BRA     Z,16B0
....................  
....................  
.................... //  Average the numbers between 1 and 21.  This will kick out the hightest and lowest readings. 
.................... tempval = 0;   //recycled the varaible used for averaging the readings together. 
1732:  CLR     E60
1734:  CLR     E62
.................... for (x = 1; x < 41; x++) 
1736:  MOV     #1,W4
1738:  MOV     W4,E66
173A:  MOV     E66,W4
173C:  MOV     #29,W3
173E:  CP      W3,W4
1740:  BRA     LE,1768
.................... 	{ 
.................... 	tempval=tempval+temparray[x]; 
1742:  MOV     E66,W4
1744:  MUL.UU  W4,#4,W0
1746:  MOV     #DB8,W4
1748:  ADD     W0,W4,W0
174A:  MOV     W0,W4
174C:  MOV     #0,W3
174E:  MOV     [W4++],[W3++]
1750:  MOV     [W4++],[W3++]
1752:  BCLR.B  43.0
1754:  MOV     W0,W2
1756:  MOV     W1,W3
1758:  MOV     E60,W0
175A:  MOV     E62,W1
175C:  CALL    DBC
1760:  MOV     W0,E60
1762:  MOV     W1,E62
1764:  INC     0E66
1766:  BRA     173A
.................... 	} 
.................... 	tempval = tempval/40.0;   //Divide the added number by 20 which is the number of values added together. 
1768:  MOV     E60,W0
176A:  MOV     E62,W1
176C:  MOV     #0,W2
176E:  MOV     #4220,W3
1770:  CALL    CF2
1774:  MOV     W0,E60
1776:  MOV     W1,E62
....................  
....................  
.................... 	return(tempval); 
1778:  MOV     E60,W0
177A:  MOV     E62,W1
177C:  MOV     [--W15],W7
177E:  MOV     [--W15],W6
1780:  MOV     [--W15],W5
1782:  RETURN  
.................... 	} 
....................  
....................  
....................  
....................  
.................... //***************************************************************************************************** 
.................... // Created May 19, 2014 
.................... // Completed May 23, 2014 
.................... // This routine reads the data from the DO or pH.  This is including the pre-deteremined gains 
.................... // The inputs are as following: 
.................... // PWM input channel 
.................... //  The PWM magic number 
.................... // the channel sensor input channel    
.................... // DO is sensor 1 
....................  
.................... // SensprControl is  a number between 1 to 3 for each I2C 
.................... // PWMIntensity  this is the general starting point for the PWM 
.................... //  RequiredReading  - this is the required light reading needed to make a measurement.  THE PID will converg on this number. 
.................... //  Use the Pgain in the routine below to control the quickness of convergance. 
.................... //  the result is an unsigned 16 bit interger. 
.................... //***************************************************************************************************** 
.................... void TakeLightReading(int SensorChannel) 
.................... { 
....................  
.................... int color,attemptcounter, attempts,ttt,x; 
.................... int32 result,stepdifference;  //This is the result of the calculation.  This is returned to the calling function. 
....................  
.................... float DOReading,pgain,tempoffset; 
.................... char uffit[60]; 
....................  
.................... unsigned int32 difference; 
....................     int8 highbyte, lowbyte; 
....................     int16 returneditem;  // this is the returned item 
....................  
....................  
....................      
....................  
....................      
.................... //************************************************************************************* 
.................... //  Added Augest 28, 2015 
.................... // This section measures the DO 
.................... //************************************************************************************* 
.................... //****************************************************************************** 
.................... // Created November 14, 2016 
.................... //  This routine measure the light patch for DO. 
.................... // This routine cycles through all of the colors and gets the number for each LED turned on.  This helps with filtering. 
.................... //  Nothing is returned   
.................... //****************************************************************************** 
.................... if (SensorChannel == 0) 
.................... { 
.................... 	selectsensor(SensorChannel);    // Added December 9, 2015     Sensor 1 is NH4. 
....................  
....................     output_high(PIN_B12);  // turn on green 
....................     delay_ms(100);  // set a PWM setup delay to stablize the timing. 
.................... } 
....................  
....................  
.................... if (SensorChannel == 1) 
.................... { 
.................... 	selectsensor(SensorChannel);    // Added December 9, 2015     Sensor 1 is NH4. 
....................     output_high(PIN_B12);  // turn on green 
....................     delay_ms(100);  // set a PWM setup delay to stablize the timing. 
.................... } 
....................  
....................  
.................... // 2 is not populated.  Added April 5, 2017 
.................... if (SensorChannel == 3) 
.................... { 
.................... 	selectsensor(SensorChannel);    // Added December 9, 2015     Sensor 1 is NH4. 
....................     output_high(PIN_B12);  // turn on green 
....................     delay_ms(100);  // set a PWM setup delay to stablize the timing. 
.................... } 
....................  
.................... 	color = GetCurrentColorAVG(3, SensorChannel);   // Number 2 is the colored  LED.  The 4 means it any gain reading 
....................  
.................... // turn off all lights 
.................... 	output_low(PIN_B12);    // turn off the blue light 
....................   
.................... 	//redABS = redABS - AmbientOxyRed; 
.................... //	greenABS = greenABS - AmbientOxyGreen; 
.................... 	//blueABS = blueABS - AmbientOxyBlue; 
.................... 	//clearABS = clearABS - AmbientOxyClear; 
....................  
.................... //if the number is less than 0, then set it to zero.  It's not possible to have negitave light. 
.................... // on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
.................... /* 
.................... if (blueABS < 0) 
.................... 	{ 
.................... 	blueABS = 0; 
.................... 	} 
.................... if (clearABS < 0) 
.................... 	{ 
.................... 	clearABS = 0; 
.................... 	}     
....................  
....................         lowbyte = 0x00FF & redABS; 
....................         returneditem = 0xFF00 & redABS; 
....................         highbyte = redABS>8;  // this moves it over to the low part 
....................         send_buffer[20] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
....................         send_buffer[19] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the    
....................      
....................      
.................... if (greenABS < 0) 
.................... 	{ 
.................... 	greenABS = 0; 
.................... 	} 
.................... if (blueABS < 0) 
.................... 	{ 
.................... 	blueABS = 0; 
.................... 	} 
.................... if (clearABS < 0) 
.................... 	{ 
.................... 	clearABS = 0; 
.................... 	}     
....................          
....................   
....................         lowbyte = 0x00FF & blueABS; 
....................         returneditem = 0xFF00 & blueABS; 
....................         highbyte = blueABS>8;  // this moves it over to the low part 
....................         send_buffer[24] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
....................         send_buffer[23] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the        
....................      
....................    } 
....................       // check for white 
....................         // turn on all of the LEDS for white 
....................     if (x==3)  // this checks the green light 
....................      { 
....................     output_low(PIN_B11);    // turn on the blue light 
....................     output_low(PIN_B12);    // turn on the blue light 
....................     output_low(PIN_B10);    // turn off the red light 
....................         delay_ms(200);  // set a PWM setup delay to stablize the timing. 
.................... 	color = GetCurrentColorAVG(3, 2);   // Number 2 is the colored  LED.  The 4 means it any gain reading 
.................... 	output_high(PIN_B11);    // turn on the blue light 
....................     output_high(PIN_B12);    // turn on the blue light 
....................     output_high(PIN_B10);    // turn off the red light 
....................   
.................... 	//redABS = redABS - AmbientOxyRed; 
.................... 	//greenABS = greenABS - AmbientOxyGreen; 
.................... 	//blueABS = blueABS - AmbientOxyBlue; 
.................... 	clearABS = clearABS - AmbientOxyClear; 
....................  
....................      
....................     if (clearABS < 0) 
.................... 	{ 
.................... 	clearABS = 0; 
.................... 	}  
....................      
....................         lowbyte = 0x00FF & clearABS; 
....................         returneditem = 0xFF00 & clearABS; 
....................         highbyte = clearABS>8;  // this moves it over to the low part 
....................         send_buffer[26] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
....................         send_buffer[25] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
....................   
....................     }     
....................     } 
....................     } 
....................  */ 
.................... 	} 
....................  
....................  
....................  
.................... //********************************************************************* 
.................... //  
.................... void main(void){ 
*
1B74:  MOV     #F50,W15
1B76:  MOV     #FFF,W0
1B78:  MOV     W0,20
1B7A:  NOP     
1B7C:  BSET.B  81.7
1B7E:  BSET.B  44.2
1B80:  MOV     #0,W0
1B82:  MOV     W0,34
1B84:  CLR     744
1B86:  BCLR.B  2CC.2
1B88:  BSET.B  217.7
1B8A:  BSET.B  217.5
1B8C:  BSET.B  216.6
1B8E:  BCLR.B  217.3
1B90:  BSET.B  216.7
1B92:  BCLR.B  217.0
1B94:  BSET.B  217.1
1B96:  BCLR.B  217.2
1B98:  MOV     #50,W4
1B9A:  MOV     W4,21A
1B9C:  BCLR.B  2CD.1
1B9E:  BSET.B  207.7
1BA0:  BSET.B  207.5
1BA2:  BSET.B  206.6
1BA4:  BCLR.B  207.3
1BA6:  BSET.B  206.7
1BA8:  BCLR.B  207.0
1BAA:  BSET.B  207.1
1BAC:  BCLR.B  207.2
1BAE:  CLR     20A
1BB0:  MOV     #9D,W4
1BB2:  MOV     W4,204
1BB4:  CLR.B   AAC
1BB6:  CLR.B   AAD
1BB8:  MOV.B   #2,W0L
1BBA:  MOV.B   W0L,AAE
1BBC:  MOV     #CCCD,W4
1BBE:  MOV     W4,B94
1BC0:  MOV     #BDCC,W4
1BC2:  MOV     W4,B96
1BC4:  CLR     C00
1BC6:  CLR     C02
1BC8:  MOV     #41A0,W4
1BCA:  MOV     W4,C04
1BCC:  MOV     #FA,W4
1BCE:  MOV     W4,C48
1BD0:  CLR     C4A
1BD2:  MOV     #C8,W4
1BD4:  MOV     W4,C4C
1BD6:  CLR     C4E
1BD8:  CLR.B   D61
1BDA:  MOV.B   #3,W0L
1BDC:  MOV.B   W0L,DA3
1BDE:  CLR     4E0
1BE0:  CLR     4E2
1BE2:  BRA     1D2E
1BE4:  DATA    80,02,08
1BE6:  DATA    5A,00,00
1BE8:  DATA    80,80,08
1BEA:  DATA    60,7C,88
1BEC:  DATA    59,39,E0
1BEE:  DATA    97,A6,3A
1BF0:  DATA    C4,1D,1E
1BF2:  DATA    3C,5E,50
1BF4:  DATA    63,3D,1A
1BF6:  DATA    FE,75,3E
1BF8:  DATA    18,72,31
1BFA:  DATA    3F,0F,8C
1BFC:  DATA    55,A6,82
1BFE:  DATA    95,D9,3D
1C00:  DATA    E6,D7,FF
1C02:  DATA    E5,C9,90
1C04:  DATA    C7,BD,CE
1C06:  DATA    40,12,47
1C08:  DATA    0C,B7,42
1C0A:  DATA    3E,9F,6D
1C0C:  DATA    94,C3,25
1C0E:  DATA    6D,7A,3E
1C10:  DATA    DA,32,0E
1C12:  DATA    BE,9F,3E
1C14:  DATA    B6,3E,6D
1C16:  DATA    AA,28,C2
1C18:  DATA    B4,FA,EF
1C1A:  DATA    3E,89,E0
1C1C:  DATA    29,E5,A4
1C1E:  DATA    30,24,3F
1C20:  DATA    A3,8E,FA
1C22:  DATA    E3,7E,D8
1C24:  DATA    55,3F,C6
1C26:  DATA    04,8A,78
1C28:  DATA    AB,B2,83
1C2A:  DATA    3F,CD,ED
1C2C:  DATA    A6,D6,08
1C2E:  DATA    6B,AC,3F
1C30:  DATA    FD,D1,84
1C32:  DATA    FF,BD,BF
1C34:  DATA    CE,3F,A1
1C36:  DATA    35,FA,FE
1C38:  DATA    42,2E,E6
1C3A:  DATA    3F,99,47
1C3C:  DATA    8A,BF,00
1C3E:  DATA    00,00,40
1C40:  DATA    40,08,00
1C42:  DATA    00,08,4C
1C44:  DATA    F3,BA,3D
1C46:  DATA    2B,9D,5F
1C48:  DATA    BF,40,08
1C4A:  DATA    00,00,18
1C4C:  DATA    05,BD,9A
1C4E:  DATA    4A,1A,A6
1C50:  DATA    C2,BF,B4
1C52:  DATA    B9,2A,1D
1C54:  DATA    07,D9,F5
1C56:  DATA    3F,02,EB
1C58:  DATA    89,67,DB
1C5A:  DATA    F6,08,C0
1C5C:  DATA    40,07,00
1C5E:  DATA    00,39,40
1C60:  DATA    2B,F2,93
1C62:  DATA    8B,43,C5
1C64:  DATA    78,3F,4F
1C66:  DATA    E0,5D,A2
1C68:  DATA    84,A9,CA
1C6A:  DATA    BF,38,8F
1C6C:  DATA    AC,EF,B5
1C6E:  DATA    D2,F1,3F
1C70:  DATA    D8,3F,DF
1C72:  DATA    BC,30,4C
1C74:  DATA    FE,BF,37
1C76:  DATA    BF,FD,3E
1C78:  DATA    3D,AA,93
1C7A:  DATA    C0,EE,50
1C7C:  DATA    B3,40,00
1C7E:  DATA    00,80,3F
1C80:  DATA    0A,8D,B1
1C82:  DATA    C0,EE,50
1C84:  DATA    B3,40,40
1C86:  DATA    06,00,00
1C88:  DATA    6B,F0,3F
1C8A:  DATA    5C,0A,58
1C8C:  DATA    F6,3B,8F
1C8E:  DATA    00,C0,3C
1C90:  DATA    8B,28,AC
1C92:  DATA    3C,BE,F6
1C94:  DATA    3F,D2,D5
1C96:  DATA    44,16,8C
1C98:  DATA    15,D7,BF
1C9A:  DATA    69,00,5A
1C9C:  DATA    2E,1B,87
1C9E:  DATA    99,3F,9A
1CA0:  DATA    5F,AD,4B
1CA2:  DATA    91,E4,01
1CA4:  DATA    C0,5D,11
1CA6:  DATA    2F,92,E4
1CA8:  DATA    81,FB,3F
1CAA:  DATA    38,DA,91
1CAC:  DATA    80,9D,C5
1CAE:  DATA    E0,BF,6F
1CB0:  DATA    12,C0,B4
1CB2:  DATA    C3,09,AB
1CB4:  DATA    3F,6B,C1
1CB6:  DATA    03,4E,C1
1CB8:  DATA    B5,45,BF
1CBA:  DATA    0A,89,34
1CBC:  DATA    3E,7C,79
1CBE:  DATA    B5,40,3F
1CC0:  DATA    02,B3,41
1CC2:  DATA    33,8C,9E
1CC4:  DATA    41,00,00
1CC6:  DATA    80,3F,1B
1CC8:  DATA    E4,35,41
1CCA:  DATA    A4,DB,E7
1CCC:  DATA    41,33,8C
1CCE:  DATA    9E,41,F7
1CD0:  DATA    40,05,FF
1CD2:  DATA    00,5A,EF
1CD4:  DATA    3F,F3,A3
1CD6:  DATA    E2,F7,D7
1CD8:  DATA    FF,01,40
1CDA:  DATA    C0,B4,FF
1CDC:  DATA    05,3C,58
1CDE:  DATA    FC,3F,3B
1CE0:  DATA    D3,C0,B5
1CE2:  DATA    BA,8C,E2
1CE4:  DATA    3F,39,D3
1CE6:  DATA    C7,3D,41
1CE8:  DATA    79,B2,3F
1CEA:  DATA    87,0D,3C
1CEC:  DATA    50,D0,AF
1CEE:  DATA    62,3F,30
1CF0:  DATA    4B,8D,A2
1CF2:  DATA    82,AA,04
1CF4:  DATA    40,09,A0
1CF6:  DATA    40,4A,05
1CF8:  DATA    76,03,40
1CFA:  DATA    EC,9E,37
1CFC:  DATA    88,A6,44
1CFE:  DATA    F0,3F,8F
1D00:  DATA    12,8D,29
1D02:  DATA    9A,5B,C7
1D04:  DATA    3F,0E,E0
1D06:  DATA    80,7C,A1
1D08:  DATA    D8,86,3F
1D0A:  DATA    29,4B,FB
1D0C:  DATA    95,C2,37
1D0E:  DATA    1A,3F,00
1D10:  DATA    00,00,00
1D12:  INC     W2,W2
1D14:  CP      W2,#1
1D16:  BRA     NZ,1D20
1D18:  TBLRDL  [W1],W3
1D1A:  TBLRDH  [W1++],W4
1D1C:  MOV.B   6,W0L
1D1E:  RETURN  
1D20:  CP      W2,#2
1D22:  BRA     NZ,1D28
1D24:  MOV.B   7,W0L
1D26:  RETURN  
1D28:  MOV.B   8,W0L
1D2A:  CLR     W2
1D2C:  RETURN  
1D2E:  MOV     #0,W6
1D30:  MOV     #0,W0
1D32:  MOV     W0,32
1D34:  MOV     #1BE4,W0
1D36:  MOV     W0,W1
1D38:  CLR     W2
1D3A:  CALL    1D12
1D3E:  MOV.B   W0L,B
1D40:  CALL    1D12
1D44:  MOV.B   W0L,A
1D46:  CP0     W5
1D48:  BRA     Z,1D7C
1D4A:  BTSS    W5.F
1D4C:  BRA     1D5C
1D4E:  CALL    1D12
1D52:  MOV.B   W0L,D
1D54:  CALL    1D12
1D58:  MOV.B   W0L,C
1D5A:  BCLR    W5.F
1D5C:  BTSS    W5.E
1D5E:  BRA     1D70
1D60:  BCLR    W5.E
1D62:  DEC     W5,W5
1D64:  CALL    1D12
1D68:  MOV.B   W0L,W7L
1D6A:  REPEAT  W5
1D6C:  MOV.B   W7L,[W6++]
1D6E:  BRA     1D3A
1D70:  CALL    1D12
1D74:  MOV.B   W0L,[W6++]
1D76:  DEC     W5,W5
1D78:  BRA     NZ,1D70
1D7A:  BRA     1D3A
1D7C:  CLR.B   DA6
....................     int8 x,returdata; 
....................     int returneddummy; 
....................     int16 changeover;  //this is used for changeing the int32 to 16 bit. 
....................     int32 OxyBlue; 
....................     float xxx; 
....................     int8 blinkinggreenlight = 0;  // Added March 30, 2017  This is the blinking green light counter varaible 
....................  
....................     int16 returneditem;  // this is the returned item 
....................     int8 highbyte, lowbyte; 
....................      
....................     Temp1DOOne = 9.5;            //These are the set points where we want to read these numbers at temperature 1 
1D7E:  CLR     CD2
1D80:  MOV     #4118,W4
1D82:  MOV     W4,CD4
.................... 	Temp1DOTwo = 4.0;            //This is at 10 degrees 
1D84:  CLR     CD6
1D86:  MOV     #4080,W4
1D88:  MOV     W4,CD8
.................... 	Temp1DOThree = 0.0; 
1D8A:  CLR     CDA
1D8C:  CLR     CDC
....................  
.................... 	Temp2DOOne = 7.5;            //These are the set points where we want to read these numbers at temperature 2 
1D8E:  CLR     CDE
1D90:  MOV     #40F0,W4
1D92:  MOV     W4,CE0
.................... 	Temp2DOTwo = 4.0;				//This is at 20 degrees 
1D94:  CLR     CE2
1D96:  MOV     #4080,W4
1D98:  MOV     W4,CE4
.................... 	Temp2DOThree = 0.0; 
1D9A:  CLR     CE6
1D9C:  CLR     CE8
....................  
.................... 	Temp3DOOne = 6.7;            //These are the set points where we want to read these numbers temperature 3 
1D9E:  MOV     #6666,W4
1DA0:  MOV     W4,CEA
1DA2:  MOV     #40D6,W4
1DA4:  MOV     W4,CEC
.................... 	Temp3DOTwo = 4.0;            //This is at 25 degrees 
1DA6:  CLR     CEE
1DA8:  MOV     #4080,W4
1DAA:  MOV     W4,CF0
.................... 	Temp3DOThree = 0.0; 
1DAC:  CLR     CF2
1DAE:  CLR     CF4
....................  
....................  
.................... 	Temp1ReadingOne = 10752.0;       //Readings for Temp3  10 degrees C 
1DB0:  CLR     CF6
1DB2:  MOV     #4628,W4
1DB4:  MOV     W4,CF8
.................... 	Temp1ReadingTwo = 11000.0;      //Readings for Temp3 
1DB6:  MOV     #E000,W4
1DB8:  MOV     W4,CFA
1DBA:  MOV     #462B,W4
1DBC:  MOV     W4,CFC
.................... 	Temp1ReadingThree = 12000.0;    //Readings for DOOne    this is no DO. 
1DBE:  MOV     #8000,W4
1DC0:  MOV     W4,CFE
1DC2:  MOV     #463B,W4
1DC4:  MOV     W4,D00
....................  
.................... 	Temp2ReadingOne = 11266.0;       //Readings for Temp3    20 degrees C 
1DC6:  MOV     #800,W4
1DC8:  MOV     W4,D02
1DCA:  MOV     #4630,W4
1DCC:  MOV     W4,D04
.................... 	Temp2ReadingTwo = 12000.0;      //Readings for Temp3 
1DCE:  MOV     #8000,W4
1DD0:  MOV     W4,D06
1DD2:  MOV     #463B,W4
1DD4:  MOV     W4,D08
.................... 	Temp2ReadingThree = 13000.0;    //Readings for DOOne 
1DD6:  MOV     #2000,W4
1DD8:  MOV     W4,D0A
1DDA:  MOV     #464B,W4
1DDC:  MOV     W4,D0C
....................  
.................... 	Temp3ReadingOne = 12425.0;       //Readings for Temp3   25 degrees C 
1DDE:  MOV     #2400,W4
1DE0:  MOV     W4,D0E
1DE2:  MOV     #4642,W4
1DE4:  MOV     W4,D10
.................... 	Temp3ReadingTwo = 13000.0;      //Readings for Temp3 
1DE6:  MOV     #2000,W4
1DE8:  MOV     W4,D12
1DEA:  MOV     #464B,W4
1DEC:  MOV     W4,D14
.................... 	Temp3ReadingThree = 14000.0;    //Readings for DOOne 
1DEE:  MOV     #C000,W4
1DF0:  MOV     W4,D16
1DF2:  MOV     #465A,W4
1DF4:  MOV     W4,D18
.................... 	TempOne = 10.0;       //Calibration temperatures for DO   Added April 7, 2015 
1DF6:  MOV     #A,W4
1DF8:  MOV     W4,D1A
....................  	TempTwo =  20.0;      //Calibration temperatures for DO  Added April 7, 2015 
1DFA:  MOV     #14,W4
1DFC:  MOV     W4,D1C
.................... 	TempThree =  25.0;     //Calibration temperatures for DO  Added April 7, 2015 
1DFE:  MOV     #19,W4
1E00:  MOV     W4,D1E
....................      
.................... output_low(PIN_B7);  // this turns on the green piolate light LED for showing the board is running.  It also blinks through out the wnile(1) loop  Added March 30, 2017 
1E02:  BCLR.B  2C8.7
1E04:  BCLR.B  2CC.7
.................... initTransMitBuffer();  // clear the sending buffer 
1E06:  CALL    33A
.................... LEDtest(); 
1E0A:  CALL    366
.................... //enable_interrupts(GLOBAL); 
....................  
....................  
.................... InitTAOS(); // this sets up the scaler time for the DO light 
1E0E:  CALL    444
.................... //StartUpTAOS(0x00);  // this starts up the integration time for the DO light sensor 
.................... setup_adc(ADC_CLOCK_INTERNAL); 
1E12:  MOV     #9F00,W4
1E14:  MOV     W4,344
1E16:  MOV     #8470,W4
1E18:  MOV     W4,340
.................... setup_adc_ports(sAN11|sAN12); 
1E1A:  CLR     4E0
1E1C:  MOV     #3000,W4
1E1E:  MOV     W4,4E2
1E20:  CLR     342
.................... enable_interrupts(INT_SI2C2);      
1E22:  BSET.B  9A.1
....................  
.................... //returndata = SaveConfiguration(); 
....................  
....................  //   CalculateCRC(); 
.................... LoadConfiguration(); 
1E24:  CALL    538
.................... rcv_buffer[2]==0x00;  // clear any buffer data for triggering calibration changes. 
1E28:  CP0.B   D64
1E2A:  BRA     Z,1E30
1E2C:  CLR.B   W0
1E2E:  BRA     1E30
....................  
....................  
.................... while(1) 
.................... {  
.................... // read the DO measurement 
....................     //FindAmbientLight(0x01);   // this selects DO   Find the background light with no blue light on 
....................         output_high(PIN_B12); 
1E30:  BCLR.B  2C9.4
1E32:  BSET.B  2CD.4
....................         returdata = GetCurrentColor(0x03, 0x01); 
1E34:  MOV.B   #3,W0L
1E36:  MOV.B   W0L,DD6
1E38:  MOV.B   #1,W0L
1E3A:  MOV.B   W0L,DD7
1E3C:  CALL    A70
1E40:  MOV.B   W0L,DA5
....................   
....................     //   TakeLightReading(0x03);    
....................     wTemp = WaterTemperature(); 
1E42:  CALL    1686
1E46:  MOV     W0,C02
1E48:  MOV     W1,C04
....................      
....................  
....................         output_low(PIN_B12); 
1E4A:  BCLR.B  2C9.4
1E4C:  BCLR.B  2CD.4
....................     // this seaves DO measurements 
....................         changeover = (int16) greenABS; 
1E4E:  PUSH    BD0
1E50:  POP     DAC
....................         lowbyte = 0x00FF & changeover; 
1E52:  MOV     DAC,W0
1E54:  AND     #FF,W0
1E56:  MOV.B   W0L,DA8
....................         returneditem = 0xFF00 & changeover; 
1E58:  PUSH    DAC
1E5A:  POP     DB6
1E5C:  MOV     #FF00,W0
1E5E:  AND     DB6
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
1E60:  CLR.B   1
1E62:  MOV.B   DB7,W0L
1E64:  MOV.B   W0L,DA7
....................      //   send_buffer[22] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
....................      //   send_buffer[21] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
....................  
....................         changeover = (int16) redABS; 
1E66:  PUSH    BC8
1E68:  POP     DAC
....................         lowbyte = 0x00FF & changeover; 
1E6A:  MOV     DAC,W0
1E6C:  AND     #FF,W0
1E6E:  MOV.B   W0L,DA8
....................         returneditem = 0xFF00 & changeover; 
1E70:  PUSH    DAC
1E72:  POP     DB6
1E74:  MOV     #FF00,W0
1E76:  AND     DB6
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
1E78:  CLR.B   1
1E7A:  MOV.B   DB7,W0L
1E7C:  MOV.B   W0L,DA7
....................         send_buffer[16] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
1E7E:  MOV.B   DA8,W0L
1E80:  MOV.B   W0L,D30
....................         send_buffer[15] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
1E82:  MOV.B   DA7,W0L
1E84:  MOV.B   W0L,D2F
....................  
....................         changeover = (int16) blueABS; 
1E86:  PUSH    BCC
1E88:  POP     DAC
....................         lowbyte = 0x00FF & changeover; 
1E8A:  MOV     DAC,W0
1E8C:  AND     #FF,W0
1E8E:  MOV.B   W0L,DA8
....................         returneditem = 0xFF00 & changeover; 
1E90:  PUSH    DAC
1E92:  POP     DB6
1E94:  MOV     #FF00,W0
1E96:  AND     DB6
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
1E98:  CLR.B   1
1E9A:  MOV.B   DB7,W0L
1E9C:  MOV.B   W0L,DA7
....................      //   send_buffer[22] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
....................      //   send_buffer[21] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
....................  
....................         changeover = (int16) clearABS; 
1E9E:  PUSH    BD4
1EA0:  POP     DAC
....................         lowbyte = 0x00FF & changeover; 
1EA2:  MOV     DAC,W0
1EA4:  AND     #FF,W0
1EA6:  MOV.B   W0L,DA8
....................         returneditem = 0xFF00 & changeover; 
1EA8:  PUSH    DAC
1EAA:  POP     DB6
1EAC:  MOV     #FF00,W0
1EAE:  AND     DB6
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
1EB0:  CLR.B   1
1EB2:  MOV.B   DB7,W0L
1EB4:  MOV.B   W0L,DA7
....................      //   send_buffer[22] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
....................      //   send_buffer[21] = highbyte;   // update this 
....................      
....................      
.................... //sysOutput.wTemp = 10.0; 
....................      output_high(PIN_B5);  // turn on white DpH LED 
1EB6:  BCLR.B  2C8.5
1EB8:  BSET.B  2CC.5
....................           // TakeLightReading(0x00);    
....................   // this selects DpH  Take a measurement and find the ABS color difference 
....................     returdata =  GetCurrentColorAVG(0x03, 0x00); 
1EBA:  MOV.B   #3,W0L
1EBC:  MOV.B   W0L,DB8
1EBE:  CLR.B   DB9
1EC0:  CALL    1812
1EC4:  MOV.B   W0L,DA5
....................      output_low(PIN_B5);  // turn on white DpH LED 
1EC6:  BCLR.B  2C8.5
1EC8:  BCLR.B  2CC.5
....................     // this saves DpH measurements 
....................         changeover = (int16) greenABS; 
1ECA:  PUSH    BD0
1ECC:  POP     DAC
....................         lowbyte = 0x00FF & changeover; 
1ECE:  MOV     DAC,W0
1ED0:  AND     #FF,W0
1ED2:  MOV.B   W0L,DA8
....................         returneditem = 0xFF00 & changeover; 
1ED4:  PUSH    DAC
1ED6:  POP     DB6
1ED8:  MOV     #FF00,W0
1EDA:  AND     DB6
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
1EDC:  CLR.B   1
1EDE:  MOV.B   DB7,W0L
1EE0:  MOV.B   W0L,DA7
....................         send_buffer[22] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
1EE2:  MOV.B   DA8,W0L
1EE4:  MOV.B   W0L,D36
....................         send_buffer[21] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
1EE6:  MOV.B   DA7,W0L
1EE8:  MOV.B   W0L,D35
....................  
....................         changeover = (int16) redABS; 
1EEA:  PUSH    BC8
1EEC:  POP     DAC
....................         lowbyte = 0x00FF & changeover; 
1EEE:  MOV     DAC,W0
1EF0:  AND     #FF,W0
1EF2:  MOV.B   W0L,DA8
....................         returneditem = 0xFF00 & changeover; 
1EF4:  PUSH    DAC
1EF6:  POP     DB6
1EF8:  MOV     #FF00,W0
1EFA:  AND     DB6
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
1EFC:  CLR.B   1
1EFE:  MOV.B   DB7,W0L
1F00:  MOV.B   W0L,DA7
....................         send_buffer[20] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
1F02:  MOV.B   DA8,W0L
1F04:  MOV.B   W0L,D34
....................         send_buffer[19] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
1F06:  MOV.B   DA7,W0L
1F08:  MOV.B   W0L,D33
....................  
....................         changeover = (int16) blueABS; 
1F0A:  PUSH    BCC
1F0C:  POP     DAC
....................         lowbyte = 0x00FF & changeover; 
1F0E:  MOV     DAC,W0
1F10:  AND     #FF,W0
1F12:  MOV.B   W0L,DA8
....................         returneditem = 0xFF00 & changeover; 
1F14:  PUSH    DAC
1F16:  POP     DB6
1F18:  MOV     #FF00,W0
1F1A:  AND     DB6
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
1F1C:  CLR.B   1
1F1E:  MOV.B   DB7,W0L
1F20:  MOV.B   W0L,DA7
....................         send_buffer[24] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
1F22:  MOV.B   DA8,W0L
1F24:  MOV.B   W0L,D38
....................         send_buffer[23] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
1F26:  MOV.B   DA7,W0L
1F28:  MOV.B   W0L,D37
....................  
....................         changeover = (int16) clearABS; 
1F2A:  PUSH    BD4
1F2C:  POP     DAC
....................         lowbyte = 0x00FF & changeover; 
1F2E:  MOV     DAC,W0
1F30:  AND     #FF,W0
1F32:  MOV.B   W0L,DA8
....................         returneditem = 0xFF00 & changeover; 
1F34:  PUSH    DAC
1F36:  POP     DB6
1F38:  MOV     #FF00,W0
1F3A:  AND     DB6
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
1F3C:  CLR.B   1
1F3E:  MOV.B   DB7,W0L
1F40:  MOV.B   W0L,DA7
....................         send_buffer[26] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
1F42:  MOV.B   DA8,W0L
1F44:  MOV.B   W0L,D3A
....................         send_buffer[25] = highbyte;   // update this 
1F46:  MOV.B   DA7,W0L
1F48:  MOV.B   W0L,D39
....................      
....................          
....................         output_low(PIN_B10);  // turn on white NH4 LED 
1F4A:  BCLR.B  2C9.2
1F4C:  BCLR.B  2CD.2
....................          // this selects NH4  Take a measurement and find the ABS color difference 
....................          returdata =  GetCurrentColorAVG(0x03, 0x03); 
1F4E:  MOV.B   #3,W0L
1F50:  MOV.B   W0L,DB8
1F52:  MOV.B   #3,W0L
1F54:  MOV.B   W0L,DB9
1F56:  CALL    1812
1F5A:  MOV.B   W0L,DA5
....................         output_high(PIN_B10);  // turn off white NH4 LED 
1F5C:  BCLR.B  2C9.2
1F5E:  BSET.B  2CD.2
....................     // this saves DpH measurements 
....................         changeover = (int16) greenABS; 
1F60:  PUSH    BD0
1F62:  POP     DAC
....................          lowbyte = 0x00FF & changeover; 
1F64:  MOV     DAC,W0
1F66:  AND     #FF,W0
1F68:  MOV.B   W0L,DA8
....................         returneditem = 0xFF00 & changeover; 
1F6A:  PUSH    DAC
1F6C:  POP     DB6
1F6E:  MOV     #FF00,W0
1F70:  AND     DB6
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
1F72:  CLR.B   1
1F74:  MOV.B   DB7,W0L
1F76:  MOV.B   W0L,DA7
....................         send_buffer[28] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
1F78:  MOV.B   DA8,W0L
1F7A:  MOV.B   W0L,D3C
....................         send_buffer[27] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
1F7C:  MOV.B   DA7,W0L
1F7E:  MOV.B   W0L,D3B
....................  
....................         changeover = (int16) redABS; 
1F80:  PUSH    BC8
1F82:  POP     DAC
....................         lowbyte = 0x00FF & changeover; 
1F84:  MOV     DAC,W0
1F86:  AND     #FF,W0
1F88:  MOV.B   W0L,DA8
....................         returneditem = 0xFF00 & changeover; 
1F8A:  PUSH    DAC
1F8C:  POP     DB6
1F8E:  MOV     #FF00,W0
1F90:  AND     DB6
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
1F92:  CLR.B   1
1F94:  MOV.B   DB7,W0L
1F96:  MOV.B   W0L,DA7
....................         send_buffer[32] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
1F98:  MOV.B   DA8,W0L
1F9A:  MOV.B   W0L,D40
....................         send_buffer[31] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
1F9C:  MOV.B   DA7,W0L
1F9E:  MOV.B   W0L,D3F
....................  
....................         changeover = (int16) blueABS; 
1FA0:  PUSH    BCC
1FA2:  POP     DAC
....................         lowbyte = 0x00FF & changeover; 
1FA4:  MOV     DAC,W0
1FA6:  AND     #FF,W0
1FA8:  MOV.B   W0L,DA8
....................         returneditem = 0xFF00 & changeover; 
1FAA:  PUSH    DAC
1FAC:  POP     DB6
1FAE:  MOV     #FF00,W0
1FB0:  AND     DB6
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
1FB2:  CLR.B   1
1FB4:  MOV.B   DB7,W0L
1FB6:  MOV.B   W0L,DA7
....................         send_buffer[34] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
1FB8:  MOV.B   DA8,W0L
1FBA:  MOV.B   W0L,D42
....................         send_buffer[33] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
1FBC:  MOV.B   DA7,W0L
1FBE:  MOV.B   W0L,D41
....................  
....................         changeover = (int16) clearABS; 
1FC0:  PUSH    BD4
1FC2:  POP     DAC
....................         lowbyte = 0x00FF & changeover; 
1FC4:  MOV     DAC,W0
1FC6:  AND     #FF,W0
1FC8:  MOV.B   W0L,DA8
....................         returneditem = 0xFF00 & changeover; 
1FCA:  PUSH    DAC
1FCC:  POP     DB6
1FCE:  MOV     #FF00,W0
1FD0:  AND     DB6
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
1FD2:  CLR.B   1
1FD4:  MOV.B   DB7,W0L
1FD6:  MOV.B   W0L,DA7
....................         send_buffer[36] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
1FD8:  MOV.B   DA8,W0L
1FDA:  MOV.B   W0L,D44
....................         send_buffer[35] = highbyte;   // update this 
1FDC:  MOV.B   DA7,W0L
1FDE:  MOV.B   W0L,D43
....................        /*  
....................          
....................         xxx =  CalcaulateDO(redABS,wTemp);  //This holds the color intensity variable and the temperature in degrees C. 
....................      
....................      
....................     */ 
....................      
....................     	sysOutput.wTemp = wTemp;  //This is the float temperature 
1FE0:  PUSH    C02
1FE2:  POP     A3E
1FE4:  PUSH    C04
1FE6:  POP     A40
....................      
....................     	if (sysOutput.wTemp < 0.0) 
1FE8:  MOV     A3E,W0
1FEA:  MOV     A40,W1
1FEC:  MOV     #0,W2
1FEE:  MOV     #0,W3
1FF0:  CALL    F66
1FF4:  BRA     NC,1FFE
....................         { 
.................... 		sysOutput.wTemp = 0.0; 
1FF6:  CLR     A3E
1FF8:  CLR     A40
....................         wTemp = 0.0; 
1FFA:  CLR     C02
1FFC:  CLR     C04
....................         } 
....................     // move calcaulated temperature into output buffer for water temperature 
....................     send_buffer[5] =  (int) wTemp;  // high whole number byte 
1FFE:  MOV     C02,W0
2000:  MOV     C04,W1
2002:  CALL    50C
2006:  MOV.B   W0L,D25
....................     send_buffer[6] =  (int) ((wTemp - (float) (int) wTemp)*100);  // high whole number byte 
2008:  MOV     C02,W0
200A:  MOV     C04,W1
200C:  CALL    50C
2010:  CALL    BE4
2014:  BSET.B  43.0
2016:  MOV     W0,W2
2018:  MOV     W1,W3
201A:  MOV     C02,W0
201C:  MOV     C04,W1
201E:  CALL    DBC
2022:  MOV     W0,W5
2024:  MOV     W1,W6
2026:  MOV     W5,W0
2028:  MOV     W6,W1
202A:  MOV     #0,W2
202C:  MOV     #42C8,W3
202E:  CALL    C2E
2032:  CALL    50C
2036:  MOV.B   W0L,D26
.................... //  Toggle green light to show the system is working.   Added March 30, 2017   
....................     
....................  
.................... if (blinkinggreenlight == 0) 
2038:  MOV.B   DA6,W0L
203A:  SE      W0,W0
203C:  CP0     W0
203E:  BRA     NZ,204A
.................... { 
....................     output_LOW(PIN_B7); 
2040:  BCLR.B  2C8.7
2042:  BCLR.B  2CC.7
....................     blinkinggreenlight=1; 
2044:  MOV.B   #1,W0L
2046:  MOV.B   W0L,DA6
.................... } 
2048:  BRA     2050
.................... else 
.................... { 
....................     output_HIGH(PIN_B7); 
204A:  BCLR.B  2C8.7
204C:  BSET.B  2CC.7
....................     blinkinggreenlight=0; 
204E:  CLR.B   DA6
.................... } 
....................       
....................  
.................... //***************************************************************** 
.................... // Created Nov 28, 2016 
.................... // This checks for any change in the update input.  Once rcv_buffer[2]== 1, then update the config varibles. 
.................... //***************************************************************** 
....................         if (rcv_buffer[2]==0x01) 
2050:  MOV     D64,W4
2052:  CP.B    W4L,#1
2054:  BRA     NZ,2082
....................           { 
....................           // move the data off the input buffer into the calibration varaibles. 
....................              
....................             movercvbuffertocolibration();   //move over the data 
2056:  CALL    19FC
....................              
....................             rcv_buffer[2]==0x00; 
205A:  CP0.B   D64
205C:  BRA     Z,2062
205E:  CLR.B   W0
2060:  BRA     2062
....................             // clear buffer 
....................             for (x=0; x < 65; x++) 
2062:  CLR.B   DA4
2064:  MOV.B   DA4,W0L
2066:  SE      W0,W0
2068:  MOV     #41,W4
206A:  CP      W4,W0
206C:  BRA     LE,2082
....................                 rcv_buffer[x]==0x00; 
206E:  MOV.B   DA4,W0L
2070:  SE      W0,W0
2072:  MOV     #D62,W4
2074:  ADD     W0,W4,W0
2076:  CP0.B   [W0]
2078:  BRA     Z,207E
207A:  CLR.B   W0
207C:  BRA     207E
207E:  INC.B   0DA4
2080:  BRA     2064
....................           } 
2082:  BRA     1E30
.................... } 
....................  
.................... } 
....................  
2084:  BRA     2084
....................  
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1L: 000F   NOWRTB NOBSS
          H: 0000  
   Word  2L: 0000  
          H: 0000  
   Word  3L: 0003   NOWRT NOPROTECT
          H: 0000  
   Word  4L: 00E3   PR_PLL SOSC_ANALOG LPRCHIGH IESO
          H: 0000  
   Word  5L: 00FA   HS OSCIO POSCFREQ_H SOSC_HIGH
          H: 0000  
   Word  6L: 005F   WPOSTS16 WDT128 WINDIS NOWDT
          H: 0000  
   Word  7L: 00F4   NOBROWNOUT NOLVR NOPUT NOALTI2C1 BORV_LOW MCLR
          H: 0000  
   Word  8L: 0003   ICSP1 DEBUG
          H: 0000  
   Word  9L: 00DF   DSWDTCK_LPRC DSBOR DSWDT
          H: 0000  

   Some fuses have been forced to be compatible with the ICD debugger.
