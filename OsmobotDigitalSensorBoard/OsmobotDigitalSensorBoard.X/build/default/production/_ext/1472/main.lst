CCS PCD C Compiler, Version 5.071, 35992               08-May-17 16:00

               Filename:   G:\OsmobotDigitalSensorBoard\OsmobotDigitalSensorBoard.X\build\default\production\_ext\1472\main.lst

               ROM used:   10914 bytes (48%)
                           Largest free fragment is 11614
               RAM used:   1512 (77%) at main() level
                           1942 (99%) worst case
               Stack used: 108 locations (68 in main + 40 for interrupts)
               Stack size: 192

*
0000:  GOTO    254E
*
0076:  DATA    38,02,00
.................... // Digital DO and NH4 Probes -  Main.c file                                                                                                                                                                                                                                                        // DO and NH4 Patch Sensor Main.c file 
.................... #include <24FV32KA302.h> 
.................... //////////// Standard Header file for the PIC24FV32KA302 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FV32KA302 
*
04A6:  MOV     W5,[W15++]
04A8:  MOV     #C,W5
04AA:  REPEAT  #3
04AC:  MOV     [W5++],[W15++]
04AE:  MUL.UU  W0,W2,W4
04B0:  BTSS    W3.F
04B2:  BRA     4B8
04B4:  MUL.SS  W0,W3,W6
04B6:  BRA     4BA
04B8:  MUL.UU  W0,W3,W6
04BA:  BCLR.B  42.0
04BC:  ADD     W6,W5,W5
04BE:  ADDC    W7,#0,W8
04C0:  BTSS    W1.F
04C2:  BRA     4C8
04C4:  MUL.SS  W1,W2,W6
04C6:  BRA     4CA
04C8:  MUL.UU  W1,W2,W6
04CA:  ADDC    W6,W5,W5
04CC:  ADDC    W7,W8,W8
04CE:  ADDC    #0,W9
04D0:  MUL.SS  W1,W3,W6
04D2:  ADDC    W6,W8,W8
04D4:  ADDC    W9,W7,W7
04D6:  MOV     W7,W3
04D8:  MOV     W8,W2
04DA:  MOV     W5,W1
04DC:  MOV     W4,W0
04DE:  MOV     #12,W5
04E0:  REPEAT  #3
04E2:  MOV     [--W15],[W5--]
04E4:  MOV     [--W15],W5
04E6:  RETURN  
04E8:  MOV     #FE00,W1
04EA:  ADD     W1,W3,W3
04EC:  MOV     #7F,W1
04EE:  ADDC    W1,#0,W1
04F0:  MOV     W1,32
04F2:  BCLR    W5.0
04F4:  CP0     W5
04F6:  BRA     Z,4FE
04F8:  TBLRDL  [W3++],[W4++]
04FA:  DEC2    W5,W5
04FC:  BRA     NZ,4F6
04FE:  RETURN  
*
054C:  MOV     W0,W2
054E:  MOV     W1,W3
0550:  MOV.B   W1L,W0L
0552:  SWAP    W0
0554:  BSET    W0.F
0556:  RLC     W1,W1
0558:  SWAP    W1
055A:  ZE      W1,W1
055C:  MOV     #8E,W4
055E:  SUB.B   W4L,W1L,W1L
0560:  BRA     Z,56E
0562:  CP0     W0
0564:  BRA     Z,56E
0566:  BCLR.B  42.0
0568:  RRC     W0,W0
056A:  DEC     W1,W1
056C:  BRA     NZ,562
056E:  BTSS    W3.F
0570:  BRA     576
0572:  NEG     W0,W0
0574:  BRA     576
0576:  RETURN  
*
06E0:  MOV     W5,[W15++]
06E2:  MOV     W6,[W15++]
06E4:  MOV     #8E,W1
06E6:  BCLR    W6.0
06E8:  BTSS    W0.F
06EA:  BRA     6F2
06EC:  BSET    W6.0
06EE:  NEG     W0,W0
06F0:  BRA     6F2
06F2:  CP0     W0
06F4:  BRA     Z,71E
06F6:  BTSC    W0.F
06F8:  BRA     702
06FA:  BCLR.B  42.0
06FC:  RLC     W0,W0
06FE:  DEC     W1,W1
0700:  BRA     6F6
0702:  SWAP    W1
0704:  BCLR.B  42.0
0706:  RRC     W1,W1
0708:  BCLR    W0.F
070A:  SWAP    W0
070C:  XOR.B   W0L,W1L,W1L
070E:  AND.B   #0,W0L
0710:  BTSC    W6.0
0712:  BSET    W1.F
0714:  BRA     724
0716:  MOV.B   W1L,W0L
0718:  BSET    W1.7
071A:  AND.B   #0,W1L
071C:  BRA     724
071E:  CLR     W0
0720:  CLR     W1
0722:  BRA     724
0724:  MOV     [--W15],W6
0726:  MOV     [--W15],W5
0728:  RETURN  
072A:  MOV     W5,[W15++]
072C:  MOV     #C,W5
072E:  REPEAT  #3
0730:  MOV     [W5++],[W15++]
0732:  CLR     W9
0734:  MOV     #8000,W8
0736:  BTSC.B  43.0
0738:  XOR     W8,W3,W3
073A:  CP0     W0
073C:  BRA     NZ,744
073E:  MOV     #7FFF,W10
0740:  AND     W1,W10,W10
0742:  BTSS.B  42.1
0744:  MOV     W1,W10
0746:  XOR     W3,W10,W11
0748:  MOV     W1,W6
074A:  MOV     W3,W7
074C:  MOV     W3,W12
074E:  BCLR.B  42.1
0750:  BCLR.B  42.0
0752:  RLC     W6,W6
0754:  SWAP    W6
0756:  AND     #FF,W6
0758:  CP0     W6
075A:  BRA     Z,89E
075C:  BCLR.B  42.1
075E:  BCLR.B  42.0
0760:  RLC     W7,W7
0762:  SWAP    W7
0764:  AND     #FF,W7
0766:  CP0     W7
0768:  BRA     Z,8A8
076A:  BCLR.B  42.1
076C:  BCLR.B  42.0
076E:  CP      W7,W6
0770:  BRA     Z,8AA
0772:  BRA     N,8BA
0774:  BCLR    W9.0
0776:  BSET    W9.1
0778:  SUB     W7,W6,W8
077A:  MOV     W7,W6
077C:  AND     #FF,W1
077E:  BSET    W1.7
0780:  AND     #FF,W3
0782:  BSET    W3.7
0784:  MOV     #28,W7
0786:  CP      W7,W8
0788:  BRA     N,7AC
078A:  BCLR.B  42.1
078C:  BCLR.B  42.0
078E:  RRC     W1,W1
0790:  RRC     W0,W0
0792:  DEC     W8,W8
0794:  BRA     NZ,78A
0796:  BRA     7B2
0798:  MOV     #28,W7
079A:  CP      W7,W8
079C:  BRA     N,7B0
079E:  BCLR.B  42.1
07A0:  BCLR.B  42.0
07A2:  RRC     W3,W3
07A4:  RRC     W2,W2
07A6:  DEC     W8,W8
07A8:  BRA     NZ,79E
07AA:  BRA     7CA
07AC:  MOV     W2,W0
07AE:  MOV     W3,W1
07B0:  BRA     838
07B2:  BTSS    W11.F
07B4:  BRA     7D8
07B6:  BTSC    W9.4
07B8:  MOV     W12,W11
07BA:  NEG     W0,W0
07BC:  BRA     Z,7C2
07BE:  COM.B   W1L,W1L
07C0:  BRA     7C4
07C2:  NEG     W1,W1
07C4:  BTSC    W9.4
07C6:  BRA     81E
07C8:  BRA     7D8
07CA:  BTSS    W11.F
07CC:  BRA     7D8
07CE:  NEG     W2,W2
07D0:  BRA     Z,7D6
07D2:  COM.B   W3L,W3L
07D4:  BRA     7D8
07D6:  NEG     W3,W3
07D8:  AND     #FF,W5
07DA:  BCLR.B  42.1
07DC:  BCLR.B  42.0
07DE:  ADD     W0,W2,W0
07E0:  ADDC.B  W1L,W3L,W1L
07E2:  BTSC.B  42.0
07E4:  BSET    W9.3
07E6:  BTSC    W9.0
07E8:  BRA     7FC
07EA:  BTSC    W9.1
07EC:  BRA     7F0
07EE:  BRA     806
07F0:  BTSC    W11.F
07F2:  BRA     81E
07F4:  BTSC    W9.3
07F6:  BRA     84A
07F8:  BSET    W9.6
07FA:  BRA     838
07FC:  BTSC    W11.F
07FE:  BRA     81E
0800:  BTSC    W9.3
0802:  BRA     84A
0804:  BRA     838
0806:  BCLR    W9.2
0808:  BTSC    W11.F
080A:  BRA     814
080C:  MOV     W10,W11
080E:  BTSC    W9.3
0810:  BRA     84A
0812:  BRA     880
0814:  BSET    W9.4
0816:  XOR.B   #80,W1L
0818:  BTSC    W1.7
081A:  BRA     7B6
081C:  MOV     W10,W11
081E:  AND     #FF,W1
0820:  IOR      W0,  W1,W7
0822:  BRA     Z,838
0824:  BTSC    W1.7
0826:  BRA     838
0828:  BCLR.B  42.1
082A:  BCLR.B  42.0
082C:  RLC     W0,W0
082E:  RLC     W1,W1
0830:  DEC     W6,W6
0832:  BTSC.B  42.1
0834:  BRA     898
0836:  BRA     824
0838:  BTSC    W9.0
083A:  MOV     W10,W11
083C:  BTSC    W9.1
083E:  MOV     W12,W11
0840:  BTSS    W9.5
0842:  BRA     878
0844:  BTSC    W10.F
0846:  BSET    W0.8
0848:  BRA     880
084A:  BSET.B  42.0
084C:  RRC.B   W1L,W1L
084E:  RRC     W0,W0
0850:  BTSC.B  42.0
0852:  BSET    W9.5
0854:  INC     W6,W6
0856:  BRA     Z,898
0858:  BTSS    W9.5
085A:  BRA     86C
085C:  INC     W0,W0
085E:  BRA     NZ,86C
0860:  INC.B   W1L,W1L
0862:  BRA     NZ,86C
0864:  RRC.B   W1L,W1L
0866:  RRC     W0,W0
0868:  INC     W6,W6
086A:  BRA     Z,898
086C:  BTSC    W9.0
086E:  MOV     W10,W11
0870:  BTSC    W9.1
0872:  MOV     W12,W11
0874:  BTSC.B  42.1
0876:  BRA     898
0878:  BTSC    W9.6
087A:  MOV     W10,W11
087C:  BTSC    W9.7
087E:  MOV     W12,W11
0880:  IOR      W0,  W1,W2
0882:  BRA     Z,8CA
0884:  BCLR    W1.7
0886:  SWAP    W6
0888:  BCLR.B  42.1
088A:  BCLR.B  42.0
088C:  RRC     W6,W6
088E:  XOR     W6,W1,W1
0890:  BSET    W1.F
0892:  BTSS    W11.F
0894:  BCLR    W1.F
0896:  BRA     8CA
0898:  MOV     #0,W0
089A:  MOV     #0,W1
089C:  BRA     8CA
089E:  BTSC    W10.F
08A0:  XOR     W8,W3,W3
08A2:  MOV     W2,W0
08A4:  MOV     W3,W1
08A6:  BRA     8CA
08A8:  BRA     8CA
08AA:  AND     #FF,W3
08AC:  BSET    W3.7
08AE:  AND     #FF,W1
08B0:  BSET    W1.7
08B2:  BTSC    W11.F
08B4:  BCLR    W3.7
08B6:  BSET    W9.2
08B8:  BRA     7CA
08BA:  SUB     W6,W7,W8
08BC:  AND     #FF,W1
08BE:  BSET    W1.7
08C0:  AND     #FF,W3
08C2:  BSET    W3.7
08C4:  BCLR    W9.1
08C6:  BSET    W9.0
08C8:  BRA     798
08CA:  MOV     #12,W5
08CC:  REPEAT  #3
08CE:  MOV     [--W15],[W5--]
08D0:  MOV     [--W15],W5
08D2:  RETURN  
08D4:  MOV     W5,[W15++]
08D6:  MOV     W6,[W15++]
08D8:  MOV     #8E,W1
08DA:  CP0     W0
08DC:  BRA     Z,902
08DE:  BTSC    W0.F
08E0:  BRA     8EA
08E2:  BCLR.B  42.0
08E4:  RLC     W0,W0
08E6:  DEC     W1,W1
08E8:  BRA     8DE
08EA:  SWAP    W1
08EC:  BCLR.B  42.0
08EE:  RRC     W1,W1
08F0:  BCLR    W0.F
08F2:  SWAP    W0
08F4:  XOR.B   W0L,W1L,W1L
08F6:  AND.B   #0,W0L
08F8:  BRA     908
08FA:  MOV.B   W1L,W0L
08FC:  BSET    W1.7
08FE:  AND.B   #0,W1L
0900:  BRA     908
0902:  CLR     W0
0904:  CLR     W1
0906:  BRA     908
0908:  MOV     [--W15],W6
090A:  MOV     [--W15],W5
090C:  RETURN  
090E:  MOV     W5,[W15++]
0910:  MOV     #C,W5
0912:  REPEAT  #4
0914:  MOV     [W5++],[W15++]
0916:  CLR     W9
0918:  XOR     W1,W3,W9
091A:  MOV     W1,W6
091C:  MOV     W0,W5
091E:  MOV     W3,W8
0920:  MOV     W2,W7
0922:  RLC     W1,W1
0924:  SWAP    W1
0926:  ZE      W1,W1
0928:  CP0     W1
092A:  BRA     Z,9C8
092C:  RLC     W3,W3
092E:  SWAP    W3
0930:  ZE      W3,W3
0932:  CP0     W3
0934:  BRA     Z,9C8
0936:  CLR     W0
0938:  SUB.B   W1L,W3L,W0L
093A:  BRA     NC,942
093C:  ADD.B   #7F,W0L
093E:  BRA     C,9C8
0940:  BRA     948
0942:  SUB.B   #81,W0L
0944:  BRA     NC,9C8
0946:  BRA     Z,9C8
0948:  MOV     W5,W1
094A:  MOV     W6,W2
094C:  BSET    W2.7
094E:  AND     #FF,W2
0950:  AND     #FF,W8
0952:  BSET    W8.7
0954:  MOV     #19,W10
0956:  CLR     W3
0958:  CLR     W4
095A:  SUB     W1,W7,W1
095C:  SUBB    W2,W8,W2
095E:  BRA     N,964
0960:  BRA     C,96A
0962:  BRA     NZ,96C
0964:  ADD     W1,W7,W1
0966:  ADDC    W2,W8,W2
0968:  BRA     96C
096A:  BSET    W4.0
096C:  DEC     W10,W10
096E:  BRA     Z,97E
0970:  BCLR.B  42.0
0972:  RLC     W1,W1
0974:  RLC     W2,W2
0976:  BCLR.B  42.0
0978:  RLC     W4,W4
097A:  RLC     W3,W3
097C:  BRA     95A
097E:  CLR     W10
0980:  BTSC    W3.8
0982:  BRA     986
0984:  BRA     992
0986:  BCLR.B  42.0
0988:  RRC     W3,W3
098A:  BCLR    W3.7
098C:  RRC     W4,W4
098E:  RLC     W10,W10
0990:  BRA     996
0992:  DEC     W0,W0
0994:  BRA     Z,9C8
0996:  BTSC    W10.F
0998:  BRA     NC,9A4
099A:  RLC     W1,W1
099C:  RLC     W2,W2
099E:  SUB     W1,W7,W1
09A0:  SUBB    W2,W8,W2
09A2:  BRA     NC,9B6
09A4:  INC     W4,W4
09A6:  BRA     NZ,9B6
09A8:  INC     W3,W3
09AA:  BRA     NZ,9B6
09AC:  INC     W0,W0
09AE:  BRA     Z,9C8
09B0:  BRA     9B6
09B2:  DEC     W0,W0
09B4:  BRA     Z,9C8
09B6:  SWAP    W0
09B8:  RRC     W0,W1
09BA:  BSET    W1.F
09BC:  BTSS    W9.F
09BE:  BCLR    W1.F
09C0:  BCLR    W3.7
09C2:  XOR.B   W3L,W1L,W1L
09C4:  MOV     W4,W0
09C6:  BRA     9CE
09C8:  MOV     #0,W0
09CA:  MOV     #0,W1
09CC:  BRA     9CE
09CE:  MOV     #14,W5
09D0:  REPEAT  #4
09D2:  MOV     [--W15],[W5--]
09D4:  MOV     [--W15],W5
09D6:  RETURN  
*
0DFA:  MOV     W5,[W15++]
0DFC:  MOV     #C,W5
0DFE:  REPEAT  #3
0E00:  MOV     [W5++],[W15++]
0E02:  MUL.UU  W0,W2,W4
0E04:  MUL.UU  W0,W3,W6
0E06:  BCLR.B  42.0
0E08:  ADD     W6,W5,W5
0E0A:  ADDC    W7,#0,W8
0E0C:  MUL.UU  W1,W2,W6
0E0E:  ADDC    W6,W5,W5
0E10:  ADDC    W7,W8,W8
0E12:  MUL.UU  W1,W3,W6
0E14:  ADD     W6,W8,W8
0E16:  ADDC    #0,W7
0E18:  MOV     W7,W3
0E1A:  MOV     W8,W2
0E1C:  MOV     W5,W1
0E1E:  MOV     W4,W0
0E20:  MOV     #12,W5
0E22:  REPEAT  #3
0E24:  MOV     [--W15],[W5--]
0E26:  MOV     [--W15],W5
0E28:  RETURN  
*
1034:  MOV     W5,[W15++]
1036:  MOV     W6,[W15++]
1038:  MOV     W0,W4
103A:  MOV     W1,W5
103C:  CLR     W0
103E:  CLR     W1
1040:  BCLR    W6.0
1042:  BTSS    W5.F
1044:  BRA     1052
1046:  BSET    W6.0
1048:  NEG     W4,W4
104A:  BRA     Z,1050
104C:  COM     W5,W5
104E:  BRA     1052
1050:  NEG     W5,W5
1052:  IOR      W4,  W5,W3
1054:  BRA     Z,107C
1056:  CLR     W2
1058:  MOV     #B6,W1
105A:  BTSC    W2.7
105C:  BRA     106C
105E:  BCLR.B  42.0
1060:  RLC     W4,W4
1062:  RLC     W5,W5
1064:  RLC     W0,W0
1066:  RLC     W2,W2
1068:  DEC     W1,W1
106A:  BRA     NZ,105A
106C:  SWAP    W1
106E:  BCLR.B  42.0
1070:  RRC     W1,W1
1072:  BCLR    W1.F
1074:  BCLR    W2.7
1076:  XOR.B   W2L,W1L,W1L
1078:  BTSC    W6.0
107A:  BSET    W1.F
107C:  MOV     [--W15],W6
107E:  MOV     [--W15],W5
1080:  RETURN  
1082:  MOV     W5,[W15++]
1084:  MOV     #C,W5
1086:  REPEAT  #4
1088:  MOV     [W5++],[W15++]
108A:  MOV     W0,W4
108C:  MOV     W1,W5
108E:  MOV     W3,W7
1090:  MOV     W2,W6
1092:  BCLR.B  42.0
1094:  BCLR.B  42.1
1096:  RLC     W1,W1
1098:  SWAP    W1
109A:  AND     #FF,W1
109C:  CP0     W1
109E:  BRA     Z,1136
10A0:  BCLR.B  42.0
10A2:  BCLR.B  42.1
10A4:  RLC     W3,W3
10A6:  SWAP    W3
10A8:  AND     #FF,W3
10AA:  CP0     W3
10AC:  BRA     Z,1136
10AE:  ZE      W0,W0
10B0:  ADD.B   W3L,W1L,W0L
10B2:  BRA     C,10BC
10B4:  SUB     #7F,W0
10B6:  BRA     Z,1136
10B8:  BRA     NC,1136
10BA:  BRA     10C0
10BC:  ADD.B   #81,W0L
10BE:  BRA     C,1136
10C0:  XOR     W5,W7,W10
10C2:  BCLR.B  42.0
10C4:  BCLR.B  42.1
10C6:  AND     #FF,W5
10C8:  BSET    W5.7
10CA:  BCLR.B  42.0
10CC:  AND     #FF,W7
10CE:  BSET    W7.7
10D0:  MUL.UU  W4,W6,W2
10D2:  MUL.UU  W5,W6,W8
10D4:  ADDC    W8,W3,W3
10D6:  MOV     W9,W1
10D8:  BTSC.B  42.0
10DA:  INC     W1,W1
10DC:  BCLR.B  42.0
10DE:  MUL.UU  W7,W4,W8
10E0:  ADDC    W8,W3,W3
10E2:  ADDC    W9,W1,W1
10E4:  MUL.UU  W5,W7,W8
10E6:  ADDC    W8,W1,W1
10E8:  INC     W0,W0
10EA:  CP0     W1
10EC:  BTSC.B  42.1
10EE:  BRA     10F2
10F0:  BRA     10F8
10F2:  CP0     W3
10F4:  BTSC.B  42.1
10F6:  BRA     1102
10F8:  BTSC    W1.F
10FA:  BRA     1102
10FC:  RLC     W3,W3
10FE:  RLC     W1,W1
1100:  DEC     W0,W0
1102:  MOV     W1,W2
1104:  BCLR.B  42.0
1106:  BTSS    W3.7
1108:  BRA     111C
110A:  MOV     #FF00,W7
110C:  AND     W3,W7,W3
110E:  ADD     #100,W3
1110:  ADDC    W2,#0,W2
1112:  CP0     W2
1114:  BRA     NZ,111C
1116:  CP0     W3
1118:  BRA     NZ,111C
111A:  INC     W0,W0
111C:  SWAP    W0
111E:  BCLR.B  42.0
1120:  BCLR.B  42.1
1122:  RRC     W0,W1
1124:  BTSC    W10.F
1126:  BSET    W1.F
1128:  BCLR    W2.F
112A:  SWAP    W2
112C:  XOR.B   W2L,W1L,W1L
112E:  SWAP    W3
1130:  MOV.B   W3L,W2L
1132:  MOV     W2,W0
1134:  BRA     113C
1136:  MOV     #0,W0
1138:  MOV     #0,W1
113A:  BRA     113C
113C:  MOV     #14,W5
113E:  REPEAT  #4
1140:  MOV     [--W15],[W5--]
1142:  MOV     [--W15],W5
1144:  RETURN  
1146:  MOV     W5,[W15++]
1148:  MOV     W1,W5
114A:  MOV     W0,W2
114C:  MOV     #B6,W4
114E:  RLC     W1,W1
1150:  SWAP    W1
1152:  AND     #FF,W1
1154:  SUB.B   W4L,W1L,W4L
1156:  MOV.B   W5L,W3L
1158:  BSET    W3.7
115A:  AND     #FF,W3
115C:  CLR     W0
115E:  CLR     W1
1160:  CP      W4,#18
1162:  BRA     N,1182
1164:  BCLR.B  42.0
1166:  RRC     W3,W3
1168:  RRC     W2,W2
116A:  RRC     W1,W1
116C:  RRC     W0,W0
116E:  DEC     W4,W4
1170:  BRA     NZ,1164
1172:  BTSS    W5.F
1174:  BRA     1182
1176:  NEG     W0,W0
1178:  BRA     Z,117E
117A:  COM     W1,W1
117C:  BRA     1182
117E:  NEG     W1,W1
1180:  BRA     1182
1182:  MOV     [--W15],W5
1184:  RETURN  
*
14FE:  MOV     W5,[W15++]
1500:  MOV     W6,[W15++]
1502:  MOV     W7,[W15++]
1504:  XOR     W1,W3,W4
1506:  BTSS    W4.F
1508:  BRA     1516
150A:  BCLR.B  42.0
150C:  BCLR.B  42.1
150E:  BTSS    W1.F
1510:  BRA     155E
1512:  BSET.B  42.0
1514:  BRA     155E
1516:  MOV     W1,W4
1518:  MOV     W0,W5
151A:  MOV     W3,W6
151C:  MOV     W2,W7
151E:  RLC     W1,W1
1520:  SWAP    W1
1522:  RLC     W3,W3
1524:  SWAP    W3
1526:  SUB.B   W3L,W1L,W1L
1528:  BRA     Z,1534
152A:  BTSS    W4.F
152C:  BRA     155E
152E:  MOV     #1,W0
1530:  XOR.B   42
1532:  BRA     155E
1534:  MOV.B   W4L,W1L
1536:  MOV.B   W6L,W3L
1538:  BCLR    W1.7
153A:  BCLR    W3.7
153C:  SUB.B   W3L,W1L,W1L
153E:  BRA     Z,154A
1540:  BTSS    W4.F
1542:  BRA     155E
1544:  MOV     #1,W0
1546:  XOR.B   42
1548:  BRA     155E
154A:  SUB     W7,W5,W1
154C:  BRA     Z,1558
154E:  BTSS    W4.F
1550:  BRA     155E
1552:  MOV     #1,W0
1554:  XOR.B   42
1556:  BRA     155E
1558:  BCLR.B  42.0
155A:  BRA     155E
155C:  BRA     155E
155E:  MOV     [--W15],W7
1560:  MOV     [--W15],W6
1562:  MOV     [--W15],W5
1564:  RETURN  
....................  
.................... #list 
....................  
.................... #DEVICE ICD=1 
.................... #device ADC=10 
.................... #define PIC24 1 
.................... #device PASS_STRINGS = IN_RAM 
.................... #device PSV=16 
.................... #device CONST=READ_ONLY 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
1566:  MOV     W5,[W15++]
1568:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
156A:  BCLR.B  E95.0
....................    y = x; 
156C:  PUSH    E96
156E:  POP     E9A
1570:  PUSH    E98
1572:  POP     E9C
....................  
....................    if (x < 0) 
1574:  MOV     E96,W0
1576:  MOV     E98,W1
1578:  MOV     #0,W2
157A:  MOV     #0,W3
157C:  CALL    14FE
1580:  BRA     NC,158E
....................    { 
....................       s = 1; 
1582:  BSET.B  E95.0
....................       y = -y; 
1584:  MOV     #E9A,W0
1586:  MOV     #E9A,W1
1588:  REPEAT  #3
158A:  MOV     [W0++],[W1++]
158C:  BTG.B   E9D.7
....................    } 
....................  
....................    if (y <= 32768.0) 
158E:  MOV     E9A,W0
1590:  MOV     E9C,W1
1592:  MOV     #0,W2
1594:  MOV     #4700,W3
1596:  CALL    14FE
159A:  BRA     C,159E
159C:  BRA     NZ,15B0
....................       res = (float32)(unsigned int16)y; 
159E:  MOV     E9A,W0
15A0:  MOV     E9C,W1
15A2:  CALL    54C
15A6:  CALL    8D4
15AA:  MOV     W0,E9E
15AC:  MOV     W1,EA0
15AE:  BRA     1642
....................  
....................  else if (y < 10000000.0) 
15B0:  MOV     E9A,W0
15B2:  MOV     E9C,W1
15B4:  MOV     #9680,W2
15B6:  MOV     #4B18,W3
15B8:  CALL    14FE
15BC:  BRA     NC,163A
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
15BE:  MOV     E9A,W0
15C0:  MOV     E9C,W1
15C2:  MOV     #0,W2
15C4:  MOV     #3800,W3
15C6:  CALL    1082
15CA:  CALL    54C
15CE:  MOV     W0,EA2
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
15D0:  MOV     E9A,W0
15D2:  MOV     E9C,W1
15D4:  MOV     #0,W2
15D6:  MOV     #3800,W3
15D8:  CALL    1082
15DC:  MOV     W0,W5
15DE:  MOV     W1,W6
15E0:  MOV     EA2,W0
15E2:  CALL    8D4
15E6:  BSET.B  43.0
15E8:  MOV     W0,W2
15EA:  MOV     W1,W3
15EC:  MOV     W5,W0
15EE:  MOV     W6,W1
15F0:  CALL    72A
15F4:  MOV     W0,W2
15F6:  MOV     W1,W3
15F8:  MOV     #0,W0
15FA:  MOV     #4700,W1
15FC:  CALL    1082
1600:  MOV     W0,E9A
1602:  MOV     W1,E9C
....................       res = 32768.0*(float32)l; 
1604:  MOV     EA2,W0
1606:  CALL    8D4
160A:  MOV     W0,W2
160C:  MOV     W1,W3
160E:  MOV     #0,W0
1610:  MOV     #4700,W1
1612:  CALL    1082
1616:  MOV     W0,E9E
1618:  MOV     W1,EA0
....................       res += (float32)(unsigned int16)y; 
161A:  MOV     E9A,W0
161C:  MOV     E9C,W1
161E:  CALL    54C
1622:  CALL    8D4
1626:  BCLR.B  43.0
1628:  MOV     W0,W2
162A:  MOV     W1,W3
162C:  MOV     E9E,W0
162E:  MOV     EA0,W1
1630:  CALL    72A
1634:  MOV     W0,E9E
1636:  MOV     W1,EA0
....................    } 
1638:  BRA     1642
....................  
....................  else 
....................   res = y; 
163A:  PUSH    E9A
163C:  POP     E9E
163E:  PUSH    E9C
1640:  POP     EA0
....................  
....................  y = y - (float32)(unsigned int16)y; 
1642:  MOV     E9A,W0
1644:  MOV     E9C,W1
1646:  CALL    54C
164A:  CALL    8D4
164E:  BSET.B  43.0
1650:  MOV     W0,W2
1652:  MOV     W1,W3
1654:  MOV     E9A,W0
1656:  MOV     E9C,W1
1658:  CALL    72A
165C:  MOV     W0,E9A
165E:  MOV     W1,E9C
....................  
....................  if (s) 
1660:  BTSS.B  E95.0
1662:  BRA     166E
....................   res = -res; 
1664:  MOV     #E9E,W0
1666:  MOV     #E9E,W1
1668:  REPEAT  #3
166A:  MOV     [W0++],[W1++]
166C:  BTG.B   EA1.7
....................  
....................  if (y != 0) 
166E:  MOV     E9A,W0
1670:  MOV     E9C,W1
1672:  MOV     #0,W2
1674:  MOV     #0,W3
1676:  CALL    14FE
167A:  BRA     Z,16B2
....................  { 
....................   if (s == 1 && n == 0) 
167C:  BTSS.B  E95.0
167E:  BRA     1696
1680:  CP0.B   E94
1682:  BRA     NZ,1696
....................    res -= 1.0; 
1684:  BSET.B  43.0
1686:  MOV     E9E,W0
1688:  MOV     EA0,W1
168A:  MOV     #0,W2
168C:  MOV     #3F80,W3
168E:  CALL    72A
1692:  MOV     W0,E9E
1694:  MOV     W1,EA0
....................  
....................   if (s == 0 && n == 1) 
1696:  BTSC.B  E95.0
1698:  BRA     16B2
169A:  MOV     E94,W4
169C:  CP.B    W4L,#1
169E:  BRA     NZ,16B2
....................    res += 1.0; 
16A0:  BCLR.B  43.0
16A2:  MOV     E9E,W0
16A4:  MOV     EA0,W1
16A6:  MOV     #0,W2
16A8:  MOV     #3F80,W3
16AA:  CALL    72A
16AE:  MOV     W0,E9E
16B0:  MOV     W1,EA0
....................  } 
....................  if (x == 0) 
16B2:  MOV     E96,W0
16B4:  MOV     E98,W1
16B6:  MOV     #0,W2
16B8:  MOV     #0,W3
16BA:  CALL    14FE
16BE:  BRA     NZ,16C4
....................     res = 0; 
16C0:  CLR     E9E
16C2:  CLR     EA0
....................  
....................  return (res); 
16C4:  MOV     E9E,W0
16C6:  MOV     EA0,W1
16C8:  MOV     [--W15],W6
16CA:  MOV     [--W15],W5
16CC:  RETURN  
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
16E2:  CLR.B   E94
16E4:  PUSH    E8C
16E6:  POP     E96
16E8:  PUSH    E8E
16EA:  POP     E98
16EC:  CALL    1566
16F0:  MOV.D   W0,W0
16F2:  RETURN  
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
16CE:  MOV.B   #1,W0L
16D0:  MOV.B   W0L,E94
16D2:  PUSH    E8C
16D4:  POP     E96
16D6:  PUSH    E8E
16D8:  POP     E98
16DA:  CALL    1566
16DE:  MOV.D   W0,W0
16E0:  RETURN  
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
*
16F4:  MOV     W5,[W15++]
16F6:  MOV     W6,[W15++]
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
16F8:  MOV     E7E,W0
16FA:  MOV     E80,W1
16FC:  MOV     #0,W2
16FE:  MOV     #0,W3
1700:  CALL    14FE
1704:  BRA     Z,177A
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
1706:  MOV     E7A,W0
1708:  MOV     E7C,W1
170A:  MOV     E7E,W2
170C:  MOV     E80,W3
170E:  CALL    90E
1712:  MOV     W0,W5
1714:  MOV     W1,W6
1716:  MOV     W5,W0
1718:  MOV     W6,W1
171A:  MOV     #0,W2
171C:  MOV     #0,W3
171E:  CALL    14FE
1722:  BRA     NC,173E
1724:  MOV     E7A,W0
1726:  MOV     E7C,W1
1728:  MOV     E7E,W2
172A:  MOV     E80,W3
172C:  CALL    90E
1730:  MOV     W0,W5
1732:  MOV     W1,W6
1734:  MOV     W5,E8C
1736:  MOV     W6,E8E
1738:  CALL    16CE
173C:  BRA     1756
173E:  MOV     E7A,W0
1740:  MOV     E7C,W1
1742:  MOV     E7E,W2
1744:  MOV     E80,W3
1746:  CALL    90E
174A:  MOV     W0,W5
174C:  MOV     W1,W6
174E:  MOV     W5,E8C
1750:  MOV     W6,E8E
1752:  CALL    16E2
1756:  MOV     W0,E82
1758:  MOV     W1,E84
....................       return(x-(i*y)); 
175A:  MOV     E82,W0
175C:  MOV     E84,W1
175E:  MOV     E7E,W2
1760:  MOV     E80,W3
1762:  CALL    1082
1766:  BSET.B  43.0
1768:  MOV     W0,W2
176A:  MOV     W1,W3
176C:  MOV     E7A,W0
176E:  MOV     E7C,W1
1770:  CALL    72A
1774:  MOV.D   W0,W0
1776:  BRA     177A
....................    } 
1778:  BRA     177A
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
177A:  MOV     [--W15],W6
177C:  MOV     [--W15],W5
177E:  RETURN  
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
*
190C:  MOV     W5,[W15++]
190E:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
1910:  MOV     E7E,W0
1912:  MOV     E80,W1
1914:  MOV     #AA3B,W2
1916:  MOV     #3FB8,W3
1918:  CALL    1082
191C:  CALL    54C
1920:  MOV.B   W0L,E7B
....................    s = 0; 
1922:  BCLR.B  E7C.0
....................    y = x; 
1924:  PUSH    E7E
1926:  POP     E82
1928:  PUSH    E80
192A:  POP     E84
....................  
....................    if (x < 0) 
192C:  MOV     E7E,W0
192E:  MOV     E80,W1
1930:  MOV     #0,W2
1932:  MOV     #0,W3
1934:  CALL    14FE
1938:  BRA     NC,1950
....................    { 
....................       s = 1; 
193A:  BSET.B  E7C.0
....................       n = -n; 
193C:  MOV     #0,W4
193E:  MOV     E7A,W3
1940:  LSR     W3,#8,W3
1942:  SUB.B   W4L,W3L,W0L
1944:  MOV.B   W0L,E7B
....................       y = -y; 
1946:  MOV     #E82,W0
1948:  MOV     #E82,W1
194A:  REPEAT  #3
194C:  MOV     [W0++],[W1++]
194E:  BTG.B   E85.7
....................    } 
....................  
....................    res = 0.0; 
1950:  CLR     E86
1952:  CLR     E88
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
1954:  MOV.B   E7B,W0L
1956:  SE      W0,W0
1958:  ADD     #7F,W0
195A:  MOV.B   W0L,E7A
....................    if(bit_test(data1,0)) 
195C:  BTSS.B  E7A.0
195E:  BRA     196C
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
1960:  MOV     #E86,W5
1962:  ADD     W5,#2,W0
1964:  MOV     W0,W5
1966:  MOV.B   [W5],W4L
1968:  IOR.B   #80,W4L
196A:  MOV.B   W4L,[W5+#0]
....................    rotate_right(&data1,1); 
196C:  MOV     #E7A,W1
196E:  RRNC.B  [W1],[W1--]
....................    bit_clear(data1,7); 
1970:  BCLR.B  E7A.7
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
1972:  MOV     #E89,W5
1974:  MOV     E7A,W0
1976:  MOV.B   W0L,[W5+#0]
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
1978:  MOV     E82,W0
197A:  MOV     E84,W1
197C:  MOV     #AA3B,W2
197E:  MOV     #3FB8,W3
1980:  CALL    1082
1984:  MOV     W0,W5
1986:  MOV     W1,W6
1988:  MOV.B   E7B,W0L
198A:  SE      W0,W0
198C:  CALL    6E0
1990:  BSET.B  43.0
1992:  MOV     W0,W2
1994:  MOV     W1,W3
1996:  MOV     W5,W0
1998:  MOV     W6,W1
199A:  CALL    72A
199E:  MOV     W0,E82
19A0:  MOV     W1,E84
....................  
....................    r = pe[0]*y + pe[1]; 
19A2:  MOV     860,W0
19A4:  MOV     862,W1
19A6:  MOV     E82,W2
19A8:  MOV     E84,W3
19AA:  CALL    1082
19AE:  MOV     W0,W5
19B0:  MOV     W1,W6
19B2:  BCLR.B  43.0
19B4:  MOV     W5,W0
19B6:  MOV     W6,W1
19B8:  MOV     864,W2
19BA:  MOV     866,W3
19BC:  CALL    72A
19C0:  MOV     W0,E8A
19C2:  MOV     W1,E8C
....................    r = r*y + pe[2]; 
19C4:  MOV     E8A,W0
19C6:  MOV     E8C,W1
19C8:  MOV     E82,W2
19CA:  MOV     E84,W3
19CC:  CALL    1082
19D0:  MOV     W0,W5
19D2:  MOV     W1,W6
19D4:  BCLR.B  43.0
19D6:  MOV     W5,W0
19D8:  MOV     W6,W1
19DA:  MOV     868,W2
19DC:  MOV     86A,W3
19DE:  CALL    72A
19E2:  MOV     W0,E8A
19E4:  MOV     W1,E8C
....................    r = r*y + pe[3]; 
19E6:  MOV     E8A,W0
19E8:  MOV     E8C,W1
19EA:  MOV     E82,W2
19EC:  MOV     E84,W3
19EE:  CALL    1082
19F2:  MOV     W0,W5
19F4:  MOV     W1,W6
19F6:  BCLR.B  43.0
19F8:  MOV     W5,W0
19FA:  MOV     W6,W1
19FC:  MOV     86C,W2
19FE:  MOV     86E,W3
1A00:  CALL    72A
1A04:  MOV     W0,E8A
1A06:  MOV     W1,E8C
....................    r = r*y + pe[4]; 
1A08:  MOV     E8A,W0
1A0A:  MOV     E8C,W1
1A0C:  MOV     E82,W2
1A0E:  MOV     E84,W3
1A10:  CALL    1082
1A14:  MOV     W0,W5
1A16:  MOV     W1,W6
1A18:  BCLR.B  43.0
1A1A:  MOV     W5,W0
1A1C:  MOV     W6,W1
1A1E:  MOV     870,W2
1A20:  MOV     872,W3
1A22:  CALL    72A
1A26:  MOV     W0,E8A
1A28:  MOV     W1,E8C
....................    r = r*y + pe[5]; 
1A2A:  MOV     E8A,W0
1A2C:  MOV     E8C,W1
1A2E:  MOV     E82,W2
1A30:  MOV     E84,W3
1A32:  CALL    1082
1A36:  MOV     W0,W5
1A38:  MOV     W1,W6
1A3A:  BCLR.B  43.0
1A3C:  MOV     W5,W0
1A3E:  MOV     W6,W1
1A40:  MOV     874,W2
1A42:  MOV     876,W3
1A44:  CALL    72A
1A48:  MOV     W0,E8A
1A4A:  MOV     W1,E8C
....................  
....................    res = res*(1.0 + y*r); 
1A4C:  MOV     E82,W0
1A4E:  MOV     E84,W1
1A50:  MOV     E8A,W2
1A52:  MOV     E8C,W3
1A54:  CALL    1082
1A58:  BCLR.B  43.0
1A5A:  MOV     W0,W2
1A5C:  MOV     W1,W3
1A5E:  MOV     #0,W0
1A60:  MOV     #3F80,W1
1A62:  CALL    72A
1A66:  MOV     W0,W2
1A68:  MOV     W1,W3
1A6A:  MOV     E86,W0
1A6C:  MOV     E88,W1
1A6E:  CALL    1082
1A72:  MOV     W0,E86
1A74:  MOV     W1,E88
....................  
....................    if (s) 
1A76:  BTSS.B  E7C.0
1A78:  BRA     1A8A
....................       res = 1.0/res; 
1A7A:  MOV     #0,W0
1A7C:  MOV     #3F80,W1
1A7E:  MOV     E86,W2
1A80:  MOV     E88,W3
1A82:  CALL    90E
1A86:  MOV     W0,E86
1A88:  MOV     W1,E88
....................    return(res); 
1A8A:  MOV     E86,W0
1A8C:  MOV     E88,W1
1A8E:  MOV     [--W15],W6
1A90:  MOV     [--W15],W5
1A92:  RETURN  
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
*
1780:  MOV     W5,[W15++]
1782:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
1784:  PUSH    E7E
1786:  POP     E82
1788:  PUSH    E80
178A:  POP     E84
....................  
....................    if (y != 1.0) 
178C:  MOV     E82,W0
178E:  MOV     E84,W1
1790:  MOV     #0,W2
1792:  MOV     #3F80,W3
1794:  CALL    14FE
1798:  BRA     Z,18FE
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
179A:  MOV     #E85,W0
179C:  MOV     W0,[W15++]
179E:  MOV.B   [W0],W0L
17A0:  MOV.B   W0L,E7B
17A2:  MOV     [--W15],W0
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
17A4:  MOV     #E85,W5
17A6:  MOV.B   #3F,W0L
17A8:  MOV.B   W0L,[W5]
....................    data1 = *(((unsigned int8 *)(&y))+2); 
17AA:  MOV     #E84,W0
17AC:  MOV     E7A,W4
17AE:  MOV.B   [W0+#0],W4L
17B0:  MOV     W4,E7A
....................    bit_clear(data1,7); 
17B2:  BCLR.B  E7A.7
....................    *(((unsigned int8 *)(&y))+2) = data1; 
17B4:  MOV     #E84,W5
17B6:  MOV     E7A,W0
17B8:  MOV.B   W0L,[W5+#0]
....................    if(bit_test(data2,7)) 
17BA:  BTSS.B  E7B.7
17BC:  BRA     17CA
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
17BE:  MOV     #E82,W5
17C0:  ADD     W5,#3,W0
17C2:  MOV     W0,W5
17C4:  MOV.B   [W5],W4L
17C6:  IOR.B   #80,W4L
17C8:  MOV.B   W4L,[W5+#0]
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
17CA:  BSET.B  43.0
17CC:  MOV     E82,W0
17CE:  MOV     E84,W1
17D0:  MOV     #0,W2
17D2:  MOV     #3F80,W3
17D4:  CALL    72A
17D8:  MOV     W0,W5
17DA:  MOV     W1,W6
17DC:  BCLR.B  43.0
17DE:  MOV     E82,W0
17E0:  MOV     E84,W1
17E2:  MOV     #0,W2
17E4:  MOV     #3F80,W3
17E6:  CALL    72A
17EA:  MOV     W0,W2
17EC:  MOV     W1,W3
17EE:  MOV     W5,W0
17F0:  MOV     W6,W1
17F2:  CALL    90E
17F6:  MOV     W0,E82
17F8:  MOV     W1,E84
....................  
....................       y2=y*y; 
17FA:  MOV     E82,W0
17FC:  MOV     E84,W1
17FE:  MOV     E82,W2
1800:  MOV     E84,W3
1802:  CALL    1082
1806:  MOV     W0,E8E
1808:  MOV     W1,E90
....................  
....................       res = pl[0]*y2 + pl[1]; 
180A:  MOV     8D8,W0
180C:  MOV     8DA,W1
180E:  MOV     E8E,W2
1810:  MOV     E90,W3
1812:  CALL    1082
1816:  MOV     W0,W5
1818:  MOV     W1,W6
181A:  BCLR.B  43.0
181C:  MOV     W5,W0
181E:  MOV     W6,W1
1820:  MOV     8DC,W2
1822:  MOV     8DE,W3
1824:  CALL    72A
1828:  MOV     W0,E86
182A:  MOV     W1,E88
....................  
....................       r = ql[0]*y2 + ql[1]; 
182C:  MOV     8E8,W0
182E:  MOV     8EA,W1
1830:  MOV     E8E,W2
1832:  MOV     E90,W3
1834:  CALL    1082
1838:  MOV     W0,W5
183A:  MOV     W1,W6
183C:  BCLR.B  43.0
183E:  MOV     W5,W0
1840:  MOV     W6,W1
1842:  MOV     8EC,W2
1844:  MOV     8EE,W3
1846:  CALL    72A
184A:  MOV     W0,E8A
184C:  MOV     W1,E8C
....................       r = r*y2 + 1.0; 
184E:  MOV     E8A,W0
1850:  MOV     E8C,W1
1852:  MOV     E8E,W2
1854:  MOV     E90,W3
1856:  CALL    1082
185A:  MOV     W0,W5
185C:  MOV     W1,W6
185E:  BCLR.B  43.0
1860:  MOV     W5,W0
1862:  MOV     W6,W1
1864:  MOV     #0,W2
1866:  MOV     #3F80,W3
1868:  CALL    72A
186C:  MOV     W0,E8A
186E:  MOV     W1,E8C
....................  
....................       res = y*res/r; 
1870:  MOV     E82,W0
1872:  MOV     E84,W1
1874:  MOV     E86,W2
1876:  MOV     E88,W3
1878:  CALL    1082
187C:  MOV     W0,W5
187E:  MOV     W1,W6
1880:  MOV     W5,W0
1882:  MOV     W6,W1
1884:  MOV     E8A,W2
1886:  MOV     E8C,W3
1888:  CALL    90E
188C:  MOV     W0,E86
188E:  MOV     W1,E88
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
1890:  MOV     #E81,W0
1892:  MOV     E7A,W4
1894:  MOV.B   [W0+#0],W4L
1896:  MOV     W4,E7A
....................     rotate_left(&data1,1); 
1898:  MOV     #E7A,W1
189A:  RLNC.B  [W1],[W1++]
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
189C:  MOV     #E80,W0
189E:  MOV     W0,[W15++]
18A0:  MOV.B   [W0],W0L
18A2:  MOV.B   W0L,E7B
18A4:  MOV     [--W15],W0
....................     if(bit_test (data2,7)) 
18A6:  BTSS.B  E7B.7
18A8:  BRA     18AC
....................       bit_set(data1,0); 
18AA:  BSET.B  E7A.0
....................     n = data1 - 0x7E; 
18AC:  MOV     E7A,W4
18AE:  CLR.B   9
18B0:  MOV     #7E,W3
18B2:  SUB     W4,W3,W0
18B4:  MOV.B   W0L,E7C
.................... #endif 
....................  
....................       if (n<0)  
18B6:  MOV.B   E7C,W0L
18B8:  SE      W0,W0
18BA:  CP      W0,#0
18BC:  BRA     GE,18D2
....................          r = -(float32)-n; 
18BE:  MOV     #0,W4
18C0:  MOV     E7C,W3
18C2:  SUB.B   W4L,W3L,W0L
18C4:  SE      W0,W0
18C6:  CALL    6E0
18CA:  MOV     W0,E8A
18CC:  MOV     W1,E8C
18CE:  BTG.B   E8D.7
18D0:  BRA     18DE
....................       else 
....................          r = (float32)n; 
18D2:  MOV.B   E7C,W0L
18D4:  SE      W0,W0
18D6:  CALL    6E0
18DA:  MOV     W0,E8A
18DC:  MOV     W1,E8C
....................  
....................       res += r*LN2; 
18DE:  MOV     E8A,W0
18E0:  MOV     E8C,W1
18E2:  MOV     #7218,W2
18E4:  MOV     #3F31,W3
18E6:  CALL    1082
18EA:  BCLR.B  43.0
18EC:  MOV     W0,W2
18EE:  MOV     W1,W3
18F0:  MOV     E86,W0
18F2:  MOV     E88,W1
18F4:  CALL    72A
18F8:  MOV     W0,E86
18FA:  MOV     W1,E88
....................    } 
18FC:  BRA     1902
....................  
....................    else 
....................       res = 0.0; 
18FE:  CLR     E86
1900:  CLR     E88
....................  
....................    return(res); 
1902:  MOV     E86,W0
1904:  MOV     E88,W1
1906:  MOV     [--W15],W6
1908:  MOV     [--W15],W5
190A:  RETURN  
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
*
1A94:  MOV     W5,[W15++]
1A96:  MOV     W6,[W15++]
1A98:  MOV     W7,[W15++]
1A9A:  MOV     W8,[W15++]
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
1A9C:  MOV     E6E,W0
1A9E:  MOV     E70,W1
1AA0:  MOV     #0,W2
1AA2:  MOV     #0,W3
1AA4:  CALL    14FE
1AA8:  BRA     NC,1B56
1AAA:  PUSH    E72
1AAC:  POP     E7A
1AAE:  PUSH    E74
1AB0:  POP     E7C
1AB2:  CLR     E7E
1AB4:  MOV     #3F80,W4
1AB6:  MOV     W4,E80
1AB8:  CALL    16F4
1ABC:  MOV     W0,W7
1ABE:  MOV     W1,W8
1AC0:  MOV     W7,W0
1AC2:  MOV     W8,W1
1AC4:  MOV     #0,W2
1AC6:  MOV     #0,W3
1AC8:  CALL    14FE
1ACC:  BRA     NZ,1B56
....................       if(fmod(y, 2) == 0) { 
1ACE:  PUSH    E72
1AD0:  POP     E7A
1AD2:  PUSH    E74
1AD4:  POP     E7C
1AD6:  CLR     E7E
1AD8:  MOV     #4000,W4
1ADA:  MOV     W4,E80
1ADC:  CALL    16F4
1AE0:  MOV     W0,W7
1AE2:  MOV     W1,W8
1AE4:  MOV     W7,W0
1AE6:  MOV     W8,W1
1AE8:  MOV     #0,W2
1AEA:  MOV     #0,W3
1AEC:  CALL    14FE
1AF0:  BRA     NZ,1B22
....................          return (exp(log(-x) * y)); 
1AF2:  MOV     E6E,W5
1AF4:  MOV     E70,W6
1AF6:  BTG     W6.F
1AF8:  MOV     W5,E7E
1AFA:  MOV     W6,E80
1AFC:  CALL    1780
1B00:  MOV     W0,W5
1B02:  MOV     W1,W6
1B04:  MOV     W5,W0
1B06:  MOV     W6,W1
1B08:  MOV     E72,W2
1B0A:  MOV     E74,W3
1B0C:  CALL    1082
1B10:  MOV     W0,W5
1B12:  MOV     W1,W6
1B14:  MOV     W5,E7E
1B16:  MOV     W6,E80
1B18:  CALL    190C
1B1C:  MOV.D   W0,W0
1B1E:  BRA     1BE2
....................       } else { 
1B20:  BRA     1B54
....................          return (-exp(log(-x) * y)); 
1B22:  MOV     E6E,W5
1B24:  MOV     E70,W6
1B26:  BTG     W6.F
1B28:  MOV     W5,E7E
1B2A:  MOV     W6,E80
1B2C:  CALL    1780
1B30:  MOV     W0,W5
1B32:  MOV     W1,W6
1B34:  MOV     W5,W0
1B36:  MOV     W6,W1
1B38:  MOV     E72,W2
1B3A:  MOV     E74,W3
1B3C:  CALL    1082
1B40:  MOV     W0,W5
1B42:  MOV     W1,W6
1B44:  MOV     W5,E7E
1B46:  MOV     W6,E80
1B48:  CALL    190C
1B4C:  MOV.D   W0,W0
1B4E:  BTG     W1.F
1B50:  MOV.D   W0,W0
1B52:  BRA     1BE2
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
1B54:  BRA     1BE2
1B56:  MOV     E6E,W0
1B58:  MOV     E70,W1
1B5A:  MOV     #0,W2
1B5C:  MOV     #0,W3
1B5E:  CALL    14FE
1B62:  BRA     NC,1B90
1B64:  PUSH    E72
1B66:  POP     E7A
1B68:  PUSH    E74
1B6A:  POP     E7C
1B6C:  CLR     E7E
1B6E:  MOV     #3F80,W4
1B70:  MOV     W4,E80
1B72:  CALL    16F4
1B76:  MOV     W0,W7
1B78:  MOV     W1,W8
1B7A:  MOV     W7,W0
1B7C:  MOV     W8,W1
1B7E:  MOV     #0,W2
1B80:  MOV     #0,W3
1B82:  CALL    14FE
1B86:  BRA     Z,1B90
....................       return 0; 
1B88:  MOV     #0,W0
1B8A:  MOV     #0,W1
1B8C:  BRA     1BE2
....................    } else { 
1B8E:  BRA     1BE2
....................       if(x != 0 || 0 >= y) { 
1B90:  MOV     E6E,W0
1B92:  MOV     E70,W1
1B94:  MOV     #0,W2
1B96:  MOV     #0,W3
1B98:  CALL    14FE
1B9C:  BRA     NZ,1BAE
1B9E:  MOV     E72,W0
1BA0:  MOV     E74,W1
1BA2:  MOV     #0,W2
1BA4:  MOV     #0,W3
1BA6:  CALL    14FE
1BAA:  BRA     C,1BAE
1BAC:  BRA     NZ,1BDC
....................          return (exp(log(x) * y)); 
1BAE:  PUSH    E6E
1BB0:  POP     E7E
1BB2:  PUSH    E70
1BB4:  POP     E80
1BB6:  CALL    1780
1BBA:  MOV     W0,W5
1BBC:  MOV     W1,W6
1BBE:  MOV     W5,W0
1BC0:  MOV     W6,W1
1BC2:  MOV     E72,W2
1BC4:  MOV     E74,W3
1BC6:  CALL    1082
1BCA:  MOV     W0,W5
1BCC:  MOV     W1,W6
1BCE:  MOV     W5,E7E
1BD0:  MOV     W6,E80
1BD2:  CALL    190C
1BD6:  MOV.D   W0,W0
1BD8:  BRA     1BE2
....................       } else return 0; 
1BDA:  BRA     1BE2
1BDC:  MOV     #0,W0
1BDE:  MOV     #0,W1
1BE0:  BRA     1BE2
....................    } 
1BE2:  MOV     [--W15],W8
1BE4:  MOV     [--W15],W7
1BE6:  MOV     [--W15],W6
1BE8:  MOV     [--W15],W5
1BEA:  RETURN  
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define SENSORBOARDA PIN_B15 
.................... #define SENSORBOARDB PIN_B14 
....................  
....................  
.................... #fuses  NOWDT, NOBROWNOUT, NOPROTECT, PUT 
.................... #use delay(crystal=8mhz, clock=32mhz) 
*
0356:  CP0     W0
0358:  BTSC.B  42.1
035A:  BRA     364
035C:  REPEAT  #3E7B
035E:  NOP     
0360:  DEC     W0,W0
0362:  BRA     NZ,35C
0364:  RETURN  
....................  
.................... #define SDAPIN PIN_B2 
.................... #define SCLPIN PIN_B3 
....................  
.................... #use I2C(stream=SENSOR, SLAVE, sda=SDAPIN,scl=SCLPIN, I2C2, address=0xa0)   // this is I2C 1 
*
0200:  MOV     #FFFF,W0
0202:  BTSS.B  218.3
0204:  BRA     202
0206:  BTSC.B  219.1
0208:  BRA     212
020A:  BTSS.B  217.2
020C:  BRA     212
020E:  BTSS.B  219.0
0210:  BRA     202
0212:  BTSS.B  218.1
0214:  BRA     212
0216:  MOV     210,W0
0218:  BTSC.B  218.6
021A:  BCLR.B  218.6
021C:  BSET.B  217.4
021E:  RETURN  
0220:  MOV     #FFFF,W0
0222:  BTSS.B  218.3
0224:  BRA     236
0226:  BTSS.B  218.2
0228:  BRA     236
022A:  BTSS.B  217.2
022C:  BRA     232
022E:  BTSS.B  219.0
0230:  BRA     236
0232:  MOV     W1,212
0234:  BSET.B  217.4
0236:  RETURN  
.................... #use I2C(stream=PH_LIGHT, MASTER, sda=PIN_B9, scl=PIN_B8)    // this is the master I2c for talking with removote sensor boards.  There is only one I2c on this chip. 
*
03F4:  MOV     #FFFF,W0
03F6:  BTSS.B  208.3
03F8:  BRA     404
03FA:  BTSC.B  209.6
03FC:  BRA     3FA
03FE:  MOV     W1,202
0400:  BTSC.B  209.6
0402:  BRA     400
0404:  MOV     #0,W0
0406:  BTSC.B  209.7
0408:  INC     W0,W0
040A:  RETURN  
*
0AD0:  MOV     #FFFF,W0
0AD2:  BTSS.B  208.3
0AD4:  BRA     AF8
0AD6:  MOV     206,W2
0AD8:  AND     W2,#1F,W2
0ADA:  BRA     NZ,AD6
0ADC:  BSET.B  206.3
0ADE:  BTSC    W1.0
0AE0:  BCLR.B  206.5
0AE2:  BTSS    W1.0
0AE4:  BSET.B  206.5
0AE6:  MOV     206,W2
0AE8:  AND     W2,#1F,W2
0AEA:  BRA     NZ,AE6
0AEC:  BSET.B  206.4
0AEE:  BTSS.B  208.1
0AF0:  BRA     AEE
0AF2:  MOV     200,W0
0AF4:  BTSC.B  208.6
0AF6:  BCLR.B  208.6
0AF8:  RETURN  
....................  
.................... #define SLAVE 1 
.................... #define SENSORNUMBER 0x39   // this means it is a Digital patch DO and NH4 board. 
.................... #define TESTER 
.................... //include this file.  Only edit this file because it changes all other remote digital boards. 
....................  
....................  
.................... //******************************************************************************* 
.................... // Created May 2, 2017 
.................... // Setup the software version and serial number for the current board. 
.................... // The software version is contained in the program sources code.   
.................... // The serial number is contained in EEPROM 
.................... //  The format is as follows: 
.................... //  Software version   UnitIDCode.Major Change.Minor Change 
.................... //  Each number is two characters or bytes. 
.................... //  The UnitDI Number is tacked on the beginning of the software version number, "SENSORNUMBER" 
.................... //****************************************************************************** 
.................... char softwareversion[5] = "01.01";   // This number gets updated each time a new software version is released.  It is not saved in normal memeory.  It is tacked on the end of the I2C transmaission. 
....................  
....................  
.................... void GetCurrentColorAVG(int8 GainIn, int8 DeviceSelect); 
....................  
....................  
....................  
....................  
....................  
.................... typedef struct outputDataStruct{ 
.................... char deviceID[16]; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int8 taosVersion; 
.................... float dOxy; 
.................... float wTemp; 
.................... float pH; 
.................... float pHLow; 
.................... float WhiteBalance; 
.................... float tdsLevel; 
.................... float wLevel; 
.................... float lLevelX; 
.................... float lLevelY; 
....................  
.................... int32 lLevelRed; 
.................... int32 lLevelGreen; 
.................... int32 lLevelBlue; 
.................... int32 lLevelClear; 
.................... int8 time; 
.................... int16 date; 
....................  
....................  
.................... float lLevelScale; 
.................... float rH,averagepH; 
.................... float aTemp; 
.................... int16 cO2; 
.................... float nh3; 
.................... float dPoint; 
.................... char DIEHARD[8]; 
.................... }outputData; 
....................  
....................  
.................... outputData sysOutput; 
.................... /* 
.................... // This is added for the retrieval of the configuration data from the host master I2C 
....................  
.................... typedef struct inputDataStruct{ 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... float eccal1x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal1y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3y;    //  This the EC data point  Added July 18, 2016 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
.................... }inputData; 
.................... inputData sysInput;  */ 
....................  
.................... #include <LightSensorForDigitalBoard.c> 
....................  
....................  
.................... #ifndef byte 
.................... #define byte int8 
.................... #endif 
....................  
.................... //Timing Register 
.................... #define SYNC_EDGE 0x40 
.................... #define INTEG_MODE_FREE 0x00 
.................... #define INTEG_MODE_MANUAL 0x10 
.................... #define INTEG_MODE_SYN_SINGLE 0x20 
.................... #define INTEG_MODE_SYN_MULTI 0x30 
....................   
....................  
....................  
.................... float tempa1, tempa2, tempa3;   //Addded May 15, 2014 These are the coefecents for thermister calculation 
.................... void selectsensor(int number); 
.................... float FindpHEquation(void); 
.................... int colorlow, colorhigh;   // gain, scale;  //This is the pair of bytes used to return the current selected color. 
.................... unsigned int16 red,green,blue,clear; 
.................... //int32 scaledred, scaledgreen, scaledblue;   // Added May 6, 2014  These are large number to hold the gain of the intensity 
....................  
.................... //************************************************************************************* 
.................... //Created March 4, 2015 
.................... // The Exposurescale is used for the preprocessor to scale down the ADC.  Each light sensor has a different scaling. 
.................... // Below is a table showing the values for each exposure scale down for the ADC. 
.................... //  000            Divide by 1 
.................... //  001            Divide by 2 
.................... //  010            Divide by 4 
.................... //  011            Divide by 8 
.................... //  100            Divide by 16 
.................... //  101            Divide by 32 
.................... //  110            Divide by 64 
.................... //  111            Does not exist and is not used. 
.................... //************************************************************************************ 
....................  
.................... byte ExposurescaleDO = 0;   //This is the global variable used for prescaler for the ADC 
.................... byte ExposurescalepH = 0;   //This is the global variable used for prescaler for the ADC  
.................... byte ExposurescaleLight = 2;   //  This used to be 2.  This is the global variable used for prescaler for the ADC   Three is used to divide by 4 
.................... float x,y,z;  //Color chart positions,coored. 
....................  
.................... //************************************************************ 
.................... //Define the 3X4 matrix for solving three unknown equations. 
.................... float matx[3][3];  //This is the global diffinition of solving a 3X3 matrix equation. This is a scrach pad matrix used to pass arrays between functions. Added May 13, 2013 
.................... float matrixequation[3][3]; //  Added May 13, 2013  This is the array used for setting up the eqaution for solving a 3X3 equation. 
.................... //float fourbyfourmatrix[4][4]; 
.................... float matrixequals[3];  
.................... // Added April 27, 2014   
.................... // Matrixequals is used for place the results of all three equations. 
.................... // This is used to subsitue into the 3X3 matrix for finding the DET. 
.................... float MatrixSolution[3];  
.................... // Added April 27, 2014  This matrix saves the 
.................... // result for the 3X3 unknown solution. 
.................... float TempCalmatrix[4][3];  //This matrix holds the temperatures and K1, K2 and Iohhh values. 
.................... float pk, slope;  //these are the varaibles used for ph calcualtions 
.................... float lastphreading = -0.1;   //This is the last compare start up.  It's negative to start the current reading. 
.................... //************************************************************** 
....................  
....................  
.................... //****************************************************************** 
.................... // Added Dec 8, 2014 
.................... // These varaibles are used for optical offsets for ph and DO. 
.................... //****************************************************************** 
.................... signed int32		AmbientOxyRed; 
.................... signed int32		AmbientOxyGreen; 
.................... signed int32		AmbientOxyBlue; 
.................... signed int32		AmbientOxyClear; 
.................... signed int32		AmbientPHRed; 
.................... signed int32		AmbientPHGreen; 
.................... signed int32		AmbientPHBlue;  
.................... signed int32		AmbientPHClear;  
.................... signed int32		Ambientnh3Red; 
.................... signed int32		Ambientnh3Green; 
.................... signed int32		Ambientnh3Blue;  
.................... signed int32		Ambientnh3Clear;  
....................  
.................... //************************************************************************ 
.................... //Added December 12, 2014 
.................... // These varaibles are used for each color absolute.  These numbers combined with the gain. 
.................... //  They are 32 bits long 
.................... //************************************************************************ 
.................... signed int32 redABS; 
.................... signed int32 blueABS; 
.................... signed int32 greenABS; 
.................... signed int32 clearABS; 
....................  
....................  
.................... //****************************************************************** 
.................... // K1 and K2 are two constants caluclated from calibration constants saved in EEPROM. 
.................... // The rest of the constants are used for calculating K1, K2 and Iohhh against temperature. 
.................... //  Added April 27, 2014 
.................... //****************************************************************** 
.................... float K1, K2, K1Temp,K2Temp;   // Added April 6, 2015  These are all of the K values for DO temperature and non temperature compensation. 
.................... float RatioI, RatioII, Iohhh; 
.................... float atwo, btwo, ctwo;   //no Temp compensated DO 
....................  
.................... //**************************************************************** 
.................... // Created/Moved May 20, 2015 
.................... // These varabbles are moved here to be global. 
.................... //  They are all for the DO only. 
.................... //**************************************************************** 
.................... int debugnumber = 0;  //Added July 13, 2015.  It keeps the current state of the debug routine calls.  Default is zero; or not in debug/calibration mode. 
....................  
....................  
....................  
....................      
....................     float wTemp = 20.0; 
....................  
....................  
....................  
.................... //********************************************************************************* 
.................... // The defs below are for pH 
.................... //************************************************************************************ 
.................... 	float pHHigh, pHMiddle, pHLower; 
....................     float pHHighCalibration,pHMiddleCalibration,pHLowerCalibration; 
....................  
.................... //********************************************************************************* 
.................... // Added May 21, 2015 
.................... // This is the calibrations for temperature on the thermister for water 
.................... //********************************************************************************* 
....................  
.................... //	float temp1,reading1,temp2,reading2,temp3,reading3; 
.................... 	int32 BlueLimit,WhiteLimit;  //This is the limit variable off the SD Card for the desiged light intesity. 
.................... 	float StartWaterTemperature;  //This is the varaible used to keep track of the init water temperature for hose air expansion. 
....................  
....................  
....................  
.................... //************************************************************ 
.................... // Added December 1, 2014 
.................... // These variables will keep the last intensity 
.................... unsigned int16 PWMDOIntensity; 
.................... unsigned int16 PWMPHIntensity; 
.................... unsigned int16 PWMnh3Intensity; 
.................... int32 DOreadingrange = 250;    //These are the starting values for the tolorance ranges for DO and pH  Added July 27, 2015 
.................... int32 pHreadingrange = 200; 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created May 13, 2013 
.................... // This routine returns the determinent for a given 3X3 mastrix passed through the funtion stack as a pointer to address. 
.................... // The Deteminete is returned at the end of the funtion call. 
.................... // This method for solving equations is called Cramer's rule 
.................... //****************************************************************************** 
.................... float FindTheDetermint(void) 
*
1BEC:  MOV     W5,[W15++]
1BEE:  MOV     W6,[W15++]
1BF0:  MOV     W7,[W15++]
1BF2:  MOV     W8,[W15++]
.................... 	{ 
.................... 	float det,part1,part2;  //Define the determint as float. 
....................  
....................     part1=matx[0][0]*matx[1][1]*matx[2][2]; 
1BF4:  MOV     AC0,W0
1BF6:  MOV     AC2,W1
1BF8:  MOV     AD0,W2
1BFA:  MOV     AD2,W3
1BFC:  CALL    1082
1C00:  MOV     W0,W5
1C02:  MOV     W1,W6
1C04:  MOV     W5,W0
1C06:  MOV     W6,W1
1C08:  MOV     AE0,W2
1C0A:  MOV     AE2,W3
1C0C:  CALL    1082
1C10:  MOV     W0,E76
1C12:  MOV     W1,E78
....................  
.................... 	det = (part1 + matx[1][0]*matx[2][1]*matx[0][2] + matx[2][0]*matx[0][1]*matx[1][2]);  
1C14:  MOV     ACC,W0
1C16:  MOV     ACE,W1
1C18:  MOV     ADC,W2
1C1A:  MOV     ADE,W3
1C1C:  CALL    1082
1C20:  MOV     W0,W5
1C22:  MOV     W1,W6
1C24:  MOV     W5,W0
1C26:  MOV     W6,W1
1C28:  MOV     AC8,W2
1C2A:  MOV     ACA,W3
1C2C:  CALL    1082
1C30:  BCLR.B  43.0
1C32:  MOV     W0,W2
1C34:  MOV     W1,W3
1C36:  MOV     E76,W0
1C38:  MOV     E78,W1
1C3A:  CALL    72A
1C3E:  MOV     W0,W5
1C40:  MOV     W1,W6
1C42:  MOV     AD8,W0
1C44:  MOV     ADA,W1
1C46:  MOV     AC4,W2
1C48:  MOV     AC6,W3
1C4A:  CALL    1082
1C4E:  MOV     W0,W7
1C50:  MOV     W1,W8
1C52:  MOV     W7,W0
1C54:  MOV     W8,W1
1C56:  MOV     AD4,W2
1C58:  MOV     AD6,W3
1C5A:  CALL    1082
1C5E:  BCLR.B  43.0
1C60:  MOV     W0,W2
1C62:  MOV     W1,W3
1C64:  MOV     W5,W0
1C66:  MOV     W6,W1
1C68:  CALL    72A
1C6C:  MOV     W0,E72
1C6E:  MOV     W1,E74
....................     part2 = (matx[0][2]*matx[1][1]*matx[2][0] + matx[1][2]*matx[2][1]*matx[0][0] + matx[2][2]*matx[0][1]*matx[1][0]); 
1C70:  MOV     AC8,W0
1C72:  MOV     ACA,W1
1C74:  MOV     AD0,W2
1C76:  MOV     AD2,W3
1C78:  CALL    1082
1C7C:  MOV     W0,W5
1C7E:  MOV     W1,W6
1C80:  MOV     W5,W0
1C82:  MOV     W6,W1
1C84:  MOV     AD8,W2
1C86:  MOV     ADA,W3
1C88:  CALL    1082
1C8C:  MOV     W0,W5
1C8E:  MOV     W1,W6
1C90:  MOV     AD4,W0
1C92:  MOV     AD6,W1
1C94:  MOV     ADC,W2
1C96:  MOV     ADE,W3
1C98:  CALL    1082
1C9C:  MOV     W0,W7
1C9E:  MOV     W1,W8
1CA0:  MOV     W7,W0
1CA2:  MOV     W8,W1
1CA4:  MOV     AC0,W2
1CA6:  MOV     AC2,W3
1CA8:  CALL    1082
1CAC:  BCLR.B  43.0
1CAE:  MOV     W0,W2
1CB0:  MOV     W1,W3
1CB2:  MOV     W5,W0
1CB4:  MOV     W6,W1
1CB6:  CALL    72A
1CBA:  MOV     W0,W5
1CBC:  MOV     W1,W6
1CBE:  MOV     AE0,W0
1CC0:  MOV     AE2,W1
1CC2:  MOV     AC4,W2
1CC4:  MOV     AC6,W3
1CC6:  CALL    1082
1CCA:  MOV     W0,W7
1CCC:  MOV     W1,W8
1CCE:  MOV     W7,W0
1CD0:  MOV     W8,W1
1CD2:  MOV     ACC,W2
1CD4:  MOV     ACE,W3
1CD6:  CALL    1082
1CDA:  BCLR.B  43.0
1CDC:  MOV     W0,W2
1CDE:  MOV     W1,W3
1CE0:  MOV     W5,W0
1CE2:  MOV     W6,W1
1CE4:  CALL    72A
1CE8:  MOV     W0,E7A
1CEA:  MOV     W1,E7C
.................... 	det = det - (matx[0][2]*matx[1][1]*matx[2][0] + matx[1][2]*matx[2][1]*matx[0][0] + matx[2][2]*matx[0][1]*matx[1][0]); 
1CEC:  MOV     AC8,W0
1CEE:  MOV     ACA,W1
1CF0:  MOV     AD0,W2
1CF2:  MOV     AD2,W3
1CF4:  CALL    1082
1CF8:  MOV     W0,W5
1CFA:  MOV     W1,W6
1CFC:  MOV     W5,W0
1CFE:  MOV     W6,W1
1D00:  MOV     AD8,W2
1D02:  MOV     ADA,W3
1D04:  CALL    1082
1D08:  MOV     W0,W5
1D0A:  MOV     W1,W6
1D0C:  MOV     AD4,W0
1D0E:  MOV     AD6,W1
1D10:  MOV     ADC,W2
1D12:  MOV     ADE,W3
1D14:  CALL    1082
1D18:  MOV     W0,W7
1D1A:  MOV     W1,W8
1D1C:  MOV     W7,W0
1D1E:  MOV     W8,W1
1D20:  MOV     AC0,W2
1D22:  MOV     AC2,W3
1D24:  CALL    1082
1D28:  BCLR.B  43.0
1D2A:  MOV     W0,W2
1D2C:  MOV     W1,W3
1D2E:  MOV     W5,W0
1D30:  MOV     W6,W1
1D32:  CALL    72A
1D36:  MOV     W0,W5
1D38:  MOV     W1,W6
1D3A:  MOV     AE0,W0
1D3C:  MOV     AE2,W1
1D3E:  MOV     AC4,W2
1D40:  MOV     AC6,W3
1D42:  CALL    1082
1D46:  MOV     W0,W7
1D48:  MOV     W1,W8
1D4A:  MOV     W7,W0
1D4C:  MOV     W8,W1
1D4E:  MOV     ACC,W2
1D50:  MOV     ACE,W3
1D52:  CALL    1082
1D56:  BCLR.B  43.0
1D58:  MOV     W0,W2
1D5A:  MOV     W1,W3
1D5C:  MOV     W5,W0
1D5E:  MOV     W6,W1
1D60:  CALL    72A
1D64:  BSET.B  43.0
1D66:  MOV     W0,W2
1D68:  MOV     W1,W3
1D6A:  MOV     E72,W0
1D6C:  MOV     E74,W1
1D6E:  CALL    72A
1D72:  MOV     W0,E72
1D74:  MOV     W1,E74
....................  
.................... 	return(det); 
1D76:  MOV     E72,W0
1D78:  MOV     E74,W1
1D7A:  MOV     [--W15],W8
1D7C:  MOV     [--W15],W7
1D7E:  MOV     [--W15],W6
1D80:  MOV     [--W15],W5
1D82:  RETURN  
.................... 	} 
....................  
.................... //****************************************************************************** 
.................... // Created May 13, 2013 
.................... // This routine is a general purpose solution for three unknowns given the coefficents of all three equations and what they eqaul. 
.................... // The coefficents are given as a matrix of 3X3 in an 3X3 array of floats starting with 0 to 2.  The results are placed in the last colomum of of the 3X3 matrix. 
.................... // The routines uses a series of deteminets to solve the problems. 
.................... //****************************************************************************** 
.................... void ThreeByThreeSolution(void) 
1D84:  MOV     W5,[W15++]
1D86:  MOV     W6,[W15++]
.................... 	{ 
....................  
.................... 	float det, detx, dety, detz; 
.................... 	int x, y; 
....................  
.................... // this finds the common det for the whole matrix 
.................... //  Move the exisitng array into the scratch pad marix  matx 
.................... 	for (x=0; x < 3; x++) 
1D88:  CLR     E6E
1D8A:  MOV     E6E,W4
1D8C:  CP      W4,#3
1D8E:  BRA     GE,1DC2
.................... 		{ 
.................... 		for (y=0; y < 3; y++) 
1D90:  CLR     E70
1D92:  MOV     E70,W4
1D94:  CP      W4,#3
1D96:  BRA     GE,1DBE
.................... 			{ 
.................... 			matx[x][y] = matrixequation[x][y];   //Move this element into the scrach matrix. 
1D98:  MOV     E6E,W4
1D9A:  MUL.UU  W4,#C,W0
1D9C:  MOV     W0,W5
1D9E:  MOV     E70,W4
1DA0:  MUL.UU  W4,#4,W0
1DA2:  ADD     W0,W5,W0
1DA4:  MOV     #AC0,W4
1DA6:  ADD     W0,W4,W5
1DA8:  MOV     E6E,W4
1DAA:  MUL.UU  W4,#C,W6
1DAC:  MOV     E70,W4
1DAE:  MUL.UU  W4,#4,W0
1DB0:  ADD     W0,W6,W0
1DB2:  MOV     #AE4,W4
1DB4:  ADD     W0,W4,W0
1DB6:  MOV     [W0++],[W5++]
1DB8:  MOV     [W0++],[W5++]
1DBA:  INC     0E70
1DBC:  BRA     1D92
.................... 			} 
1DBE:  INC     0E6E
1DC0:  BRA     1D8A
.................... 		} 
.................... /* 
.................... 	matx[0][0] = 1.0;  //this for testing the deteminte routine. 
.................... 	matx[1][0] = 0.0;  // remove all of this when completed. 
.................... 	matx[2][0] = 3.0;    // Example  
.................... 	matx[0][1] = 2.0;    //  1.0  0.0  3.0 
.................... 	matx[1][1] = 1.0;    //  2.0  1.0  0.0 
.................... 	matx[2][1] = 0.0;    //  4.0  1.0  0.0 
.................... 	matx[0][2] = 4.0; 
.................... 	matx[1][2] = 1.0; 
.................... 	matx[2][2] = 0.0; 
.................... */ 
.................... 	det = FindTheDetermint(); 
1DC2:  CALL    1BEC
1DC6:  MOV     W0,E5E
1DC8:  MOV     W1,E60
....................  
....................  
.................... //  Move the exisitng array into the scratch pad matrix  matrix 
.................... 	for (x=0; x < 3; x++) 
1DCA:  CLR     E6E
1DCC:  MOV     E6E,W4
1DCE:  CP      W4,#3
1DD0:  BRA     GE,1E04
.................... 		{ 
.................... 		for (y=0; y < 3; y++) 
1DD2:  CLR     E70
1DD4:  MOV     E70,W4
1DD6:  CP      W4,#3
1DD8:  BRA     GE,1E00
.................... 			{ 
.................... 			matx[x][y] = matrixequation[x][y];   //Move this element into the scrach matrix. 
1DDA:  MOV     E6E,W4
1DDC:  MUL.UU  W4,#C,W0
1DDE:  MOV     W0,W5
1DE0:  MOV     E70,W4
1DE2:  MUL.UU  W4,#4,W0
1DE4:  ADD     W0,W5,W0
1DE6:  MOV     #AC0,W4
1DE8:  ADD     W0,W4,W5
1DEA:  MOV     E6E,W4
1DEC:  MUL.UU  W4,#C,W6
1DEE:  MOV     E70,W4
1DF0:  MUL.UU  W4,#4,W0
1DF2:  ADD     W0,W6,W0
1DF4:  MOV     #AE4,W4
1DF6:  ADD     W0,W4,W0
1DF8:  MOV     [W0++],[W5++]
1DFA:  MOV     [W0++],[W5++]
1DFC:  INC     0E70
1DFE:  BRA     1DD4
.................... 			} 
1E00:  INC     0E6E
1E02:  BRA     1DCC
.................... 		} 
.................... 		for (y=0; y < 3; y++) //move the first colunm into the x 
1E04:  CLR     E70
1E06:  MOV     E70,W4
1E08:  CP      W4,#3
1E0A:  BRA     GE,1E24
.................... 			{ 
....................                  matx[0][y] = matrixequals[y]; 
1E0C:  MOV     E70,W4
1E0E:  MUL.UU  W4,#4,W0
1E10:  MOV     #AC0,W4
1E12:  ADD     W0,W4,W5
1E14:  MOV     E70,W4
1E16:  MUL.UU  W4,#4,W0
1E18:  MOV     #B08,W4
1E1A:  ADD     W0,W4,W0
1E1C:  MOV     [W0++],[W5++]
1E1E:  MOV     [W0++],[W5++]
1E20:  INC     0E70
1E22:  BRA     1E06
.................... 			} 
....................  
.................... 	detx = FindTheDetermint(); //find the detmeinent 
1E24:  CALL    1BEC
1E28:  MOV     W0,E62
1E2A:  MOV     W1,E64
....................       MatrixSolution[0] = detx/det; //Stuff the results in the x location 
1E2C:  MOV     E62,W0
1E2E:  MOV     E64,W1
1E30:  MOV     E5E,W2
1E32:  MOV     E60,W3
1E34:  CALL    90E
1E38:  MOV     W0,B14
1E3A:  MOV     W1,B16
....................  
.................... //  Move the exisitng array into the scratch pad matrix  matrix 
.................... 	for (x=0; x < 3; x++) 
1E3C:  CLR     E6E
1E3E:  MOV     E6E,W4
1E40:  CP      W4,#3
1E42:  BRA     GE,1E76
.................... 		{ 
.................... 		for (y=0; y < 3; y++) 
1E44:  CLR     E70
1E46:  MOV     E70,W4
1E48:  CP      W4,#3
1E4A:  BRA     GE,1E72
.................... 			{ 
.................... 			matx[x][y] = matrixequation[x][y];   //Move this element into the scrach matrix. 
1E4C:  MOV     E6E,W4
1E4E:  MUL.UU  W4,#C,W0
1E50:  MOV     W0,W5
1E52:  MOV     E70,W4
1E54:  MUL.UU  W4,#4,W0
1E56:  ADD     W0,W5,W0
1E58:  MOV     #AC0,W4
1E5A:  ADD     W0,W4,W5
1E5C:  MOV     E6E,W4
1E5E:  MUL.UU  W4,#C,W6
1E60:  MOV     E70,W4
1E62:  MUL.UU  W4,#4,W0
1E64:  ADD     W0,W6,W0
1E66:  MOV     #AE4,W4
1E68:  ADD     W0,W4,W0
1E6A:  MOV     [W0++],[W5++]
1E6C:  MOV     [W0++],[W5++]
1E6E:  INC     0E70
1E70:  BRA     1E46
.................... 			} 
1E72:  INC     0E6E
1E74:  BRA     1E3E
.................... 		} 
.................... 		for (y=0; y < 3; y++) //move the first colunm into the x 
1E76:  CLR     E70
1E78:  MOV     E70,W4
1E7A:  CP      W4,#3
1E7C:  BRA     GE,1E96
.................... 			{ 
....................                  matx[1][y] = matrixequals[y]; 
1E7E:  MOV     E70,W4
1E80:  MUL.UU  W4,#4,W0
1E82:  MOV     #ACC,W4
1E84:  ADD     W0,W4,W5
1E86:  MOV     E70,W4
1E88:  MUL.UU  W4,#4,W0
1E8A:  MOV     #B08,W4
1E8C:  ADD     W0,W4,W0
1E8E:  MOV     [W0++],[W5++]
1E90:  MOV     [W0++],[W5++]
1E92:  INC     0E70
1E94:  BRA     1E78
.................... 			} 
....................  
.................... 	dety = FindTheDetermint(); //find the detmeinent 
1E96:  CALL    1BEC
1E9A:  MOV     W0,E66
1E9C:  MOV     W1,E68
....................       MatrixSolution[1] = dety/det; //Stuff the results in the x location 
1E9E:  MOV     E66,W0
1EA0:  MOV     E68,W1
1EA2:  MOV     E5E,W2
1EA4:  MOV     E60,W3
1EA6:  CALL    90E
1EAA:  MOV     W0,B18
1EAC:  MOV     W1,B1A
....................  
....................  
.................... //  Move the exisitng array into the scratch pad matrix  matrix 
.................... 	for (x=0; x < 3; x++) 
1EAE:  CLR     E6E
1EB0:  MOV     E6E,W4
1EB2:  CP      W4,#3
1EB4:  BRA     GE,1EE8
.................... 		{ 
.................... 		for (y=0; y < 3; y++) 
1EB6:  CLR     E70
1EB8:  MOV     E70,W4
1EBA:  CP      W4,#3
1EBC:  BRA     GE,1EE4
.................... 			{ 
.................... 			matx[x][y] = matrixequation[x][y];   //Move this element into the scrach matrix. 
1EBE:  MOV     E6E,W4
1EC0:  MUL.UU  W4,#C,W0
1EC2:  MOV     W0,W5
1EC4:  MOV     E70,W4
1EC6:  MUL.UU  W4,#4,W0
1EC8:  ADD     W0,W5,W0
1ECA:  MOV     #AC0,W4
1ECC:  ADD     W0,W4,W5
1ECE:  MOV     E6E,W4
1ED0:  MUL.UU  W4,#C,W6
1ED2:  MOV     E70,W4
1ED4:  MUL.UU  W4,#4,W0
1ED6:  ADD     W0,W6,W0
1ED8:  MOV     #AE4,W4
1EDA:  ADD     W0,W4,W0
1EDC:  MOV     [W0++],[W5++]
1EDE:  MOV     [W0++],[W5++]
1EE0:  INC     0E70
1EE2:  BRA     1EB8
.................... 			} 
1EE4:  INC     0E6E
1EE6:  BRA     1EB0
.................... 		} 
.................... 		for (y=0; y < 3; y++) //move the first colunm into the x 
1EE8:  CLR     E70
1EEA:  MOV     E70,W4
1EEC:  CP      W4,#3
1EEE:  BRA     GE,1F08
.................... 			{ 
....................                  matx[2][y] = matrixequals[y];  // replace the colunm 
1EF0:  MOV     E70,W4
1EF2:  MUL.UU  W4,#4,W0
1EF4:  MOV     #AD8,W4
1EF6:  ADD     W0,W4,W5
1EF8:  MOV     E70,W4
1EFA:  MUL.UU  W4,#4,W0
1EFC:  MOV     #B08,W4
1EFE:  ADD     W0,W4,W0
1F00:  MOV     [W0++],[W5++]
1F02:  MOV     [W0++],[W5++]
1F04:  INC     0E70
1F06:  BRA     1EEA
.................... 			} 
....................  
.................... 	detz = FindTheDetermint(); //find the detmeinent 
1F08:  CALL    1BEC
1F0C:  MOV     W0,E6A
1F0E:  MOV     W1,E6C
....................       MatrixSolution[2] = detz/det; //Stuff the results in the x location 
1F10:  MOV     E6A,W0
1F12:  MOV     E6C,W1
1F14:  MOV     E5E,W2
1F16:  MOV     E60,W3
1F18:  CALL    90E
1F1C:  MOV     W0,B1C
1F1E:  MOV     W1,B1E
1F20:  MOV     [--W15],W6
1F22:  MOV     [--W15],W5
1F24:  RETURN  
....................  
.................... 	} 
....................  
.................... #ifdef TESTER 
....................  
.................... //*************************************************************************** 
.................... // Created December 2, 2015 
.................... // Changed for the digital sensor board Oct 13, 2016 
.................... // This routine sets the encoder to select where the I2C clock signal goes to. 
.................... // It returns nothing. 
.................... // The input is number for 0 to 5;  each one selecting a sensor. 
.................... // Added March 17, 2016 
.................... //  SENSORBOARDA    0       1      0         1 
.................... //  SENSORBOARDB    0       0      1         1 
.................... //                in unit   top   bot Rj45   nothing 
.................... //*************************************************************************** 
.................... void selectsensor(int number) 
.................... 	{ 
.................... //fprintf(BT,"Device Number Selected %i\n\r",sensor number); 
.................... 	if (number > 3)   // Set the high bit 
*
03B0:  MOV     E88,W4
03B2:  CP      W4,#3
03B4:  BRA     LE,3BC
.................... 		{ 
.................... 		number = number - 4;    // Remove the offset so the bottom part of the byte can be accessed 
03B6:  MOV     E88,W4
03B8:  SUB     W4,#4,W0
03BA:  MOV     W0,E88
.................... 		} 
....................  
.................... 	if (number == 0)   // Set the lower bits. 
03BC:  CP0     E88
03BE:  BRA     NZ,3C8
.................... 		{ 
.................... 		output_low(SENSORBOARDA);   // This is connected to the input for the A on both 74139 chips. 
03C0:  BCLR.B  2C9.7
03C2:  BCLR.B  2CD.7
.................... 		output_low(SENSORBOARDB);   // This is connected to the input for the B on both 74139 chips. 
03C4:  BCLR.B  2C9.6
03C6:  BCLR.B  2CD.6
.................... 		} 
....................  
.................... 	if (number == 1) 
03C8:  MOV     E88,W4
03CA:  CP      W4,#1
03CC:  BRA     NZ,3D6
.................... 		{ 
.................... 		output_high(SENSORBOARDA);   // This is connected to the input for the A on both 74139 chips. 
03CE:  BCLR.B  2C9.7
03D0:  BSET.B  2CD.7
.................... 		output_low(SENSORBOARDB);   // This is connected to the input for the B on both 74139 chips. 
03D2:  BCLR.B  2C9.6
03D4:  BCLR.B  2CD.6
.................... 		} 
.................... 	if (number == 2) 
03D6:  MOV     E88,W4
03D8:  CP      W4,#2
03DA:  BRA     NZ,3E4
.................... 		{ 
.................... 		output_low(SENSORBOARDA);   // This is connected to the input for the A on both 74139 chips. 
03DC:  BCLR.B  2C9.7
03DE:  BCLR.B  2CD.7
.................... 		output_high(SENSORBOARDB);   // This is connected to the input for the B on both 74139 chips. 
03E0:  BCLR.B  2C9.6
03E2:  BSET.B  2CD.6
.................... 		} 
.................... 	if (number == 3) 
03E4:  MOV     E88,W4
03E6:  CP      W4,#3
03E8:  BRA     NZ,3F2
.................... 		{ 
.................... 		output_high(SENSORBOARDA);   // This is connected to the input for the A on both 74139 chips. 
03EA:  BCLR.B  2C9.7
03EC:  BSET.B  2CD.7
.................... 		output_high(SENSORBOARDB);   // This is connected to the input for the B on both 74139 chips. 
03EE:  BCLR.B  2C9.6
03F0:  BSET.B  2CD.6
.................... 		} 
03F2:  RETURN  
....................  
.................... 	} 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************** 
.................... //Created March 17, 2013 
.................... // This routine reads the all four inputs and returns the 16 bit value for that color. 
.................... // The value for color is as follows: 
.................... // 1:red 
.................... // 2:greem 
.................... // 3:blue 
.................... // 4:clear 
.................... // The retuened value is measured value. 
.................... //  This measurement is influnenced by the scalling factor for each ADC. 
.................... //  The two numbers are returned through tow global varibles. 
.................... //  The variables are colorlow and colorhigh. 
.................... // Added Oct 20, 2014 - Multi I2C lines can be used for each light sensor 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the room 
.................... //****************************************************************** 
.................... void ReadColorTAOS(int selectedcolor, int lightsensor) 
.................... 	{ 
....................  
.................... 	switch(selectedcolor) 
*
0AFA:  MOV     E7E,W0
0AFC:  XOR     #2,W0
0AFE:  BRA     Z,B0E
0B00:  XOR     #3,W0
0B02:  BRA     Z,BC8
0B04:  XOR     #2,W0
0B06:  BRA     Z,C82
0B08:  XOR     #7,W0
0B0A:  BRA     Z,D3C
0B0C:  BRA     DF6
.................... 		{ 
.................... 		case 2:   //green 
.................... 			i2c_start(PH_LIGHT); 
0B0E:  BTSS.B  208.3
0B10:  BRA     B1A
0B12:  BSET.B  206.1
0B14:  BTSC.B  206.1
0B16:  BRA     B14
0B18:  BRA     B20
0B1A:  BSET.B  206.0
0B1C:  BTSC.B  206.0
0B1E:  BRA     B1C
.................... 			i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0B20:  MOV.B   #52,W1L
0B22:  CALL    3F4
.................... 			i2c_write(PH_LIGHT,0x98);  //Send the command for reading the green light low byte 
0B26:  MOV.B   #98,W1L
0B28:  CALL    3F4
.................... 			i2c_stop(PH_LIGHT); 
0B2C:  MOV     #1F,W0
0B2E:  AND     206,W0
0B30:  BRA     NZ,B2C
0B32:  BSET.B  206.2
0B34:  BTSC.B  206.2
0B36:  BRA     B34
....................  
....................     		i2c_start(PH_LIGHT); 
0B38:  BTSS.B  208.3
0B3A:  BRA     B44
0B3C:  BSET.B  206.1
0B3E:  BTSC.B  206.1
0B40:  BRA     B3E
0B42:  BRA     B4A
0B44:  BSET.B  206.0
0B46:  BTSC.B  206.0
0B48:  BRA     B46
.................... 			i2c_write(PH_LIGHT,0x53);  //Move the address number left on and add a one to make is a read command. 
0B4A:  MOV.B   #53,W1L
0B4C:  CALL    3F4
.................... 			colorlow = i2c_read(PH_LIGHT,0);   // read the low byte 
0B50:  MOV     #0,W1
0B52:  MOV     W1,[W15++]
0B54:  MOV     [--W15],W1
0B56:  CALL    AD0
0B5A:  MOV.B   W0L,AA6
0B5C:  CLR.B   AA7
.................... 			i2c_stop(PH_LIGHT); 
0B5E:  MOV     #1F,W0
0B60:  AND     206,W0
0B62:  BRA     NZ,B5E
0B64:  BSET.B  206.2
0B66:  BTSC.B  206.2
0B68:  BRA     B66
....................  
.................... 			i2c_start(PH_LIGHT); 
0B6A:  BTSS.B  208.3
0B6C:  BRA     B76
0B6E:  BSET.B  206.1
0B70:  BTSC.B  206.1
0B72:  BRA     B70
0B74:  BRA     B7C
0B76:  BSET.B  206.0
0B78:  BTSC.B  206.0
0B7A:  BRA     B78
.................... 			i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0B7C:  MOV.B   #52,W1L
0B7E:  CALL    3F4
.................... 			i2c_write(PH_LIGHT,0x99);  //Send the command for reading the high byte 
0B82:  MOV.B   #99,W1L
0B84:  CALL    3F4
.................... 			i2c_stop(PH_LIGHT); 
0B88:  MOV     #1F,W0
0B8A:  AND     206,W0
0B8C:  BRA     NZ,B88
0B8E:  BSET.B  206.2
0B90:  BTSC.B  206.2
0B92:  BRA     B90
....................  
....................     		i2c_start(PH_LIGHT); 
0B94:  BTSS.B  208.3
0B96:  BRA     BA0
0B98:  BSET.B  206.1
0B9A:  BTSC.B  206.1
0B9C:  BRA     B9A
0B9E:  BRA     BA6
0BA0:  BSET.B  206.0
0BA2:  BTSC.B  206.0
0BA4:  BRA     BA2
.................... 			i2c_write(PH_LIGHT,0x53);  //Move the address number left on and add a one to make is a read command. 
0BA6:  MOV.B   #53,W1L
0BA8:  CALL    3F4
.................... 			colorhigh = i2c_read(PH_LIGHT,0);  // read the high byte 
0BAC:  MOV     #0,W1
0BAE:  MOV     W1,[W15++]
0BB0:  MOV     [--W15],W1
0BB2:  CALL    AD0
0BB6:  MOV.B   W0L,AA8
0BB8:  CLR.B   AA9
.................... 			i2c_stop(PH_LIGHT); 
0BBA:  MOV     #1F,W0
0BBC:  AND     206,W0
0BBE:  BRA     NZ,BBA
0BC0:  BSET.B  206.2
0BC2:  BTSC.B  206.2
0BC4:  BRA     BC2
.................... 			break; 
0BC6:  BRA     DF8
....................  
....................  
.................... 		case 1:   //red 
.................... 			i2c_start(PH_LIGHT); 
0BC8:  BTSS.B  208.3
0BCA:  BRA     BD4
0BCC:  BSET.B  206.1
0BCE:  BTSC.B  206.1
0BD0:  BRA     BCE
0BD2:  BRA     BDA
0BD4:  BSET.B  206.0
0BD6:  BTSC.B  206.0
0BD8:  BRA     BD6
.................... 			i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0BDA:  MOV.B   #52,W1L
0BDC:  CALL    3F4
.................... 			i2c_write(PH_LIGHT,0x96);  //Send the command for reading the version 
0BE0:  MOV.B   #96,W1L
0BE2:  CALL    3F4
.................... 			i2c_stop(PH_LIGHT); 
0BE6:  MOV     #1F,W0
0BE8:  AND     206,W0
0BEA:  BRA     NZ,BE6
0BEC:  BSET.B  206.2
0BEE:  BTSC.B  206.2
0BF0:  BRA     BEE
....................  
....................     		i2c_start(PH_LIGHT); 
0BF2:  BTSS.B  208.3
0BF4:  BRA     BFE
0BF6:  BSET.B  206.1
0BF8:  BTSC.B  206.1
0BFA:  BRA     BF8
0BFC:  BRA     C04
0BFE:  BSET.B  206.0
0C00:  BTSC.B  206.0
0C02:  BRA     C00
.................... 			i2c_write(PH_LIGHT,0x53);  //Move the address number left on and add a one to make is a read command. 
0C04:  MOV.B   #53,W1L
0C06:  CALL    3F4
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
0C0A:  MOV     #0,W1
0C0C:  MOV     W1,[W15++]
0C0E:  MOV     [--W15],W1
0C10:  CALL    AD0
0C14:  MOV.B   W0L,AA6
0C16:  CLR.B   AA7
.................... 			i2c_stop(PH_LIGHT); 
0C18:  MOV     #1F,W0
0C1A:  AND     206,W0
0C1C:  BRA     NZ,C18
0C1E:  BSET.B  206.2
0C20:  BTSC.B  206.2
0C22:  BRA     C20
....................  
.................... 			i2c_start(PH_LIGHT); 
0C24:  BTSS.B  208.3
0C26:  BRA     C30
0C28:  BSET.B  206.1
0C2A:  BTSC.B  206.1
0C2C:  BRA     C2A
0C2E:  BRA     C36
0C30:  BSET.B  206.0
0C32:  BTSC.B  206.0
0C34:  BRA     C32
.................... 			i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0C36:  MOV.B   #52,W1L
0C38:  CALL    3F4
.................... 			i2c_write(PH_LIGHT,0x97);  //Send the command for reading the version 
0C3C:  MOV.B   #97,W1L
0C3E:  CALL    3F4
.................... 			i2c_stop(PH_LIGHT); 
0C42:  MOV     #1F,W0
0C44:  AND     206,W0
0C46:  BRA     NZ,C42
0C48:  BSET.B  206.2
0C4A:  BTSC.B  206.2
0C4C:  BRA     C4A
....................  
....................     		i2c_start(PH_LIGHT); 
0C4E:  BTSS.B  208.3
0C50:  BRA     C5A
0C52:  BSET.B  206.1
0C54:  BTSC.B  206.1
0C56:  BRA     C54
0C58:  BRA     C60
0C5A:  BSET.B  206.0
0C5C:  BTSC.B  206.0
0C5E:  BRA     C5C
.................... 			i2c_write(PH_LIGHT,0x53);  //Move the address number left on and add a one to make is a read command. 
0C60:  MOV.B   #53,W1L
0C62:  CALL    3F4
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
0C66:  MOV     #0,W1
0C68:  MOV     W1,[W15++]
0C6A:  MOV     [--W15],W1
0C6C:  CALL    AD0
0C70:  MOV.B   W0L,AA8
0C72:  CLR.B   AA9
.................... 			i2c_stop(PH_LIGHT); 
0C74:  MOV     #1F,W0
0C76:  AND     206,W0
0C78:  BRA     NZ,C74
0C7A:  BSET.B  206.2
0C7C:  BTSC.B  206.2
0C7E:  BRA     C7C
.................... 			break; 
0C80:  BRA     DF8
....................  
.................... 		case 3:   //blue 
.................... 			i2c_start(PH_LIGHT); 
0C82:  BTSS.B  208.3
0C84:  BRA     C8E
0C86:  BSET.B  206.1
0C88:  BTSC.B  206.1
0C8A:  BRA     C88
0C8C:  BRA     C94
0C8E:  BSET.B  206.0
0C90:  BTSC.B  206.0
0C92:  BRA     C90
.................... 			i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0C94:  MOV.B   #52,W1L
0C96:  CALL    3F4
.................... 			i2c_write(PH_LIGHT,0x9A);  //Send the command for reading the version 
0C9A:  MOV.B   #9A,W1L
0C9C:  CALL    3F4
.................... 			i2c_stop(PH_LIGHT); 
0CA0:  MOV     #1F,W0
0CA2:  AND     206,W0
0CA4:  BRA     NZ,CA0
0CA6:  BSET.B  206.2
0CA8:  BTSC.B  206.2
0CAA:  BRA     CA8
....................  
....................     		i2c_start(PH_LIGHT); 
0CAC:  BTSS.B  208.3
0CAE:  BRA     CB8
0CB0:  BSET.B  206.1
0CB2:  BTSC.B  206.1
0CB4:  BRA     CB2
0CB6:  BRA     CBE
0CB8:  BSET.B  206.0
0CBA:  BTSC.B  206.0
0CBC:  BRA     CBA
.................... 			i2c_write(PH_LIGHT,0x53);  //Move the address number left on and add a one to make is a read command. 
0CBE:  MOV.B   #53,W1L
0CC0:  CALL    3F4
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
0CC4:  MOV     #0,W1
0CC6:  MOV     W1,[W15++]
0CC8:  MOV     [--W15],W1
0CCA:  CALL    AD0
0CCE:  MOV.B   W0L,AA6
0CD0:  CLR.B   AA7
.................... 			i2c_stop(PH_LIGHT); 
0CD2:  MOV     #1F,W0
0CD4:  AND     206,W0
0CD6:  BRA     NZ,CD2
0CD8:  BSET.B  206.2
0CDA:  BTSC.B  206.2
0CDC:  BRA     CDA
....................  
.................... 			i2c_start(PH_LIGHT); 
0CDE:  BTSS.B  208.3
0CE0:  BRA     CEA
0CE2:  BSET.B  206.1
0CE4:  BTSC.B  206.1
0CE6:  BRA     CE4
0CE8:  BRA     CF0
0CEA:  BSET.B  206.0
0CEC:  BTSC.B  206.0
0CEE:  BRA     CEC
.................... 			i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0CF0:  MOV.B   #52,W1L
0CF2:  CALL    3F4
.................... 			i2c_write(PH_LIGHT,0x9B);  //Send the command for reading the version 
0CF6:  MOV.B   #9B,W1L
0CF8:  CALL    3F4
.................... 			i2c_stop(PH_LIGHT); 
0CFC:  MOV     #1F,W0
0CFE:  AND     206,W0
0D00:  BRA     NZ,CFC
0D02:  BSET.B  206.2
0D04:  BTSC.B  206.2
0D06:  BRA     D04
....................  
....................     		i2c_start(PH_LIGHT); 
0D08:  BTSS.B  208.3
0D0A:  BRA     D14
0D0C:  BSET.B  206.1
0D0E:  BTSC.B  206.1
0D10:  BRA     D0E
0D12:  BRA     D1A
0D14:  BSET.B  206.0
0D16:  BTSC.B  206.0
0D18:  BRA     D16
.................... 			i2c_write(PH_LIGHT,0x53);  //Move the address number left on and add a one to make is a read command. 
0D1A:  MOV.B   #53,W1L
0D1C:  CALL    3F4
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
0D20:  MOV     #0,W1
0D22:  MOV     W1,[W15++]
0D24:  MOV     [--W15],W1
0D26:  CALL    AD0
0D2A:  MOV.B   W0L,AA8
0D2C:  CLR.B   AA9
.................... 			i2c_stop(PH_LIGHT); 
0D2E:  MOV     #1F,W0
0D30:  AND     206,W0
0D32:  BRA     NZ,D2E
0D34:  BSET.B  206.2
0D36:  BTSC.B  206.2
0D38:  BRA     D36
.................... 			break; 
0D3A:  BRA     DF8
....................  
.................... 		case 4:   //clear 
.................... 			i2c_start(PH_LIGHT); 
0D3C:  BTSS.B  208.3
0D3E:  BRA     D48
0D40:  BSET.B  206.1
0D42:  BTSC.B  206.1
0D44:  BRA     D42
0D46:  BRA     D4E
0D48:  BSET.B  206.0
0D4A:  BTSC.B  206.0
0D4C:  BRA     D4A
.................... 			i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0D4E:  MOV.B   #52,W1L
0D50:  CALL    3F4
.................... 			i2c_write(PH_LIGHT,0x94);  //Send the command for reading the version 
0D54:  MOV.B   #94,W1L
0D56:  CALL    3F4
.................... 			i2c_stop(PH_LIGHT); 
0D5A:  MOV     #1F,W0
0D5C:  AND     206,W0
0D5E:  BRA     NZ,D5A
0D60:  BSET.B  206.2
0D62:  BTSC.B  206.2
0D64:  BRA     D62
....................  
....................     		i2c_start(PH_LIGHT); 
0D66:  BTSS.B  208.3
0D68:  BRA     D72
0D6A:  BSET.B  206.1
0D6C:  BTSC.B  206.1
0D6E:  BRA     D6C
0D70:  BRA     D78
0D72:  BSET.B  206.0
0D74:  BTSC.B  206.0
0D76:  BRA     D74
.................... 			i2c_write(PH_LIGHT,0x53);  //Move the address number left on and add a one to make is a read command. 
0D78:  MOV.B   #53,W1L
0D7A:  CALL    3F4
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
0D7E:  MOV     #0,W1
0D80:  MOV     W1,[W15++]
0D82:  MOV     [--W15],W1
0D84:  CALL    AD0
0D88:  MOV.B   W0L,AA6
0D8A:  CLR.B   AA7
.................... 			i2c_stop(PH_LIGHT); 
0D8C:  MOV     #1F,W0
0D8E:  AND     206,W0
0D90:  BRA     NZ,D8C
0D92:  BSET.B  206.2
0D94:  BTSC.B  206.2
0D96:  BRA     D94
....................  
.................... 			i2c_start(PH_LIGHT); 
0D98:  BTSS.B  208.3
0D9A:  BRA     DA4
0D9C:  BSET.B  206.1
0D9E:  BTSC.B  206.1
0DA0:  BRA     D9E
0DA2:  BRA     DAA
0DA4:  BSET.B  206.0
0DA6:  BTSC.B  206.0
0DA8:  BRA     DA6
.................... 			i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0DAA:  MOV.B   #52,W1L
0DAC:  CALL    3F4
.................... 			i2c_write(PH_LIGHT,0x95);  //Send the command for reading the version 
0DB0:  MOV.B   #95,W1L
0DB2:  CALL    3F4
.................... 			i2c_stop(PH_LIGHT); 
0DB6:  MOV     #1F,W0
0DB8:  AND     206,W0
0DBA:  BRA     NZ,DB6
0DBC:  BSET.B  206.2
0DBE:  BTSC.B  206.2
0DC0:  BRA     DBE
....................  
....................     		i2c_start(PH_LIGHT); 
0DC2:  BTSS.B  208.3
0DC4:  BRA     DCE
0DC6:  BSET.B  206.1
0DC8:  BTSC.B  206.1
0DCA:  BRA     DC8
0DCC:  BRA     DD4
0DCE:  BSET.B  206.0
0DD0:  BTSC.B  206.0
0DD2:  BRA     DD0
.................... 			i2c_write(PH_LIGHT,0x53);  //Move the address number left on and add a one to make is a read command. 
0DD4:  MOV.B   #53,W1L
0DD6:  CALL    3F4
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
0DDA:  MOV     #0,W1
0DDC:  MOV     W1,[W15++]
0DDE:  MOV     [--W15],W1
0DE0:  CALL    AD0
0DE4:  MOV.B   W0L,AA8
0DE6:  CLR.B   AA9
.................... 			i2c_stop(PH_LIGHT); 
0DE8:  MOV     #1F,W0
0DEA:  AND     206,W0
0DEC:  BRA     NZ,DE8
0DEE:  BSET.B  206.2
0DF0:  BTSC.B  206.2
0DF2:  BRA     DF0
.................... 			break; 
0DF4:  BRA     DF8
....................  
.................... 		default:	 
.................... 			break; 
0DF6:  BRA     DF8
.................... 	} 
0DF8:  RETURN  
....................  
.................... } 
....................  
....................  
.................... //********************************************************************** 
.................... // Created March 19, 2013 
.................... // Power up light chip 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the room 
.................... //  Updated December 8, 2015 
.................... //  StartupATOS is used for all six sensors.  The number of the sensor needs to be provided. 
.................... //********************************************************************** 
.................... void StartUpTAOS(int lightsensor) 
.................... 	{ 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
*
040C:  PUSH    D84
040E:  POP     E88
0410:  CALL    3B0
.................... // then send the command down to the sensor.  All of the communication is done through the I2C on PH_LIGHT. 
.................... 	i2c_start(PH_LIGHT); 
0414:  BTSS.B  208.3
0416:  BRA     420
0418:  BSET.B  206.1
041A:  BTSC.B  206.1
041C:  BRA     41A
041E:  BRA     426
0420:  BSET.B  206.0
0422:  BTSC.B  206.0
0424:  BRA     422
.................... 	i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0426:  MOV.B   #52,W1L
0428:  CALL    3F4
.................... 	i2c_write(PH_LIGHT,0x80);  //Send the command for reading the version  
042C:  MOV.B   #80,W1L
042E:  CALL    3F4
....................     //  0x01 turns on chip 
....................     //  0x03 turns on and starts taking a reading 
....................      
.................... 	i2c_write(PH_LIGHT,0x01);  //Send the command for turning on the chip only   
0432:  MOV.B   #1,W1L
0434:  CALL    3F4
.................... 	i2c_stop(PH_LIGHT); 
0438:  MOV     #1F,W0
043A:  AND     206,W0
043C:  BRA     NZ,438
043E:  BSET.B  206.2
0440:  BTSC.B  206.2
0442:  BRA     440
....................      
....................     delay_ms(3); 
0444:  REPEAT  #3B7E
0446:  NOP     
0448:  REPEAT  #3FFF
044A:  NOP     
044C:  REPEAT  #3FFF
044E:  NOP     
....................     // WLONG configuration.  0x00 is off 
....................     //                       0x02 is on 
....................     i2c_start(PH_LIGHT); 
0450:  BTSS.B  208.3
0452:  BRA     45C
0454:  BSET.B  206.1
0456:  BTSC.B  206.1
0458:  BRA     456
045A:  BRA     462
045C:  BSET.B  206.0
045E:  BTSC.B  206.0
0460:  BRA     45E
.................... 	i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0462:  MOV.B   #52,W1L
0464:  CALL    3F4
.................... 	i2c_write(PH_LIGHT,0x8D);  //Send the command for reading the version  
0468:  MOV.B   #8D,W1L
046A:  CALL    3F4
....................     //  0x01 turns on chip 
....................     //  0x03 turns on and starts taking a reading 
....................      
.................... 	i2c_write(PH_LIGHT,0x00);  //Send the command for turning on the chip only   
046E:  CLR.B   W1
0470:  CALL    3F4
.................... 	i2c_stop(PH_LIGHT); 
0474:  MOV     #1F,W0
0476:  AND     206,W0
0478:  BRA     NZ,474
047A:  BSET.B  206.2
047C:  BTSC.B  206.2
047E:  BRA     47C
0480:  RETURN  
....................     
....................      
....................      
.................... 	} 
....................  
....................  
....................  
.................... //******************************************************************** 
.................... // Created March 17, 2013 
.................... // This routine changes the gain/scaling routine for each color/ADC. 
.................... // The passed varaible is the gain for the ADC.  All colors get the same gain. 
.................... //  AnalogGain is a value between 0 to 3.   
.................... //  0 is 1X 
.................... //  1 is 4X 
.................... //  2 is 16X 
.................... //  3 is 64X 
.................... //Prescaler are values between 0 and 6.  0 is div by 1; 6 is divide by 64. 
.................... // Added Oct 20, 2014 
.................... //  The lightsensor is added to select which sensor we want to use 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the ROOM 
.................... //******************************************************************** 
.................... void setTAOSGain(int lightsensor) 
.................... 	{ 
.................... byte controlword,Integrationtime,again; 
....................  
.................... float tempowrd; 
....................  
.................... Integrationtime = 0;   // set it to this value if nothing else takes it. 
*
09D8:  CLR.B   E7F
....................  
....................  
.................... if (lightsensor==3)   // changed March 23, 2016.  The passing number is the true sensor number, not the index   Used to be 1 
09DA:  MOV     E82,W4
09DC:  CP      W4,#3
09DE:  BRA     NZ,9E8
.................... 	{ 
....................     Integrationtime = 100; 
09E0:  MOV.B   #64,W0L
09E2:  MOV.B   W0L,E7F
....................     again = 0x03; 
09E4:  MOV.B   #3,W0L
09E6:  MOV.B   W0L,E80
.................... 	//PrescalerGain = ExposurescaleDO; 
.................... 	} 
....................  
.................... if (lightsensor==1)  // changed March 23, 2016.  The passing number is the true sensor number, not the index   Used to be 2 
09E8:  MOV     E82,W4
09EA:  CP      W4,#1
09EC:  BRA     NZ,9F6
.................... 	{ 
.................... 	//PrescalerGain = ExposurescalepH; 
....................     Integrationtime = 100; 
09EE:  MOV.B   #64,W0L
09F0:  MOV.B   W0L,E7F
....................     again = 0x03; 
09F2:  MOV.B   #3,W0L
09F4:  MOV.B   W0L,E80
.................... 	} 
....................  
.................... if (lightsensor==0)   // This is now for NH4 
09F6:  CP0     E82
09F8:  BRA     NZ,A02
.................... 	{ 
....................     //PrescalerGain = ExposurescaleLight; 
.................... 	Integrationtime = 100; 
09FA:  MOV.B   #64,W0L
09FC:  MOV.B   W0L,E7F
....................     again = 0x03; 
09FE:  MOV.B   #3,W0L
0A00:  MOV.B   W0L,E80
.................... 	} 
....................  
....................  
.................... // Concatinate the control byte. 
.................... //controlword = AnalogGain*16 + PrescalerGain;  //This is the offset for gain to placeinto the chip.  Added March 4, 2015 
.................... // Calculate the integtation time 
.................... tempowrd = (float) Integrationtime; 
0A02:  MOV.B   E7F,W0L
0A04:  CLR.B   1
0A06:  CALL    8D4
0A0A:  MOV     W0,E84
0A0C:  MOV     W1,E86
.................... tempowrd = tempowrd / 2.4; 
0A0E:  MOV     E84,W0
0A10:  MOV     E86,W1
0A12:  MOV     #999A,W2
0A14:  MOV     #4019,W3
0A16:  CALL    90E
0A1A:  MOV     W0,E84
0A1C:  MOV     W1,E86
.................... Integrationtime = (byte) tempowrd; 
0A1E:  MOV     E84,W0
0A20:  MOV     E86,W1
0A22:  CALL    54C
0A26:  MOV.B   W0L,E7F
.................... controlword = 256 - Integrationtime; 
0A28:  MOV     #0,W4
0A2A:  MOV     E7E,W3
0A2C:  LSR     W3,#8,W3
0A2E:  SUB.B   W4L,W3L,W0L
0A30:  MOV.B   W0L,E7E
....................  
....................  
.................... selectsensor(lightsensor);   // make the selection to talk with this sensor. 
0A32:  PUSH    E82
0A34:  POP     E88
0A36:  CALL    3B0
....................  
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
.................... // Added April 26, 2017 
.................... // Update intigration time 
.................... 	i2c_start(PH_LIGHT); 
0A3A:  BTSS.B  208.3
0A3C:  BRA     A46
0A3E:  BSET.B  206.1
0A40:  BTSC.B  206.1
0A42:  BRA     A40
0A44:  BRA     A4C
0A46:  BSET.B  206.0
0A48:  BTSC.B  206.0
0A4A:  BRA     A48
.................... 	i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0A4C:  MOV.B   #52,W1L
0A4E:  CALL    3F4
.................... 	i2c_write(PH_LIGHT,0x81);  //The 0x80 is used to tell it's a command.  This is for register 0x07. 
0A52:  MOV.B   #81,W1L
0A54:  CALL    3F4
.................... 	i2c_write(PH_LIGHT,controlword);  //Move the address number left on and add a zero. 
0A58:  MOV.B   E7E,W0L
0A5A:  MOV.B   W0L,2
0A5C:  CALL    3F4
.................... 	i2c_stop(PH_LIGHT); 
0A60:  MOV     #1F,W0
0A62:  AND     206,W0
0A64:  BRA     NZ,A60
0A66:  BSET.B  206.2
0A68:  BTSC.B  206.2
0A6A:  BRA     A68
.................... 	 
....................      
....................     // Added April 26, 2017 
....................     // Update the wait/delay time 
....................      
....................   	i2c_start(PH_LIGHT); 
0A6C:  BTSS.B  208.3
0A6E:  BRA     A78
0A70:  BSET.B  206.1
0A72:  BTSC.B  206.1
0A74:  BRA     A72
0A76:  BRA     A7E
0A78:  BSET.B  206.0
0A7A:  BTSC.B  206.0
0A7C:  BRA     A7A
.................... 	i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0A7E:  MOV.B   #52,W1L
0A80:  CALL    3F4
.................... 	i2c_write(PH_LIGHT,0x83);  //The 0x80 is used to tell it's a command.  This is for register 0x07. 
0A84:  MOV.B   #83,W1L
0A86:  CALL    3F4
.................... 	i2c_write(PH_LIGHT,0xff);  //Move the address number left on and add a zero. 
0A8A:  SETM.B  W1
0A8C:  CALL    3F4
.................... 	i2c_stop(PH_LIGHT);   
0A90:  MOV     #1F,W0
0A92:  AND     206,W0
0A94:  BRA     NZ,A90
0A96:  BSET.B  206.2
0A98:  BTSC.B  206.2
0A9A:  BRA     A98
....................      
....................      
....................      
....................     // Added April 26, 2017 
....................     // Updates the again 
....................      
....................   	i2c_start(PH_LIGHT); 
0A9C:  BTSS.B  208.3
0A9E:  BRA     AA8
0AA0:  BSET.B  206.1
0AA2:  BTSC.B  206.1
0AA4:  BRA     AA2
0AA6:  BRA     AAE
0AA8:  BSET.B  206.0
0AAA:  BTSC.B  206.0
0AAC:  BRA     AAA
.................... 	i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0AAE:  MOV.B   #52,W1L
0AB0:  CALL    3F4
.................... 	i2c_write(PH_LIGHT,0x8F);  //The 0x80 is used to tell it's a command.  This is for register 0x07. 
0AB4:  MOV.B   #8F,W1L
0AB6:  CALL    3F4
.................... 	i2c_write(PH_LIGHT,again);  //Move the address number left on and add a zero. 
0ABA:  MOV.B   E80,W0L
0ABC:  MOV.B   W0L,2
0ABE:  CALL    3F4
.................... 	i2c_stop(PH_LIGHT);   
0AC2:  MOV     #1F,W0
0AC4:  AND     206,W0
0AC6:  BRA     NZ,AC2
0AC8:  BSET.B  206.2
0ACA:  BTSC.B  206.2
0ACC:  BRA     ACA
0ACE:  RETURN  
....................      
....................       
....................      
.................... 	} 
....................  
.................... //****************************************************************************************** 
.................... // Created April 26, 2014 
.................... // This routine finds the color light for any of four spectrum devices.  The inputs for GainIn are as follows: 
.................... //  4:  Determine the gain for what ND to use where all of the colors are not saturated. 
.................... //  0 is 1X 
.................... //  1 is 4X 
.................... //  2 is 16X 
.................... //  3 is 64X 
.................... //  These are the same numbers used by the chip 
.................... //  The returned result of the function is always the gain used.  For instance if a predetemined gain is used, that gain 
.................... // is returned.  If the automatic gain is used, the detemine gain is returned, not the number 4. 
.................... //  All colors are returned as global varaibles for other routines to use. 
.................... // ********************* 
.................... // The inputs for the chip select is as follows: 
.................... // 0: Number 1 
.................... // 1: Number 2 
.................... // 2: Number 3 
.................... // 3: Number 4  - this number does not exist on the Osmobot as is because thing is connected to it. 
.................... // The colors are returned in the global variables as follows: 
.................... // green, red, blue and clear 
.................... //  When a device is not selected correctly, the number 0xFF is returned as an error on the I2C. 
.................... //****************************************************************************************** 
....................  
.................... int8 GetCurrentColor(int8 GainIn, int8 DeviceSelect) 
*
0E2A:  MOV     W5,[W15++]
0E2C:  MOV     W6,[W15++]
.................... 	{ 
....................  
.................... //  Set the device to be processed 
....................     int x,returned; 
....................      
.................... unsigned int gainMultiplyer; 
....................  
.................... 		setTAOSGain(DeviceSelect); //Gain and then scale 
0E2E:  MOV.B   E77,W0L
0E30:  MOV.B   W0L,W4L
0E32:  SE      W4,W3
0E34:  MOV     W3,E82
0E36:  CALL    9D8
....................  
....................         // created April 26, 2017 
....................         // this new sections starts itegration and waits for the chip to be ready for reading. 
....................     i2c_start(PH_LIGHT); 
0E3A:  BTSS.B  208.3
0E3C:  BRA     E46
0E3E:  BSET.B  206.1
0E40:  BTSC.B  206.1
0E42:  BRA     E40
0E44:  BRA     E4C
0E46:  BSET.B  206.0
0E48:  BTSC.B  206.0
0E4A:  BRA     E48
.................... 	i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0E4C:  MOV.B   #52,W1L
0E4E:  CALL    3F4
.................... 	i2c_write(PH_LIGHT,0x80);  //Send the command for reading the version 
0E52:  MOV.B   #80,W1L
0E54:  CALL    3F4
....................      
....................     //  0x01 turns on chip 
....................     //  0x03 turns on and starts taking a reading 
....................      
.................... 	i2c_write(PH_LIGHT,0x03);  //Send the command for turning on the chip only and starts integration   
0E58:  MOV.B   #3,W1L
0E5A:  CALL    3F4
.................... 	i2c_stop(PH_LIGHT); 
0E5E:  MOV     #1F,W0
0E60:  AND     206,W0
0E62:  BRA     NZ,E5E
0E64:  BSET.B  206.2
0E66:  BTSC.B  206.2
0E68:  BRA     E66
....................     delay_ms(10); 
0E6A:  MOV     #A,W0
0E6C:  CALL    356
....................     // loop until reading AVALID 
....................     for (x=0; x < 1000; x++) 
0E70:  CLR     E78
0E72:  MOV     E78,W4
0E74:  MOV     #3E8,W3
0E76:  CP      W3,W4
0E78:  BRA     LE,EE2
....................     { 
....................         // exit loop when the AVAILD is high 
.................... 	i2c_start(PH_LIGHT); 
0E7A:  BTSS.B  208.3
0E7C:  BRA     E86
0E7E:  BSET.B  206.1
0E80:  BTSC.B  206.1
0E82:  BRA     E80
0E84:  BRA     E8C
0E86:  BSET.B  206.0
0E88:  BTSC.B  206.0
0E8A:  BRA     E88
.................... 	i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0E8C:  MOV.B   #52,W1L
0E8E:  CALL    3F4
.................... 	i2c_write(PH_LIGHT,0x93);  //Send the command for reading the version 
0E92:  MOV.B   #93,W1L
0E94:  CALL    3F4
.................... 	i2c_stop(PH_LIGHT); 
0E98:  MOV     #1F,W0
0E9A:  AND     206,W0
0E9C:  BRA     NZ,E98
0E9E:  BSET.B  206.2
0EA0:  BTSC.B  206.2
0EA2:  BRA     EA0
....................     i2c_start(PH_LIGHT); 
0EA4:  BTSS.B  208.3
0EA6:  BRA     EB0
0EA8:  BSET.B  206.1
0EAA:  BTSC.B  206.1
0EAC:  BRA     EAA
0EAE:  BRA     EB6
0EB0:  BSET.B  206.0
0EB2:  BTSC.B  206.0
0EB4:  BRA     EB2
.................... 	i2c_write(PH_LIGHT,0x53);  //Move the address number left on and add a one to make is a read command. 
0EB6:  MOV.B   #53,W1L
0EB8:  CALL    3F4
.................... 	returned = i2c_read(PH_LIGHT,0); 
0EBC:  MOV     #0,W1
0EBE:  MOV     W1,[W15++]
0EC0:  MOV     [--W15],W1
0EC2:  CALL    AD0
0EC6:  MOV.B   W0L,E7A
0EC8:  CLR.B   E7B
.................... 	i2c_stop(PH_LIGHT); 
0ECA:  MOV     #1F,W0
0ECC:  AND     206,W0
0ECE:  BRA     NZ,ECA
0ED0:  BSET.B  206.2
0ED2:  BTSC.B  206.2
0ED4:  BRA     ED2
....................      
....................   //  delay_ms(150); 
....................     if (returned == 0x11) 
0ED6:  MOV     E7A,W4
0ED8:  CP      W4,#11
0EDA:  BRA     NZ,EDE
....................         break; 
0EDC:  BRA     EE2
0EDE:  INC     0E78
0EE0:  BRA     E72
....................  //    return(returned);   
....................     } 
....................      
....................   
....................     if (x > 990) 
0EE2:  MOV     E78,W4
0EE4:  MOV     #3DE,W3
0EE6:  CP      W3,W4
0EE8:  BRA     GE,EEE
....................         return(0xFF);   // if the loop fails, then return 0xFF for showing the device does not work.  It does not hang up. 
0EEA:  SETM.B  0
0EEC:  BRA     102E
....................          
....................      
....................     // Turn off intigration 
....................     i2c_start(PH_LIGHT); 
0EEE:  BTSS.B  208.3
0EF0:  BRA     EFA
0EF2:  BSET.B  206.1
0EF4:  BTSC.B  206.1
0EF6:  BRA     EF4
0EF8:  BRA     F00
0EFA:  BSET.B  206.0
0EFC:  BTSC.B  206.0
0EFE:  BRA     EFC
.................... 	i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
0F00:  MOV.B   #52,W1L
0F02:  CALL    3F4
.................... 	i2c_write(PH_LIGHT,0x80);  //Send the command for reading the version 
0F06:  MOV.B   #80,W1L
0F08:  CALL    3F4
....................      
....................     //  0x01 turns on chip 
....................     //  0x03 turns on and starts taking a reading 
....................      
.................... 	i2c_write(PH_LIGHT,0x01);  //Send the command for turning off the chip only   
0F0C:  MOV.B   #1,W1L
0F0E:  CALL    3F4
.................... 	i2c_stop(PH_LIGHT); 
0F12:  MOV     #1F,W0
0F14:  AND     206,W0
0F16:  BRA     NZ,F12
0F18:  BSET.B  206.2
0F1A:  BTSC.B  206.2
0F1C:  BRA     F1A
....................     delay_ms(3); 
0F1E:  REPEAT  #3B7E
0F20:  NOP     
0F22:  REPEAT  #3FFF
0F24:  NOP     
0F26:  REPEAT  #3FFF
0F28:  NOP     
....................      
....................      
....................      
.................... 		ReadColorTAOS(2,DeviceSelect);  //green 
0F2A:  MOV.B   E77,W0L
0F2C:  MOV.B   W0L,W4L
0F2E:  SE      W4,W3
0F30:  MOV     W3,E80
0F32:  MOV     #2,W3
0F34:  MOV     W3,E7E
0F36:  CALL    AFA
....................  
.................... 		green = colorlow + colorhigh * 256; 
0F3A:  MOV     AA8,W4
0F3C:  MOV     #100,W3
0F3E:  MUL.SS  W4,W3,W0
0F40:  MOV     AA6,W4
0F42:  ADD     W0,W4,W0
0F44:  MOV     W0,AAC
....................  
.................... 		ReadColorTAOS(1,DeviceSelect);  //red 
0F46:  MOV.B   E77,W0L
0F48:  MOV.B   W0L,W4L
0F4A:  SE      W4,W3
0F4C:  MOV     W3,E80
0F4E:  MOV     #1,W3
0F50:  MOV     W3,E7E
0F52:  CALL    AFA
.................... 		red = colorlow + colorhigh * 256; 
0F56:  MOV     AA8,W4
0F58:  MOV     #100,W3
0F5A:  MUL.SS  W4,W3,W0
0F5C:  MOV     AA6,W4
0F5E:  ADD     W0,W4,W0
0F60:  MOV     W0,AAA
....................  
.................... 		ReadColorTAOS(4,DeviceSelect);  //clear 
0F62:  MOV.B   E77,W0L
0F64:  MOV.B   W0L,W4L
0F66:  SE      W4,W3
0F68:  MOV     W3,E80
0F6A:  MOV     #4,W3
0F6C:  MOV     W3,E7E
0F6E:  CALL    AFA
.................... 		clear = colorlow + colorhigh * 256; 
0F72:  MOV     AA8,W4
0F74:  MOV     #100,W3
0F76:  MUL.SS  W4,W3,W0
0F78:  MOV     AA6,W4
0F7A:  ADD     W0,W4,W0
0F7C:  MOV     W0,AB0
....................  
.................... 		ReadColorTAOS(3,DeviceSelect);  //blue 
0F7E:  MOV.B   E77,W0L
0F80:  MOV.B   W0L,W4L
0F82:  SE      W4,W3
0F84:  MOV     W3,E80
0F86:  MOV     #3,W3
0F88:  MOV     W3,E7E
0F8A:  CALL    AFA
.................... 		blue = colorlow + colorhigh * 256; 
0F8E:  MOV     AA8,W4
0F90:  MOV     #100,W3
0F92:  MUL.SS  W4,W3,W0
0F94:  MOV     AA6,W4
0F96:  ADD     W0,W4,W0
0F98:  MOV     W0,AAE
....................  
.................... //***************************************************************** 
.................... // Created December 12, 2014 
.................... // This section changes each color to an ABS color using the gainIn scales 
.................... //***************************************************************** 
....................  
.................... 		if (GainIn == 0) 
0F9A:  MOV.B   E76,W0L
0F9C:  SE      W0,W0
0F9E:  CP0     W0
0FA0:  BRA     NZ,FA6
.................... 			{ 
.................... 			gainMultiplyer =  1; 
0FA2:  MOV     #1,W4
0FA4:  MOV     W4,E7C
.................... 			} 
.................... 		if (GainIn == 1) 
0FA6:  MOV.B   E76,W0L
0FA8:  SE      W0,W0
0FAA:  CP      W0,#1
0FAC:  BRA     NZ,FB2
.................... 			{ 
.................... 			gainMultiplyer =  4; 
0FAE:  MOV     #4,W4
0FB0:  MOV     W4,E7C
.................... 			} 
.................... 		if (GainIn == 2) 
0FB2:  MOV.B   E76,W0L
0FB4:  SE      W0,W0
0FB6:  CP      W0,#2
0FB8:  BRA     NZ,FBE
.................... 			{ 
.................... 			gainMultiplyer =  16; 
0FBA:  MOV     #10,W4
0FBC:  MOV     W4,E7C
.................... 			} 
.................... 		if (GainIn == 3) 
0FBE:  MOV.B   E76,W0L
0FC0:  SE      W0,W0
0FC2:  CP      W0,#3
0FC4:  BRA     NZ,FCA
.................... 			{ 
.................... 			gainMultiplyer =  64; 
0FC6:  MOV     #40,W4
0FC8:  MOV     W4,E7C
.................... 			} 
.................... 		redABS = (unsigned int32) red * (unsigned int32) gainMultiplyer; 
0FCA:  MOV     AAA,W5
0FCC:  MOV     #0,W6
0FCE:  MOV     E7C,W0
0FD0:  MOV     #0,W1
0FD2:  MOV     W0,W2
0FD4:  MOV     W1,W3
0FD6:  MOV     W5,W0
0FD8:  MOV     W6,W1
0FDA:  CALL    DFA
0FDE:  MOV     W0,B8C
0FE0:  MOV     W1,B8E
.................... 		greenABS = (unsigned int32) green * (unsigned int32) gainMultiplyer; 
0FE2:  MOV     AAC,W5
0FE4:  MOV     #0,W6
0FE6:  MOV     E7C,W0
0FE8:  MOV     #0,W1
0FEA:  MOV     W0,W2
0FEC:  MOV     W1,W3
0FEE:  MOV     W5,W0
0FF0:  MOV     W6,W1
0FF2:  CALL    DFA
0FF6:  MOV     W0,B94
0FF8:  MOV     W1,B96
.................... 		blueABS = (unsigned int32) blue * (unsigned int32) gainMultiplyer; 
0FFA:  MOV     AAE,W5
0FFC:  MOV     #0,W6
0FFE:  MOV     E7C,W0
1000:  MOV     #0,W1
1002:  MOV     W0,W2
1004:  MOV     W1,W3
1006:  MOV     W5,W0
1008:  MOV     W6,W1
100A:  CALL    DFA
100E:  MOV     W0,B90
1010:  MOV     W1,B92
.................... 		clearABS = (unsigned int32) clear * (unsigned int32) gainMultiplyer; 
1012:  MOV     AB0,W5
1014:  MOV     #0,W6
1016:  MOV     E7C,W0
1018:  MOV     #0,W1
101A:  MOV     W0,W2
101C:  MOV     W1,W3
101E:  MOV     W5,W0
1020:  MOV     W6,W1
1022:  CALL    DFA
1026:  MOV     W0,B98
1028:  MOV     W1,B9A
.................... 		return(GainIn); 
102A:  MOV.B   E76,W0L
102C:  MOV.B   W0L,0
102E:  MOV     [--W15],W6
1030:  MOV     [--W15],W5
1032:  RETURN  
....................  
.................... 		} 
....................  
.................... //******************************************************************************************* 
.................... // Created May 4, 2017 
.................... //  This takes several color readings and then averages them together.  This is a direct drop in 
.................... // for the current "int8 GetCurrentColor(int8 GainIn, int8 DeviceSelect)" 
.................... // Returns the gain and the returned value is in the global varaibles called 
.................... // red, green , blue and clear. 
.................... //  Changed May 18, 2015   
.................... // The below routine is changed from 20 samples to 200 to get the stability down 
.................... //******************************************************************************************* 
.................... void GetCurrentColorAVG(int8 GainIn, int8 DeviceSelect) 
*
1186:  MOV     W5,[W15++]
1188:  MOV     W6,[W15++]
118A:  MOV     W7,[W15++]
118C:  MOV     #C,W4
118E:  MOV     W4,DAC
.................... 	{ 
.................... float tempred, tempblue, tempgreen, tempclear, ageraging;   //These are the averaging varaibles used for internal to the averaging calculations 
.................... float ttred, ttgreen,ttblue,ttclear; 
.................... int x,GainOut,averagesamples = 12; 
.................... unsigned int gainMultiplyer; 
....................  
.................... //****************************************************************************** 
.................... // Created May 3, 2017 
.................... // Added an array of numbers for averaging.  The high and low is throuwn out 
.................... //****************************************************************************** 
.................... int32 arrayred[12]; 
.................... int32 arraygreen[12]; 
.................... int32 arrayblue[12]; 
.................... int32 arrayclear[12]; 
.................... int32 tempvar; 
.................... int done; 
....................  
.................... 	tempred = 0.0; 
1190:  CLR     D84
1192:  CLR     D86
.................... 	tempblue = 0.0; 
1194:  CLR     D88
1196:  CLR     D8A
.................... 	tempgreen = 0.0; 
1198:  CLR     D8C
119A:  CLR     D8E
.................... 	tempclear = 0.0; 
119C:  CLR     D90
119E:  CLR     D92
....................     ageraging = (float) averagesamples - 2.0; 
11A0:  MOV     DAC,W0
11A2:  CALL    6E0
11A6:  MOV     W0,W5
11A8:  MOV     W1,W6
11AA:  BSET.B  43.0
11AC:  MOV     W5,W0
11AE:  MOV     W6,W1
11B0:  MOV     #0,W2
11B2:  MOV     #4000,W3
11B4:  CALL    72A
11B8:  MOV     W0,D94
11BA:  MOV     W1,D96
....................     // Get the data and put it into an array 
.................... 	for (x = 0; x < averagesamples; x++) 
11BC:  CLR     DA8
11BE:  MOV     DA8,W0
11C0:  MOV     DAC,W4
11C2:  CP      W4,W0
11C4:  BRA     LE,1212
.................... 		{ 
.................... 		GainOut = GetCurrentColor(GainIn, DeviceSelect); 
11C6:  MOV.B   D82,W0L
11C8:  MOV.B   W0L,E76
11CA:  MOV.B   D83,W0L
11CC:  MOV.B   W0L,E77
11CE:  CALL    E2A
11D2:  SE      W0,W0
11D4:  MOV     W0,DAA
....................         arrayred[x] = redABS; 
11D6:  MOV     DA8,W4
11D8:  MUL.UU  W4,#4,W0
11DA:  MOV     #DB0,W4
11DC:  ADD     W0,W4,W5
11DE:  MOV     #B8C,W4
11E0:  MOV     [W4++],[W5++]
11E2:  MOV     [W4++],[W5++]
....................         arraygreen[x] = greenABS; 
11E4:  MOV     DA8,W4
11E6:  MUL.UU  W4,#4,W0
11E8:  MOV     #DE0,W4
11EA:  ADD     W0,W4,W5
11EC:  MOV     #B94,W4
11EE:  MOV     [W4++],[W5++]
11F0:  MOV     [W4++],[W5++]
....................         arrayblue[x] = blueABS; 
11F2:  MOV     DA8,W4
11F4:  MUL.UU  W4,#4,W0
11F6:  MOV     #E10,W4
11F8:  ADD     W0,W4,W5
11FA:  MOV     #B90,W4
11FC:  MOV     [W4++],[W5++]
11FE:  MOV     [W4++],[W5++]
....................         arrayClear[x] = clearABS; 
1200:  MOV     DA8,W4
1202:  MUL.UU  W4,#4,W0
1204:  MOV     #E40,W4
1206:  ADD     W0,W4,W5
1208:  MOV     #B98,W4
120A:  MOV     [W4++],[W5++]
120C:  MOV     [W4++],[W5++]
120E:  INC     0DA8
1210:  BRA     11BE
.................... 		} 
....................      
....................     // put the array in order 
....................      
....................     done=0;  // set the first flag to get out. 
1212:  CLR     E74
....................     while(!done) 
1214:  CP0     E74
1216:  BRA     NZ,1338
....................     { 
....................         done = 1; 
1218:  MOV     #1,W4
121A:  MOV     W4,E74
....................         for (x=0; x < 11; x++) 
121C:  CLR     DA8
121E:  MOV     DA8,W4
1220:  CP      W4,#B
1222:  BRA     GE,1336
....................         { 
....................            if  (arrayclear[x] > arrayclear[x+1]) 
1224:  MOV     DA8,W4
1226:  MUL.UU  W4,#4,W0
1228:  MOV     #E40,W4
122A:  ADD     W0,W4,W0
122C:  MOV     #A,W4
122E:  MOV     [W0++],[W4++]
1230:  MOV     [W0++],[W4++]
1232:  MOV     DA8,W4
1234:  ADD     W4,#1,W7
1236:  MOV     W7,W4
1238:  MUL.UU  W4,#4,W0
123A:  MOV     #E40,W4
123C:  ADD     W0,W4,W0
123E:  MOV     W0,W4
1240:  MOV     #0,W3
1242:  MOV     [W4++],[W3++]
1244:  MOV     [W4++],[W3++]
1246:  CP      W1,W6
1248:  BRA     GT,1332
124A:  BRA     LT,1250
124C:  CP      W0,W5
124E:  BRA     C,1332
....................            { 
....................               done = 0;  // go for another round  
1250:  CLR     E74
....................                tempvar = arrayclear[x]; 
1252:  MOV     DA8,W4
1254:  MUL.UU  W4,#4,W0
1256:  MOV     #E40,W4
1258:  ADD     W0,W4,W0
125A:  MOV     #E70,W4
125C:  MOV     [W0++],[W4++]
125E:  MOV     [W0++],[W4++]
....................                arrayclear[x] = arrayclear[x+1]; 
1260:  MOV     DA8,W4
1262:  MUL.UU  W4,#4,W0
1264:  MOV     #E40,W4
1266:  ADD     W0,W4,W5
1268:  MOV     DA8,W4
126A:  ADD     W4,#1,W6
126C:  MOV     W6,W4
126E:  MUL.UU  W4,#4,W0
1270:  MOV     #E40,W4
1272:  ADD     W0,W4,W0
1274:  MOV     [W0++],[W5++]
1276:  MOV     [W0++],[W5++]
....................                arrayclear[x+1] = tempvar; 
1278:  MOV     DA8,W4
127A:  ADD     W4,#1,W5
127C:  MOV     W5,W4
127E:  MUL.UU  W4,#4,W0
1280:  MOV     #E40,W4
1282:  ADD     W0,W4,W5
1284:  MOV     #E70,W4
1286:  MOV     [W4++],[W5++]
1288:  MOV     [W4++],[W5++]
....................                 
....................                tempvar = arrayred[x]; 
128A:  MOV     DA8,W4
128C:  MUL.UU  W4,#4,W0
128E:  MOV     #DB0,W4
1290:  ADD     W0,W4,W0
1292:  MOV     #E70,W4
1294:  MOV     [W0++],[W4++]
1296:  MOV     [W0++],[W4++]
....................                arrayred[x] = arrayred[x+1]; 
1298:  MOV     DA8,W4
129A:  MUL.UU  W4,#4,W0
129C:  MOV     #DB0,W4
129E:  ADD     W0,W4,W5
12A0:  MOV     DA8,W4
12A2:  ADD     W4,#1,W6
12A4:  MOV     W6,W4
12A6:  MUL.UU  W4,#4,W0
12A8:  MOV     #DB0,W4
12AA:  ADD     W0,W4,W0
12AC:  MOV     [W0++],[W5++]
12AE:  MOV     [W0++],[W5++]
....................                arrayred[x+1] = tempvar; 
12B0:  MOV     DA8,W4
12B2:  ADD     W4,#1,W5
12B4:  MOV     W5,W4
12B6:  MUL.UU  W4,#4,W0
12B8:  MOV     #DB0,W4
12BA:  ADD     W0,W4,W5
12BC:  MOV     #E70,W4
12BE:  MOV     [W4++],[W5++]
12C0:  MOV     [W4++],[W5++]
....................                 
....................                tempvar = arraygreen[x]; 
12C2:  MOV     DA8,W4
12C4:  MUL.UU  W4,#4,W0
12C6:  MOV     #DE0,W4
12C8:  ADD     W0,W4,W0
12CA:  MOV     #E70,W4
12CC:  MOV     [W0++],[W4++]
12CE:  MOV     [W0++],[W4++]
....................                arraygreen[x] = arraygreen[x+1]; 
12D0:  MOV     DA8,W4
12D2:  MUL.UU  W4,#4,W0
12D4:  MOV     #DE0,W4
12D6:  ADD     W0,W4,W5
12D8:  MOV     DA8,W4
12DA:  ADD     W4,#1,W6
12DC:  MOV     W6,W4
12DE:  MUL.UU  W4,#4,W0
12E0:  MOV     #DE0,W4
12E2:  ADD     W0,W4,W0
12E4:  MOV     [W0++],[W5++]
12E6:  MOV     [W0++],[W5++]
....................                arraygreen[x+1] = tempvar; 
12E8:  MOV     DA8,W4
12EA:  ADD     W4,#1,W5
12EC:  MOV     W5,W4
12EE:  MUL.UU  W4,#4,W0
12F0:  MOV     #DE0,W4
12F2:  ADD     W0,W4,W5
12F4:  MOV     #E70,W4
12F6:  MOV     [W4++],[W5++]
12F8:  MOV     [W4++],[W5++]
....................                 
....................                tempvar = arrayblue[x]; 
12FA:  MOV     DA8,W4
12FC:  MUL.UU  W4,#4,W0
12FE:  MOV     #E10,W4
1300:  ADD     W0,W4,W0
1302:  MOV     #E70,W4
1304:  MOV     [W0++],[W4++]
1306:  MOV     [W0++],[W4++]
....................                arrayblue[x] = arrayblue[x+1]; 
1308:  MOV     DA8,W4
130A:  MUL.UU  W4,#4,W0
130C:  MOV     #E10,W4
130E:  ADD     W0,W4,W5
1310:  MOV     DA8,W4
1312:  ADD     W4,#1,W6
1314:  MOV     W6,W4
1316:  MUL.UU  W4,#4,W0
1318:  MOV     #E10,W4
131A:  ADD     W0,W4,W0
131C:  MOV     [W0++],[W5++]
131E:  MOV     [W0++],[W5++]
....................                arrayblue[x+1] = tempvar; 
1320:  MOV     DA8,W4
1322:  ADD     W4,#1,W5
1324:  MOV     W5,W4
1326:  MUL.UU  W4,#4,W0
1328:  MOV     #E10,W4
132A:  ADD     W0,W4,W5
132C:  MOV     #E70,W4
132E:  MOV     [W4++],[W5++]
1330:  MOV     [W4++],[W5++]
....................            } 
1332:  INC     0DA8
1334:  BRA     121E
....................         } 
1336:  BRA     1214
....................  
....................     } 
....................      
....................     // average them all together 
....................     // throw out the high and low number of Clear 
....................      
....................     for (x=1; x < 11; x++) 
1338:  MOV     #1,W4
133A:  MOV     W4,DA8
133C:  MOV     DA8,W4
133E:  CP      W4,#B
1340:  BRA     GE,1412
....................     { 
....................     
....................         ttred = (float) arrayred[x]; 
1342:  MOV     DA8,W4
1344:  MUL.UU  W4,#4,W0
1346:  MOV     #DB0,W4
1348:  ADD     W0,W4,W0
134A:  MOV     W0,W4
134C:  MOV     #0,W3
134E:  MOV     [W4++],[W3++]
1350:  MOV     [W4++],[W3++]
1352:  CALL    1034
1356:  MOV     W0,D98
1358:  MOV     W1,D9A
....................         ttclear = (float) arrayclear[x]; 
135A:  MOV     DA8,W4
135C:  MUL.UU  W4,#4,W0
135E:  MOV     #E40,W4
1360:  ADD     W0,W4,W0
1362:  MOV     W0,W4
1364:  MOV     #0,W3
1366:  MOV     [W4++],[W3++]
1368:  MOV     [W4++],[W3++]
136A:  CALL    1034
136E:  MOV     W0,DA4
1370:  MOV     W1,DA6
....................         ttgreen = (float) arraygreen[x]; 
1372:  MOV     DA8,W4
1374:  MUL.UU  W4,#4,W0
1376:  MOV     #DE0,W4
1378:  ADD     W0,W4,W0
137A:  MOV     W0,W4
137C:  MOV     #0,W3
137E:  MOV     [W4++],[W3++]
1380:  MOV     [W4++],[W3++]
1382:  CALL    1034
1386:  MOV     W0,D9C
1388:  MOV     W1,D9E
....................         ttblue = (float) arrayblue[x];        
138A:  MOV     DA8,W4
138C:  MUL.UU  W4,#4,W0
138E:  MOV     #E10,W4
1390:  ADD     W0,W4,W0
1392:  MOV     W0,W4
1394:  MOV     #0,W3
1396:  MOV     [W4++],[W3++]
1398:  MOV     [W4++],[W3++]
139A:  CALL    1034
139E:  MOV     W0,DA0
13A0:  MOV     W1,DA2
....................     // if (DeviceSelect == 0x03)    
....................     // { 
....................         tempred = tempred + ttred/ttclear; 
13A2:  MOV     D98,W0
13A4:  MOV     D9A,W1
13A6:  MOV     DA4,W2
13A8:  MOV     DA6,W3
13AA:  CALL    90E
13AE:  BCLR.B  43.0
13B0:  MOV     W0,W2
13B2:  MOV     W1,W3
13B4:  MOV     D84,W0
13B6:  MOV     D86,W1
13B8:  CALL    72A
13BC:  MOV     W0,D84
13BE:  MOV     W1,D86
.................... 		tempblue = tempblue + ttblue/ttclear; 
13C0:  MOV     DA0,W0
13C2:  MOV     DA2,W1
13C4:  MOV     DA4,W2
13C6:  MOV     DA6,W3
13C8:  CALL    90E
13CC:  BCLR.B  43.0
13CE:  MOV     W0,W2
13D0:  MOV     W1,W3
13D2:  MOV     D88,W0
13D4:  MOV     D8A,W1
13D6:  CALL    72A
13DA:  MOV     W0,D88
13DC:  MOV     W1,D8A
.................... 		tempgreen = tempgreen + ttgreen/ttclear; 
13DE:  MOV     D9C,W0
13E0:  MOV     D9E,W1
13E2:  MOV     DA4,W2
13E4:  MOV     DA6,W3
13E6:  CALL    90E
13EA:  BCLR.B  43.0
13EC:  MOV     W0,W2
13EE:  MOV     W1,W3
13F0:  MOV     D8C,W0
13F2:  MOV     D8E,W1
13F4:  CALL    72A
13F8:  MOV     W0,D8C
13FA:  MOV     W1,D8E
.................... 		tempclear = tempclear + ttclear; 
13FC:  BCLR.B  43.0
13FE:  MOV     D90,W0
1400:  MOV     D92,W1
1402:  MOV     DA4,W2
1404:  MOV     DA6,W3
1406:  CALL    72A
140A:  MOV     W0,D90
140C:  MOV     W1,D92
140E:  INC     0DA8
1410:  BRA     133C
....................     // } 
....................     // else 
....................    //  { 
....................      //   tempred = tempred + ttred; 
.................... 	//	tempblue = tempblue + ttblue; 
.................... 	//	tempgreen = tempgreen + ttgreen; 
.................... 	//	tempclear = tempclear + ttclear;          
....................    //  } 
....................     } 
.................... 	tempred = (tempred*10000.0)/ageraging; 
1412:  MOV     D84,W0
1414:  MOV     D86,W1
1416:  MOV     #4000,W2
1418:  MOV     #461C,W3
141A:  CALL    1082
141E:  MOV     W0,W5
1420:  MOV     W1,W6
1422:  MOV     W5,W0
1424:  MOV     W6,W1
1426:  MOV     D94,W2
1428:  MOV     D96,W3
142A:  CALL    90E
142E:  MOV     W0,D84
1430:  MOV     W1,D86
.................... 	tempblue = (tempblue*10000.0)/ageraging; 
1432:  MOV     D88,W0
1434:  MOV     D8A,W1
1436:  MOV     #4000,W2
1438:  MOV     #461C,W3
143A:  CALL    1082
143E:  MOV     W0,W5
1440:  MOV     W1,W6
1442:  MOV     W5,W0
1444:  MOV     W6,W1
1446:  MOV     D94,W2
1448:  MOV     D96,W3
144A:  CALL    90E
144E:  MOV     W0,D88
1450:  MOV     W1,D8A
.................... 	tempgreen = (tempgreen*10000.0)/ageraging; 
1452:  MOV     D8C,W0
1454:  MOV     D8E,W1
1456:  MOV     #4000,W2
1458:  MOV     #461C,W3
145A:  CALL    1082
145E:  MOV     W0,W5
1460:  MOV     W1,W6
1462:  MOV     W5,W0
1464:  MOV     W6,W1
1466:  MOV     D94,W2
1468:  MOV     D96,W3
146A:  CALL    90E
146E:  MOV     W0,D8C
1470:  MOV     W1,D8E
.................... 	tempclear = tempclear/ageraging; 
1472:  MOV     D90,W0
1474:  MOV     D92,W1
1476:  MOV     D94,W2
1478:  MOV     D96,W3
147A:  CALL    90E
147E:  MOV     W0,D90
1480:  MOV     W1,D92
.................... 	redABS = (unsigned int32) tempred; 
1482:  MOV     D84,W0
1484:  MOV     D86,W1
1486:  CALL    1146
148A:  MOV     W0,B8C
148C:  MOV     W1,B8E
.................... 	blueABS = (unsigned int32) tempblue; 
148E:  MOV     D88,W0
1490:  MOV     D8A,W1
1492:  CALL    1146
1496:  MOV     W0,B90
1498:  MOV     W1,B92
.................... 	greenABS = (unsigned int32) tempgreen; 
149A:  MOV     D8C,W0
149C:  MOV     D8E,W1
149E:  CALL    1146
14A2:  MOV     W0,B94
14A4:  MOV     W1,B96
.................... 	clearABS = (unsigned int32) tempclear; 
14A6:  MOV     D90,W0
14A8:  MOV     D92,W1
14AA:  CALL    1146
14AE:  MOV     W0,B98
14B0:  MOV     W1,B9A
14B2:  MOV     [--W15],W7
14B4:  MOV     [--W15],W6
14B6:  MOV     [--W15],W5
14B8:  RETURN  
....................  
.................... 	} 
....................  
.................... //*************************************************************************************** 
.................... // Created Dec. 8, 2014 
.................... // This routine find the ambiant light and saves it as global variables for ph and DO routines to use. 
.................... //  The input is the selected sensor with the LED turned off.  The results are saved. 
.................... // Changed December 12, 2014 
.................... //  Removed the averaging part of the program and used the GetCurrentColorABS program instead 
.................... //  It has twice as many reading for averaging. 
.................... //*************************************************************************************** 
.................... void FindAmbientLight(int DeviceSelect) 
.................... 	{ 
.................... 		GetCurrentColorAVG(3,DeviceSelect); 
....................  
.................... 	if (DeviceSelect == 1)   //Setup the OXyegen offsets. 
.................... 		{ 
.................... 		AmbientOxyRed = redABS; 
.................... 		AmbientOxyGreen = greenABS; 
.................... 		AmbientOxyBlue = blueABS; 
.................... 		AmbientOxyClear = clearABS; 
.................... 		} 
....................  
.................... 	if (DeviceSelect == 2)  //Setup the PH offsets. 
.................... 		{ 
.................... 		AmbientPHRed = redABS; 
.................... 		AmbientPHGreen = greenABS; 
.................... 		AmbientPHBlue = blueABS; 
.................... 		AmbientPHClear = clearABS; 
.................... 		} 
....................          
....................        if (DeviceSelect == 9)  //Setup the PH offsets. 
.................... 		{ 
.................... 		Ambientnh3Red = redABS; 
.................... 		Ambientnh3Green = greenABS; 
.................... 		Ambientnh3Blue = blueABS; 
.................... 		Ambientnh3Clear = clearABS; 
.................... 		} 
....................  
.................... 	} 
....................  
....................  
....................  
....................  
.................... //******************************************************************** 
.................... // Created March 19, 2013 
.................... // Get the version of the device.  This  routine is used for testing I2C. 
.................... // Command 0x04 
.................... // This routine returns the version of the light chip.  
.................... //********************************************************************* 
.................... int8 getTAOSVersion(int lightsensor) 
.................... 	{ 
.................... int8 version; 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
....................  
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
....................  
.................... 	i2c_start(PH_LIGHT); 
.................... 	i2c_write(PH_LIGHT,0x52);  //Move the address number left on and add a zero. 
.................... 	i2c_write(PH_LIGHT,0x92);  //Send the command for reading the version 
.................... 	i2c_stop(PH_LIGHT); 
....................     i2c_start(PH_LIGHT); 
.................... 	i2c_write(PH_LIGHT,0x53);  //Move the address number left on and add a one to make is a read command. 
.................... 	version = i2c_read(PH_LIGHT,0); 
.................... 	i2c_stop(PH_LIGHT); 
....................  
.................... 	return(version); 
.................... 	} 
....................  
....................  
.................... //*********************************************************************** 
.................... // Created March 20, 2013 
.................... // This routine changes the exposure time for each sample. 
.................... //  There are three modes of intigration or exposure time per sample. 
.................... // 0 for 12ms 
.................... // 1 for 100 ms 
.................... // 2 for 400 ms 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the room 
.................... //*********************************************************************** 
.................... void ExposureTimeTAOS(byte integration, byte lightsensor) 
.................... 	{ 
....................  
.................... 	selectsensor(lightsensor);   // make the selection to talk with this sensor. 
....................  
.................... // then send the command down to the sensor.  All of the communication is done through the I2C on PH_LIGHT. 
.................... 	i2c_start(PH_LIGHT); 
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
.................... 	i2c_write(PH_LIGHT,0x81);  //Send the command for reading the Timing Register 
.................... 	i2c_write(PH_LIGHT,integration);  //Send the command for reading the version 
.................... 	i2c_stop(PH_LIGHT); 
....................  
.................... 	}  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************************************** 
.................... // Created April 27, 2014 
.................... //This routine inits all of the slave I2C where they have a gain of 1 and start with no ND filteration 
....................  
.................... //NOTE: INTEG_MODE and TIME/COUNTER fields should be written before ADC_EN is asserted. 
.................... //FIELD VALUE NOMINAL INTEGRATION TIME  
.................... //0000                12 ms  
.................... //0001                100 ms  
.................... //0010                400 ms 
.................... //***************************************************************************************** 
.................... void InitTAOS(void) 
.................... { 
....................  
.................... int8 x; 
....................  
....................  
.................... // turn on chips  and wait for 2.4 ms.  Only turn on chips, do not start intigration 
....................  
.................... StartUpTAOS(0x00);  // this starts up the integration time for the DO light sensor 
*
0482:  CLR     D84
0484:  CALL    40C
.................... StartUpTAOS(0x01);  // this starts up the integration time for the DO light sensor 
0488:  MOV     #1,W4
048A:  MOV     W4,D84
048C:  CALL    40C
.................... StartUpTAOS(0x03);  // this starts up the integration time for the DO light sensor 
0490:  MOV     #3,W4
0492:  MOV     W4,D84
0494:  CALL    40C
....................  
.................... delay_ms(3);    // wait for time to expire 
0498:  REPEAT  #3B7E
049A:  NOP     
049C:  REPEAT  #3FFF
049E:  NOP     
04A0:  REPEAT  #3FFF
04A2:  NOP     
04A4:  RETURN  
.................... } 
....................  
....................  
....................  
.................... //************************************************************************* 
.................... // Created November 14, 2016 
.................... // This routine runs the self test for all of the LEDs on the board. 
.................... // The routine returns nothing. 
.................... //************************************************************************* 
.................... void LEDtest(void) 
.................... { 
....................     //  turn off all LEDs 
....................     output_low(PIN_B12);    // turn off the blue light 
*
0366:  BCLR.B  2C9.4
0368:  BCLR.B  2CD.4
....................      
....................     output_low(PIN_B5);  // turn off orange DpH LED 
036A:  BCLR.B  2C8.5
036C:  BCLR.B  2CC.5
....................     output_high(PIN_B11);  // turn off blue 
036E:  BCLR.B  2C9.3
0370:  BSET.B  2CD.3
....................     output_low(PIN_B10);  // turn off NH4 
0372:  BCLR.B  2C9.2
0374:  BCLR.B  2CD.2
....................   
....................      
....................     output_high(PIN_B5);  // turn on white DpH LED 
0376:  BCLR.B  2C8.5
0378:  BSET.B  2CC.5
....................     delay_ms(250); 
037A:  MOV     #FA,W0
037C:  CALL    356
....................     output_low(PIN_B5);  // turn off orange DpH LED 
0380:  BCLR.B  2C8.5
0382:  BCLR.B  2CC.5
....................     output_low(PIN_B12);  // turn on blue for DO    
0384:  BCLR.B  2C9.4
0386:  BCLR.B  2CD.4
....................      delay_ms(250); 
0388:  MOV     #FA,W0
038A:  CALL    356
....................     output_low(PIN_B12);  // turn off blue DO 
038E:  BCLR.B  2C9.4
0390:  BCLR.B  2CD.4
....................     output_high(PIN_B10);  // turn on NH4   
0392:  BCLR.B  2C9.2
0394:  BSET.B  2CD.2
....................     delay_ms(250); 
0396:  MOV     #FA,W0
0398:  CALL    356
....................  
....................  
....................     output_low(PIN_B11);  // turn off blue 
039C:  BCLR.B  2C9.3
039E:  BCLR.B  2CD.3
....................     output_low(PIN_B10);  // turn off red 
03A0:  BCLR.B  2C9.2
03A2:  BCLR.B  2CD.2
....................     output_low(PIN_B5);  // turn off red for p  
03A4:  BCLR.B  2C8.5
03A6:  BCLR.B  2CC.5
....................     delay_ms(250); 
03A8:  MOV     #FA,W0
03AA:  CALL    356
03AE:  RETURN  
.................... } 
....................  
.................... #include "C:\Aquarium Software\Debug Monitor\CommonPassedDataFromMaterToSlave.h" 
.................... //********************************************************************************************** 
.................... // Created November 23, 2016 
.................... //these are the calibration varibles so far on the tester.   
.................... //********************************************************************************************** 
....................  
.................... typedef struct { 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
.................... float eccal1x; 
.................... float eccal2x; 
.................... float eccal3x; 
.................... float eccal1y; 
.................... float eccal2y; 
.................... float eccal3y; 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... }Calstuff; 
.................... Calstuff sysInput;  
.................... /* 
....................  
.................... typedef struct inputDataStruct{ 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... float eccal1x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal1y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3y;    //  This the EC data point  Added July 18, 2016 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... }inputData; 
.................... inputData sysInput; 
....................  
.................... */ 
....................  
.................... #ifdef SLAVE 
....................  
.................... float Temp1DOOne; 
.................... float Temp1DOTwo; 
.................... float Temp1DOThree; 
.................... float Temp2DOOne; 
.................... float Temp2DOTwo; 
.................... float Temp2DOThree; 
.................... float Temp3DOOne; 
.................... float Temp3DOTwo; 
.................... float Temp3DOThree; 
.................... float Temp1ReadingOne; 
.................... float Temp1ReadingTwo; 
.................... float Temp1ReadingThree; 
.................... float Temp2ReadingOne; 
.................... float Temp2ReadingTwo; 
.................... float Temp2ReadingThree; 
.................... float Temp3ReadingOne; 
.................... float Temp3ReadingTwo; 
.................... float Temp3ReadingThree; 
....................  
.................... unsigned int16 TempOne; 
.................... unsigned int16 TempTwo; 
.................... unsigned int16 TempThree; 
....................  
.................... #endif 
....................  
.................... #include "..\OsomobotCarbonDioxideDigitalSensor\OsomobotCarbonDioxideDigitalSensor.X\ITwoSeeGeneralCommunicationSlave.c"     // this is included to connect to the master Osmobot. 
.................... //*************************************************************************************** 
.................... // Created October 16, 2016 
.................... // This file is included in project to make this unit a slave for the Osmobot. 
.................... // include this in the top of the project and update the data array with the data wanting to be returned. 
.................... //************************************************************************************** 
.................... //#define SDAPIN PIN_B2 
.................... //#define SCLPIN PIN_B3 
....................  
.................... //#use I2C(stream=SENSOR, SLAVE, sda=SDAPIN,scl=SCLPIN, FORCE_HW, address=0xa0, NO_STRETCH)   // this is I2C 1 
....................  
.................... char send_buffer[65];   // this is filled by this unit for sending data. 
.................... unsigned int8 rcv_buffer[65];   // this is the received data from the master  
.................... unsigned  int8 address, streamCntr=0;  
.................... float nhcalibration[5][2];  // this is the configuration array for nh4 + nh3 calibration.  It can go up to 10 points for data calibration. 
....................  
....................  
....................  
.................... //*************************************************************************** 
.................... // Created Oct 7, 2016 
.................... // Updated Oct 16, 2016  -- Added CO2 structure for sending data.  -- Changed the number of registers to 100 from 20. 
.................... // This routine sets the protocal for communicating to a remote custom I2c device. 
.................... // The frames and commands are as follows: 
.................... // Address 0x12  for this device. 
.................... // write a command to the command register before reading or writing to the device 
.................... // Command Register  :    01    // A one for R reads all data points from the unit   //  A one for W writes calibration numbers for all instruments 
.................... //      MSB                  LSB 
.................... //       7  6  5  4  3  2  1  0 
.................... //       X  X  X  X  X  X  R  W 
.................... // There are 20 registers (bytes) for reading data from the unit 
.................... // There are 40 registers (bytes) for writing data to the unit 
.................... // Reading frame definition     --  has to be done in sequence each time. 
.................... // 1: HN4  whole number portion of reading 
.................... // 2: NH4  fraction of the reading 
.................... // 3: DO  whole number portion of reading 
.................... // 4: DO  fraction of the reading 
.................... // 5: Water Temperature  whole number portion of reading 
.................... // 6: Water Temperature  fraction of the reading 
.................... // 7: CO2 High byte    Updated Oct 16, 2016 
.................... // 8: CO2 Low Byte   Updated Oct 16, 2016 
.................... // 9: Air Temperature whole number    Updated Oct 24, 2016 
.................... // 10: Air Temperature fractional part   Updated Oct 24, 2016 
.................... // 11: Air RH  whole number   Updated Oct 24, 2016 
.................... // 12: Air RH fractional part    Updated Oct 24, 2016 
.................... // 13: Water Temperature High Byte raw data   Updated Feb 15, 2017 
.................... // 14: Water Temperature Low Byte raw data   Updated Feb 15, 2017 
.................... // 15: DO  RawData High Byte 
.................... // 16: DO  RawData Low Byte 
.................... // 17: NH4 RawData High Byte 
.................... // 18: NH4 RawData Low Byte 
....................         // Added Fab 26, 2017 
....................         // these items are the raw numbers for NH4 
.................... // 19: NH4 Patch RED RawData High Byte 
.................... // 20: NH4 Patch RED RawData Low Byte 
.................... // 21: NH4 Patch GREEN RawData High Byte 
.................... // 22: NH4 Patch GREEN RawData Low Byte 
.................... // 23: NH4 Patch BLUE RawData High Byte 
.................... // 24: NH4 Patch blue RawData Low Byte 
.................... // 25: NH4 Patch WHITE RawData High Byte 
.................... // 26: NH4 Patch WHITE RawData Low Byte 
.................... // 27: DpH  Digital Red RawData High Byte 
.................... // 28: DpH  Digital Red RawData Low Byte 
.................... // 29:  DpH Reading  whole number  updated March 30, 2017 
.................... // 30:  DpH fractional part  updated March 30, 2017 
.................... // 31: DpH  Digital Green RawData High Byte   updated April 3, 2017 
.................... // 32: DpH  Digital Green RawData Low Byte   updated April 3, 2017 
.................... // 33: DpH  Digital Blue RawData High Byte   updated April 3, 2017 
.................... // 34: DpH  Digital Blue RawData Low Byte   updated April 3, 2017 
.................... // 35: DpH  Digital White RawData High Byte   updated April 3, 2017 
.................... // 36: DpH  Digital White RawData Low Byte   updated April 3, 2017 
.................... // XX:  TBD 
....................  
....................  
.................... /* 
....................  unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... float eccal1x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal1y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3y;    //  This the EC data point  Added July 18, 2016 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
....................  */ 
....................  
....................  
....................  
....................  
....................  
.................... // Writing frame definition  --  has to be done in sequence each time. 
.................... // 1: HN4  whole number portion of HN4 calibration for point 1 
.................... // 2: NH4  fraction of the reading of HN4 calibration for point 1 
.................... // 3: HN4  whole number portion of HN4 calibration for point 2 
.................... // 4: NH4  fraction of the reading of HN4 calibration for point 2 
.................... // 5: HN4  whole number returned value of HN4 calibration for point 1 
.................... // 6: NH4  fraction of the returned value of HN4 calibration for point 1 
.................... // 7: HN4  whole number returned value of HN4 calibration for point 2 
.................... // 8: NH4  fraction of the returned value of HN4 calibration for point 2 
.................... // 9: TBD   all zeros 
.................... // 10: TBD 
.................... // 11: TBD 
.................... // 12: TBD 
.................... // 13: TBD 
.................... // 14: TBD 
.................... // 15: TBD 
.................... // 16: TBD 
.................... // 17: TBD 
.................... // 18: TBD 
.................... // 19: TBD 
.................... // 20: TBD 
.................... //  ...... 
.................... // 99: checksum high byte 
.................... // 100: checksum low byte 
.................... // returns a 1 if the checksum is OK and it receives data 
.................... //****************************************************************************** 
....................  
....................  
.................... //******************************************************************************* 
.................... // Create November 2, 2016 
.................... // Save this float into eeprom 
.................... // returns nothing. 
.................... //  give the pointer to the number, the location in eeprom and length 
.................... //****************************************************************************** 
.................... void eeprom_write_block(int16 *ptr, unsigned int8 addr, unsigned char len) 
.................... { 
....................   unsigned int16 *data = ptr; 
....................     unsigned int16 bufferin[4]; 
....................     unsigned int8 stuffit = addr; 
....................     len=len>>1;    // Since we are using 16 bits, two bytes are used at a time because of defs. 
....................     addr=addr<<1;   //mult by two offset to the correct location. 
....................  
....................     //read back the data 
....................    while (len--) { 
....................         write_eeprom(addr, *data++); 
....................         addr=addr+2;  // need to skip two bytes since this is a 16 bit CPU   
....................     }  
.................... //    bufferin[0] = read_eeprom[0]; 
....................  //   bufferin[1] = read_eeprom[2];        
....................  stuffit= stuffit+1;     
.................... } 
....................  
....................  
....................  
.................... //******************************************************************************* 
.................... // Create May 2, 2017 
.................... // Read this string of characters from eeprom 
.................... // returns nothing. 
.................... //  give the pointer to the number, the location in eeprom and length 
.................... //****************************************************************************** 
.................... void eeprom_read_block(unsigned int16 location, unsigned char len) 
.................... { 
....................  unsigned int16 dummytempvar; // Added May 2, 2017   for splitting in to chars 
....................  unsigned int16 *addr; 
....................     location=location<<1;   //mult by two offset to the correct location. 
....................  addr = location; 
....................      
....................     //read back the data 
....................    while (len--) { 
....................  //       dummytempvar = read_eeprom[addr];   // read the 16 bit word from this location.  It's two bytes long 
....................         softwareversion[len--] = (char) dummytempvar >> 8; 
....................         softwareversion[len] = (char) dummytempvar; 
....................         addr=addr+2;  // need to skip two bytes since this is a 16 bit CPU   
....................     }    
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... float READ_FLOAT_EEPROM(long int n)  
*
0500:  MOV     W5,[W15++]
0502:  MOV     W6,[W15++]
0504:  MOV     W7,[W15++]
.................... {  
....................    int i;  
....................    float data; 
....................  
....................    for (i = 0; i < 2; i++)  
0506:  CLR     D8A
0508:  MOV     D8A,W4
050A:  CP      W4,#2
050C:  BRA     GE,540
....................       *((int16*)&data + i) = read_eeprom(2*i + 2*n); 
050E:  MOV     #D8C,W5
0510:  MOV     D8A,W4
0512:  MUL.UU  W4,#2,W0
0514:  ADD     W0,W5,W0
0516:  MOV     W0,W5
0518:  MOV     D8A,W4
051A:  MUL.UU  W4,#2,W6
051C:  MOV     #2,W0
051E:  MOV     #0,W1
0520:  MOV     D86,W2
0522:  MOV     D88,W3
0524:  CALL    4A6
0528:  ADD     W0,W6,W6
052A:  ADDC    W1,#0,W7
052C:  MOV     W5,[W15++]
052E:  MOV     W6,W3
0530:  MOV     #0,W4
0532:  MOV     #2,W5
0534:  CALL    4E8
0538:  MOV     [--W15],W5
053A:  MOV     W0,[W5]
053C:  INC     0D8A
053E:  BRA     508
....................  
....................    return(data);  
0540:  MOV     D8C,W0
0542:  MOV     D8E,W1
0544:  MOV     [--W15],W7
0546:  MOV     [--W15],W6
0548:  MOV     [--W15],W5
054A:  RETURN  
.................... } 
....................  
....................   
....................      
.................... //****************************************************************************** 
.................... // Created October 17, 2016 
.................... // This is a check sum for the data sent through the I2C back to the master.  The numbers are split and put into the 
.................... // last two locations of the upload send_buffer[]. 
.................... //  Nothing is returned, but the data is updated in this function. 
.................... //****************************************************************************** 
.................... void CalculateCRC(void) 
.................... { 
....................     unsigned int16 checksum; 
....................     unsigned int8 checksumhigh, checksumlow, x; 
....................     for (x=0; x < 98; x++) 
....................     { 
....................     checksum = checksum + send_buffer[x]; 
....................     } 
....................     //seperate the numbers into high and low 
....................     checksumlow = 0x00FF & checksum; 
....................     //  place the numbers in the array 
....................     checksumhigh = (0xFF00 & checksum)>>8; 
....................     send_buffer[98]=checksumhigh; 
....................     send_buffer[99]=checksumlow; 
.................... }     
....................      
.................... //****************************************************************************** 
.................... // Created Oct. 16, 2016 
.................... // this routine clears the data in the return buffer to all 0xFF.  This means if the data is 0xFF, there is no sensor data avaible and is ignored by the 
.................... // master CPU.  That means the main CPU master needs to go through all of the returned data and check to see if it is not 0xFF for all sets of bytes. 
.................... //****************************************************************************** 
....................  
....................     void initTransMitBuffer(void) 
*
033A:  MOV     W5,[W15++]
....................     { 
....................         // there are 100 points in the transmit buffer. 
....................         int x; 
....................         for (x = 0; x < 65; x++)   // set all of the returned data to 0xFF.  If there is data to be returned, it will change it to non 0xFF 
033C:  CLR     D82
033E:  MOV     D82,W4
0340:  MOV     #41,W3
0342:  CP      W3,W4
0344:  BRA     LE,352
....................         { 
....................             send_buffer[x] = 0xFF; 
0346:  MOV     #CCC,W4
0348:  MOV     D82,W3
034A:  ADD     W3,W4,W5
034C:  SETM.B  [W5]
034E:  INC     0D82
0350:  BRA     33E
....................         } 
0352:  MOV     [--W15],W5
0354:  RETURN  
....................        
....................     } 
....................        
....................      
.................... //***************************************************************** 
.................... //Created November 2, 2016 
.................... //  This is the eeprom read function to load all of the calibration data from the eeprom 
.................... // This routine can be triggered from the program and from one of the commands from the I2C 
.................... // It returns all of the data read from the internal data eeprom 
.................... //****************************************************************** 
.................... int LoadConfiguration(void) 
.................... { 
....................     float checkvalue;   // this is used for returning the value and checking to see if it took. 
....................      
....................    /* 
....................     float Temp1DOOne = 9.5;            //These are the set points where we want to read these numbers at temperature 1 
.................... 	float Temp1DOTwo = 4.0;            //This is at 10 degrees 
.................... 	float Temp1DOThree = 0.0; 
.................... */  
....................     Temp1DOOne = READ_FLOAT_EEPROM(0); 
*
0578:  CLR     D86
057A:  CLR     D88
057C:  CALL    500
0580:  MOV     W0,C7E
0582:  MOV     W1,C80
....................     Temp1DOTwo = READ_FLOAT_EEPROM(1); 
0584:  MOV     #1,W4
0586:  MOV     W4,D86
0588:  CLR     D88
058A:  CALL    500
058E:  MOV     W0,C82
0590:  MOV     W1,C84
....................     Temp1DOThree = READ_FLOAT_EEPROM(2); 
0592:  MOV     #2,W4
0594:  MOV     W4,D86
0596:  CLR     D88
0598:  CALL    500
059C:  MOV     W0,C86
059E:  MOV     W1,C88
....................     /* 
....................  
.................... 	float Temp2DOOne = 7.5;            //These are the set points where we want to read these numbers at temperature 2 
.................... 	float Temp2DOTwo = 4.0;				//This is at 20 degrees 
.................... 	float Temp2DOThree = 0.0; 
....................  
....................      */ 
....................     Temp2DOOne = READ_FLOAT_EEPROM(3); 
05A0:  MOV     #3,W4
05A2:  MOV     W4,D86
05A4:  CLR     D88
05A6:  CALL    500
05AA:  MOV     W0,C8A
05AC:  MOV     W1,C8C
....................     Temp2DOTwo = READ_FLOAT_EEPROM(4); 
05AE:  MOV     #4,W4
05B0:  MOV     W4,D86
05B2:  CLR     D88
05B4:  CALL    500
05B8:  MOV     W0,C8E
05BA:  MOV     W1,C90
....................     Temp2DOThree = READ_FLOAT_EEPROM(5); 
05BC:  MOV     #5,W4
05BE:  MOV     W4,D86
05C0:  CLR     D88
05C2:  CALL    500
05C6:  MOV     W0,C92
05C8:  MOV     W1,C94
....................     /* 
.................... 	float Temp3DOOne = 6.7;            //These are the set points where we want to read these numbers temperature 3 
.................... 	float Temp3DOTwo = 4.0;            //This is at 25 degrees 
.................... 	float Temp3DOThree = 0.0;   
....................  */ 
....................     Temp3DOOne = READ_FLOAT_EEPROM(6); 
05CA:  MOV     #6,W4
05CC:  MOV     W4,D86
05CE:  CLR     D88
05D0:  CALL    500
05D4:  MOV     W0,C96
05D6:  MOV     W1,C98
....................     Temp3DOTwo = READ_FLOAT_EEPROM(7); 
05D8:  MOV     #7,W4
05DA:  MOV     W4,D86
05DC:  CLR     D88
05DE:  CALL    500
05E2:  MOV     W0,C9A
05E4:  MOV     W1,C9C
....................     Temp3DOThree = READ_FLOAT_EEPROM(8); 
05E6:  MOV     #8,W4
05E8:  MOV     W4,D86
05EA:  CLR     D88
05EC:  CALL    500
05F0:  MOV     W0,C9E
05F2:  MOV     W1,CA0
....................     /* 
....................       
....................     float Temp1ReadingOne = 10752.0;       //Readings for Temp3  10 degrees C 
.................... 	float Temp1ReadingTwo = 11000.0;      //Readings for Temp3 
.................... 	float Temp1ReadingThree = 12000.0;    //Readings for DOOne    this is no DO. 
....................       
....................      */ 
....................     Temp1ReadingOne = READ_FLOAT_EEPROM(9); 
05F4:  MOV     #9,W4
05F6:  MOV     W4,D86
05F8:  CLR     D88
05FA:  CALL    500
05FE:  MOV     W0,CA2
0600:  MOV     W1,CA4
....................     Temp1ReadingTwo = READ_FLOAT_EEPROM(10); 
0602:  MOV     #A,W4
0604:  MOV     W4,D86
0606:  CLR     D88
0608:  CALL    500
060C:  MOV     W0,CA6
060E:  MOV     W1,CA8
....................     Temp1ReadingThree = READ_FLOAT_EEPROM(11); 
0610:  MOV     #B,W4
0612:  MOV     W4,D86
0614:  CLR     D88
0616:  CALL    500
061A:  MOV     W0,CAA
061C:  MOV     W1,CAC
....................      /*  
....................       
.................... 	float Temp2ReadingOne = 11266.0;       //Readings for Temp3    20 degrees C 
.................... 	float Temp2ReadingTwo = 12000.0;      //Readings for Temp3 
.................... 	float Temp2ReadingThree = 13000.0;    //Readings for DOOne 
.................... */ 
....................     Temp2ReadingOne = READ_FLOAT_EEPROM(12); 
061E:  MOV     #C,W4
0620:  MOV     W4,D86
0622:  CLR     D88
0624:  CALL    500
0628:  MOV     W0,CAE
062A:  MOV     W1,CB0
....................     Temp2ReadingTwo = READ_FLOAT_EEPROM(13); 
062C:  MOV     #D,W4
062E:  MOV     W4,D86
0630:  CLR     D88
0632:  CALL    500
0636:  MOV     W0,CB2
0638:  MOV     W1,CB4
....................     Temp2ReadingThree = READ_FLOAT_EEPROM(14); 
063A:  MOV     #E,W4
063C:  MOV     W4,D86
063E:  CLR     D88
0640:  CALL    500
0644:  MOV     W0,CB6
0646:  MOV     W1,CB8
....................     /* 
.................... 	float Temp3ReadingOne = 12425.0;       //Readings for Temp3   25 degrees C 
.................... 	float Temp3ReadingTwo = 13000.0;      //Readings for Temp3 
.................... 	float Temp3ReadingThree = 14000.0;    //Readings for DOOne 
.................... */ 
....................     Temp3ReadingOne = READ_FLOAT_EEPROM(15); 
0648:  MOV     #F,W4
064A:  MOV     W4,D86
064C:  CLR     D88
064E:  CALL    500
0652:  MOV     W0,CBA
0654:  MOV     W1,CBC
....................     Temp3ReadingTwo = READ_FLOAT_EEPROM(16); 
0656:  MOV     #10,W4
0658:  MOV     W4,D86
065A:  CLR     D88
065C:  CALL    500
0660:  MOV     W0,CBE
0662:  MOV     W1,CC0
....................     Temp3ReadingThree = READ_FLOAT_EEPROM(17); 
0664:  MOV     #11,W4
0666:  MOV     W4,D86
0668:  CLR     D88
066A:  CALL    500
066E:  MOV     W0,CC2
0670:  MOV     W1,CC4
....................     /* 
....................     
.................... 	float TempOne = 10.0;       //Calibration temperatures for DO   Added April 7, 2015 
....................  	float TempTwo =  20.0;      //Calibration temperatures for DO  Added April 7, 2015 
.................... 	float TempThree =  25.0;     //Calibration temperatures for DO  Added April 7, 2015 
....................  
....................      */ 
....................     TempOne = READ_FLOAT_EEPROM(18); 
0672:  MOV     #12,W4
0674:  MOV     W4,D86
0676:  CLR     D88
0678:  CALL    500
067C:  CALL    54C
0680:  MOV     W0,CC6
....................     TempTwo = READ_FLOAT_EEPROM(19); 
0682:  MOV     #13,W4
0684:  MOV     W4,D86
0686:  CLR     D88
0688:  CALL    500
068C:  CALL    54C
0690:  MOV     W0,CC8
....................     TempThree = READ_FLOAT_EEPROM(20); 
0692:  MOV     #14,W4
0694:  MOV     W4,D86
0696:  CLR     D88
0698:  CALL    500
069C:  CALL    54C
06A0:  MOV     W0,CCA
....................      
....................     //************************************************************************** 
....................     // Created May 2, 2017 
....................     // This section puts together the serial number and the software version for sending to the host 
....................     // The format is software version first with the UnitID Number at the head seperated by a "." 
....................     // There rest of it from EEPROM   - 8 characters 
....................     //  This is put into the same string. 
....................     //************************************************************************* 
....................     // Read the EEPROM serialnumber 
....................      
....................      
....................     // Add the DeviceID Code, version number and serialnumber to the string 
....................      
....................      
....................      
....................      
....................      
....................      
....................      
....................      
....................     //  Load the values for the NH4 + NH3 calibration.  There are two numbers.   
....................     //  Put the numbers in to the 2D matrix 
....................      
....................     nhcalibration[0][1] = 0.1;   //   .1 ppm 
06A2:  MOV     #CCCD,W4
06A4:  MOV     W4,D54
06A6:  MOV     #3DCC,W4
06A8:  MOV     W4,D56
....................     nhcalibration[0][0] =  3018.0;   // its data 
06AA:  MOV     #A000,W4
06AC:  MOV     W4,D50
06AE:  MOV     #453C,W4
06B0:  MOV     W4,D52
....................     nhcalibration[1][1] = 5.0;   //   .1 ppm 
06B2:  CLR     D5C
06B4:  MOV     #40A0,W4
06B6:  MOV     W4,D5E
....................     nhcalibration[1][0] =  3395.0;   // its data 
06B8:  MOV     #3000,W4
06BA:  MOV     W4,D58
06BC:  MOV     #4554,W4
06BE:  MOV     W4,D5A
....................     nhcalibration[2][1] = 10.0;   //   .1 ppm 
06C0:  CLR     D64
06C2:  MOV     #4120,W4
06C4:  MOV     W4,D66
....................     nhcalibration[2][0] =  3918.0;   // its data 
06C6:  MOV     #E000,W4
06C8:  MOV     W4,D60
06CA:  MOV     #4574,W4
06CC:  MOV     W4,D62
....................     nhcalibration[3][1] = 100.0;   //   .1 ppm 
06CE:  CLR     D6C
06D0:  MOV     #42C8,W4
06D2:  MOV     W4,D6E
....................     nhcalibration[3][0] =  4076.0;   // its data 
06D4:  MOV     #C000,W4
06D6:  MOV     W4,D68
06D8:  MOV     #457E,W4
06DA:  MOV     W4,D6A
....................              
....................      
....................     return(0);   // if it makes it to here, everything is ok. 
06DC:  CLR     0
06DE:  RETURN  
.................... } 
....................  
.................... //******************************************************************************* 
.................... // Create November 2, 2016 
.................... // Save this float into eeprom 
.................... // returns nothing. 
.................... //  give the pointer to the number, the location in eeprom and length 
.................... //****************************************************************************** 
.................... void eeprom_write_blocktest(int16 *ptr, unsigned int8 addr, unsigned char len) 
.................... { 
....................   unsigned int16 *data = ptr; 
....................     unsigned int16 bufferin[4]; 
....................     unsigned int8 stuff = addr; 
....................     len=len>>1;    // Since we are using 16 bits, two bytes are used at a time because of defs. 
....................     addr=addr<<1;   //mult by two offset to the correct location. 
....................  
....................     //read back the data 
....................    while (len--) { 
....................         write_eeprom(addr, *data++); 
....................         addr=addr+2;  // need to skip two bytes since this is a 16 bit CPU   
....................     }  
....................  //   bufferin[0] = read_eeprom[stuff]; 
....................  //   bufferin[1] = read_eeprom[stuff+2];        
....................  stuff= stuff+1;     
.................... } 
....................  
....................  
....................  
.................... //***************************************************************** 
.................... //Created Oct. 19, 2016 
.................... //  This is the eeprom write function to save all of the calibration data to the eeprom 
.................... // This routine can be triggered from the program and from one of the commands from the I2C 
.................... // It returns a 0 if everything is OK,  A 1 is returned when it failed. 
.................... //  It does a write and reads back the data to make it made it. 
.................... //****************************************************************** 
.................... int SaveConfiguration(void) 
.................... { 
....................     float checkvalue;   // this is used for returning the value and checking to see if it took. 
....................      
....................    /* 
....................     float Temp1DOOne = 9.5;            //These are the set points where we want to read these numbers at temperature 1 
.................... 	float Temp1DOTwo = 4.0;            //This is at 10 degrees 
.................... 	float Temp1DOThree = 0.0; 
.................... */  
....................     eeprom_write_blocktest(&Temp1DOOne, 0, sizeof Temp1DOOne); 
....................     checkvalue = READ_FLOAT_EEPROM(0); 
....................     if (Temp1DOOne != checkvalue) 
....................         return(1);    // return this error 
....................     eeprom_write_blocktest(&Temp1DOTwo, 1, sizeof Temp1DOTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(1); 
....................     if (Temp1DOTwo != checkvalue) 
....................         return(2);    // return this error 
....................      eeprom_write_blocktest(&Temp1DOThree, 2, sizeof Temp1DOThree); 
....................     checkvalue = READ_FLOAT_EEPROM(2); 
....................     if (Temp1DOThree != checkvalue) 
....................         return(3);    // return this error 
....................      
....................     // this routine saves the data for the NH4, EC, DO and temperature 
....................     /* 
....................  
.................... 	float Temp2DOOne = 7.5;            //These are the set points where we want to read these numbers at temperature 2 
.................... 	float Temp2DOTwo = 4.0;				//This is at 20 degrees 
.................... 	float Temp2DOThree = 0.0; 
....................  
....................      */ 
....................     eeprom_write_block(&Temp2DOOne, 3, sizeof Temp2DOOne); 
....................     checkvalue = READ_FLOAT_EEPROM(3); 
....................     if (Temp2DOOne != checkvalue) 
....................         return(4);    // return this error 
....................     eeprom_write_block(&Temp2DOTwo, 4, sizeof Temp2DOTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(4); 
....................     if (Temp2DOTwo != checkvalue) 
....................         return(5);    // return this error 
....................      eeprom_write_block(&Temp2DOThree, 5, sizeof Temp2DOThree); 
....................     checkvalue = READ_FLOAT_EEPROM(5); 
....................     if (Temp2DOThree != checkvalue) 
....................         return(6);    // return this error 
....................     
....................     /* 
.................... 	float Temp3DOOne = 6.7;            //These are the set points where we want to read these numbers temperature 3 
.................... 	float Temp3DOTwo = 4.0;            //This is at 25 degrees 
.................... 	float Temp3DOThree = 0.0;   
....................  */ 
....................      
....................     eeprom_write_block(&Temp3DOOne, 6, sizeof Temp3DOOne); 
....................     checkvalue = READ_FLOAT_EEPROM(6); 
....................     if (Temp3DOOne != checkvalue) 
....................         return(7);    // return this error 
....................     eeprom_write_block(&Temp3DOTwo, 7, sizeof Temp3DOTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(7); 
....................     if (Temp3DOTwo != checkvalue) 
....................         return(8);    // return this error 
....................      eeprom_write_block(&Temp3DOThree, 8, sizeof Temp3DOThree); 
....................     checkvalue = READ_FLOAT_EEPROM(8); 
....................     if (Temp3DOThree != checkvalue) 
....................         return(9);    // return this error   
....................     /* 
....................       
....................     float Temp1ReadingOne = 10752.0;       //Readings for Temp3  10 degrees C 
.................... 	float Temp1ReadingTwo = 11000.0;      //Readings for Temp3 
.................... 	float Temp1ReadingThree = 12000.0;    //Readings for DOOne    this is no DO. 
....................       
....................      */ 
....................      
....................     eeprom_write_block(&Temp1ReadingOne, 9, sizeof Temp1ReadingOne); 
....................     checkvalue = READ_FLOAT_EEPROM(9); 
....................     if (Temp1ReadingOne != checkvalue) 
....................         return(10);    // return this error 
....................     eeprom_write_block(&Temp1ReadingTwo, 10, sizeof Temp1ReadingTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(10); 
....................     if (Temp1ReadingTwo != checkvalue) 
....................         return(11);    // return this error 
....................      eeprom_write_block(&Temp1ReadingThree, 11, sizeof Temp1ReadingThree); 
....................     checkvalue = READ_FLOAT_EEPROM(11); 
....................     if (Temp1ReadingThree != checkvalue) 
....................         return(12);    // return this error 
....................      
....................      /*  
....................       
....................  
.................... 	float Temp2ReadingOne = 11266.0;       //Readings for Temp3    20 degrees C 
.................... 	float Temp2ReadingTwo = 12000.0;      //Readings for Temp3 
.................... 	float Temp2ReadingThree = 13000.0;    //Readings for DOOne 
.................... */ 
....................     eeprom_write_block(&Temp2ReadingOne, 12, sizeof Temp2ReadingOne); 
....................     checkvalue = READ_FLOAT_EEPROM(12); 
....................     if (Temp2ReadingOne != checkvalue) 
....................         return(13);    // return this error 
....................     eeprom_write_block(&Temp2ReadingTwo, 13, sizeof Temp2ReadingTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(13); 
....................     if (Temp2ReadingTwo != checkvalue) 
....................         return(14);    // return this error 
....................      eeprom_write_block(&Temp2ReadingThree, 14, sizeof Temp2ReadingThree); 
....................     checkvalue = READ_FLOAT_EEPROM(14); 
....................     if (Temp2ReadingThree != checkvalue) 
....................         return(15);    // return this error 
....................     /* 
.................... 	float Temp3ReadingOne = 12425.0;       //Readings for Temp3   25 degrees C 
.................... 	float Temp3ReadingTwo = 13000.0;      //Readings for Temp3 
.................... 	float Temp3ReadingThree = 14000.0;    //Readings for DOOne 
.................... */ 
....................     eeprom_write_block(&Temp3ReadingOne, 15, sizeof Temp3ReadingOne); 
....................     checkvalue = READ_FLOAT_EEPROM(15); 
....................     if (Temp3ReadingOne != checkvalue) 
....................         return(16);    // return this error 
....................     eeprom_write_block(&Temp3ReadingTwo, 16, sizeof Temp3ReadingTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(16); 
....................     if (Temp3ReadingTwo != checkvalue) 
....................         return(17);    // return this error 
....................      eeprom_write_block(&Temp3ReadingThree, 17, sizeof Temp3ReadingThree); 
....................     checkvalue = READ_FLOAT_EEPROM(17); 
....................     if (Temp3ReadingThree != checkvalue) 
....................         return(18);    // return this error 
....................     /* 
....................     
.................... 	float TempOne = 10.0;       //Calibration temperatures for DO   Added April 7, 2015 
....................  	float TempTwo =  20.0;      //Calibration temperatures for DO  Added April 7, 2015 
.................... 	float TempThree =  25.0;     //Calibration temperatures for DO  Added April 7, 2015 
....................  
....................       
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
....................      */ 
....................      
....................     eeprom_write_block(&sysInput.DOpt1returnednumber, 18, sizeof sysInput.DOpt1returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(18); 
....................     if (sysInput.DOpt1returnednumber != checkvalue) 
....................         return(19);    // return this error 
....................     eeprom_write_block(&sysInput.DOpt2returnednumber, 19, sizeof sysInput.DOpt2returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(19); 
....................     if (sysInput.DOpt2returnednumber != checkvalue) 
....................         return(20);    // return this error 
....................      eeprom_write_block(&sysInput.DOpt3returnednumber, 20, sizeof sysInput.DOpt3returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(20); 
....................     if (sysInput.DOpt3returnednumber != checkvalue) 
....................         return(21);    // return this error 
....................      /* 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
....................     */ 
....................      
....................      
....................     eeprom_write_block(&sysInput.Thermisterpt1cal1of3, 21, sizeof sysInput.Thermisterpt1cal1of3); 
....................     checkvalue = READ_FLOAT_EEPROM(21); 
....................     if (sysInput.Thermisterpt1cal1of3 != checkvalue) 
....................         return(22);    // return this error 
....................     eeprom_write_block(&sysInput.Thermisterpt1cal2of3, 22, sizeof sysInput.Thermisterpt1cal2of3); 
....................     checkvalue = READ_FLOAT_EEPROM(22); 
....................     if (sysInput.Thermisterpt1cal2of3 != checkvalue) 
....................         return(23);    // return this error 
....................      eeprom_write_block(&sysInput.Thermisterpt1cal3of3, 23, sizeof sysInput.Thermisterpt1cal3of3); 
....................     checkvalue = READ_FLOAT_EEPROM(23); 
....................     if (sysInput.Thermisterpt1cal3of3 != checkvalue) 
....................         return(24);    // return this error 
....................      
.................... /* 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
....................   */ 
....................      
....................    eeprom_write_block(&sysInput.Thermisterpt1returnednumber, 24, sizeof sysInput.Thermisterpt1returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(24); 
....................     if (sysInput.Thermisterpt1returnednumber!= checkvalue) 
....................         return(25);    // return this error 
....................     eeprom_write_block(&sysInput.Thermisterpt2returnednumber, 25, sizeof sysInput.Thermisterpt2returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(25); 
....................     if (sysInput.Thermisterpt2returnednumber != checkvalue) 
....................         return(26);    // return this error 
....................      eeprom_write_block(&sysInput.Thermisterpt3returnednumber, 26, sizeof sysInput.Thermisterpt3returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(26); 
....................     if (sysInput.Thermisterpt3returnednumber != checkvalue) 
....................         return(27);    // return this error 
....................       
....................      
....................     return(0);   // if it makes it to here, everything is ok. 
.................... } 
....................  
....................  
....................  
.................... //********************************************************************************************* 
.................... // Created November 28, 2016 
.................... // This moves the data from the recieve buffer into the configuation varaubles. 
.................... // Returns nothing.  This is called when rcv_buffer[2] == 0x01 
.................... //********************************************************************************************* 
.................... void movercvbuffertocolibration(void) 
*
23D6:  MOV     W5,[W15++]
23D8:  MOV     W6,[W15++]
.................... { 
....................   
....................     int8 lowbyte,highbyte; 
....................     unsigned int16 items; 
....................     int i;  
....................    float data; 
....................         
....................     //these are the two byte int16s 
....................     lowbyte = rcv_buffer[3]; 
23DA:  MOV.B   D11,W0L
23DC:  MOV.B   W0L,D82
....................     highbyte = rcv_buffer[4]; 
23DE:  MOV.B   D12,W0L
23E0:  MOV.B   W0L,D83
....................     items = (int16) highbyte; 
23E2:  MOV.B   D83,W0L
23E4:  SE      W0,W0
23E6:  MOV     W0,D84
....................     sysInput.nh4pt1cal1of3 = (items<<8) +  lowbyte;   
23E8:  MOV.B   D84,W0L
23EA:  MOV.B   W0L,B
23EC:  CLR.B   W5
23EE:  MOV.B   D82,W0L
23F0:  SE      W0,W0
23F2:  ADD     W0,W5,W0
23F4:  MOV     W0,C08
....................   
....................     lowbyte = rcv_buffer[5]; 
23F6:  MOV.B   D13,W0L
23F8:  MOV.B   W0L,D82
....................     highbyte = rcv_buffer[6]; 
23FA:  MOV.B   D14,W0L
23FC:  MOV.B   W0L,D83
....................     items = (int16) highbyte; 
23FE:  MOV.B   D83,W0L
2400:  SE      W0,W0
2402:  MOV     W0,D84
....................     sysInput.nh4pt1cal2of3 = (items<<8) +  lowbyte;   
2404:  MOV.B   D84,W0L
2406:  MOV.B   W0L,B
2408:  CLR.B   W5
240A:  MOV.B   D82,W0L
240C:  SE      W0,W0
240E:  ADD     W0,W5,W0
2410:  MOV     W0,C0A
....................      
....................     lowbyte = rcv_buffer[7]; 
2412:  MOV.B   D15,W0L
2414:  MOV.B   W0L,D82
....................     highbyte = rcv_buffer[8]; 
2416:  MOV.B   D16,W0L
2418:  MOV.B   W0L,D83
....................     items = (int16) highbyte; 
241A:  MOV.B   D83,W0L
241C:  SE      W0,W0
241E:  MOV     W0,D84
....................     sysInput.nh4pt1cal3of3 = (items<<8) +  lowbyte;   
2420:  MOV.B   D84,W0L
2422:  MOV.B   W0L,B
2424:  CLR.B   W5
2426:  MOV.B   D82,W0L
2428:  SE      W0,W0
242A:  ADD     W0,W5,W0
242C:  MOV     W0,C0C
....................      
....................          
....................     lowbyte = rcv_buffer[9]; 
242E:  MOV.B   D17,W0L
2430:  MOV.B   W0L,D82
....................     highbyte = rcv_buffer[10]; 
2432:  MOV.B   D18,W0L
2434:  MOV.B   W0L,D83
....................     items = (int16) highbyte; 
2436:  MOV.B   D83,W0L
2438:  SE      W0,W0
243A:  MOV     W0,D84
....................     sysInput.nh4pt2cal1of3 = (items<<8) +  lowbyte;   
243C:  MOV.B   D84,W0L
243E:  MOV.B   W0L,B
2440:  CLR.B   W5
2442:  MOV.B   D82,W0L
2444:  SE      W0,W0
2446:  ADD     W0,W5,W0
2448:  MOV     W0,C0E
....................   
....................     lowbyte = rcv_buffer[11]; 
244A:  MOV.B   D19,W0L
244C:  MOV.B   W0L,D82
....................     highbyte = rcv_buffer[12]; 
244E:  MOV.B   D1A,W0L
2450:  MOV.B   W0L,D83
....................     items = (int16) highbyte; 
2452:  MOV.B   D83,W0L
2454:  SE      W0,W0
2456:  MOV     W0,D84
....................     sysInput.nh4pt2cal2of3 = (items<<8) +  lowbyte;   
2458:  MOV.B   D84,W0L
245A:  MOV.B   W0L,B
245C:  CLR.B   W5
245E:  MOV.B   D82,W0L
2460:  SE      W0,W0
2462:  ADD     W0,W5,W0
2464:  MOV     W0,C10
....................      
....................     lowbyte = rcv_buffer[13]; 
2466:  MOV.B   D1B,W0L
2468:  MOV.B   W0L,D82
....................     highbyte = rcv_buffer[14]; 
246A:  MOV.B   D1C,W0L
246C:  MOV.B   W0L,D83
....................     items = (int16) highbyte; 
246E:  MOV.B   D83,W0L
2470:  SE      W0,W0
2472:  MOV     W0,D84
....................     sysInput.nh4pt2cal3of3 = (items<<8) +  lowbyte;   
2474:  MOV.B   D84,W0L
2476:  MOV.B   W0L,B
2478:  CLR.B   W5
247A:  MOV.B   D82,W0L
247C:  SE      W0,W0
247E:  ADD     W0,W5,W0
2480:  MOV     W0,C12
....................              
....................     lowbyte = rcv_buffer[15]; 
2482:  MOV.B   D1D,W0L
2484:  MOV.B   W0L,D82
....................     highbyte = rcv_buffer[16]; 
2486:  MOV.B   D1E,W0L
2488:  MOV.B   W0L,D83
....................     items = (int16) highbyte; 
248A:  MOV.B   D83,W0L
248C:  SE      W0,W0
248E:  MOV     W0,D84
....................     sysInput.nh4pt3cal1of3 = (items<<8) +  lowbyte;   
2490:  MOV.B   D84,W0L
2492:  MOV.B   W0L,B
2494:  CLR.B   W5
2496:  MOV.B   D82,W0L
2498:  SE      W0,W0
249A:  ADD     W0,W5,W0
249C:  MOV     W0,C14
....................   
....................     lowbyte = rcv_buffer[17]; 
249E:  MOV.B   D1F,W0L
24A0:  MOV.B   W0L,D82
....................     highbyte = rcv_buffer[18]; 
24A2:  MOV.B   D20,W0L
24A4:  MOV.B   W0L,D83
....................     items = (int16) highbyte; 
24A6:  MOV.B   D83,W0L
24A8:  SE      W0,W0
24AA:  MOV     W0,D84
....................     sysInput.nh4pt3cal2of3 = (items<<8) +  lowbyte;   
24AC:  MOV.B   D84,W0L
24AE:  MOV.B   W0L,B
24B0:  CLR.B   W5
24B2:  MOV.B   D82,W0L
24B4:  SE      W0,W0
24B6:  ADD     W0,W5,W0
24B8:  MOV     W0,C16
....................      
....................     lowbyte = rcv_buffer[19]; 
24BA:  MOV.B   D21,W0L
24BC:  MOV.B   W0L,D82
....................     highbyte = rcv_buffer[20]; 
24BE:  MOV.B   D22,W0L
24C0:  MOV.B   W0L,D83
....................     items = (int16) highbyte; 
24C2:  MOV.B   D83,W0L
24C4:  SE      W0,W0
24C6:  MOV     W0,D84
....................     sysInput.nh4pt3cal3of3 = (items<<8) +  lowbyte;   
24C8:  MOV.B   D84,W0L
24CA:  MOV.B   W0L,B
24CC:  CLR.B   W5
24CE:  MOV.B   D82,W0L
24D0:  SE      W0,W0
24D2:  ADD     W0,W5,W0
24D4:  MOV     W0,C18
....................      
....................     // these are the four byte floats 
....................      
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
24D6:  CLR     D86
24D8:  MOV     D86,W4
24DA:  CP      W4,#4
24DC:  BRA     GE,24F4
....................       *((int8*)&data + i) = rcv_buffer[i + 21]; 
24DE:  MOV     #D88,W5
24E0:  MOV     W5,W0
24E2:  ADD     D86,W0
24E4:  MOV     W0,W5
24E6:  MOV     D86,W4
24E8:  ADD     W4,#15,W6
24EA:  MOV     #D0E,W4
24EC:  ADD     W6,W4,W0
24EE:  MOV.B   [W0],[W5]
24F0:  INC     0D86
24F2:  BRA     24D8
....................     sysInput.nh4pt1returnednumber = data; 
24F4:  PUSH    D88
24F6:  POP     C1A
24F8:  PUSH    D8A
24FA:  POP     C1C
....................  
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
24FC:  CLR     D86
24FE:  MOV     D86,W4
2500:  CP      W4,#4
2502:  BRA     GE,251A
....................       *((int8*)&data + i) = rcv_buffer[i + 25]; 
2504:  MOV     #D88,W5
2506:  MOV     W5,W0
2508:  ADD     D86,W0
250A:  MOV     W0,W5
250C:  MOV     D86,W4
250E:  ADD     W4,#19,W6
2510:  MOV     #D0E,W4
2512:  ADD     W6,W4,W0
2514:  MOV.B   [W0],[W5]
2516:  INC     0D86
2518:  BRA     24FE
....................     sysInput.nh4pt1returnednumber = data; 
251A:  PUSH    D88
251C:  POP     C1A
251E:  PUSH    D8A
2520:  POP     C1C
....................  
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
2522:  CLR     D86
2524:  MOV     D86,W4
2526:  CP      W4,#4
2528:  BRA     GE,2540
....................       *((int8*)&data + i) = rcv_buffer[i + 29]; 
252A:  MOV     #D88,W5
252C:  MOV     W5,W0
252E:  ADD     D86,W0
2530:  MOV     W0,W5
2532:  MOV     D86,W4
2534:  ADD     W4,#1D,W6
2536:  MOV     #D0E,W4
2538:  ADD     W6,W4,W0
253A:  MOV.B   [W0],[W5]
253C:  INC     0D86
253E:  BRA     2524
....................     sysInput.nh4pt1returnednumber = data;     
2540:  PUSH    D88
2542:  POP     C1A
2544:  PUSH    D8A
2546:  POP     C1C
2548:  MOV     [--W15],W6
254A:  MOV     [--W15],W5
254C:  RETURN  
....................      
.................... } 
....................  
....................  
.................... #INT_SI2C2 
....................  
.................... void si2c2_interrupt() 
*
0238:  PUSH    42
023A:  PUSH    36
023C:  PUSH    32
023E:  MOV     W0,[W15++]
0240:  MOV     #2,W0
0242:  REPEAT  #C
0244:  MOV     [W0++],[W15++]
....................     { 
....................  
.................... unsigned int8  incoming, state; 
....................  
....................         state=i2c_isr_state(SENSOR); 
0246:  BTSC.B  218.5
0248:  BRA     252
024A:  CLR.B   D78
024C:  BTSS.B  218.2
024E:  BRA     252
0250:  BSET.B  D78.7
0252:  MOV.B   D78,W0L
0254:  CLR.B   1
0256:  INC.B   0D78
0258:  MOV.B   W0L,F2D
....................  
....................    if(state <= 0x80)                      //Master is sending data 
025A:  MOV     F2C,W4
025C:  LSR     W4,#8,W4
025E:  MOV     #80,W3
0260:  CP.B    W3L,W4L
0262:  BRA     NC,2C2
....................    { 
....................       incoming = i2c_read(SENSOR,1);  
0264:  MOV     #1,W1
0266:  MOV     W1,[W15++]
0268:  MOV     [--W15],W1
026A:  CALL    200
026E:  MOV.B   W0L,F2C
....................       if(state == 1)                     //First received byte is address  
0270:  MOV     F2C,W4
0272:  LSR     W4,#8,W4
0274:  CP.B    W4L,#1
0276:  BRA     NZ,27E
....................       {//First received byte is address 
....................          address = incoming; 
0278:  MOV.B   F2C,W0L
027A:  MOV.B   W0L,D0D
....................          streamCntr=0; 
027C:  CLR.B   D4F
....................       } 
....................       if(state == 2)                     //Second received byte is data  
027E:  MOV     F2C,W4
0280:  LSR     W4,#8,W4
0282:  CP.B    W4L,#2
0284:  BRA     NZ,294
....................           {   
....................           rcv_buffer[address] = incoming;  
0286:  MOV     D0C,W4
0288:  LSR     W4,#8,W4
028A:  MOV     #D0E,W3
028C:  ADD     W4,W3,W5
028E:  MOV     F2C,W0
0290:  MOV.B   W0L,[W5+#0]
....................           streamCntr=0; 
0292:  CLR.B   D4F
....................           } 
....................        
....................       if(state == 1)                      //First received byte is address 
0294:  MOV     F2C,W4
0296:  LSR     W4,#8,W4
0298:  CP.B    W4L,#1
029A:  BRA     NZ,2A2
....................          address = incoming; 
029C:  MOV.B   F2C,W0L
029E:  MOV.B   W0L,D0D
02A0:  BRA     2C2
....................       else if(state >= 2 && state != 0x80)   //Received byte is data auto from the master 
02A2:  MOV     F2C,W4
02A4:  LSR     W4,#8,W4
02A6:  CP.B    W4L,#2
02A8:  BRA     NC,2C2
02AA:  MOV     F2C,W4
02AC:  LSR     W4,#8,W4
02AE:  XOR.B   #80,W4L
02B0:  BRA     Z,2C2
....................            { 
....................             rcv_buffer[address++] = incoming; 
02B2:  MOV.B   D0D,W0L
02B4:  INC.B   0D0D
02B6:  ZE      W0,W0
02B8:  MOV     #D0E,W4
02BA:  ADD     W0,W4,W5
02BC:  MOV     F2C,W0
02BE:  MOV.B   W0L,[W5+#0]
....................             streamCntr=0; 
02C0:  CLR.B   D4F
....................             } 
....................    } 
....................  
....................    if((state >= 0x80) & (rcv_buffer[0x40] != 0x01))               //Master is requesting data 
02C2:  MOV     F2C,W4
02C4:  LSR     W4,#8,W4
02C6:  MOV     #80,W3
02C8:  CP.B    W3L,W4L
02CA:  BRA     GTU,2CE
02CC:  BRA     2D2
02CE:  CLR.B   W0
02D0:  BRA     2D4
02D2:  MOV.B   #1,W0L
02D4:  MOV.B   W0L,W5L
02D6:  MOV     D4E,W4
02D8:  CP.B    W4L,#1
02DA:  BRA     NZ,2E0
02DC:  CLR.B   W0
02DE:  BRA     2E2
02E0:  MOV.B   #1,W0L
02E2:  AND.B   W5L,W0L,W0L
02E4:  CP0.B   W0L
02E6:  BRA     Z,2FA
....................    { 
....................  //     if (streamCntr > 0x40)  
.................... //      { 
....................           
....................            
....................  //     } 
....................  //     else 
.................... //      { 
....................       i2c_write(SENSOR,send_buffer[streamCntr++]); 
02E8:  MOV.B   D4F,W0L
02EA:  INC.B   0D4F
02EC:  ZE      W0,W0
02EE:  MOV     #CCC,W4
02F0:  ADD     W0,W4,W0
02F2:  MOV.B   [W0],W5L
02F4:  MOV.B   W5L,W1L
02F6:  CALL    220
.................... //      } 
....................    } 
....................       if((state >= 0x80) & (rcv_buffer[0x40] == 0x01))               //Master is requesting data 
02FA:  MOV     F2C,W4
02FC:  LSR     W4,#8,W4
02FE:  MOV     #80,W3
0300:  CP.B    W3L,W4L
0302:  BRA     GTU,306
0304:  BRA     30A
0306:  CLR.B   W0
0308:  BRA     30C
030A:  MOV.B   #1,W0L
030C:  MOV.B   W0L,W5L
030E:  MOV     D4E,W4
0310:  CP.B    W4L,#1
0312:  BRA     Z,318
0314:  CLR.B   W0
0316:  BRA     31A
0318:  MOV.B   #1,W0L
031A:  AND.B   W5L,W0L,W0L
031C:  CP0.B   W0L
031E:  BRA     Z,328
....................    { 
....................       i2c_write(SENSOR,SENSORNUMBER); 
0320:  MOV.B   #39,W1L
0322:  CALL    220
....................       rcv_buffer[0x40]=0x00; 
0326:  CLR.B   D4E
....................    } 
0328:  BCLR.B  8A.1
032A:  MOV     #1A,W0
032C:  REPEAT  #C
032E:  MOV     [--W15],[W0--]
0330:  MOV     [--W15],W0
0332:  POP     32
0334:  POP     36
0336:  POP     42
0338:  RETFIE  
.................... 	} 
....................     
....................      
....................  
.................... //*********************************************************** 
.................... //***************************************************************************** 
.................... // Created April 6, 2015 
.................... //  This routine finds the constants K1 and K2 for any four given values of O2 concentration and intensity. 
.................... //  IntensityHighOxy matches up with LowOxyPercentage 
.................... //  IntensityLowOxy matches up with HighOxyPercentage 
.................... //  Updated April 29, 2014 
.................... //  This routine is completed with formula for K1 and K2. 
.................... // Added or changed May 18, 2015.   
.................... //  Switched around reading 3 and reading 1 in the void function statment.  This appears to be backwards and conrfusuing when measureing all nine values for DO and temperatures. 
.................... //  ***************************************************************************** 
.................... void SolveForTempCompK1AndK2(float disolvedOxygen1, float disolvedOxygen2, float disolvedOxygen3, float reading3, float reading2, float reading1) 
.................... 	{ 
....................  
.................... //float disolvedOxygen1,disolvedOxygen2,disolvedOxygen3; 
.................... //float reading1,reading2, reading3; 
.................... 	float32 root1,root2,RatioOfIntensity,IntensityReadingfloat; 
.................... 	int32 IntensityReading; 
....................   
.................... //disolvedOxygen1 = 9.600;  //Percent   this is the highest reading 
.................... //disolvedOxygen2 = 2.00;  //Percent 
.................... //disolvedOxygen3 = 0.0;  //Percent   this is the lowest reading 
....................  
.................... float RatioITemp, RatioIITemp; 
....................  
....................  
.................... //reading3 = 1000.0;    ///This is the reading close to tru O2 20% O2. 
.................... //reading2 = 3880.0;    //This is for 5% of O2  
.................... //reading1 = 9000.0;  //This is for the low O2 reading for close to the axis reading.  This is the hight nummber 
....................  
....................  
.................... //  Find the ratios for all three combinations. 
.................... 	RatioITemp=(reading1/reading3)-1.0;  // I0/I1 - 1.0 
.................... 	RatioIITemp=(reading1/reading2)-1.0;    //  I0/I2 - 1.0 
....................  
....................  
.................... // Find K2  
....................      K2Temp = ((RatioITemp/disolvedOxygen1) - (RatioIITemp/disolvedOxygen2))/(disolvedOxygen1 - disolvedOxygen2); 
....................  
.................... // Find K1 
....................  
....................      K1Temp = (RatioITemp-(K2Temp*disolvedOxygen1*disolvedOxygen1))/disolvedOxygen1; 
....................  
....................  
.................... // Find Iohhh  
....................  
.................... //	Iohhh = RatioITemp;   //This used to be reading1   April 7, 2015  Removed and kept as reference. 
....................  
.................... 	Iohhh = reading1;   //This used to be reading1   May 19, 2015 This is the hightest reading for the lowest DO measyrement. 
....................  
....................  
.................... IntensityReading = 16000; 
.................... //IntensityReading = reading3; 
.................... IntensityReadingfloat = (float) IntensityReading;   // Added May 18, 2015.  This is added to convert the hex number into a float so it can be calculated. 
....................  
.................... RatioOfIntensity = 1.0 - Iohhh/IntensityReadingfloat; 
....................  
.................... 	root1 = sqrt(K1Temp*K1Temp - 4.0*RatioOfIntensity*K2Temp)- K1Temp; 
.................... 	 
.................... 	root1 = (root1)/(2.0*K2Temp);  //This is the plus version of the equation 
.................... 	root2 = (-1.0 * K1Temp - (sqrt((K1Temp*K1Temp)-4.0*(RatioOfIntensity)*K2Temp)))/(2.0*K2Temp);  // This is the negative version of the equation.  Most likely not used? 
....................  
....................  
.................... 	} 
....................  
....................  
.................... //*********************************************************************************************************** 
.................... //Created April 6, 2015 
.................... // This routine finds all of the values for DO temperature Compensation. 
.................... //There are four temperatures DO is calibrated for.  Each one has its own set of coefficents that needs to be calculated from the calibration data.   
.................... // All temperatures are measured and converted into Kalvin. 
.................... // All measurments are seperated into ranges split by the temperature ranges. 
.................... //The temperature ranges are as follows: 
.................... // T1 = 10  degrees C. 
.................... // T2 = 20  degrees C. 
.................... // T3 = 25  degrees C. 
.................... // Three sets of I values at differnt O2 concentrations needs to be measured or guessed. 
.................... // One for each temperature.  The K1 and K2 values are found for each temperature and then a set of coefficents for temperature is found. 
.................... // This routine  
.................... //************************************************************************************************************* 
.................... void CalculateK1andK2WithTempComp(float temperature) 
.................... 	{ 
.................... /*   This is commented out because the varuibles are used globally and are saved on the SD Card. Added May 20, 2015 
.................... 	float Temp1DOOne = 9.5;            //These are the set points where we want to read these numbers at temperature 1 
.................... 	float Temp1DOTwo = 4.0;            //This is at 10 degrees 
.................... 	float Temp1DOThree = 0.0; 
....................  
.................... 	float Temp2DOOne = 7.5;            //These are the set points where we want to read these numbers at temperature 2 
.................... 	float Temp2DOTwo = 4.0;				//This is at 20 degrees 
.................... 	float Temp2DOThree = 0.0; 
....................  
.................... 	float Temp3DOOne = 6.7;            //These are the set points where we want to read these numbers temperature 3 
.................... 	float Temp3DOTwo = 4.0;            //This is at 25 degrees 
.................... 	float Temp3DOThree = 0.0; 
....................  
....................  
.................... 	float Temp1ReadingOne = 10752.0;       //Readings for Temp3  10 degrees C 
.................... 	float Temp1ReadingTwo = 11000.0;      //Readings for Temp3 
.................... 	float Temp1ReadingThree = 12000.0;    //Readings for DOOne    this is no DO. 
....................  
.................... 	float Temp2ReadingOne = 11266.0;       //Readings for Temp3    20 degrees C 
.................... 	float Temp2ReadingTwo = 12000.0;      //Readings for Temp3 
.................... 	float Temp2ReadingThree = 13000.0;    //Readings for DOOne 
....................  
.................... 	float Temp3ReadingOne = 12425.0;       //Readings for Temp3   25 degrees C 
.................... 	float Temp3ReadingTwo = 13000.0;      //Readings for Temp3 
.................... 	float Temp3ReadingThree = 14000.0;    //Readings for DOOne 
.................... */ 
.................... 	float  K1TempOne,K2TempOne, K1TempTwo, K2TempTwo, K1TempThree, K2TempThree, TempOneOut, TempTwoOut, TempThreeOut; 
.................... /* 
.................... 	float TempOne = 10.0;       //Calibration temperatures for DO   Added April 7, 2015 
....................  	float TempTwo =  20.0;      //Calibration temperatures for DO  Added April 7, 2015 
.................... 	float TempThree =  25.0;     //Calibration temperatures for DO  Added April 7, 2015 
....................  
.................... */ 
.................... 	float IohhhTempTwo,IohhhTempThree,IohhhTempOne;   //This is added May 18, 2015 for using the Ioh as part of the temperature compensation rourtines. 
....................  
.................... //Find all of the K values for solving temperature compensation.  There needs to be three equations for three unknows for K1, K2 and I which is the highest reading 
....................  
.................... 	SolveForTempCompK1AndK2(Temp3DOOne, Temp3DOTwo, Temp3DOThree, Temp3ReadingOne, Temp3ReadingTwo, Temp3ReadingThree); 
....................  
.................... //Save the first set of K values for Tempature 3  or 25 degrees 
.................... 	K1TempThree = K1Temp; 
.................... 	K2TempThree = K2Temp; 
.................... 	IohhhTempThree = Iohhh; 
....................  
.................... 	SolveForTempCompK1AndK2(Temp2DOOne, Temp2DOTwo, Temp2DOThree, Temp2ReadingOne, Temp2ReadingTwo, Temp2ReadingThree); 
.................... //Save the first set of K values for Tempature 2 which is at 20 degrees C 
.................... 	K1TempTwo = K1Temp; 
.................... 	K2TempTwo = K2Temp; 
.................... 	IohhhTempTwo = Iohhh; 
....................  
.................... 	SolveForTempCompK1AndK2(Temp1DOOne, Temp1DOTwo, Temp1DOThree, Temp1ReadingOne, Temp1ReadingTwo, Temp1ReadingThree); 
.................... //Save the first set of K values for Tempature 1 which is at 10 degrees C 
.................... 	K1TempOne = K1Temp; 
.................... 	K2TempOne = K2Temp; 
.................... 	IohhhTempOne = Iohhh; 
....................  
.................... //******************************************************************************************************* 
.................... //Solve for K1 and find a,b and c for K1 temperature compensation 
.................... //Created April 7, 2015 
.................... //******************************************************************************************************* 
.................... // The temperature needs to be converted to degrees Kalvin 
....................  
....................  
.................... temperature = temperature + 273.0;   //The conversion from C to K is add 273 to degrees C. 
....................  
.................... TempOneOut = TempOne + 273.0;     //The conversion from C to K is add 273 to degrees C. 
.................... TempTwoOut = TempTwo + 273.0;     //The conversion from C to K is add 273 to degrees C. 
.................... TempThreeOut = TempThree + 273.0;     //The conversion from C to K is add 273 to degrees C. 
....................  
.................... //Find K1 coefficents for T = 5  or 273 +5 = 278 degress K. 
....................  
....................       matrixequation[0][0] = 1; 
....................       matrixequation[1][0] = TempOneOut;  
....................       matrixequation[2][0] = TempOneOut * TempOneOut;  
....................       matrixequals[0] = K1TempOne;  
....................       matrixequation[0][1] = 1; 
....................       matrixequation[1][1] = TempTwoOut;  
....................       matrixequation[2][1] = TempTwoOut * TempTwoOut;  
....................       matrixequals[1] = K1TempTwo;  
....................       matrixequation[0][2] = 1; 
....................       matrixequation[1][2] = TempThreeOut;  
....................       matrixequation[2][2] = TempThreeOut * TempThreeOut;     
....................       matrixequals[2] = K1TempThree; 
....................  
.................... ThreeByThreeSolution();  // Call to solve for coefs for K1 
....................  
....................  
.................... 	atwo = MatrixSolution[0];   //Move the solution into the coefs 
.................... 	btwo = MatrixSolution[1];   //Move the solution into the coefs 
.................... 	ctwo = MatrixSolution[2];   //Move the solution into the coefs 
....................  
....................  
.................... //Found solution coefficenta for K1.  Now take the current temperature and calculate the Current K1 value. 
....................  
.................... K1 = atwo + btwo*temperature + ctwo*temperature*temperature; 
....................  
....................       matrixequation[0][0] = 1; 
....................       matrixequation[1][0] = TempOneOut;  
....................       matrixequation[2][0] = TempOneOut * TempOneOut;  
....................       matrixequals[0] = K2TempOne;  
....................       matrixequation[0][1] = 1; 
....................       matrixequation[1][1] = TempTwoOut;  
....................       matrixequation[2][1] = TempTwoOut * TempTwoOut;  
....................       matrixequals[1] = K2TempTwo;  
....................       matrixequation[0][2] = 1; 
....................       matrixequation[1][2] = TempThreeOut;  
....................       matrixequation[2][2] = TempThreeOut * TempThreeOut;     
....................       matrixequals[2] = K2TempThree; 
....................  
.................... ThreeByThreeSolution();  // Call to solve for coefs for K1 
....................  
....................  
.................... 	atwo = MatrixSolution[0];   //Move the solution into the coefs 
.................... 	btwo = MatrixSolution[1];   //Move the solution into the coefs 
.................... 	ctwo = MatrixSolution[2];   //Move the solution into the coefs 
....................  
.................... K2 = atwo + btwo*temperature + ctwo*temperature*temperature; 
....................  
....................  
.................... //Now we need to find the last ratio for light intenstiry Ioooooooo 
....................  
.................... //************************************************************ 
.................... // Save May 18, 2015.  This saved for reference only.  it's the orginal one 
.................... // Iohhhhs have been added as part of the temperature compensation.  It's a ratio, not only one reading. 
.................... //************************************************************ 
....................  
....................  
....................       matrixequation[0][0] = 1; 
....................       matrixequation[1][0] = TempOneOut;  
....................       matrixequation[2][0] = TempOneOut * TempOneOut;  
....................       matrixequals[0] = IohhhTempOne;  
....................       matrixequation[0][1] = 1; 
....................       matrixequation[1][1] = TempTwoOut;  
....................       matrixequation[2][1] = TempTwoOut * TempTwoOut;  
....................       matrixequals[1] = IohhhTempTwo;  
....................       matrixequation[0][2] = 1; 
....................       matrixequation[1][2] = TempThreeOut;  
....................       matrixequation[2][2] = TempThreeOut * TempThreeOut;     
....................       matrixequals[2] = IohhhTempThree; 
....................  
.................... ThreeByThreeSolution();  // Call to solve for coefs for K1 
....................  
....................  
.................... 	atwo = MatrixSolution[0];   //Move the solution into the coefs 
.................... 	btwo = MatrixSolution[1];   //Move the solution into the coefs 
.................... 	ctwo = MatrixSolution[2];   //Move the solution into the coefs 
....................  
.................... Iohhh = atwo + btwo*temperature + ctwo*temperature*temperature; 
....................  
.................... 	} 
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... // Created May 9, 2013 
.................... // This rouitne uses the current read Intensity, K1 and K2 to determine the currnet percent of O2 
.................... // The calibration calculation routine needs to first be run before this routine works. 
.................... // Later on the temperature is also considered for Do compensation. 
.................... //**************************************************************************** 
.................... float CalcaulateDO(unsigned int32 IntensityReading, float temperature) 
.................... 	{ 
....................  
.................... 	float32 root1,root2,RatioOfIntensity,IntensityReadingfloat; 
....................     float tempcalc,tempinside,tempsquare;  //This is used to calcaulte the intermediate steps for the quadratic equation. 
....................  
.................... //*************** 
.................... // May 1, 2014  
.................... // This is commented out to first test the K1 and K2 equations.  Temp comp is added later. 
.................... //*************** 
....................  
.................... //Iohhh = azero + bzero * temperature + czero * temperature * temperature; 
....................  
.................... //K1 = aone + bone * temperature + cone * temperature * temperature; 
.................... //K2 = atwo + btwo * temperature + ctwo * temperature * temperature; 
.................... //SolveForK1AndK2(int16 IntensityLowOxy, int16 IntensityHighOxy, int16 IntensityMiddleOxy, float LowOxyPercentage, float HighOxyPercentage) 
....................  
....................  
.................... //****************************************************************************** 
.................... // Added April 7, 2015 
.................... //  This is the old non-temperature compensated DO calculations. 
.................... //The routine is left for reference and history. 
.................... //SolveForK1AndK2(); 
....................  
.................... //***************************************************************************** 
.................... //Created April 7, 2015 
.................... // The routine below calculates the K1, K2 and Ihooo for the current temperature.  Tempature must be in degrees C. 
.................... CalculateK1andK2WithTempComp(temperature); 
....................  
.................... //************************************************************** //Added April 27, 2014 
.................... // Before the DO can be calculated, it needs to be temperature  
.................... // compensated.  The values of K2, K1 and Iohhh need to be  
.................... // calculated through the three X three matrix temperature shift. 
.................... // ************************************************************** 
.................... //IntensityReading = 200.0;   //this is the test input reading.  This is commeneted out for the real data Nov. 14, 2014 
....................  
.................... IntensityReadingfloat = (float) IntensityReading;   // Added May 18, 2015.  This is added to convert the hex number into a float so it can be calculated. 
....................  
.................... RatioOfIntensity = 1.0 - Iohhh/IntensityReadingfloat; 
....................  
.................... tempcalc = K1*K1; 
.................... tempinside = 4.0*RatioOfIntensity*K2; 
.................... tempcalc = tempcalc - tempinside; 
.................... tempsquare = sqrt(tempcalc); 
....................  
.................... 	root1 = tempsquare - K1; 
.................... 	root1 = sqrt(K1*K1 - 4.0*RatioOfIntensity*K2)- K1; 
.................... 	 
.................... 	root1 = (root1)/(2.0*K2);  //This is the plus version of the equation 
.................... 	root2 = (-1.0 * K1 - (sqrt((K1*K1)-4.0*(RatioOfIntensity)*K2)))/(2.0*K2);  // This is the negative version of the equation.  Most likely not used? 
....................  
.................... 	return(root1);  //If this root is positive, the return it. 
.................... 	} 
....................  
.................... //****************************************************************************** 
.................... //Created May 8, 2017 
.................... // This routine finds the water temperature from the on board thermister using polyninal regression. 
.................... //  It takes the raw data from the ADC at 12 bits and converts it to C. 
.................... // The routing first convert to degrees K and then back to advoid divistion by zero 
.................... // The input paramater is the raw ADC data 
.................... // Returns a float of the tempersture in degrees C. 
.................... //****************************************************************************** 
.................... float CalculateWaterTemperature(int16 inptadc) 
*
1F26:  MOV     W5,[W15++]
1F28:  MOV     #C,W5
1F2A:  REPEAT  #5
1F2C:  MOV     [W5++],[W15++]
1F2E:  MOV     #3,W4
1F30:  MOV     W4,E44
1F32:  MOV     #2,W4
1F34:  MOV     W4,E4C
.................... { 
....................  
....................     int n = 3;  // this is the number of points from the calibration testing.  this changes for more or less data points. 
....................     int x,y,z;  // dummy varaibles for accessing matx[x][y] 
....................     int regressionorder = 2; 
....................     float summationresult, am, amm, ammm;   // this is a temp varible used for adding all of the items. 
.................... //  fill the matrix with n, T, T^2 and T^3 
.................... //  Since this is a second order regression, only a 3X3 matrix is filled. 
....................      
.................... nhcalibration[0][0] = 200.0;   //  this is at 40 degrees C 
1F36:  CLR     D50
1F38:  MOV     #4348,W4
1F3A:  MOV     W4,D52
.................... nhcalibration[0][1] = 40.0 + 273.0;   //  this is at 40 degrees C   // The numbers are backwards in order 
1F3C:  MOV     #8000,W4
1F3E:  MOV     W4,D54
1F40:  MOV     #439C,W4
1F42:  MOV     W4,D56
.................... nhcalibration[1][0] = 448.0;   //  this is at 40 degrees C 
1F44:  CLR     D58
1F46:  MOV     #43E0,W4
1F48:  MOV     W4,D5A
.................... nhcalibration[1][1] = 16.0 + 273.0;   //  this is at 40 degrees C   // The numbers are backwards in order 
1F4A:  MOV     #8000,W4
1F4C:  MOV     W4,D5C
1F4E:  MOV     #4390,W4
1F50:  MOV     W4,D5E
.................... nhcalibration[2][0] = 590.0;   //  this is at 40 degrees C 
1F52:  MOV     #8000,W4
1F54:  MOV     W4,D60
1F56:  MOV     #4413,W4
1F58:  MOV     W4,D62
.................... nhcalibration[2][1] = 6.0 + 273.0;   //  this is at 40 degrees C   // The numbers are backwards in order 
1F5A:  MOV     #8000,W4
1F5C:  MOV     W4,D64
1F5E:  MOV     #438B,W4
1F60:  MOV     W4,D66
....................      
....................     for (y=0; y <= regressionorder; y++) 
1F62:  CLR     E48
1F64:  MOV     E48,W0
1F66:  MOV     E4C,W4
1F68:  CP      W4,W0
1F6A:  BRA     LT,1FDE
....................     { 
....................         for (x=0; x <= regressionorder; x++) 
1F6C:  CLR     E46
1F6E:  MOV     E46,W0
1F70:  MOV     E4C,W4
1F72:  CP      W4,W0
1F74:  BRA     LT,1FDA
....................         { 
....................            summationresult = 0.0;//  set to zero before starting the summation. 
1F76:  CLR     E4E
1F78:  CLR     E50
....................            for (z=0; z < n; z++)  // find the sum of each items needed 
1F7A:  CLR     E4A
1F7C:  MOV     E4A,W0
1F7E:  MOV     E44,W4
1F80:  CP      W4,W0
1F82:  BRA     LE,1FC0
....................            { 
....................                summationresult = summationresult + pow(nhcalibration[z][0],(x+y)); 
1F84:  MOV     E4A,W4
1F86:  MUL.UU  W4,#8,W0
1F88:  MOV     W0,W5
1F8A:  MOV     #D50,W4
1F8C:  ADD     W5,W4,W0
1F8E:  MOV     #C,W4
1F90:  MOV     [W0++],[W4++]
1F92:  MOV     [W0++],[W4++]
1F94:  MOV     E46,W0
1F96:  ADD     E48,W0
1F98:  CALL    6E0
1F9C:  MOV.D   W0,W8
1F9E:  MOV     W6,E6E
1FA0:  MOV     W7,E70
1FA2:  MOV     W8,E72
1FA4:  MOV     W9,E74
1FA6:  CALL    1A94
1FAA:  BCLR.B  43.0
1FAC:  MOV     W0,W2
1FAE:  MOV     W1,W3
1FB0:  MOV     E4E,W0
1FB2:  MOV     E50,W1
1FB4:  CALL    72A
1FB8:  MOV     W0,E4E
1FBA:  MOV     W1,E50
1FBC:  INC     0E4A
1FBE:  BRA     1F7C
....................            } 
....................              
....................             matrixequation[x][y] = summationresult;  // place the sum of the squares or whatever into the array. 
1FC0:  MOV     E46,W4
1FC2:  MUL.UU  W4,#C,W0
1FC4:  MOV     W0,W5
1FC6:  MOV     E48,W4
1FC8:  MUL.UU  W4,#4,W0
1FCA:  ADD     W0,W5,W0
1FCC:  MOV     #AE4,W4
1FCE:  ADD     W0,W4,W5
1FD0:  MOV     #E4E,W4
1FD2:  MOV     [W4++],[W5++]
1FD4:  MOV     [W4++],[W5++]
1FD6:  INC     0E46
1FD8:  BRA     1F6E
....................         } 
1FDA:  INC     0E48
1FDC:  BRA     1F64
....................     } 
....................     matx[0][0] = (float) n;  // place the first location the number of samples for the regression matrix. 
1FDE:  MOV     E44,W0
1FE0:  CALL    6E0
1FE4:  MOV     W0,AC0
1FE6:  MOV     W1,AC2
....................  
....................     // figure out the blue color times the input number sumation. 
....................      
....................     for (x=0; x < n; x++ ) 
1FE8:  CLR     E46
1FEA:  MOV     E46,W0
1FEC:  MOV     E44,W4
1FEE:  CP      W4,W0
1FF0:  BRA     LE,206A
....................     { 
....................        summationresult = 0.0;//  set to zero before starting the summation. 
1FF2:  CLR     E4E
1FF4:  CLR     E50
....................        for (z=0; z < n; z++)  // find the sum of each items needed  
1FF6:  CLR     E4A
1FF8:  MOV     E4A,W0
1FFA:  MOV     E44,W4
1FFC:  CP      W4,W0
1FFE:  BRA     LE,2058
....................        { 
....................         summationresult = summationresult + nhcalibration[z][1]*pow(nhcalibration[z][0],x); 
2000:  MOV     E4A,W4
2002:  MUL.UU  W4,#8,W0
2004:  MOV     W0,W5
2006:  ADD     W5,#4,W0
2008:  MOV     #D50,W4
200A:  ADD     W0,W4,W0
200C:  MOV     #A,W4
200E:  MOV     [W0++],[W4++]
2010:  MOV     [W0++],[W4++]
2012:  MOV     E4A,W4
2014:  MUL.UU  W4,#8,W0
2016:  MOV     W0,W7
2018:  MOV     #D50,W4
201A:  ADD     W7,W4,W0
201C:  MOV     #10,W4
201E:  MOV     [W0++],[W4++]
2020:  MOV     [W0++],[W4++]
2022:  MOV     E46,W0
2024:  CALL    6E0
2028:  MOV.D   W0,W10
202A:  MOV     W8,E6E
202C:  MOV     W9,E70
202E:  MOV     W10,E72
2030:  MOV     W11,E74
2032:  CALL    1A94
2036:  MOV     W0,W2
2038:  MOV     W1,W3
203A:  MOV     W5,W0
203C:  MOV     W6,W1
203E:  CALL    1082
2042:  BCLR.B  43.0
2044:  MOV     W0,W2
2046:  MOV     W1,W3
2048:  MOV     E4E,W0
204A:  MOV     E50,W1
204C:  CALL    72A
2050:  MOV     W0,E4E
2052:  MOV     W1,E50
2054:  INC     0E4A
2056:  BRA     1FF8
....................        } 
....................         matrixequals[x] = summationresult; 
2058:  MOV     E46,W4
205A:  MUL.UU  W4,#4,W0
205C:  MOV     #B08,W4
205E:  ADD     W0,W4,W5
2060:  MOV     #E4E,W4
2062:  MOV     [W4++],[W5++]
2064:  MOV     [W4++],[W5++]
2066:  INC     0E46
2068:  BRA     1FEA
....................     } 
....................     ThreeByThreeSolution();    //  find the coeffs 
206A:  CALL    1D84
....................          
....................     ammm= MatrixSolution[2]; 
206E:  PUSH    B1C
2070:  POP     E5A
2072:  PUSH    B1E
2074:  POP     E5C
....................     amm = MatrixSolution[1]; 
2076:  PUSH    B18
2078:  POP     E56
207A:  PUSH    B1A
207C:  POP     E58
....................     am = MatrixSolution[0]; 
207E:  PUSH    B14
2080:  POP     E52
2082:  PUSH    B16
2084:  POP     E54
....................     summationresult = (float) inptadc; 
2086:  MOV     E42,W0
2088:  CALL    6E0
208C:  MOV     W0,E4E
208E:  MOV     W1,E50
....................     summationresult = am + amm*summationresult + ammm*summationresult*summationresult; 
2090:  MOV     E56,W0
2092:  MOV     E58,W1
2094:  MOV     E4E,W2
2096:  MOV     E50,W3
2098:  CALL    1082
209C:  BCLR.B  43.0
209E:  MOV     W0,W2
20A0:  MOV     W1,W3
20A2:  MOV     E52,W0
20A4:  MOV     E54,W1
20A6:  CALL    72A
20AA:  MOV     W0,W5
20AC:  MOV     W1,W6
20AE:  MOV     E5A,W0
20B0:  MOV     E5C,W1
20B2:  MOV     E4E,W2
20B4:  MOV     E50,W3
20B6:  CALL    1082
20BA:  MOV     W0,W7
20BC:  MOV     W1,W8
20BE:  MOV     W7,W0
20C0:  MOV     W8,W1
20C2:  MOV     E4E,W2
20C4:  MOV     E50,W3
20C6:  CALL    1082
20CA:  BCLR.B  43.0
20CC:  MOV     W0,W2
20CE:  MOV     W1,W3
20D0:  MOV     W5,W0
20D2:  MOV     W6,W1
20D4:  CALL    72A
20D8:  MOV     W0,E4E
20DA:  MOV     W1,E50
....................      
....................     return(summationresult); 
20DC:  MOV     E4E,W0
20DE:  MOV     E50,W1
20E0:  MOV     #16,W5
20E2:  REPEAT  #5
20E4:  MOV     [--W15],[W5--]
20E6:  MOV     [--W15],W5
20E8:  RETURN  
....................      
.................... } 
....................  
....................   
.................... //************************************************************* 
.................... // Created Nov. 6, 2012 
.................... //  This routine reads an ADC and averages 16 samples into one and returns the number. 
.................... // There is no scaling or any signal condition except for a low pass averaging filter. 
.................... //  The input selection is for ADC 1, 2, 3 and 5.  The numbers 0, 1, 2 and 4 are used for selecting the ADC. 
.................... //************************************************************* 
....................  
.................... int16 GetADCValue(int selection) 
.................... 	{ 
.................... 	int16 ReturnedADC, Summer;	 
.................... 	int f; 
.................... 					//setup_adc(ADC_CLOCK_INTERNAL);  //Setup the ADC to run.. 
.................... 					set_adc_channel(selection);  
*
14BA:  MOV     E42,W1
14BC:  AND     #1F,W1
14BE:  MOV     #FF,W2
14C0:  INC     W2,W2
14C2:  AND     #7,W2
14C4:  SL      W2,#5,W2
14C6:  IOR      W1,  W2,W1
14C8:  MOV     W1,348
....................                     		delay_ms(10); 
14CA:  MOV     #A,W0
14CC:  CALL    356
.................... 					Summer=0; 
14D0:  CLR     E46
.................... 					for (f=0; f < 32; f++) 
14D2:  CLR     E48
14D4:  MOV     E48,W4
14D6:  MOV     #20,W3
14D8:  CP      W3,W4
14DA:  BRA     LE,14F2
.................... 						{ 
.................... 					delay_us(10); 
14DC:  REPEAT  #9E
14DE:  NOP     
.................... 					Summer = Summer + read_adc(); // Read adc channel 10  
14E0:  BCLR.B  340.0
14E2:  BSET.B  340.1
14E4:  BTSS.B  340.0
14E6:  BRA     14E4
14E8:  MOV     300,W0
14EA:  LSR     W0,#2,W0
14EC:  ADD     E46
14EE:  INC     0E48
14F0:  BRA     14D4
.................... 						} 
.................... 					ReturnedADC = Summer>>5; 
14F2:  MOV     E46,W0
14F4:  LSR     W0,#5,W0
14F6:  MOV     W0,E44
.................... 	return(ReturnedADC);	 
14F8:  PUSH    E44
14FA:  POP     0
14FC:  RETURN  
.................... 	} 
....................  
....................  
....................  
....................  
.................... //***************************************************************** 
.................... // Created Nov. 6, 2012 
.................... // Converts the ADC number on a scale of 5 volts minus some for Op-amp issues 
.................... // The numerical convertion is conveted into degrees C. 
.................... // The returned value in C degrees. 
.................... //  Ths interm convertion is to Kalvin and will later be switched over to Kalvin scale. 
.................... //***************************************************************** 
....................   
....................  
.................... float ConvertADCToKalvin(int ADCInputNumber) 
*
20EA:  MOV     W5,[W15++]
20EC:  MOV     W6,[W15++]
.................... 	{ 
.................... int16 ReturnedADC; 
.................... float32 Kelvin; 
....................     int8 highbyte, lowbyte; 
....................     int16 returneditem;  // this is the returned item 
.................... 	ReturnedADC = GetADCValue(ADCInputNumber);  //This gets the current ADC convertion for the channel number. 
20EE:  PUSH    E38
20F0:  POP     E42
20F2:  CALL    14BA
20F6:  MOV     W0,E3A
.................... //    ADCVoltageIn = ReturnedADC * 5.0 / 1024.0;  //Recycled the same float variable.  This is for the 5 volts version. 
....................  // tempfloater = (float) ReturnedADC; 
....................   //ADCVoltageIn = (float) ReturnedADC * 3.3 / 1024.0;  //Recycled the same float variable.  This converts the input into scaling 
....................  
....................         lowbyte = 0x00FF & ReturnedADC; 
20F8:  MOV     E3A,W0
20FA:  AND     #FF,W0
20FC:  MOV.B   W0L,E37
....................         returneditem = 0xFF00 & ReturnedADC; 
20FE:  PUSH    E3A
2100:  POP     E40
2102:  MOV     #FF00,W0
2104:  AND     E40
....................         highbyte = ReturnedADC/256;  // this moves it over to the low part 
2106:  MOV     E3A,W4
2108:  MOV     #100,W3
210A:  REPEAT  #11
210C:  DIV.S   W4,W3
210E:  MOV.B   W0L,E36
....................         send_buffer[14] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
2110:  MOV.B   E37,W0L
2112:  MOV.B   W0L,CDA
....................         send_buffer[13] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
2114:  MOV.B   E36,W0L
2116:  MOV.B   W0L,CD9
....................  
....................  
.................... Kelvin = CalculateWaterTemperature(ReturnedADC) - 273.0; 
2118:  PUSH    E3A
211A:  POP     E42
211C:  CALL    1F26
2120:  MOV     W0,W5
2122:  MOV     W1,W6
2124:  BSET.B  43.0
2126:  MOV     W5,W0
2128:  MOV     W6,W1
212A:  MOV     #8000,W2
212C:  MOV     #4388,W3
212E:  CALL    72A
2132:  MOV     W0,E3C
2134:  MOV     W1,E3E
....................  
.................... 	return(Kelvin); 
2136:  MOV     E3C,W0
2138:  MOV     E3E,W1
213A:  MOV     [--W15],W6
213C:  MOV     [--W15],W5
213E:  RETURN  
.................... 	} 
....................  
....................  
....................  
.................... //********************************************************************* 
.................... // Created June 25, 2015 
.................... // This routine calls the water temperature program and averages together twenty points.  Twenty two points are 
.................... // collected and the high and low reading is thrown out.   
.................... // There is no input needed in this routine.  The result is returned as a float. 
.................... //********************************************************************* 
.................... float WaterTemperature(void) 
2140:  MOV     W5,[W15++]
2142:  MOV     W6,[W15++]
2144:  MOV     W7,[W15++]
.................... 	{ 
.................... float temparray[42], tempval; 
....................  
.................... int  switchflag,x;  //This is used in the ordering routine to indicate if two numbers have been switched.  If not, then the array is in numerical order. 
....................  
.................... for (x=0; x < 42; x++)   // Get all of the readings and save them in an array. 
2146:  CLR     E30
2148:  MOV     E30,W4
214A:  MOV     #2A,W3
214C:  CP      W3,W4
214E:  BRA     LE,216A
.................... 	{ 
.................... 	temparray[x] = ConvertADCToKalvin(11);   //This called current thermisting reading routine. It returns a temperature reading in C. 
2150:  MOV     E30,W4
2152:  MUL.UU  W4,#4,W0
2154:  MOV     #D82,W4
2156:  ADD     W0,W4,W5
2158:  MOV     #B,W4
215A:  MOV     W4,E38
215C:  CALL    20EA
2160:  MOV     #0,W4
2162:  MOV     [W4++],[W5++]
2164:  MOV     [W4++],[W5++]
2166:  INC     0E30
2168:  BRA     2148
.................... 	} 
....................  
.................... //  Place the numbers in order in the array from the lowest reading at the high numbers indexs and the hightest readings at the low indexes. 
....................  
.................... do { 
.................... switchflag =0;  //Set it to zero indicating everything is in order. 
216A:  CLR     E2E
.................... for (x=0; x < 41; x++) 
216C:  CLR     E30
216E:  MOV     E30,W4
2170:  MOV     #29,W3
2172:  CP      W3,W4
2174:  BRA     LE,21E6
.................... 	{ 
.................... 	if (temparray[x] < temparray[x+1]) 
2176:  MOV     E30,W4
2178:  MUL.UU  W4,#4,W0
217A:  MOV     #D82,W4
217C:  ADD     W0,W4,W0
217E:  MOV     #A,W4
2180:  MOV     [W0++],[W4++]
2182:  MOV     [W0++],[W4++]
2184:  MOV     E30,W4
2186:  ADD     W4,#1,W7
2188:  MOV     W7,W4
218A:  MUL.UU  W4,#4,W0
218C:  MOV     #D82,W4
218E:  ADD     W0,W4,W0
2190:  MOV     W0,W4
2192:  MOV     #0,W3
2194:  MOV     [W4++],[W3++]
2196:  MOV     [W4++],[W3++]
2198:  MOV     W0,W2
219A:  MOV     W1,W3
219C:  MOV     W5,W0
219E:  MOV     W6,W1
21A0:  CALL    14FE
21A4:  BRA     NC,21E2
.................... 		{ 
.................... 		tempval = temparray[x]; 
21A6:  MOV     E30,W4
21A8:  MUL.UU  W4,#4,W0
21AA:  MOV     #D82,W4
21AC:  ADD     W0,W4,W0
21AE:  MOV     #E2A,W4
21B0:  MOV     [W0++],[W4++]
21B2:  MOV     [W0++],[W4++]
.................... 		temparray[x] = temparray[x+1]; 
21B4:  MOV     E30,W4
21B6:  MUL.UU  W4,#4,W0
21B8:  MOV     #D82,W4
21BA:  ADD     W0,W4,W5
21BC:  MOV     E30,W4
21BE:  ADD     W4,#1,W6
21C0:  MOV     W6,W4
21C2:  MUL.UU  W4,#4,W0
21C4:  MOV     #D82,W4
21C6:  ADD     W0,W4,W0
21C8:  MOV     [W0++],[W5++]
21CA:  MOV     [W0++],[W5++]
.................... 		temparray[x+1] = tempval; 
21CC:  MOV     E30,W4
21CE:  ADD     W4,#1,W5
21D0:  MOV     W5,W4
21D2:  MUL.UU  W4,#4,W0
21D4:  MOV     #D82,W4
21D6:  ADD     W0,W4,W5
21D8:  MOV     #E2A,W4
21DA:  MOV     [W4++],[W5++]
21DC:  MOV     [W4++],[W5++]
.................... 		// Since this case is true, then switch the numbers in the array and set the not completed flag to 1. 
.................... 		switchflag =1;   //  Indicate are reversal needed to be done. 
21DE:  MOV     #1,W4
21E0:  MOV     W4,E2E
.................... 		} 
21E2:  INC     0E30
21E4:  BRA     216E
.................... 	} 
.................... } while(switchflag == 1);   //If the value is zero, the array is in order. 
21E6:  MOV     E2E,W4
21E8:  CP      W4,#1
21EA:  BRA     Z,216A
....................  
....................  
.................... //  Average the numbers between 1 and 21.  This will kick out the hightest and lowest readings. 
.................... tempval = 0;   //recycled the varaible used for averaging the readings together. 
21EC:  CLR     E2A
21EE:  CLR     E2C
.................... for (x = 1; x < 41; x++) 
21F0:  MOV     #1,W4
21F2:  MOV     W4,E30
21F4:  MOV     E30,W4
21F6:  MOV     #29,W3
21F8:  CP      W3,W4
21FA:  BRA     LE,2222
.................... 	{ 
.................... 	tempval=tempval+temparray[x]; 
21FC:  MOV     E30,W4
21FE:  MUL.UU  W4,#4,W0
2200:  MOV     #D82,W4
2202:  ADD     W0,W4,W0
2204:  MOV     W0,W4
2206:  MOV     #0,W3
2208:  MOV     [W4++],[W3++]
220A:  MOV     [W4++],[W3++]
220C:  BCLR.B  43.0
220E:  MOV     W0,W2
2210:  MOV     W1,W3
2212:  MOV     E2A,W0
2214:  MOV     E2C,W1
2216:  CALL    72A
221A:  MOV     W0,E2A
221C:  MOV     W1,E2C
221E:  INC     0E30
2220:  BRA     21F4
.................... 	} 
.................... 	tempval = tempval/40.0;   //Divide the added number by 20 which is the number of values added together. 
2222:  MOV     E2A,W0
2224:  MOV     E2C,W1
2226:  MOV     #0,W2
2228:  MOV     #4220,W3
222A:  CALL    90E
222E:  MOV     W0,E2A
2230:  MOV     W1,E2C
....................  
....................  
.................... 	return(tempval); 
2232:  MOV     E2A,W0
2234:  MOV     E2C,W1
2236:  MOV     [--W15],W7
2238:  MOV     [--W15],W6
223A:  MOV     [--W15],W5
223C:  RETURN  
.................... 	} 
....................  
....................  
....................  
....................  
.................... //***************************************************************************************************** 
.................... // Created May 19, 2014 
.................... // Completed May 23, 2014 
.................... // This routine reads the data from the DO or pH.  This is including the pre-deteremined gains 
.................... // The inputs are as following: 
.................... // PWM input channel 
.................... //  The PWM magic number 
.................... // the channel sensor input channel    
.................... // DO is sensor 1 
....................  
.................... // SensprControl is  a number between 1 to 3 for each I2C 
.................... // PWMIntensity  this is the general starting point for the PWM 
.................... //  RequiredReading  - this is the required light reading needed to make a measurement.  THE PID will converg on this number. 
.................... //  Use the Pgain in the routine below to control the quickness of convergance. 
.................... //  the result is an unsigned 16 bit interger. 
.................... //***************************************************************************************************** 
.................... void TakeLightReading(int SensorChannel) 
.................... { 
....................  
....................   
....................      
.................... //************************************************************************************* 
.................... //  Added Augest 28, 2015 
.................... // This section measures the DO 
.................... //************************************************************************************* 
.................... //****************************************************************************** 
.................... // Created November 14, 2016 
.................... //  This routine measure the light patch for DO. 
.................... // This routine cycles through all of the colors and gets the number for each LED turned on.  This helps with filtering. 
.................... //  Nothing is returned   
.................... //****************************************************************************** 
.................... if (SensorChannel == 0) 
.................... { 
.................... 	selectsensor(SensorChannel);    // Added December 9, 2015     Sensor 1 is NH4. 
....................  
....................     output_high(PIN_B12);  // turn on green 
....................     delay_ms(100);  // set a PWM setup delay to stablize the timing. 
.................... } 
....................  
....................  
.................... if (SensorChannel == 1) 
.................... { 
.................... 	selectsensor(SensorChannel);    // Added December 9, 2015     Sensor 1 is NH4. 
....................     output_high(PIN_B12);  // turn on green 
....................     delay_ms(100);  // set a PWM setup delay to stablize the timing. 
.................... } 
....................  
....................  
.................... // 2 is not populated.  Added April 5, 2017 
.................... if (SensorChannel == 3) 
.................... { 
.................... 	selectsensor(SensorChannel);    // Added December 9, 2015     Sensor 1 is NH4. 
....................     output_high(PIN_B12);  // turn on green 
....................     delay_ms(100);  // set a PWM setup delay to stablize the timing. 
.................... } 
....................  
.................... 	 GetCurrentColorAVG(0, SensorChannel);   // Number 2 is the colored  LED.  The 4 means it any gain reading 
....................  
.................... // turn off all lights 
.................... 	output_low(PIN_B12);    // turn off the blue light 
....................   
.................... 	//redABS = redABS - AmbientOxyRed; 
.................... //	greenABS = greenABS - AmbientOxyGreen; 
.................... 	//blueABS = blueABS - AmbientOxyBlue; 
.................... 	//clearABS = clearABS - AmbientOxyClear; 
....................  
.................... //if the number is less than 0, then set it to zero.  It's not possible to have negitave light. 
.................... // on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
.................... /* 
.................... if (blueABS < 0) 
.................... 	{ 
.................... 	blueABS = 0; 
.................... 	} 
.................... if (clearABS < 0) 
.................... 	{ 
.................... 	clearABS = 0; 
.................... 	}     
....................  
....................         lowbyte = 0x00FF & redABS; 
....................         returneditem = 0xFF00 & redABS; 
....................         highbyte = redABS>8;  // this moves it over to the low part 
....................         send_buffer[20] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
....................         send_buffer[19] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the    
....................      
....................      
.................... if (greenABS < 0) 
.................... 	{ 
.................... 	greenABS = 0; 
.................... 	} 
.................... if (blueABS < 0) 
.................... 	{ 
.................... 	blueABS = 0; 
.................... 	} 
.................... if (clearABS < 0) 
.................... 	{ 
.................... 	clearABS = 0; 
.................... 	}     
....................          
....................   
....................         lowbyte = 0x00FF & blueABS; 
....................         returneditem = 0xFF00 & blueABS; 
....................         highbyte = blueABS>8;  // this moves it over to the low part 
....................         send_buffer[24] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
....................         send_buffer[23] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the        
....................      
....................    } 
....................       // check for white 
....................         // turn on all of the LEDS for white 
....................     if (x==3)  // this checks the green light 
....................      { 
....................     output_low(PIN_B11);    // turn on the blue light 
....................     output_low(PIN_B12);    // turn on the blue light 
....................     output_low(PIN_B10);    // turn off the red light 
....................         delay_ms(200);  // set a PWM setup delay to stablize the timing. 
.................... 	color = GetCurrentColorAVG(3, 2);   // Number 2 is the colored  LED.  The 4 means it any gain reading 
.................... 	output_high(PIN_B11);    // turn on the blue light 
....................     output_high(PIN_B12);    // turn on the blue light 
....................     output_high(PIN_B10);    // turn off the red light 
....................   
.................... 	//redABS = redABS - AmbientOxyRed; 
.................... 	//greenABS = greenABS - AmbientOxyGreen; 
.................... 	//blueABS = blueABS - AmbientOxyBlue; 
.................... 	clearABS = clearABS - AmbientOxyClear; 
....................  
....................      
....................     if (clearABS < 0) 
.................... 	{ 
.................... 	clearABS = 0; 
.................... 	}  
....................      
....................         lowbyte = 0x00FF & clearABS; 
....................         returneditem = 0xFF00 & clearABS; 
....................         highbyte = clearABS>8;  // this moves it over to the low part 
....................         send_buffer[26] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
....................         send_buffer[25] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
....................   
....................     }     
....................     } 
....................     } 
....................  */ 
.................... 	} 
....................  
....................  
.................... //*************************************************************************************************** 
.................... // Created May 5, 2017 
.................... // This routine uses polynomal regresion for determining the NN4 + NH3 from the optical patch 
.................... // Right now it only solves for second order.  All of the hooks are left in place for third order. 
.................... //  The input color value is entered as a int16 
.................... // Returned is a float of the resultant NN4 + NH3.  It needs to be seperated between NH4 and NH3 
.................... float calculateAmmonia(int inputcolor) 
223E:  MOV     W5,[W15++]
2240:  MOV     #C,W5
2242:  REPEAT  #5
2244:  MOV     [W5++],[W15++]
2246:  MOV     #4,W4
2248:  MOV     W4,D84
224A:  MOV     #2,W4
224C:  MOV     W4,D8C
.................... { 
....................     int n = 4;  // this is the number of points from the calibration testing.  this changes for more or less data points. 
....................     int x,y,z;  // dummy varaibles for accessing matx[x][y] 
....................     int regressionorder = 2; 
....................     float summationresult, am, amm, ammm;   // this is a temp varible used for adding all of the items. 
.................... //  fill the matrix with n, T, T^2 and T^3 
.................... //  Since this is a second order regression, only a 3X3 matrix is filled. 
....................      
....................     for (y=0; y <= regressionorder; y++) 
224E:  CLR     D88
2250:  MOV     D88,W0
2252:  MOV     D8C,W4
2254:  CP      W4,W0
2256:  BRA     LT,22CA
....................     { 
....................         for (x=0; x <= regressionorder; x++) 
2258:  CLR     D86
225A:  MOV     D86,W0
225C:  MOV     D8C,W4
225E:  CP      W4,W0
2260:  BRA     LT,22C6
....................         { 
....................            summationresult = 0.0;//  set to zero before starting the summation. 
2262:  CLR     D8E
2264:  CLR     D90
....................            for (z=0; z < n; z++)  // find the sum of each items needed 
2266:  CLR     D8A
2268:  MOV     D8A,W0
226A:  MOV     D84,W4
226C:  CP      W4,W0
226E:  BRA     LE,22AC
....................            { 
....................                summationresult = summationresult + pow(nhcalibration[z][0],(x+y)); 
2270:  MOV     D8A,W4
2272:  MUL.UU  W4,#8,W0
2274:  MOV     W0,W5
2276:  MOV     #D50,W4
2278:  ADD     W5,W4,W0
227A:  MOV     #C,W4
227C:  MOV     [W0++],[W4++]
227E:  MOV     [W0++],[W4++]
2280:  MOV     D86,W0
2282:  ADD     D88,W0
2284:  CALL    6E0
2288:  MOV.D   W0,W8
228A:  MOV     W6,E6E
228C:  MOV     W7,E70
228E:  MOV     W8,E72
2290:  MOV     W9,E74
2292:  CALL    1A94
2296:  BCLR.B  43.0
2298:  MOV     W0,W2
229A:  MOV     W1,W3
229C:  MOV     D8E,W0
229E:  MOV     D90,W1
22A0:  CALL    72A
22A4:  MOV     W0,D8E
22A6:  MOV     W1,D90
22A8:  INC     0D8A
22AA:  BRA     2268
....................            } 
....................              
....................             matrixequation[x][y] = summationresult;  // place the sum of the squares or whatever into the array. 
22AC:  MOV     D86,W4
22AE:  MUL.UU  W4,#C,W0
22B0:  MOV     W0,W5
22B2:  MOV     D88,W4
22B4:  MUL.UU  W4,#4,W0
22B6:  ADD     W0,W5,W0
22B8:  MOV     #AE4,W4
22BA:  ADD     W0,W4,W5
22BC:  MOV     #D8E,W4
22BE:  MOV     [W4++],[W5++]
22C0:  MOV     [W4++],[W5++]
22C2:  INC     0D86
22C4:  BRA     225A
....................         } 
22C6:  INC     0D88
22C8:  BRA     2250
....................     } 
....................     matx[0][0] = (float) n;  // place the first location the number of samples for the regression matrix. 
22CA:  MOV     D84,W0
22CC:  CALL    6E0
22D0:  MOV     W0,AC0
22D2:  MOV     W1,AC2
....................  
....................     // figure out the blue color times the input number sumation. 
....................      
....................     for (x=0; x < n; x++ ) 
22D4:  CLR     D86
22D6:  MOV     D86,W0
22D8:  MOV     D84,W4
22DA:  CP      W4,W0
22DC:  BRA     LE,2356
....................     { 
....................        summationresult = 0.0;//  set to zero before starting the summation. 
22DE:  CLR     D8E
22E0:  CLR     D90
....................        for (z=0; z < n; z++)  // find the sum of each items needed  
22E2:  CLR     D8A
22E4:  MOV     D8A,W0
22E6:  MOV     D84,W4
22E8:  CP      W4,W0
22EA:  BRA     LE,2344
....................        { 
....................         summationresult = summationresult + nhcalibration[z][1]*pow(nhcalibration[z][0],x); 
22EC:  MOV     D8A,W4
22EE:  MUL.UU  W4,#8,W0
22F0:  MOV     W0,W5
22F2:  ADD     W5,#4,W0
22F4:  MOV     #D50,W4
22F6:  ADD     W0,W4,W0
22F8:  MOV     #A,W4
22FA:  MOV     [W0++],[W4++]
22FC:  MOV     [W0++],[W4++]
22FE:  MOV     D8A,W4
2300:  MUL.UU  W4,#8,W0
2302:  MOV     W0,W7
2304:  MOV     #D50,W4
2306:  ADD     W7,W4,W0
2308:  MOV     #10,W4
230A:  MOV     [W0++],[W4++]
230C:  MOV     [W0++],[W4++]
230E:  MOV     D86,W0
2310:  CALL    6E0
2314:  MOV.D   W0,W10
2316:  MOV     W8,E6E
2318:  MOV     W9,E70
231A:  MOV     W10,E72
231C:  MOV     W11,E74
231E:  CALL    1A94
2322:  MOV     W0,W2
2324:  MOV     W1,W3
2326:  MOV     W5,W0
2328:  MOV     W6,W1
232A:  CALL    1082
232E:  BCLR.B  43.0
2330:  MOV     W0,W2
2332:  MOV     W1,W3
2334:  MOV     D8E,W0
2336:  MOV     D90,W1
2338:  CALL    72A
233C:  MOV     W0,D8E
233E:  MOV     W1,D90
2340:  INC     0D8A
2342:  BRA     22E4
....................        } 
....................         matrixequals[x] = summationresult; 
2344:  MOV     D86,W4
2346:  MUL.UU  W4,#4,W0
2348:  MOV     #B08,W4
234A:  ADD     W0,W4,W5
234C:  MOV     #D8E,W4
234E:  MOV     [W4++],[W5++]
2350:  MOV     [W4++],[W5++]
2352:  INC     0D86
2354:  BRA     22D6
....................     } 
....................     ThreeByThreeSolution();    //  find the coeffs 
2356:  CALL    1D84
....................          
....................     ammm= MatrixSolution[2]; 
235A:  PUSH    B1C
235C:  POP     D9A
235E:  PUSH    B1E
2360:  POP     D9C
....................     amm = MatrixSolution[1]; 
2362:  PUSH    B18
2364:  POP     D96
2366:  PUSH    B1A
2368:  POP     D98
....................     am = MatrixSolution[0]; 
236A:  PUSH    B14
236C:  POP     D92
236E:  PUSH    B16
2370:  POP     D94
....................     summationresult = (float) inputcolor; 
2372:  MOV     D82,W0
2374:  CALL    6E0
2378:  MOV     W0,D8E
237A:  MOV     W1,D90
....................     summationresult = am + amm*summationresult + ammm*summationresult*summationresult; 
237C:  MOV     D96,W0
237E:  MOV     D98,W1
2380:  MOV     D8E,W2
2382:  MOV     D90,W3
2384:  CALL    1082
2388:  BCLR.B  43.0
238A:  MOV     W0,W2
238C:  MOV     W1,W3
238E:  MOV     D92,W0
2390:  MOV     D94,W1
2392:  CALL    72A
2396:  MOV     W0,W5
2398:  MOV     W1,W6
239A:  MOV     D9A,W0
239C:  MOV     D9C,W1
239E:  MOV     D8E,W2
23A0:  MOV     D90,W3
23A2:  CALL    1082
23A6:  MOV     W0,W7
23A8:  MOV     W1,W8
23AA:  MOV     W7,W0
23AC:  MOV     W8,W1
23AE:  MOV     D8E,W2
23B0:  MOV     D90,W3
23B2:  CALL    1082
23B6:  BCLR.B  43.0
23B8:  MOV     W0,W2
23BA:  MOV     W1,W3
23BC:  MOV     W5,W0
23BE:  MOV     W6,W1
23C0:  CALL    72A
23C4:  MOV     W0,D8E
23C6:  MOV     W1,D90
....................      
....................     return(summationresult); 
23C8:  MOV     D8E,W0
23CA:  MOV     D90,W1
23CC:  MOV     #16,W5
23CE:  REPEAT  #5
23D0:  MOV     [--W15],[W5--]
23D2:  MOV     [--W15],W5
23D4:  RETURN  
.................... } 
....................  
....................  
....................  
....................  
.................... //********************************************************************* 
.................... //  
.................... void main(void){ 
*
254E:  MOV     #F40,W15
2550:  MOV     #FFF,W0
2552:  MOV     W0,20
2554:  NOP     
2556:  BSET.B  81.7
2558:  BSET.B  44.2
255A:  MOV     #0,W0
255C:  MOV     W0,34
255E:  CLR     744
2560:  BCLR.B  2CC.2
2562:  BSET.B  217.7
2564:  BSET.B  217.5
2566:  BSET.B  216.6
2568:  BCLR.B  217.3
256A:  BSET.B  216.7
256C:  BCLR.B  217.0
256E:  BSET.B  217.1
2570:  BCLR.B  217.2
2572:  MOV     #50,W4
2574:  MOV     W4,21A
2576:  BCLR.B  2CD.1
2578:  BSET.B  207.7
257A:  BSET.B  207.5
257C:  BSET.B  206.6
257E:  BCLR.B  207.3
2580:  BSET.B  206.7
2582:  BCLR.B  207.0
2584:  BSET.B  207.1
2586:  BCLR.B  207.2
2588:  CLR     20A
258A:  MOV     #9D,W4
258C:  MOV     W4,204
258E:  CLR.B   A25
2590:  CLR.B   AB2
2592:  MOV.B   #2,W0L
2594:  MOV.B   W0L,AB3
2596:  MOV     #CCCD,W4
2598:  MOV     W4,B58
259A:  MOV     #BDCC,W4
259C:  MOV     W4,B5A
259E:  CLR     BC4
25A0:  CLR     BC6
25A2:  MOV     #41A0,W4
25A4:  MOV     W4,BC8
25A6:  MOV     #FA,W4
25A8:  MOV     W4,BF4
25AA:  CLR     BF6
25AC:  MOV     #C8,W4
25AE:  MOV     W4,BF8
25B0:  CLR     BFA
25B2:  CLR.B   D4F
25B4:  MOV.B   #3,W0L
25B6:  MOV.B   W0L,D78
25B8:  CLR     4E0
25BA:  CLR     4E2
25BC:  BRA     270A
25BE:  DATA    80,02,08
25C0:  DATA    5A,00,00
25C2:  DATA    80,80,08
25C4:  DATA    60,7C,88
25C6:  DATA    59,39,E0
25C8:  DATA    97,A6,3A
25CA:  DATA    C4,1D,1E
25CC:  DATA    3C,5E,50
25CE:  DATA    63,3D,1A
25D0:  DATA    FE,75,3E
25D2:  DATA    18,72,31
25D4:  DATA    3F,0F,8C
25D6:  DATA    55,A6,82
25D8:  DATA    95,D9,3D
25DA:  DATA    E6,D7,FF
25DC:  DATA    E5,C9,90
25DE:  DATA    C7,BD,CE
25E0:  DATA    40,12,47
25E2:  DATA    0C,B7,42
25E4:  DATA    3E,9F,6D
25E6:  DATA    94,C3,25
25E8:  DATA    6D,7A,3E
25EA:  DATA    DA,32,0E
25EC:  DATA    BE,9F,3E
25EE:  DATA    B6,3E,6D
25F0:  DATA    AA,28,C2
25F2:  DATA    B4,FA,EF
25F4:  DATA    3E,89,E0
25F6:  DATA    29,E5,A4
25F8:  DATA    30,24,3F
25FA:  DATA    A3,8E,FA
25FC:  DATA    E3,7E,D8
25FE:  DATA    55,3F,C6
2600:  DATA    04,8A,78
2602:  DATA    AB,B2,83
2604:  DATA    3F,CD,ED
2606:  DATA    A6,D6,08
2608:  DATA    6B,AC,3F
260A:  DATA    FD,D1,84
260C:  DATA    FF,BD,BF
260E:  DATA    CE,3F,A1
2610:  DATA    35,FA,FE
2612:  DATA    42,2E,E6
2614:  DATA    3F,99,47
2616:  DATA    8A,BF,00
2618:  DATA    00,00,40
261A:  DATA    40,08,00
261C:  DATA    00,08,4C
261E:  DATA    F3,BA,3D
2620:  DATA    2B,9D,5F
2622:  DATA    BF,40,08
2624:  DATA    00,00,18
2626:  DATA    05,BD,9A
2628:  DATA    4A,1A,A6
262A:  DATA    C2,BF,B4
262C:  DATA    B9,2A,1D
262E:  DATA    07,D9,F5
2630:  DATA    3F,02,EB
2632:  DATA    89,67,DB
2634:  DATA    F6,08,C0
2636:  DATA    40,07,00
2638:  DATA    00,39,40
263A:  DATA    2B,F2,93
263C:  DATA    8B,43,C5
263E:  DATA    78,3F,4F
2640:  DATA    E0,5D,A2
2642:  DATA    84,A9,CA
2644:  DATA    BF,38,8F
2646:  DATA    AC,EF,B5
2648:  DATA    D2,F1,3F
264A:  DATA    D8,3F,DF
264C:  DATA    BC,30,4C
264E:  DATA    FE,BF,37
2650:  DATA    BF,FD,3E
2652:  DATA    3D,AA,93
2654:  DATA    C0,EE,50
2656:  DATA    B3,40,00
2658:  DATA    00,80,3F
265A:  DATA    0A,8D,B1
265C:  DATA    C0,EE,50
265E:  DATA    B3,40,40
2660:  DATA    06,00,00
2662:  DATA    6B,F0,3F
2664:  DATA    5C,0A,58
2666:  DATA    F6,3B,8F
2668:  DATA    00,C0,3C
266A:  DATA    8B,28,AC
266C:  DATA    3C,BE,F6
266E:  DATA    3F,D2,D5
2670:  DATA    44,16,8C
2672:  DATA    15,D7,BF
2674:  DATA    69,00,5A
2676:  DATA    2E,1B,87
2678:  DATA    99,3F,9A
267A:  DATA    5F,AD,4B
267C:  DATA    91,E4,01
267E:  DATA    C0,5D,11
2680:  DATA    2F,92,E4
2682:  DATA    81,FB,3F
2684:  DATA    38,DA,91
2686:  DATA    80,9D,C5
2688:  DATA    E0,BF,6F
268A:  DATA    12,C0,B4
268C:  DATA    C3,09,AB
268E:  DATA    3F,6B,C1
2690:  DATA    03,4E,C1
2692:  DATA    B5,45,BF
2694:  DATA    0A,89,34
2696:  DATA    3E,7C,79
2698:  DATA    B5,40,3F
269A:  DATA    02,B3,41
269C:  DATA    33,8C,9E
269E:  DATA    41,00,00
26A0:  DATA    80,3F,1B
26A2:  DATA    E4,35,41
26A4:  DATA    A4,DB,E7
26A6:  DATA    41,33,8C
26A8:  DATA    9E,41,F7
26AA:  DATA    40,05,FF
26AC:  DATA    00,5F,EF
26AE:  DATA    3F,F3,A3
26B0:  DATA    E2,F7,D7
26B2:  DATA    FF,01,40
26B4:  DATA    C0,B4,FF
26B6:  DATA    05,3C,58
26B8:  DATA    FC,3F,3B
26BA:  DATA    D3,C0,B5
26BC:  DATA    BA,8C,E2
26BE:  DATA    3F,39,D3
26C0:  DATA    C7,3D,41
26C2:  DATA    79,B2,3F
26C4:  DATA    87,0D,3C
26C6:  DATA    50,D0,AF
26C8:  DATA    62,3F,30
26CA:  DATA    4B,8D,A2
26CC:  DATA    82,AA,04
26CE:  DATA    40,09,A0
26D0:  DATA    40,4A,05
26D2:  DATA    76,03,40
26D4:  DATA    EC,9E,37
26D6:  DATA    88,A6,44
26D8:  DATA    F0,3F,8F
26DA:  DATA    12,8D,29
26DC:  DATA    9A,5B,C7
26DE:  DATA    3F,0E,E0
26E0:  DATA    80,7C,A1
26E2:  DATA    D8,86,3F
26E4:  DATA    29,4B,FB
26E6:  DATA    95,C2,37
26E8:  DATA    1A,3F,30
26EA:  DATA    31,2E,30
26EC:  DATA    31,00,00
26EE:  INC     W2,W2
26F0:  CP      W2,#1
26F2:  BRA     NZ,26FC
26F4:  TBLRDL  [W1],W3
26F6:  TBLRDH  [W1++],W4
26F8:  MOV.B   6,W0L
26FA:  RETURN  
26FC:  CP      W2,#2
26FE:  BRA     NZ,2704
2700:  MOV.B   7,W0L
2702:  RETURN  
2704:  MOV.B   8,W0L
2706:  CLR     W2
2708:  RETURN  
270A:  MOV     #0,W6
270C:  MOV     #0,W0
270E:  MOV     W0,32
2710:  MOV     #25BE,W0
2712:  MOV     W0,W1
2714:  CLR     W2
2716:  CALL    26EE
271A:  MOV.B   W0L,B
271C:  CALL    26EE
2720:  MOV.B   W0L,A
2722:  CP0     W5
2724:  BRA     Z,2758
2726:  BTSS    W5.F
2728:  BRA     2738
272A:  CALL    26EE
272E:  MOV.B   W0L,D
2730:  CALL    26EE
2734:  MOV.B   W0L,C
2736:  BCLR    W5.F
2738:  BTSS    W5.E
273A:  BRA     274C
273C:  BCLR    W5.E
273E:  DEC     W5,W5
2740:  CALL    26EE
2744:  MOV.B   W0L,W7L
2746:  REPEAT  W5
2748:  MOV.B   W7L,[W6++]
274A:  BRA     2716
274C:  CALL    26EE
2750:  MOV.B   W0L,[W6++]
2752:  DEC     W5,W5
2754:  BRA     NZ,274C
2756:  BRA     2716
2758:  CLR.B   D7B
....................     int8 x; 
....................  
....................     int16 changeover;  //this is used for changeing the int32 to 16 bit. 
....................  
....................   
....................     int8 blinkinggreenlight = 0;  // Added March 30, 2017  This is the blinking green light counter varaible 
....................  
....................     int16 returneditem;  // this is the returned item 
....................     int8 highbyte, lowbyte; 
....................      
....................     Temp1DOOne = 9.5;            //These are the set points where we want to read these numbers at temperature 1 
275A:  CLR     C7E
275C:  MOV     #4118,W4
275E:  MOV     W4,C80
.................... 	Temp1DOTwo = 4.0;            //This is at 10 degrees 
2760:  CLR     C82
2762:  MOV     #4080,W4
2764:  MOV     W4,C84
.................... 	Temp1DOThree = 0.0; 
2766:  CLR     C86
2768:  CLR     C88
....................  
.................... 	Temp2DOOne = 7.5;            //These are the set points where we want to read these numbers at temperature 2 
276A:  CLR     C8A
276C:  MOV     #40F0,W4
276E:  MOV     W4,C8C
.................... 	Temp2DOTwo = 4.0;				//This is at 20 degrees 
2770:  CLR     C8E
2772:  MOV     #4080,W4
2774:  MOV     W4,C90
.................... 	Temp2DOThree = 0.0; 
2776:  CLR     C92
2778:  CLR     C94
....................  
.................... 	Temp3DOOne = 6.7;            //These are the set points where we want to read these numbers temperature 3 
277A:  MOV     #6666,W4
277C:  MOV     W4,C96
277E:  MOV     #40D6,W4
2780:  MOV     W4,C98
.................... 	Temp3DOTwo = 4.0;            //This is at 25 degrees 
2782:  CLR     C9A
2784:  MOV     #4080,W4
2786:  MOV     W4,C9C
.................... 	Temp3DOThree = 0.0; 
2788:  CLR     C9E
278A:  CLR     CA0
....................  
....................  
.................... 	Temp1ReadingOne = 10752.0;       //Readings for Temp3  10 degrees C 
278C:  CLR     CA2
278E:  MOV     #4628,W4
2790:  MOV     W4,CA4
.................... 	Temp1ReadingTwo = 11000.0;      //Readings for Temp3 
2792:  MOV     #E000,W4
2794:  MOV     W4,CA6
2796:  MOV     #462B,W4
2798:  MOV     W4,CA8
.................... 	Temp1ReadingThree = 12000.0;    //Readings for DOOne    this is no DO. 
279A:  MOV     #8000,W4
279C:  MOV     W4,CAA
279E:  MOV     #463B,W4
27A0:  MOV     W4,CAC
....................  
.................... 	Temp2ReadingOne = 11266.0;       //Readings for Temp3    20 degrees C 
27A2:  MOV     #800,W4
27A4:  MOV     W4,CAE
27A6:  MOV     #4630,W4
27A8:  MOV     W4,CB0
.................... 	Temp2ReadingTwo = 12000.0;      //Readings for Temp3 
27AA:  MOV     #8000,W4
27AC:  MOV     W4,CB2
27AE:  MOV     #463B,W4
27B0:  MOV     W4,CB4
.................... 	Temp2ReadingThree = 13000.0;    //Readings for DOOne 
27B2:  MOV     #2000,W4
27B4:  MOV     W4,CB6
27B6:  MOV     #464B,W4
27B8:  MOV     W4,CB8
....................  
.................... 	Temp3ReadingOne = 12425.0;       //Readings for Temp3   25 degrees C 
27BA:  MOV     #2400,W4
27BC:  MOV     W4,CBA
27BE:  MOV     #4642,W4
27C0:  MOV     W4,CBC
.................... 	Temp3ReadingTwo = 13000.0;      //Readings for Temp3 
27C2:  MOV     #2000,W4
27C4:  MOV     W4,CBE
27C6:  MOV     #464B,W4
27C8:  MOV     W4,CC0
.................... 	Temp3ReadingThree = 14000.0;    //Readings for DOOne 
27CA:  MOV     #C000,W4
27CC:  MOV     W4,CC2
27CE:  MOV     #465A,W4
27D0:  MOV     W4,CC4
.................... 	TempOne = 10.0;       //Calibration temperatures for DO   Added April 7, 2015 
27D2:  MOV     #A,W4
27D4:  MOV     W4,CC6
....................  	TempTwo =  20.0;      //Calibration temperatures for DO  Added April 7, 2015 
27D6:  MOV     #14,W4
27D8:  MOV     W4,CC8
.................... 	TempThree =  25.0;     //Calibration temperatures for DO  Added April 7, 2015 
27DA:  MOV     #19,W4
27DC:  MOV     W4,CCA
....................      
.................... output_low(PIN_B7);  // this turns on the green piolate light LED for showing the board is running.  It also blinks through out the wnile(1) loop  Added March 30, 2017 
27DE:  BCLR.B  2C8.7
27E0:  BCLR.B  2CC.7
.................... initTransMitBuffer();  // clear the sending buffer 
27E2:  CALL    33A
.................... LEDtest(); 
27E6:  CALL    366
.................... //enable_interrupts(GLOBAL); 
....................  
....................  
.................... InitTAOS(); // this sets up the scaler time for the DO light 
27EA:  CALL    482
.................... delay_ms(1000); 
27EE:  MOV     #3E8,W0
27F0:  CALL    356
....................  
....................  
....................  
.................... setup_adc(ADC_CLOCK_INTERNAL); 
27F4:  MOV     #9F00,W4
27F6:  MOV     W4,344
27F8:  MOV     #8470,W4
27FA:  MOV     W4,340
.................... setup_adc_ports(sAN11|sAN12); 
27FC:  CLR     4E0
27FE:  MOV     #3000,W4
2800:  MOV     W4,4E2
2802:  CLR     342
.................... enable_interrupts(INT_SI2C2);      
2804:  BSET.B  9A.1
....................  
.................... //returndata = SaveConfiguration(); 
....................  
....................  //   CalculateCRC(); 
.................... LoadConfiguration(); 
2806:  CALL    578
.................... rcv_buffer[2]==0x00;  // clear any buffer data for triggering calibration changes. 
280A:  CP0.B   D10
280C:  BRA     Z,2812
280E:  CLR.B   W0
2810:  BRA     2812
....................  
....................  
.................... while(1) 
.................... {  
.................... // read the DO measurement 
....................     //FindAmbientLight(0x01);   // this selects DO   Find the background light with no blue light on 
....................         output_high(PIN_B12); 
2812:  BCLR.B  2C9.4
2814:  BSET.B  2CD.4
.................... //        returdata = GetCurrentColor(0x00, 0x01); 
....................         GetCurrentColorAVG(0x00, 0x01); 
2816:  CLR.B   D82
2818:  MOV.B   #1,W0L
281A:  MOV.B   W0L,D83
281C:  CALL    1186
....................     //   TakeLightReading(0x03);    
....................         wTemp = WaterTemperature(); 
2820:  CALL    2140
2824:  MOV     W0,BC6
2826:  MOV     W1,BC8
....................         output_low(PIN_B12); 
2828:  BCLR.B  2C9.4
282A:  BCLR.B  2CD.4
....................     // this seaves DO measurements 
....................         changeover = (int16) greenABS; 
282C:  PUSH    B94
282E:  POP     D7E
....................         lowbyte = 0x00FF & changeover; 
2830:  MOV     D7E,W0
2832:  AND     #FF,W0
2834:  MOV.B   W0L,D7D
....................         returneditem = 0xFF00 & changeover; 
2836:  PUSH    D7E
2838:  POP     D80
283A:  MOV     #FF00,W0
283C:  AND     D80
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
283E:  CLR.B   1
2840:  MOV.B   D81,W0L
2842:  MOV.B   W0L,D7C
....................      //   send_buffer[22] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
....................      //   send_buffer[21] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
....................  
....................         changeover = (int16) redABS; 
2844:  PUSH    B8C
2846:  POP     D7E
....................         lowbyte = 0x00FF & changeover; 
2848:  MOV     D7E,W0
284A:  AND     #FF,W0
284C:  MOV.B   W0L,D7D
....................         returneditem = 0xFF00 & changeover; 
284E:  PUSH    D7E
2850:  POP     D80
2852:  MOV     #FF00,W0
2854:  AND     D80
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
2856:  CLR.B   1
2858:  MOV.B   D81,W0L
285A:  MOV.B   W0L,D7C
....................         send_buffer[16] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
285C:  MOV.B   D7D,W0L
285E:  MOV.B   W0L,CDC
....................         send_buffer[15] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
2860:  MOV.B   D7C,W0L
2862:  MOV.B   W0L,CDB
....................  
....................         changeover = (int16) blueABS; 
2864:  PUSH    B90
2866:  POP     D7E
....................         lowbyte = 0x00FF & changeover; 
2868:  MOV     D7E,W0
286A:  AND     #FF,W0
286C:  MOV.B   W0L,D7D
....................         returneditem = 0xFF00 & changeover; 
286E:  PUSH    D7E
2870:  POP     D80
2872:  MOV     #FF00,W0
2874:  AND     D80
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
2876:  CLR.B   1
2878:  MOV.B   D81,W0L
287A:  MOV.B   W0L,D7C
....................      //   send_buffer[22] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
....................      //   send_buffer[21] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
....................  
....................         changeover = (int16) clearABS; 
287C:  PUSH    B98
287E:  POP     D7E
....................         lowbyte = 0x00FF & changeover; 
2880:  MOV     D7E,W0
2882:  AND     #FF,W0
2884:  MOV.B   W0L,D7D
....................         returneditem = 0xFF00 & changeover; 
2886:  PUSH    D7E
2888:  POP     D80
288A:  MOV     #FF00,W0
288C:  AND     D80
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
288E:  CLR.B   1
2890:  MOV.B   D81,W0L
2892:  MOV.B   W0L,D7C
....................      //   send_buffer[22] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
....................      //   send_buffer[21] = highbyte;   // update this 
....................      
....................      
.................... //sysOutput.wTemp = 10.0; 
....................      output_high(PIN_B5);  // turn on white DpH LED 
2894:  BCLR.B  2C8.5
2896:  BSET.B  2CC.5
....................           // TakeLightReading(0x00);    
....................   // this selects DpH  Take a measurement and find the ABS color difference 
....................  //   returdata =  GetCurrentColorAVG(0x00, 0x00); 
....................     GetCurrentColorAVG(0x00, 0x00); 
2898:  CLR.B   D82
289A:  CLR.B   D83
289C:  CALL    1186
....................      output_low(PIN_B5);  // turn on white DpH LED 
28A0:  BCLR.B  2C8.5
28A2:  BCLR.B  2CC.5
....................     // this saves DpH measurements 
....................         changeover = (int16) greenABS; 
28A4:  PUSH    B94
28A6:  POP     D7E
....................         lowbyte = 0x00FF & changeover; 
28A8:  MOV     D7E,W0
28AA:  AND     #FF,W0
28AC:  MOV.B   W0L,D7D
....................         returneditem = 0xFF00 & changeover; 
28AE:  PUSH    D7E
28B0:  POP     D80
28B2:  MOV     #FF00,W0
28B4:  AND     D80
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
28B6:  CLR.B   1
28B8:  MOV.B   D81,W0L
28BA:  MOV.B   W0L,D7C
....................         send_buffer[22] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
28BC:  MOV.B   D7D,W0L
28BE:  MOV.B   W0L,CE2
....................         send_buffer[21] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
28C0:  MOV.B   D7C,W0L
28C2:  MOV.B   W0L,CE1
....................  
....................         changeover = (int16) redABS; 
28C4:  PUSH    B8C
28C6:  POP     D7E
....................         lowbyte = 0x00FF & changeover; 
28C8:  MOV     D7E,W0
28CA:  AND     #FF,W0
28CC:  MOV.B   W0L,D7D
....................         returneditem = 0xFF00 & changeover; 
28CE:  PUSH    D7E
28D0:  POP     D80
28D2:  MOV     #FF00,W0
28D4:  AND     D80
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
28D6:  CLR.B   1
28D8:  MOV.B   D81,W0L
28DA:  MOV.B   W0L,D7C
....................         send_buffer[20] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
28DC:  MOV.B   D7D,W0L
28DE:  MOV.B   W0L,CE0
....................         send_buffer[19] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
28E0:  MOV.B   D7C,W0L
28E2:  MOV.B   W0L,CDF
....................  
....................         changeover = (int16) blueABS; 
28E4:  PUSH    B90
28E6:  POP     D7E
....................         lowbyte = 0x00FF & changeover; 
28E8:  MOV     D7E,W0
28EA:  AND     #FF,W0
28EC:  MOV.B   W0L,D7D
....................         returneditem = 0xFF00 & changeover; 
28EE:  PUSH    D7E
28F0:  POP     D80
28F2:  MOV     #FF00,W0
28F4:  AND     D80
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
28F6:  CLR.B   1
28F8:  MOV.B   D81,W0L
28FA:  MOV.B   W0L,D7C
....................         send_buffer[24] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
28FC:  MOV.B   D7D,W0L
28FE:  MOV.B   W0L,CE4
....................         send_buffer[23] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
2900:  MOV.B   D7C,W0L
2902:  MOV.B   W0L,CE3
....................  
....................         changeover = (int16) clearABS; 
2904:  PUSH    B98
2906:  POP     D7E
....................         lowbyte = 0x00FF & changeover; 
2908:  MOV     D7E,W0
290A:  AND     #FF,W0
290C:  MOV.B   W0L,D7D
....................         returneditem = 0xFF00 & changeover; 
290E:  PUSH    D7E
2910:  POP     D80
2912:  MOV     #FF00,W0
2914:  AND     D80
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
2916:  CLR.B   1
2918:  MOV.B   D81,W0L
291A:  MOV.B   W0L,D7C
....................         send_buffer[26] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
291C:  MOV.B   D7D,W0L
291E:  MOV.B   W0L,CE6
....................         send_buffer[25] = highbyte;   // update this 
2920:  MOV.B   D7C,W0L
2922:  MOV.B   W0L,CE5
....................      
....................          
....................         output_high(PIN_B10);  // turn on white NH4 LED 
2924:  BCLR.B  2C9.2
2926:  BSET.B  2CD.2
....................          // this selects NH4  Take a measurement and find the ABS color difference 
....................       //   returdata =  GetCurrentColorAVG(0x03, 0x03); 
....................          GetCurrentColorAVG(0x00, 0x03); 
2928:  CLR.B   D82
292A:  MOV.B   #3,W0L
292C:  MOV.B   W0L,D83
292E:  CALL    1186
....................         output_low(PIN_B10);  // turn off white NH4 LED 
2932:  BCLR.B  2C9.2
2934:  BCLR.B  2CD.2
....................     // this saves DpH measurements 
....................         changeover = (int16) greenABS; 
2936:  PUSH    B94
2938:  POP     D7E
....................          lowbyte = 0x00FF & changeover; 
293A:  MOV     D7E,W0
293C:  AND     #FF,W0
293E:  MOV.B   W0L,D7D
....................         returneditem = 0xFF00 & changeover; 
2940:  PUSH    D7E
2942:  POP     D80
2944:  MOV     #FF00,W0
2946:  AND     D80
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
2948:  CLR.B   1
294A:  MOV.B   D81,W0L
294C:  MOV.B   W0L,D7C
....................         send_buffer[28] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
294E:  MOV.B   D7D,W0L
2950:  MOV.B   W0L,CE8
....................         send_buffer[27] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
2952:  MOV.B   D7C,W0L
2954:  MOV.B   W0L,CE7
....................  
....................         changeover = (int16) redABS; 
2956:  PUSH    B8C
2958:  POP     D7E
....................         lowbyte = 0x00FF & changeover; 
295A:  MOV     D7E,W0
295C:  AND     #FF,W0
295E:  MOV.B   W0L,D7D
....................         returneditem = 0xFF00 & changeover; 
2960:  PUSH    D7E
2962:  POP     D80
2964:  MOV     #FF00,W0
2966:  AND     D80
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
2968:  CLR.B   1
296A:  MOV.B   D81,W0L
296C:  MOV.B   W0L,D7C
....................         send_buffer[32] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
296E:  MOV.B   D7D,W0L
2970:  MOV.B   W0L,CEC
....................         send_buffer[31] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
2972:  MOV.B   D7C,W0L
2974:  MOV.B   W0L,CEB
....................  
....................         changeover = (int16) blueABS; 
2976:  PUSH    B90
2978:  POP     D7E
....................         lowbyte = 0x00FF & changeover; 
297A:  MOV     D7E,W0
297C:  AND     #FF,W0
297E:  MOV.B   W0L,D7D
....................         returneditem = 0xFF00 & changeover; 
2980:  PUSH    D7E
2982:  POP     D80
2984:  MOV     #FF00,W0
2986:  AND     D80
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
2988:  CLR.B   1
298A:  MOV.B   D81,W0L
298C:  MOV.B   W0L,D7C
....................         send_buffer[34] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
298E:  MOV.B   D7D,W0L
2990:  MOV.B   W0L,CEE
....................         send_buffer[33] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
2992:  MOV.B   D7C,W0L
2994:  MOV.B   W0L,CED
....................  
....................          
....................        sysOutput.nh3 = calculateAmmonia(changeover);   // find the nh4 + nh3      
2996:  PUSH    D7E
2998:  POP     D82
299A:  CALL    223E
299E:  MOV     W0,A8A
29A0:  MOV     W1,A8C
....................          
....................         changeover = (int16) clearABS; 
29A2:  PUSH    B98
29A4:  POP     D7E
....................         lowbyte = 0x00FF & changeover; 
29A6:  MOV     D7E,W0
29A8:  AND     #FF,W0
29AA:  MOV.B   W0L,D7D
....................         returneditem = 0xFF00 & changeover; 
29AC:  PUSH    D7E
29AE:  POP     D80
29B0:  MOV     #FF00,W0
29B2:  AND     D80
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
29B4:  CLR.B   1
29B6:  MOV.B   D81,W0L
29B8:  MOV.B   W0L,D7C
....................         send_buffer[36] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
29BA:  MOV.B   D7D,W0L
29BC:  MOV.B   W0L,CF0
....................         send_buffer[35] = highbyte;   // update this 
29BE:  MOV.B   D7C,W0L
29C0:  MOV.B   W0L,CEF
....................  
....................   
....................          
....................      // move calcaulated temperature into output buffer for water temperature 
....................     send_buffer[1] =  (int) sysOutput.nh3;  // high whole number byte 
29C2:  MOV     A8A,W0
29C4:  MOV     A8C,W1
29C6:  CALL    54C
29CA:  MOV.B   W0L,CCD
....................     send_buffer[2] =  (int) ((sysOutput.nh3 - (float) (int) sysOutput.nh3)*100);  // high whole number byte    
29CC:  MOV     A8A,W0
29CE:  MOV     A8C,W1
29D0:  CALL    54C
29D4:  CALL    6E0
29D8:  BSET.B  43.0
29DA:  MOV     W0,W2
29DC:  MOV     W1,W3
29DE:  MOV     A8A,W0
29E0:  MOV     A8C,W1
29E2:  CALL    72A
29E6:  MOV     W0,W5
29E8:  MOV     W1,W6
29EA:  MOV     W5,W0
29EC:  MOV     W6,W1
29EE:  MOV     #0,W2
29F0:  MOV     #42C8,W3
29F2:  CALL    1082
29F6:  CALL    54C
29FA:  MOV.B   W0L,CCE
....................          
....................          
....................     	sysOutput.wTemp = wTemp;  //This is the float temperature 
29FC:  PUSH    BC6
29FE:  POP     A44
2A00:  PUSH    BC8
2A02:  POP     A46
....................      
....................     	if (sysOutput.wTemp < 0.0) 
2A04:  MOV     A44,W0
2A06:  MOV     A46,W1
2A08:  MOV     #0,W2
2A0A:  MOV     #0,W3
2A0C:  CALL    14FE
2A10:  BRA     NC,2A1A
....................         { 
.................... 		sysOutput.wTemp = 0.0; 
2A12:  CLR     A44
2A14:  CLR     A46
....................         wTemp = 0.0; 
2A16:  CLR     BC6
2A18:  CLR     BC8
....................         } 
....................     // move calcaulated temperature into output buffer for water temperature 
....................     send_buffer[5] =  (int) wTemp;  // high whole number byte 
2A1A:  MOV     BC6,W0
2A1C:  MOV     BC8,W1
2A1E:  CALL    54C
2A22:  MOV.B   W0L,CD1
....................     send_buffer[6] =  (int) ((wTemp - (float) (int) wTemp)*100);  // high whole number byte 
2A24:  MOV     BC6,W0
2A26:  MOV     BC8,W1
2A28:  CALL    54C
2A2C:  CALL    6E0
2A30:  BSET.B  43.0
2A32:  MOV     W0,W2
2A34:  MOV     W1,W3
2A36:  MOV     BC6,W0
2A38:  MOV     BC8,W1
2A3A:  CALL    72A
2A3E:  MOV     W0,W5
2A40:  MOV     W1,W6
2A42:  MOV     W5,W0
2A44:  MOV     W6,W1
2A46:  MOV     #0,W2
2A48:  MOV     #42C8,W3
2A4A:  CALL    1082
2A4E:  CALL    54C
2A52:  MOV.B   W0L,CD2
.................... //  Toggle green light to show the system is working.   Added March 30, 2017   
....................     
....................  
.................... if (blinkinggreenlight == 0) 
2A54:  MOV.B   D7B,W0L
2A56:  SE      W0,W0
2A58:  CP0     W0
2A5A:  BRA     NZ,2A66
.................... { 
....................     output_LOW(PIN_B7); 
2A5C:  BCLR.B  2C8.7
2A5E:  BCLR.B  2CC.7
....................     blinkinggreenlight=1; 
2A60:  MOV.B   #1,W0L
2A62:  MOV.B   W0L,D7B
.................... } 
2A64:  BRA     2A6C
.................... else 
.................... { 
....................     output_HIGH(PIN_B7); 
2A66:  BCLR.B  2C8.7
2A68:  BSET.B  2CC.7
....................     blinkinggreenlight=0; 
2A6A:  CLR.B   D7B
.................... } 
....................       
....................  
.................... //***************************************************************** 
.................... // Created Nov 28, 2016 
.................... // This checks for any change in the update input.  Once rcv_buffer[2]== 1, then update the config varibles. 
.................... //***************************************************************** 
....................         if (rcv_buffer[2]==0x01) 
2A6C:  MOV     D10,W4
2A6E:  CP.B    W4L,#1
2A70:  BRA     NZ,2A9E
....................           { 
....................           // move the data off the input buffer into the calibration varaibles. 
....................              
....................             movercvbuffertocolibration();   //move over the data 
2A72:  CALL    23D6
....................              
....................             rcv_buffer[2]==0x00; 
2A76:  CP0.B   D10
2A78:  BRA     Z,2A7E
2A7A:  CLR.B   W0
2A7C:  BRA     2A7E
....................             // clear buffer 
....................             for (x=0; x < 65; x++) 
2A7E:  CLR.B   D7A
2A80:  MOV.B   D7A,W0L
2A82:  SE      W0,W0
2A84:  MOV     #41,W4
2A86:  CP      W4,W0
2A88:  BRA     LE,2A9E
....................                 rcv_buffer[x]==0x00; 
2A8A:  MOV.B   D7A,W0L
2A8C:  SE      W0,W0
2A8E:  MOV     #D0E,W4
2A90:  ADD     W0,W4,W0
2A92:  CP0.B   [W0]
2A94:  BRA     Z,2A9A
2A96:  CLR.B   W0
2A98:  BRA     2A9A
2A9A:  INC.B   0D7A
2A9C:  BRA     2A80
....................           } 
2A9E:  BRA     2812
.................... } 
....................  
.................... } 
....................  
2AA0:  BRA     2AA0
....................  
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1L: 000F   NOWRTB NOBSS
          H: 0000  
   Word  2L: 0000  
          H: 0000  
   Word  3L: 0003   NOWRT NOPROTECT
          H: 0000  
   Word  4L: 00E3   PR_PLL SOSC_ANALOG LPRCHIGH IESO
          H: 0000  
   Word  5L: 00FA   HS OSCIO POSCFREQ_H SOSC_HIGH
          H: 0000  
   Word  6L: 005F   WPOSTS16 WDT128 WINDIS NOWDT
          H: 0000  
   Word  7L: 00F4   NOBROWNOUT NOLVR NOPUT NOALTI2C1 BORV_LOW MCLR
          H: 0000  
   Word  8L: 0003   ICSP1 DEBUG
          H: 0000  
   Word  9L: 00DF   DSWDTCK_LPRC DSBOR DSWDT
          H: 0000  

   Some fuses have been forced to be compatible with the ICD debugger.
