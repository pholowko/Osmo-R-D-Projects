CCS PCD C Compiler, Version 5.071, 35992               05-Apr-17 09:00

               Filename:   G:\OsomobotCarbonDioxideDigitalSensor\OsomobotCarbonDioxideDigitalSensor.X\build\default\production\main.lst

               ROM used:   2942 bytes (13%)
                           Largest free fragment is 19586
               RAM used:   716 (37%) at main() level
                           740 (38%) worst case
               Stack used: 14 locations
               Stack size: 96

*
0000:  GOTO    9EC
.................... // CO2 Sensor RH temp Main.c file 
.................... #include <24FV32KA302.h> 
.................... //////////// Standard Header file for the PIC24FV32KA302 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FV32KA302 
*
05D6:  MOV     W5,[W15++]
05D8:  MOV     W6,[W15++]
05DA:  MOV     #8E,W1
05DC:  BCLR    W6.0
05DE:  BTSS    W0.F
05E0:  BRA     5E8
05E2:  BSET    W6.0
05E4:  NEG     W0,W0
05E6:  BRA     5E8
05E8:  CP0     W0
05EA:  BRA     Z,614
05EC:  BTSC    W0.F
05EE:  BRA     5F8
05F0:  BCLR.B  42.0
05F2:  RLC     W0,W0
05F4:  DEC     W1,W1
05F6:  BRA     5EC
05F8:  SWAP    W1
05FA:  BCLR.B  42.0
05FC:  RRC     W1,W1
05FE:  BCLR    W0.F
0600:  SWAP    W0
0602:  XOR.B   W0L,W1L,W1L
0604:  AND.B   #0,W0L
0606:  BTSC    W6.0
0608:  BSET    W1.F
060A:  BRA     61A
060C:  MOV.B   W1L,W0L
060E:  BSET    W1.7
0610:  AND.B   #0,W1L
0612:  BRA     61A
0614:  CLR     W0
0616:  CLR     W1
0618:  BRA     61A
061A:  MOV     [--W15],W6
061C:  MOV     [--W15],W5
061E:  RETURN  
0620:  MOV     W5,[W15++]
0622:  MOV     #C,W5
0624:  REPEAT  #4
0626:  MOV     [W5++],[W15++]
0628:  MOV     W0,W4
062A:  MOV     W1,W5
062C:  MOV     W3,W7
062E:  MOV     W2,W6
0630:  BCLR.B  42.0
0632:  BCLR.B  42.1
0634:  RLC     W1,W1
0636:  SWAP    W1
0638:  AND     #FF,W1
063A:  CP0     W1
063C:  BRA     Z,6D4
063E:  BCLR.B  42.0
0640:  BCLR.B  42.1
0642:  RLC     W3,W3
0644:  SWAP    W3
0646:  AND     #FF,W3
0648:  CP0     W3
064A:  BRA     Z,6D4
064C:  ZE      W0,W0
064E:  ADD.B   W3L,W1L,W0L
0650:  BRA     C,65A
0652:  SUB     #7F,W0
0654:  BRA     Z,6D4
0656:  BRA     NC,6D4
0658:  BRA     65E
065A:  ADD.B   #81,W0L
065C:  BRA     C,6D4
065E:  XOR     W5,W7,W10
0660:  BCLR.B  42.0
0662:  BCLR.B  42.1
0664:  AND     #FF,W5
0666:  BSET    W5.7
0668:  BCLR.B  42.0
066A:  AND     #FF,W7
066C:  BSET    W7.7
066E:  MUL.UU  W4,W6,W2
0670:  MUL.UU  W5,W6,W8
0672:  ADDC    W8,W3,W3
0674:  MOV     W9,W1
0676:  BTSC.B  42.0
0678:  INC     W1,W1
067A:  BCLR.B  42.0
067C:  MUL.UU  W7,W4,W8
067E:  ADDC    W8,W3,W3
0680:  ADDC    W9,W1,W1
0682:  MUL.UU  W5,W7,W8
0684:  ADDC    W8,W1,W1
0686:  INC     W0,W0
0688:  CP0     W1
068A:  BTSC.B  42.1
068C:  BRA     690
068E:  BRA     696
0690:  CP0     W3
0692:  BTSC.B  42.1
0694:  BRA     6A0
0696:  BTSC    W1.F
0698:  BRA     6A0
069A:  RLC     W3,W3
069C:  RLC     W1,W1
069E:  DEC     W0,W0
06A0:  MOV     W1,W2
06A2:  BCLR.B  42.0
06A4:  BTSS    W3.7
06A6:  BRA     6BA
06A8:  MOV     #FF00,W7
06AA:  AND     W3,W7,W3
06AC:  ADD     #100,W3
06AE:  ADDC    W2,#0,W2
06B0:  CP0     W2
06B2:  BRA     NZ,6BA
06B4:  CP0     W3
06B6:  BRA     NZ,6BA
06B8:  INC     W0,W0
06BA:  SWAP    W0
06BC:  BCLR.B  42.0
06BE:  BCLR.B  42.1
06C0:  RRC     W0,W1
06C2:  BTSC    W10.F
06C4:  BSET    W1.F
06C6:  BCLR    W2.F
06C8:  SWAP    W2
06CA:  XOR.B   W2L,W1L,W1L
06CC:  SWAP    W3
06CE:  MOV.B   W3L,W2L
06D0:  MOV     W2,W0
06D2:  BRA     6DA
06D4:  MOV     #0,W0
06D6:  MOV     #0,W1
06D8:  BRA     6DA
06DA:  MOV     #14,W5
06DC:  REPEAT  #4
06DE:  MOV     [--W15],[W5--]
06E0:  MOV     [--W15],W5
06E2:  RETURN  
06E4:  MOV     W5,[W15++]
06E6:  MOV     #C,W5
06E8:  REPEAT  #4
06EA:  MOV     [W5++],[W15++]
06EC:  CLR     W9
06EE:  XOR     W1,W3,W9
06F0:  MOV     W1,W6
06F2:  MOV     W0,W5
06F4:  MOV     W3,W8
06F6:  MOV     W2,W7
06F8:  RLC     W1,W1
06FA:  SWAP    W1
06FC:  ZE      W1,W1
06FE:  CP0     W1
0700:  BRA     Z,79E
0702:  RLC     W3,W3
0704:  SWAP    W3
0706:  ZE      W3,W3
0708:  CP0     W3
070A:  BRA     Z,79E
070C:  CLR     W0
070E:  SUB.B   W1L,W3L,W0L
0710:  BRA     NC,718
0712:  ADD.B   #7F,W0L
0714:  BRA     C,79E
0716:  BRA     71E
0718:  SUB.B   #81,W0L
071A:  BRA     NC,79E
071C:  BRA     Z,79E
071E:  MOV     W5,W1
0720:  MOV     W6,W2
0722:  BSET    W2.7
0724:  AND     #FF,W2
0726:  AND     #FF,W8
0728:  BSET    W8.7
072A:  MOV     #19,W10
072C:  CLR     W3
072E:  CLR     W4
0730:  SUB     W1,W7,W1
0732:  SUBB    W2,W8,W2
0734:  BRA     N,73A
0736:  BRA     C,740
0738:  BRA     NZ,742
073A:  ADD     W1,W7,W1
073C:  ADDC    W2,W8,W2
073E:  BRA     742
0740:  BSET    W4.0
0742:  DEC     W10,W10
0744:  BRA     Z,754
0746:  BCLR.B  42.0
0748:  RLC     W1,W1
074A:  RLC     W2,W2
074C:  BCLR.B  42.0
074E:  RLC     W4,W4
0750:  RLC     W3,W3
0752:  BRA     730
0754:  CLR     W10
0756:  BTSC    W3.8
0758:  BRA     75C
075A:  BRA     768
075C:  BCLR.B  42.0
075E:  RRC     W3,W3
0760:  BCLR    W3.7
0762:  RRC     W4,W4
0764:  RLC     W10,W10
0766:  BRA     76C
0768:  DEC     W0,W0
076A:  BRA     Z,79E
076C:  BTSC    W10.F
076E:  BRA     NC,77A
0770:  RLC     W1,W1
0772:  RLC     W2,W2
0774:  SUB     W1,W7,W1
0776:  SUBB    W2,W8,W2
0778:  BRA     NC,78C
077A:  INC     W4,W4
077C:  BRA     NZ,78C
077E:  INC     W3,W3
0780:  BRA     NZ,78C
0782:  INC     W0,W0
0784:  BRA     Z,79E
0786:  BRA     78C
0788:  DEC     W0,W0
078A:  BRA     Z,79E
078C:  SWAP    W0
078E:  RRC     W0,W1
0790:  BSET    W1.F
0792:  BTSS    W9.F
0794:  BCLR    W1.F
0796:  BCLR    W3.7
0798:  XOR.B   W3L,W1L,W1L
079A:  MOV     W4,W0
079C:  BRA     7A4
079E:  MOV     #0,W0
07A0:  MOV     #0,W1
07A2:  BRA     7A4
07A4:  MOV     #14,W5
07A6:  REPEAT  #4
07A8:  MOV     [--W15],[W5--]
07AA:  MOV     [--W15],W5
07AC:  RETURN  
07AE:  MOV     W5,[W15++]
07B0:  MOV     #C,W5
07B2:  REPEAT  #3
07B4:  MOV     [W5++],[W15++]
07B6:  CLR     W9
07B8:  MOV     #8000,W8
07BA:  BTSC.B  43.0
07BC:  XOR     W8,W3,W3
07BE:  CP0     W0
07C0:  BRA     NZ,7C8
07C2:  MOV     #7FFF,W10
07C4:  AND     W1,W10,W10
07C6:  BTSS.B  42.1
07C8:  MOV     W1,W10
07CA:  XOR     W3,W10,W11
07CC:  MOV     W1,W6
07CE:  MOV     W3,W7
07D0:  MOV     W3,W12
07D2:  BCLR.B  42.1
07D4:  BCLR.B  42.0
07D6:  RLC     W6,W6
07D8:  SWAP    W6
07DA:  AND     #FF,W6
07DC:  CP0     W6
07DE:  BRA     Z,922
07E0:  BCLR.B  42.1
07E2:  BCLR.B  42.0
07E4:  RLC     W7,W7
07E6:  SWAP    W7
07E8:  AND     #FF,W7
07EA:  CP0     W7
07EC:  BRA     Z,92C
07EE:  BCLR.B  42.1
07F0:  BCLR.B  42.0
07F2:  CP      W7,W6
07F4:  BRA     Z,92E
07F6:  BRA     N,93E
07F8:  BCLR    W9.0
07FA:  BSET    W9.1
07FC:  SUB     W7,W6,W8
07FE:  MOV     W7,W6
0800:  AND     #FF,W1
0802:  BSET    W1.7
0804:  AND     #FF,W3
0806:  BSET    W3.7
0808:  MOV     #28,W7
080A:  CP      W7,W8
080C:  BRA     N,830
080E:  BCLR.B  42.1
0810:  BCLR.B  42.0
0812:  RRC     W1,W1
0814:  RRC     W0,W0
0816:  DEC     W8,W8
0818:  BRA     NZ,80E
081A:  BRA     836
081C:  MOV     #28,W7
081E:  CP      W7,W8
0820:  BRA     N,834
0822:  BCLR.B  42.1
0824:  BCLR.B  42.0
0826:  RRC     W3,W3
0828:  RRC     W2,W2
082A:  DEC     W8,W8
082C:  BRA     NZ,822
082E:  BRA     84E
0830:  MOV     W2,W0
0832:  MOV     W3,W1
0834:  BRA     8BC
0836:  BTSS    W11.F
0838:  BRA     85C
083A:  BTSC    W9.4
083C:  MOV     W12,W11
083E:  NEG     W0,W0
0840:  BRA     Z,846
0842:  COM.B   W1L,W1L
0844:  BRA     848
0846:  NEG     W1,W1
0848:  BTSC    W9.4
084A:  BRA     8A2
084C:  BRA     85C
084E:  BTSS    W11.F
0850:  BRA     85C
0852:  NEG     W2,W2
0854:  BRA     Z,85A
0856:  COM.B   W3L,W3L
0858:  BRA     85C
085A:  NEG     W3,W3
085C:  AND     #FF,W5
085E:  BCLR.B  42.1
0860:  BCLR.B  42.0
0862:  ADD     W0,W2,W0
0864:  ADDC.B  W1L,W3L,W1L
0866:  BTSC.B  42.0
0868:  BSET    W9.3
086A:  BTSC    W9.0
086C:  BRA     880
086E:  BTSC    W9.1
0870:  BRA     874
0872:  BRA     88A
0874:  BTSC    W11.F
0876:  BRA     8A2
0878:  BTSC    W9.3
087A:  BRA     8CE
087C:  BSET    W9.6
087E:  BRA     8BC
0880:  BTSC    W11.F
0882:  BRA     8A2
0884:  BTSC    W9.3
0886:  BRA     8CE
0888:  BRA     8BC
088A:  BCLR    W9.2
088C:  BTSC    W11.F
088E:  BRA     898
0890:  MOV     W10,W11
0892:  BTSC    W9.3
0894:  BRA     8CE
0896:  BRA     904
0898:  BSET    W9.4
089A:  XOR.B   #80,W1L
089C:  BTSC    W1.7
089E:  BRA     83A
08A0:  MOV     W10,W11
08A2:  AND     #FF,W1
08A4:  IOR      W0,  W1,W7
08A6:  BRA     Z,8BC
08A8:  BTSC    W1.7
08AA:  BRA     8BC
08AC:  BCLR.B  42.1
08AE:  BCLR.B  42.0
08B0:  RLC     W0,W0
08B2:  RLC     W1,W1
08B4:  DEC     W6,W6
08B6:  BTSC.B  42.1
08B8:  BRA     91C
08BA:  BRA     8A8
08BC:  BTSC    W9.0
08BE:  MOV     W10,W11
08C0:  BTSC    W9.1
08C2:  MOV     W12,W11
08C4:  BTSS    W9.5
08C6:  BRA     8FC
08C8:  BTSC    W10.F
08CA:  BSET    W0.8
08CC:  BRA     904
08CE:  BSET.B  42.0
08D0:  RRC.B   W1L,W1L
08D2:  RRC     W0,W0
08D4:  BTSC.B  42.0
08D6:  BSET    W9.5
08D8:  INC     W6,W6
08DA:  BRA     Z,91C
08DC:  BTSS    W9.5
08DE:  BRA     8F0
08E0:  INC     W0,W0
08E2:  BRA     NZ,8F0
08E4:  INC.B   W1L,W1L
08E6:  BRA     NZ,8F0
08E8:  RRC.B   W1L,W1L
08EA:  RRC     W0,W0
08EC:  INC     W6,W6
08EE:  BRA     Z,91C
08F0:  BTSC    W9.0
08F2:  MOV     W10,W11
08F4:  BTSC    W9.1
08F6:  MOV     W12,W11
08F8:  BTSC.B  42.1
08FA:  BRA     91C
08FC:  BTSC    W9.6
08FE:  MOV     W10,W11
0900:  BTSC    W9.7
0902:  MOV     W12,W11
0904:  IOR      W0,  W1,W2
0906:  BRA     Z,94E
0908:  BCLR    W1.7
090A:  SWAP    W6
090C:  BCLR.B  42.1
090E:  BCLR.B  42.0
0910:  RRC     W6,W6
0912:  XOR     W6,W1,W1
0914:  BSET    W1.F
0916:  BTSS    W11.F
0918:  BCLR    W1.F
091A:  BRA     94E
091C:  MOV     #0,W0
091E:  MOV     #0,W1
0920:  BRA     94E
0922:  BTSC    W10.F
0924:  XOR     W8,W3,W3
0926:  MOV     W2,W0
0928:  MOV     W3,W1
092A:  BRA     94E
092C:  BRA     94E
092E:  AND     #FF,W3
0930:  BSET    W3.7
0932:  AND     #FF,W1
0934:  BSET    W1.7
0936:  BTSC    W11.F
0938:  BCLR    W3.7
093A:  BSET    W9.2
093C:  BRA     84E
093E:  SUB     W6,W7,W8
0940:  AND     #FF,W1
0942:  BSET    W1.7
0944:  AND     #FF,W3
0946:  BSET    W3.7
0948:  BCLR    W9.1
094A:  BSET    W9.0
094C:  BRA     81C
094E:  MOV     #12,W5
0950:  REPEAT  #3
0952:  MOV     [--W15],[W5--]
0954:  MOV     [--W15],W5
0956:  RETURN  
0958:  MOV     W5,[W15++]
095A:  MOV     W6,[W15++]
095C:  MOV     W7,[W15++]
095E:  XOR     W1,W3,W4
0960:  BTSS    W4.F
0962:  BRA     970
0964:  BCLR.B  42.0
0966:  BCLR.B  42.1
0968:  BTSS    W1.F
096A:  BRA     9B8
096C:  BSET.B  42.0
096E:  BRA     9B8
0970:  MOV     W1,W4
0972:  MOV     W0,W5
0974:  MOV     W3,W6
0976:  MOV     W2,W7
0978:  RLC     W1,W1
097A:  SWAP    W1
097C:  RLC     W3,W3
097E:  SWAP    W3
0980:  SUB.B   W3L,W1L,W1L
0982:  BRA     Z,98E
0984:  BTSS    W4.F
0986:  BRA     9B8
0988:  MOV     #1,W0
098A:  XOR.B   42
098C:  BRA     9B8
098E:  MOV.B   W4L,W1L
0990:  MOV.B   W6L,W3L
0992:  BCLR    W1.7
0994:  BCLR    W3.7
0996:  SUB.B   W3L,W1L,W1L
0998:  BRA     Z,9A4
099A:  BTSS    W4.F
099C:  BRA     9B8
099E:  MOV     #1,W0
09A0:  XOR.B   42
09A2:  BRA     9B8
09A4:  SUB     W7,W5,W1
09A6:  BRA     Z,9B2
09A8:  BTSS    W4.F
09AA:  BRA     9B8
09AC:  MOV     #1,W0
09AE:  XOR.B   42
09B0:  BRA     9B8
09B2:  BCLR.B  42.0
09B4:  BRA     9B8
09B6:  BRA     9B8
09B8:  MOV     [--W15],W7
09BA:  MOV     [--W15],W6
09BC:  MOV     [--W15],W5
09BE:  RETURN  
09C0:  MOV     W0,W2
09C2:  MOV     W1,W3
09C4:  MOV.B   W1L,W0L
09C6:  SWAP    W0
09C8:  BSET    W0.F
09CA:  RLC     W1,W1
09CC:  SWAP    W1
09CE:  ZE      W1,W1
09D0:  MOV     #8E,W4
09D2:  SUB.B   W4L,W1L,W1L
09D4:  BRA     Z,9E2
09D6:  CP0     W0
09D8:  BRA     Z,9E2
09DA:  BCLR.B  42.0
09DC:  RRC     W0,W0
09DE:  DEC     W1,W1
09E0:  BRA     NZ,9D6
09E2:  BTSS    W3.F
09E4:  BRA     9EA
09E6:  NEG     W0,W0
09E8:  BRA     9EA
09EA:  RETURN  
....................  
.................... #list 
....................  
.................... #DEVICE ICD=TRUE 
.................... #device ADC=10 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #define SDAPIN PIN_B2 
.................... #define SCLPIN PIN_B3 
....................  
.................... #define SDATPIN PIN_B9 
.................... #define SCLTPIN PIN_B8 
....................  
.................... #fuses  NOWDT, NOBROWNOUT, NOPROTECT, PUT  
....................  
.................... #use delay( crystal=8mhz, clock=32mhz ) 
*
0226:  CP0     W0
0228:  BTSC.B  42.1
022A:  BRA     234
022C:  REPEAT  #3E7B
022E:  NOP     
0230:  DEC     W0,W0
0232:  BRA     NZ,22C
0234:  RETURN  
.................... //#use delay(crystal=25000000, clock=25000000)   // this is commented out for the new board.  It is the old 25MHz crystal. 
....................  
.................... //#use I2C(stream=SENSOR, SLAVE, sda=SDAPIN,scl=SCLPIN, I2C2, address=0xa0)   // this is I2C 1 
.................... #use I2C(stream=PH_LIGHT, MASTER, sda=SDATPIN, scl=SCLTPIN, I2C1, force_hw)    // this is the master I2c for talking with removote sensor boards.  There is only one I2c on this chip. 
*
0464:  MOV     #FFFF,W0
0466:  BTSS.B  208.3
0468:  BRA     474
046A:  BTSC.B  209.6
046C:  BRA     46A
046E:  MOV     W1,202
0470:  BTSC.B  209.6
0472:  BRA     470
0474:  MOV     #0,W0
0476:  BTSC.B  209.7
0478:  INC     W0,W0
047A:  RETURN  
*
04BA:  MOV     #FFFF,W0
04BC:  BTSS.B  208.3
04BE:  BRA     4E2
04C0:  MOV     206,W2
04C2:  AND     W2,#1F,W2
04C4:  BRA     NZ,4C0
04C6:  BSET.B  206.3
04C8:  BTSC    W1.0
04CA:  BCLR.B  206.5
04CC:  BTSS    W1.0
04CE:  BSET.B  206.5
04D0:  MOV     206,W2
04D2:  AND     W2,#1F,W2
04D4:  BRA     NZ,4D0
04D6:  BSET.B  206.4
04D8:  BTSS.B  208.1
04DA:  BRA     4D8
04DC:  MOV     200,W0
04DE:  BTSC.B  208.6
04E0:  BCLR.B  208.6
04E2:  RETURN  
.................... #define RHTEMP PIN_B15      //  this is the pin used for talking to the RH and Temp sensor 
....................  
....................  
.................... #define TESTER 
.................... #define COTWOSENSOR 1 
.................... #define SLAVE 1 
.................... #define SENSORNUMBER 0xd9   // this means it is CO2 
....................  
.................... int8 startupdate = 0; // this is the flag to start an upload  
.................... int16 th,tl,hh,hl;  // variables for 1050 RH and temp sensor 
....................  
.................... typedef struct outputDataStruct{ 
.................... char deviceID[16]; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int8 taosVersion; 
.................... float dOxy; 
.................... float wTemp; 
.................... float pH; 
.................... float pHLow; 
.................... float WhiteBalance; 
.................... float tdsLevel; 
.................... float wLevel; 
.................... float lLevelX; 
.................... float lLevelY; 
....................  
.................... int32 lLevelRed; 
.................... int32 lLevelGreen; 
.................... int32 lLevelBlue; 
.................... int32 lLevelClear; 
.................... int8 time; 
.................... int16 date; 
....................  
....................  
.................... float lLevelScale; 
.................... float rH,averagepH; 
.................... float aTemp; 
.................... int16 cO2; 
.................... float nh3; 
.................... float dPoint; 
.................... char DIEHARD[8]; 
.................... }outputData; 
....................  
....................  
.................... outputData sysOutput; 
....................  
.................... //***************************************************************************** 
.................... // Created Febuary 20, 2017 
.................... // This is the selection routine where it picks which I2C to talk with.   
.................... //  It does not exist on the CO2 since there is only one I2C used for talking with the RH/Temp sensor 
.................... //****************************************************************************** 
....................  
.................... void selectsensor(int junk)  //This is added in this module to perform a dummy select.  It's used in the OSmobot only. 
.................... { 
....................     return; 
.................... } 
....................  
....................  
....................  
.................... #include "C:\Aquarium Software\Debug Monitor\CommonPassedDataFromMaterToSlave.h" 
.................... //********************************************************************************************** 
.................... // Created November 23, 2016 
.................... //these are the calibration varibles so far on the tester.   
.................... //********************************************************************************************** 
....................  
.................... typedef struct { 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
.................... float eccal1x; 
.................... float eccal2x; 
.................... float eccal3x; 
.................... float eccal1y; 
.................... float eccal2y; 
.................... float eccal3y; 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... }Calstuff; 
.................... Calstuff sysInput;  
.................... /* 
....................  
.................... typedef struct inputDataStruct{ 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... float eccal1x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal1y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3y;    //  This the EC data point  Added July 18, 2016 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... }inputData; 
.................... inputData sysInput; 
....................  
.................... */ 
....................  
.................... #ifdef SLAVE 
....................  
.................... float Temp1DOOne; 
.................... float Temp1DOTwo; 
.................... float Temp1DOThree; 
.................... float Temp2DOOne; 
.................... float Temp2DOTwo; 
.................... float Temp2DOThree; 
.................... float Temp3DOOne; 
.................... float Temp3DOTwo; 
.................... float Temp3DOThree; 
.................... float Temp1ReadingOne; 
.................... float Temp1ReadingTwo; 
.................... float Temp1ReadingThree; 
.................... float Temp2ReadingOne; 
.................... float Temp2ReadingTwo; 
.................... float Temp2ReadingThree; 
.................... float Temp3ReadingOne; 
.................... float Temp3ReadingTwo; 
.................... float Temp3ReadingThree; 
....................  
.................... unsigned int16 TempOne; 
.................... unsigned int16 TempTwo; 
.................... unsigned int16 TempThree; 
....................  
.................... #endif 
....................  
.................... #include <G:\Osmobot4PostProduction\Instrumentation\CheapRHAndTemp.c> 
.................... #ifdef TESTER 
.................... //****************************************************************************** 
.................... // Created Jan 12, 2017 
.................... // This routine gets the current model number and serial number of the HDC1080 RH/Temp chip.   
.................... // Returned values are valid if the function returns a zero. 
.................... // The RH and Temp is saved in the normal OUTPUT varaibles if the devices is attached to the usnit. 
.................... // The index is used to select the RJ45 port needed.   
.................... // For this set of boards, it's set to one port as a default.  It still needs to be called with the default value in place. 
.................... //****************************************************************************** 
.................... int16 GetHDC1080Version(int index) 
.................... { 
....................     int16 version, tempver; 
.................... #ifndef COTWOSENSOR 
.................... 	selectsensor(index);   // make the selection to talk with this sensor. 
.................... #endif 
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
....................  
.................... 	i2c_start(PH_LIGHT); 
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
.................... 	i2c_write(PH_LIGHT,0xFF);  //Send the command for reading the version 
.................... 	i2c_stop(PH_LIGHT); 
....................     i2c_start(PH_LIGHT); 
.................... 	i2c_write(PH_LIGHT,0x81);  //Move the address number left on and add a one to make is a read command. 
.................... 	tempver = i2c_read(PH_LIGHT); 
....................     version = i2c_read(PH_LIGHT); 
.................... 	i2c_stop(PH_LIGHT); 
....................      version = version + (tempver<<8); 
....................     return(version); 
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Jan 13, 2017 
.................... // This routine inits the HDC1080 RH/Temp chip.   
.................... // No returned value.  Sets all measurements to max resolution which is 14 bits 
.................... // The index is used to select the RJ45 port needed.   
.................... // For this set of boards, it's set to one port as a default.  It still needs to be called with the default value in place. 
.................... //****************************************************************************** 
.................... void GetHDC1080init(int index) 
.................... { 
....................     int version, tempver; 
....................  
.................... #ifndef COTWOSENSOR 
.................... 	selectsensor(index);   // make the selection to talk with this sensor. 
.................... #endif 
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
....................     // set the configuration register 
.................... 	i2c_start(PH_LIGHT); 
*
047C:  BTSS.B  208.3
047E:  BRA     488
0480:  BSET.B  206.1
0482:  BTSC.B  206.1
0484:  BRA     482
0486:  BRA     48E
0488:  BSET.B  206.0
048A:  BTSC.B  206.0
048C:  BRA     48A
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
048E:  MOV.B   #80,W1L
0490:  CALL    464
.................... 	i2c_write(PH_LIGHT,0x02);  //Point the next two  bytes to the command register. 
0494:  MOV.B   #2,W1L
0496:  CALL    464
....................     i2c_write(PH_LIGHT,0x00);  // Send the MSB first.  In this case it is the default witch is 14 bits 
049A:  CLR.B   W1
049C:  CALL    464
.................... 	i2c_write(PH_LIGHT,0x00);  //Send the configuration LSB 
04A0:  CLR.B   W1
04A2:  CALL    464
.................... 	i2c_stop(PH_LIGHT); 
04A6:  MOV     #1F,W0
04A8:  AND     206,W0
04AA:  BRA     NZ,4A6
04AC:  BSET.B  206.2
04AE:  BTSC.B  206.2
04B0:  BRA     4AE
....................     delay_ms(45);  //This is the time it takes to get the first measurement 
04B2:  MOV     #2D,W0
04B4:  CALL    226
04B8:  RETURN  
....................       
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Jan 11, 2017 
.................... // This routine gets the current reading of the HDC1080 RH/Temp chip.   
.................... // Returned values are valid if the runction returns a zero. 
.................... // The RH and Temp is saved in the normal OUTPUT varaibles if the devices is attached to the usnit. 
.................... // The index is used to select the RJ45 port needed.   
.................... // For this set of boards, it's set to one port as a default.  It still needs to be called with the default value in place. 
.................... //****************************************************************************** 
.................... float GetHDC1080RHTemp(int index) 
.................... { 
....................     unsigned int8 temphigh,templow,rhhigh, rhlow; 
....................     float t,h; 
....................     //int th,tl,hh,hl; 
....................     GetHDC1080init(index); 
*
04E4:  PUSH    ACA
04E6:  POP     AD4
04E8:  CALL    47C
.................... #ifndef COTWOSENSOR 
.................... 	selectsensor(index);   // make the selection to talk with this sensor. 
.................... #endif 
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
.................... // trigger tempeerature  measurement 
.................... 	i2c_start(PH_LIGHT); 
04EC:  BTSS.B  208.3
04EE:  BRA     4F8
04F0:  BSET.B  206.1
04F2:  BTSC.B  206.1
04F4:  BRA     4F2
04F6:  BRA     4FE
04F8:  BSET.B  206.0
04FA:  BTSC.B  206.0
04FC:  BRA     4FA
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
04FE:  MOV.B   #80,W1L
0500:  CALL    464
.................... 	i2c_write(PH_LIGHT,0x00);  //Send the command for reading the version 
0504:  CLR.B   W1
0506:  CALL    464
.................... //	i2c_stop(PH_LIGHT); 
....................     delay_ms(20);   // wait for measurement 
050A:  MOV     #14,W0
050C:  CALL    226
....................      
....................      
....................      
....................  //   Start over to read the measurement.  This kicks the chip out of low power mode. 
....................     i2c_start(PH_LIGHT); 
0510:  BTSS.B  208.3
0512:  BRA     51C
0514:  BSET.B  206.1
0516:  BTSC.B  206.1
0518:  BRA     516
051A:  BRA     522
051C:  BSET.B  206.0
051E:  BTSC.B  206.0
0520:  BRA     51E
.................... 	i2c_write(PH_LIGHT,0x81);  //Move the address number left on and add a one to make is a read command. 
0522:  MOV.B   #81,W1L
0524:  CALL    464
.................... 	temphigh = i2c_read(PH_LIGHT); 
0528:  MOV     #1,W1
052A:  MOV     W1,[W15++]
052C:  MOV     [--W15],W1
052E:  CALL    4BA
0532:  MOV.B   W0L,AC6
....................     delay_ms(10);   // wait for measurement 
0534:  MOV     #A,W0
0536:  CALL    226
....................       
....................     templow = i2c_read(PH_LIGHT,0); 
053A:  MOV     #0,W1
053C:  MOV     W1,[W15++]
053E:  MOV     [--W15],W1
0540:  CALL    4BA
0544:  MOV.B   W0L,AC7
....................   	i2c_stop(PH_LIGHT);   
0546:  MOV     #1F,W0
0548:  AND     206,W0
054A:  BRA     NZ,546
054C:  BSET.B  206.2
054E:  BTSC.B  206.2
0550:  BRA     54E
....................    
....................      
....................     // trigger rh  measurement 
.................... 	i2c_start(PH_LIGHT); 
0552:  BTSS.B  208.3
0554:  BRA     55E
0556:  BSET.B  206.1
0558:  BTSC.B  206.1
055A:  BRA     558
055C:  BRA     564
055E:  BSET.B  206.0
0560:  BTSC.B  206.0
0562:  BRA     560
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
0564:  MOV.B   #80,W1L
0566:  CALL    464
.................... 	i2c_write(PH_LIGHT,0x01);  //Send the command for reading the version 
056A:  MOV.B   #1,W1L
056C:  CALL    464
.................... //	i2c_stop(PH_LIGHT); 
....................     delay_ms(20);   // wait for measurement 
0570:  MOV     #14,W0
0572:  CALL    226
....................      
....................   //   Start over to read the measurement.  This kicks the chip out of low power mode. 
....................     i2c_start(PH_LIGHT); 
0576:  BTSS.B  208.3
0578:  BRA     582
057A:  BSET.B  206.1
057C:  BTSC.B  206.1
057E:  BRA     57C
0580:  BRA     588
0582:  BSET.B  206.0
0584:  BTSC.B  206.0
0586:  BRA     584
.................... 	i2c_write(PH_LIGHT,0x81);  //Move the address number left on and add a one to make is a read command.    
0588:  MOV.B   #81,W1L
058A:  CALL    464
....................     rhhigh = i2c_read(PH_LIGHT); 
058E:  MOV     #1,W1
0590:  MOV     W1,[W15++]
0592:  MOV     [--W15],W1
0594:  CALL    4BA
0598:  MOV.B   W0L,AC8
....................        delay_ms(10);   // wait for measurement 
059A:  MOV     #A,W0
059C:  CALL    226
....................     rhlow = i2c_read(PH_LIGHT,0); 
05A0:  MOV     #0,W1
05A2:  MOV     W1,[W15++]
05A4:  MOV     [--W15],W1
05A6:  CALL    4BA
05AA:  MOV.B   W0L,AC9
.................... 	i2c_stop(PH_LIGHT); 
05AC:  MOV     #1F,W0
05AE:  AND     206,W0
05B0:  BRA     NZ,5AC
05B2:  BSET.B  206.2
05B4:  BTSC.B  206.2
05B6:  BRA     5B4
....................      
....................     th = (int) temphigh; 
05B8:  MOV.B   AC6,W0L
05BA:  MOV.B   W0L,862
05BC:  CLR.B   863
....................     tl = (int) templow; 
05BE:  MOV.B   AC7,W0L
05C0:  MOV.B   W0L,864
05C2:  CLR.B   865
....................     hh = (int) rhhigh; 
05C4:  MOV.B   AC8,W0L
05C6:  MOV.B   W0L,866
05C8:  CLR.B   867
....................     hl = (int) rhlow; 
05CA:  MOV.B   AC9,W0L
05CC:  MOV.B   W0L,868
05CE:  CLR.B   869
....................      
....................  //   t = (float) (th << 8 | tl); 
....................  //   h = (float) (hh << 8 | hl); 
....................  //   t = t * 165.0 / 65536.0 - 40.0; 
.................... //	h = h * 100.0 / 65536.0;	 
....................  
....................      
....................      
....................     return(t); 
05D0:  MOV     ACC,W0
05D2:  MOV     ACE,W1
05D4:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
.................... #ifndef TIRHTEMP 
....................  
.................... float RHData, Temperature;   // These are the values for the coefenents for decay solutions. 
....................  
.................... //**************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // Init all of the I/O bits to make the RH/Temp sensor work 
.................... // Returns nothing 
.................... //**************************************************************************** 
.................... void initRHTemp(void) 
.................... 	{ 
.................... 	output_high(RHTEMP);   //This sets the output high. 
.................... 	} 
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // Find the check sum number 
.................... //  0 - all is good, 1 - all is bad 
.................... //**************************************************************************** 
.................... int16 CheckSumRHTemp(long RawRH, long RawTemp) 
.................... 	{ 
.................... 	int16 checksum2,checksum3; 
....................  
.................... 	checksum2 = (int16) 0xFF00 & RawRH; 
....................     checksum2 = checksum2>>8; 
.................... 	checksum2 = checksum2 + (int16) (0x00FF & RawRH); 
....................  
.................... 	checksum3 = (int16) (0xFF00 & RawTemp); 
....................     checksum3 = checksum3>>8; 
.................... 	checksum2 = checksum3 + checksum2 + (int16) (0x00FF & RawTemp); 
....................  
.................... 	return(0x00FF & checksum2); 
.................... 	} 
....................  
....................  
.................... //*************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // This routine returns the RH and Temps as float through global variables 
.................... // Returns 1 if there is an error.  a zero if there none 
.................... // All calculations for converion and reading the sensor is done here. 
.................... //*************************************************************************** 
.................... int GetTempRH(void) 
.................... 	{ 
.................... 	int x,y,w,counter; 
....................     long  RawRH, RawTemp, CheckSum;//These are the global varaibles for RH and Temperature 
....................  
....................  
.................... //  Send command out to the I/O pin 
.................... 	output_high(RHTEMP);   //This sets the output high. 
.................... 	output_low(RHTEMP);   //This sets the output high. 
.................... 	delay_ms(5); 
.................... 	output_high(RHTEMP);   //This sets the output high. 
.................... 	delay_us(40); 
.................... 	output_float(RHTEMP); 
.................... 	delay_us(20); 
....................  
.................... 	for (x=0; x < 5; x++) ///This waits to get out of the MCU command 
.................... 		{ 
.................... 		y=input_state(RHTEMP); 
.................... 		if (!y) break; 
.................... 		delay_us(10); 
.................... 		} 
.................... 	for (x=0; x < 20; x++)   //This waits through the zero and finds a 1 
.................... 		{ 
.................... 		y=input_state(RHTEMP); 
.................... 		if (y) break; 
.................... 		delay_us(10); 
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(10); 
.................... 		} 
.................... 	 
.................... //beginning of first bit zero 
.................... //Setup the for loop 
.................... RawRH = 0; /// Clear out the variable 
.................... for (counter=0; counter < 16; counter++) 
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the bit to time out the zero for the next bit 
.................... 		if (y) break; 
.................... 		delay_us(5); 
.................... 		} 
.................... 		w=y; 
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(5); 
.................... 		} 
....................  
.................... 	RawRH=RawRH<<1;	// Shift the whole word one bit left. 
.................... 	if (x > 6) 
.................... 		{ 
.................... 		RawRH = RawRH + 0x0001; 
.................... 		} 
.................... 	} 
.................... 	 
....................  
....................  
.................... RawTemp = 0; /// Clear out the variable 
.................... for (counter=0; counter < 16; counter++) 
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the bit to time out the zero for the next bit 
.................... 		if (y) break; 
.................... 		delay_us(5); 
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(5); 
.................... 		} 
.................... 	 
....................  
.................... 	RawTemp=RawTemp<<1;	// Shift the whole word one bit left. 
.................... 	if (x > 6) 
.................... 		{ 
.................... 		RawTemp = RawTemp + 0x0001; 
.................... 		} 
.................... 	} 
....................  
....................  
....................  
.................... CheckSum = 0; /// Clear out the variable 
.................... for (counter=0; counter < 8; counter++) 
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the bit to time out the zero for the next bit 
.................... 		if (y) break; 
.................... 		delay_us(5); 
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(5); 
.................... 		} 
.................... 	 
....................  
.................... 	CheckSum=CheckSum<<1;	// Shift the whole word one bit left. 
.................... 	if (x > 6) 
.................... 		{ 
.................... 		CheckSum = CheckSum + 0x0001; 
.................... 		} 
.................... 	} 
....................  
.................... 	RHData = (float)RawRH; 
....................  
.................... if (CheckSum == CheckSumRHTemp(RawRH,RawTemp)) 
.................... 	{ 
.................... 	RHData = (float)RawRH/10.0; 
....................     Temperature = ((float)RawTemp)/10.0; 
.................... 	return(0); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 	return(1); 
.................... 	} 
.................... 	} 
....................  
.................... #endif 
....................  
.................... #ifdef CHEAPEC  
.................... //************************************************************************************* 
.................... // Created September 2, 2015 
.................... // This routines calculated all of the values for a given set of decay equation. 
.................... //  The equation is y = AA + BBexp^-CCx.  This is an electrcial decay equation that has to be run several times to get the values for AA, BB and CC. 
.................... // It's assumed the first value is the highest ppm  with the lowst value for x as in imput. 
.................... // The result are gloabe variables for AA, BB and BC. 
.................... // AA is calculated by knowing the first assmetopt. 
....................  
.................... float solvefordecay(int32 measurement)	 
.................... 	{ 
....................  
.................... 	float eccheck;    //These are used for holding the caluclated values for the current returned iteration.  The x input is not needed because it's already defined. 
.................... 	int x; 
....................  
....................  
.................... //********************************************************************** 
.................... // Added Sept 3, 2015 
.................... // Updated with regression equations May 31, 2016 
.................... // The attempt to solve for a decaying curve is stopped for now.   
.................... // Currently a liner approach is used for three points. 
.................... //********************************************************************** 
.................... // Form the calibration data proved on the EEPROM, find all of the coef for the lineized LOG function. 
.................... //  Y = B + m(ln(x)) 
.................... // B =  
.................... // Find Y     
....................      
....................      
....................      
....................      
....................      
....................      
.................... eccheck = (float) measurement;   /// Change over the data type to a float for correct operations in the range testing. 
....................  
....................  
.................... if (eccheck > eccalibrationx[0])    
.................... 	{ 
.................... 	y = 0.0; 
.................... 	return(y);   //Send out the result if it's to a limit. 
.................... 	} 
....................  
.................... if (eccheck <= eccalibrationx[2]) 
.................... 	{ 
.................... 	y = 2000.0; 
.................... 	return(y);  //Send out the result if it's to a limit. 
.................... 	} 
....................  
.................... } 
....................  
....................  
....................  
.................... //************************************************************************************ 
.................... // Created Augest 24, 2015 
.................... // This routine measures the time delay for EC  or TDS.  It does this by cycling through a decay of an RC circute. 
.................... // The pinouts are as follwos: 
.................... // PICCPU    Function 
.................... // RC14     - C+ 
.................... // RC13     - C- 
.................... // RD0      - EC+ 
.................... // RD11     - EC- 
.................... // This is the firing order for measurement: 
.................... // EC1     input   low       low               input        measuere decay    high 
.................... // C+      high    input     measuere decay    high         low               input 
.................... // C-      low     low       low               high         high              high 
.................... // The returned results is an average of 16 measurements of plus and mnues measurentents at 1Khz 
.................... // returns a float with the current EC value. 
.................... //************************************************************************************* 
.................... float measureTDS(void) 
.................... 	{ 
....................  
.................... 	int statecounter,x; 
.................... 	int32 currentreadingunder=0,y,z;  // This is used as the state counter for the measurmeents.  It goes between 1 to seven. 
.................... 	int32 measurement=0, currentreading;   //This is the measurement accumlator and then it's averaged. 
.................... 	float result; 
....................  
.................... //  Set up the output and input for the EC meter. 
.................... /* 
.................... while(1) 
.................... 	{ 
.................... 	output_high(PIN_D10);    //  Define as EC1 
.................... 	output_low(PIN_D10);    //  Define as EC1 
.................... 	} 
.................... */ 
.................... output_high(PIN_D10);    //  Define as EC1- 
....................  
.................... //************************************************* 
.................... // Changed from the old board to the last version on March 28, 2016 
.................... // The two C+ and C- are changed from D0  & C13 to D8 and RD9 for C+ and RD8 for C- 
.................... // Old settings are below. 
.................... //output_high(PIN_D0);     // Define as C+   // Added September 6, 2015  Needs to be changed to RD9 for the new board 
.................... //output_float(PIN_C13);           // Define as C-   // Added September 6, 2015  Needs to be changed to RD8 for the new board 
.................... //************************************************************** 
....................  
.................... output_high(PIN_D9);     // Define as C+   // Added September 6, 2015  Needs to be changed to RD9 for the new board 
.................... output_float(PIN_D8);           // Define as C-   // Added September 6, 2015  Needs to be changed to RD8 for the new board 
....................  
.................... output_high(PIN_D11);    //  Define as EC2+   This is the negative direction charge compared to ground.  
.................... // input_state(); 
.................... //while(1) 
.................... //	{ 
.................... restart_wdt();   // restart the WD timer.  It set for 65 seconds 
.................... for (x = 1; x <=16; x++) 
.................... 	{ 
....................  
.................... 	for (statecounter = 1; statecounter < 7; statecounter++) 
.................... 		{ 
.................... 		switch(statecounter) 
.................... 			{ 
.................... 			case 1:     //  Charge Cap to max in + direction. 
.................... 				output_float(PIN_D10);    //  Define as EC- 
.................... 				input(PIN_D11);    //  Define as EC+    keep floarting to no interferiw with measurement.				 
.................... 				//output_high(PIN_D0);     // Define as C+ 
....................                 output_high(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				//output_low(PIN_C13);           // Define as C- 
....................                 output_low(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 				delay_us(100);   // Wait for the CAP to charge to Vcc.  Check on scope. 
.................... 				break; 
.................... 			case 2: 
.................... 				output_low(PIN_D11);    //  Define as EC+ 
.................... 				output_float(PIN_D10);    //  Define as EC-    keep floarting to no interferiw with measurement.				 
.................... //				input(PIN_D0);     // Define as C+ 
....................  
.................... 		//		output_low(PIN_D0);     // Define as C+ 
.................... 				//output_low(PIN_C13);           // Define as C- 
....................                 output_low(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 			//	currentreading = input(PIN_D11);   // update the output for the first one. 
.................... 				for (currentreading = 0; currentreading < 20000; currentreading++) 
.................... 					{ 
.................... 				//	fprintf(BT,"Current EC currentreading %i\n\r",currentreading); 
.................... 				/*	if (!input(PIN_D0)) 
.................... 							{ 
.................... 							 y = currentreading;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							}  */ 
....................  					if (!input(PIN_D9))   //New Board I/O pin  March 28, 2016 
.................... 							{ 
.................... 							 y = currentreading;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							}                    
.................... 					} 
.................... 				break; 
.................... 			case 3: 
.................... 			    input(PIN_D10);    //  Define as EC- 
.................... 				output_float(PIN_D11);    //  Define as EC+    keep floarting to no interferiw with measurement.				 
....................  
.................... 				//output_high(PIN_D0);     // Define as C+   //Discharge the CAP in the other direction. 
....................                 output_high(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				//output_high(PIN_C13);           // Define as C- 
....................                 output_high(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 				delay_us(100);   // Wait for the CAP to charge to Vcc.  Check on scope. 
....................  
.................... 				break; 
.................... 			case 4: 
.................... 				//output_high(PIN_C13);     // Define as C+ 
....................                 output_high(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 				//output_low(PIN_D0);           // Define as C- 
....................                 output_low(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				delay_us(100);   // Wait for the CAP to charge to Vcc.  Check on scope. 
.................... 				break; 
.................... 			case 5: 
.................... 				output_high(PIN_D10);    //  Define as EC- 
.................... 				output_float(PIN_D11);    //  Define as EC+    keep floarting to no interferiw with measurement.				 
.................... //				input(PIN_D0);     // Define as C+ 
....................  
.................... 		//		output_low(PIN_D0);     // Define as C+ 
.................... 			//	output_high(PIN_D0);           // Define as C+ 
.................... 			//	currentreading = input(PIN_D11);   // update the output for the first one. 
.................... 				for (currentreadingunder = 0; currentreadingunder < 20000; currentreadingunder++) 
.................... 					{ 
.................... 				//	fprintf(BT,"Current EC currentreading %i\n\r",currentreading); 
.................... 				/*	if (input(PIN_D0))    //  measure using C- 
.................... 							{ 
.................... 							 z = currentreadingunder;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							}  */ 
....................                     if (input(PIN_D9))    //  measure using C-  New Board I/O pin  March 28, 2016 
.................... 							{ 
.................... 							 z = currentreadingunder;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							} 
.................... 					} 
.................... 				break; 
....................  
.................... 			case 6: 
....................  
.................... 				//output_low(PIN_D0);     // Define as C+   //Discharge the CAP in the other direction. 
....................                 output_low(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				//output_low(PIN_C13);           // Define as C- 
....................                 output_low(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
....................  
....................  
....................  
.................... 				break; 
.................... 			default: 
....................  
....................  
.................... 				break; 
.................... 			} 
....................  
.................... 	 measurement =  measurement + y;   // Add together all of the 16 numbers. 
.................... currentreadingunder = currentreadingunder + z; 
.................... restart_wdt();   // restart the WD timer.  It set for 65 seconds 
.................... 		} 
....................  
....................  
.................... 	} 
.................... currentreadingunder = currentreadingunder/16; 
.................... 	measurement = measurement/16;   // Do the average 
....................  
....................  
.................... //********************************************************************************* 
.................... // Created Aug 10, 2016 
.................... // Set all EC probe levels to zero when leaving the routine. 
.................... //******************************************************************************** 
....................   output_low(PIN_D8);     //Set to low to prevent interference with pH bulb. 
....................   output_low(PIN_D9); 
....................   output_low(PIN_D10); 
....................   output_low(PIN_D11); 
....................  
.................... //************************************************************************************************ 
.................... // Created Sept 1, 2015 
.................... // Below takes the decay value from the C+ side and converts it into ppm.   
.................... // At this time there is no temperature compensation. 
.................... // At this time the calibration values are not saved in SD Card. 
.................... //************************************************************************************************ 
....................  
.................... //  Current measured data 
.................... //  Reading            ppm 
.................... //  36                 1553 
.................... //  51                 468 
.................... //  700                24 
....................  
.................... eccalibrationx[0] = 447.0; 
.................... eccalibrationx[1] = 44.0; 
.................... eccalibrationx[2] = 19.0; 
....................  
....................  
.................... eccalibrationy[0]  = 33.0; 
.................... eccalibrationy[1]  = 481.0; 
.................... eccalibrationy[2]  = 1718.0; 
....................  
....................  
.................... result = solvefordecay(measurement); // Solve for the current value for calibration for this EC meter 
.................... fprintf(BT,"Current EC reading top %Lu under %Lu  ppm %f\n\r",measurement,currentreadingunder,result); 
.................... result =  (float) measurement; 
.................... //measurement=0; 
.................... //} 
.................... //return(result);   // this is the old return  Changed April 14, 2016 
.................... return(result);	 
.................... 	}   // end of function. 
....................  
.................... #endif 
....................  
.................... #include "I2cCO2.c" 
....................  
....................  
.................... //**************************************************************************************** 
.................... // Added Jan 24, 2012 
.................... // This is a file for all the routines to connect with a CO2 K-30 sensor. 
.................... //The changes below are for the internal sensor inside the CELSS system. 
.................... //**************************************************************************************** 
....................  
.................... //#define DATACO2  PIN_A2    /*set DATACO2 to PortA1 and SCKCO2 to portA2*/ //Old ones 
.................... //#define SCKCO2   PIN_A1     // Old ones 
....................  
.................... //#define DATACO2  PIN_B2    /*set DATACO2 to PortB3 and SCKCO2 to portB2*/  
.................... //#define SCKCO2   PIN_B3    //This is set up for BioSphere2  Added June 20, 2013 
....................  
.................... #define DATACO2  PIN_B11    /*set DATACO2 to PortB3 and SCKCO2 to portB2*/  
.................... #define SCKCO2   PIN_B10    //This is set up for BioSphere2  Added June 20, 2013 
....................  
.................... //**************************************************************************************** 
.................... // Added Jan 28, 2012 
.................... // This routine is used to send the timing for reading one Byte of data from the I2c. 
.................... //**************************************************************************************** 
.................... BYTE CO2ReadByte(void) 
.................... { 
....................  
....................   int i; 
.................... 	BYTE lVal1;   //Add September 3, 2012.  This def needed to be added. 
....................    long lTmp,lValue; 
.................... 	lVal1=0; 
*
02EA:  CLR.B   AD2
....................    output_low(SCKCO2); 
02EC:  BCLR.B  2C9.2
02EE:  BCLR.B  2CD.2
....................    delay_us(5); 
02F0:  REPEAT  #4E
02F2:  NOP     
.................... 	output_float(DATACO2); 
02F4:  BSET.B  2C9.3
....................    for (i=0; i<8; i++)         //Read CO2 sensor without ACK. 
02F6:  CLR     AD4
02F8:  MOV     AD4,W4
02FA:  CP      W4,#8
02FC:  BRA     GE,32C
.................... 	   { 
.................... 		lVal1<<=1; 
02FE:  SL.B    AD2
....................     	output_high(SCKCO2);  //Clock High is when the data is legal. 
0300:  BCLR.B  2C9.2
0302:  BSET.B  2CD.2
....................     	delay_us(10); 
0304:  REPEAT  #9E
0306:  NOP     
....................     	lTmp = input(DATACO2); 
0308:  BSET.B  2C9.3
030A:  CLR     AD6
030C:  BTSC.B  2CB.3
030E:  INC     0AD6
0310:  CLR     AD8
....................    	    delay_us(10); 
0312:  REPEAT  #9E
0314:  NOP     
....................     	output_low(SCKCO2); 
0316:  BCLR.B  2C9.2
0318:  BCLR.B  2CD.2
....................     	delay_us(10); 
031A:  REPEAT  #9E
031C:  NOP     
....................     	if (lTmp) lVal1|=1;  
031E:  CP0     AD6
0320:  BRA     NZ,326
0322:  CP0     AD8
0324:  BRA     Z,328
0326:  BSET.B  AD2.0
0328:  INC     0AD4
032A:  BRA     2F8
....................    		}  
.................... 		output_low(DATACO2); 
032C:  BCLR.B  2C9.3
032E:  BCLR.B  2CD.3
....................  		delay_us(5); 
0330:  REPEAT  #4E
0332:  NOP     
....................     	output_high(SCKCO2);  //Clock High is when the data is legal. 
0334:  BCLR.B  2C9.2
0336:  BSET.B  2CD.2
....................  		delay_us(5); 
0338:  REPEAT  #4E
033A:  NOP     
....................     	output_low(SCKCO2); 
033C:  BCLR.B  2C9.2
033E:  BCLR.B  2CD.2
.................... 		delay_us(5); 
0340:  REPEAT  #4E
0342:  NOP     
.................... 	    output_float(DATACO2); 
0344:  BSET.B  2C9.3
.................... 		delay_us(5); 
0346:  REPEAT  #4E
0348:  NOP     
....................  
.................... return(lVal1); 
034A:  MOV.B   AD2,W0L
034C:  MOV.B   W0L,0
034E:  RETURN  
.................... } 
....................  
....................  
.................... void CO2SendStopBit(void) 
.................... //**************************************************************************************** 
.................... // Added Jan 28, 2012 
.................... // This routine sends a start bit only. 
.................... //Starting with the clock and data lines low for data SDA change.   
.................... //Leaving Data lines  high. 
.................... //**************************************************************************************** 
.................... { 
....................  
.................... 	output_high(DATACO2); 
*
02CC:  BCLR.B  2C9.3
02CE:  BSET.B  2CD.3
....................     delay_us(6); 
02D0:  REPEAT  #5E
02D2:  NOP     
....................     output_high(SCKCO2); 
02D4:  BCLR.B  2C9.2
02D6:  BSET.B  2CD.2
....................     delay_us(6); 
02D8:  REPEAT  #5E
02DA:  NOP     
.................... 	output_low(DATACO2); 
02DC:  BCLR.B  2C9.3
02DE:  BCLR.B  2CD.3
....................     delay_us(10); 
02E0:  REPEAT  #9E
02E2:  NOP     
.................... 	output_high(DATACO2); 
02E4:  BCLR.B  2C9.3
02E6:  BSET.B  2CD.3
02E8:  RETURN  
.................... 	 
.................... } 
....................  
....................  
.................... //**************************************************************************************** 
.................... // Added Jan 28, 2012 
.................... // This routine is used to send the timing to send one Byte of data to the CO2 sensor. 
.................... //This routines makes about 10 attempts of writing one byte of data with ACK.  If the ACk is not present, then it tries again until 10 times are up. 
.................... //The routine returns a 0 ieverything is OK, it returns a 1 if it failed. 
.................... //This routines assumes a startbit has occured. 
.................... //**************************************************************************************** 
.................... int CO2WriteByte(BYTE command) 
.................... { 
....................  
.................... int i,ii; 
.................... int lTmp; 
.................... int state; 
.................... //Make sure the start bit is active. 
.................... // All data lines are coming in Low 
....................  
.................... 	//Setup first bit of data to write. 
....................  
.................... //for (ii=0; ii<10; ii++)  //loop through 10 tries 
.................... //**************************************************************** 
.................... //Added 2/13/2012 
.................... //*  data is sent to the CO2 sensor in a backwards way.  For instance the command address 0x68 is b01101000.  The LSB is send firt and the last bit is the MSB.   
.................... //*  The wave form looks like   b00010110.  All numbers are like that for the CO2 sensor. 
.................... //*  To receive data from the CO2 sensor. 
.................... //*   Master Transmit: 
.................... //*   <68> <04> <00> <03> <00> <01> <C8> <F3>       
.................... //*  This means  
.................... //*  0x68 is the command.  In the I2C world this needs to be shifted to 0xD0  or  0x68 = b01101000 to 11010000  padded 0 shift left.  
.................... //*  0x04 is the register 
.................... //*  0x00 and 0x03 is the register.  It is sent in this order. 
.................... //*  0x00 and 0x01 is the number of bytes read back in this case 2. 
.................... //*  The last two are the check Sum where the LSByte is send first and the high one last. 
.................... //*  All data is reversted. 
....................  
....................  
.................... //*   Slave Reply: 
.................... //*   <68> <04> <02> <03> <01> <24> <09>   This gives the nuimger of 0x301 ppm. 
....................  
.................... //{ 
....................    output_low(SCKCO2); 
*
024E:  BCLR.B  2C9.2
0250:  BCLR.B  2CD.2
....................    delay_us(5); 
0252:  REPEAT  #4E
0254:  NOP     
.................... 	ii = 0x80; 
0256:  MOV     #80,W4
0258:  MOV     W4,AD6
....................    for (i=1; i<=8; i++) 
025A:  MOV     #1,W4
025C:  MOV     W4,AD4
025E:  MOV     AD4,W4
0260:  CP      W4,#8
0262:  BRA     GT,296
....................    {if (ii & command)  
0264:  MOV.B   AD2,W0L
0266:  CLR.B   1
0268:  AND     AD6,W0
026A:  CP0     W0
026C:  BRA     Z,274
.................... 		{ 
.................... 		output_high(DATACO2); 
026E:  BCLR.B  2C9.3
0270:  BSET.B  2CD.3
.................... 		} 
0272:  BRA     278
....................     else  
.................... 		{  
.................... 		output_low(DATACO2); 
0274:  BCLR.B  2C9.3
0276:  BCLR.B  2CD.3
.................... 		}	 
.................... 		ii/=2;   
0278:  MOV     AD6,W4
027A:  MOV     #2,W3
027C:  REPEAT  #11
027E:  DIV.S   W4,W3
0280:  MOV     W0,AD6
.................... 		  delay_us(10);  
0282:  REPEAT  #9E
0284:  NOP     
....................           output_high(SCKCO2); 
0286:  BCLR.B  2C9.2
0288:  BSET.B  2CD.2
....................           delay_us(10); 
028A:  REPEAT  #9E
028C:  NOP     
....................           output_low(SCKCO2); 
028E:  BCLR.B  2C9.2
0290:  BCLR.B  2CD.2
0292:  INC     0AD4
0294:  BRA     25E
....................       }   
....................  delay_us(7); 
0296:  REPEAT  #6E
0298:  NOP     
....................   output_float(DATACO2); 
029A:  BSET.B  2C9.3
....................    delay_us(7); 
029C:  REPEAT  #6E
029E:  NOP     
....................           output_high(SCKCO2); 
02A0:  BCLR.B  2C9.2
02A2:  BSET.B  2CD.2
....................           delay_us(10); 
02A4:  REPEAT  #9E
02A6:  NOP     
....................   
....................         //  output_low(SCKCO2); 
.................... 	//	  delay_us(10); 
....................  
....................  //  output_high(SCKCO2); 
....................  
....................  state = 0; 
02A8:  CLR     ADA
.................... 	lTmp=input(DATACO2);   //Check to see if the Data line is high.  Low means sensor can take a command.  A Low means sensor is not ready. 
02AA:  BSET.B  2C9.3
02AC:  CLR     AD8
02AE:  BTSC.B  2CB.3
02B0:  INC     0AD8
.................... if(lTmp != 0) 
02B2:  CP0     AD8
02B4:  BRA     Z,2BA
.................... 		{ 
.................... 		state = 0;  //This means the device is not ready. 
02B6:  CLR     ADA
.................... //		CO2SendStopBit(); 
.................... 		} 
02B8:  BRA     2BE
.................... 		else 
.................... 		{ 
.................... 		state = 1;  //This means the device is ready or ACK worked 
02BA:  MOV     #1,W4
02BC:  MOV     W4,ADA
.................... 		//break; 
.................... 		}  
.................... output_low(SCKCO2); 
02BE:  BCLR.B  2C9.2
02C0:  BCLR.B  2CD.2
....................  
.................... output_high(DATACO2); 
02C2:  BCLR.B  2C9.3
02C4:  BSET.B  2CD.3
....................  
.................... //start to setup stop bit if needed or loop back and do it again. 
.................... //	output_low(DATACO2); 
.................... 	 
....................  //   delay_us(10); 
.................... //} 
....................  
....................  
.................... return(state);   //If it returns a 0, then is failed.  If it reutrns a 1, it worked. 
02C6:  PUSH    ADA
02C8:  POP     0
02CA:  RETURN  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... void CO2SendStartBit(void) 
.................... //**************************************************************************************** 
.................... // Added Jan 24, 2012 
.................... // This routine sends a start bit only. 
.................... //Leaving the clock low for data SDA change.   
.................... //Leaving Data high. 
.................... //This routine assumes all lines are high for a while. 
.................... //**************************************************************************************** 
.................... { 
....................   output_high(SCKCO2); 
*
0236:  BCLR.B  2C9.2
0238:  BSET.B  2CD.2
....................    output_high(DATACO2); 
023A:  BCLR.B  2C9.3
023C:  BSET.B  2CD.3
.................... 	delay_ms(20); 
023E:  MOV     #14,W0
0240:  CALL    226
....................   output_low(DATACO2);   //High to low on the data line  Start Condition 
0244:  BCLR.B  2C9.3
0246:  BCLR.B  2CD.3
.................... 	delay_us(10); 
0248:  REPEAT  #9E
024A:  NOP     
024C:  RETURN  
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... int WakeUpCO2Sensor(void) 
.................... //**************************************************************************************** 
.................... //  Added Jan 24, 2012 
.................... //This wakes up the CO2 scensor and then keeps the clock going until the first command 
.................... // can be set to the CO2 Sensor. 
.................... //**************************************************************************************** 
....................  
.................... { 
....................  
....................  
.................... int lTmp; 
.................... int state; 
....................  
....................  
.................... CO2SendStartBit(); 
.................... lTmp=CO2WriteByte(0xFE);  //This is a test wakeup. 
....................  
.................... CO2SendStopBit(); 
....................  
.................... 	 
.................... 	return(lTmp); 
.................... }	 
.................... 	 
.................... //int ReadCOSensor(BYTE &ReturnedReadSuccess, BYTE &data1, BYTE &data2, BYTE &CheckSum) 
.................... int16 ReadCOSensor(void) 
*
0350:  MOV     W5,[W15++]
.................... //****************************************************************************************** 
.................... // Added Jan 24, 2012 
.................... // This routine sends the sequence of bytes to the CO2 device and then waits for the return data line to go low. 
.................... //  At the time, the program starts to read the data coming back from the CO2. 
.................... //****************************************************************************************** 
....................  
.................... 	{ 
.................... int16 lTmp;	 
.................... int i,lTmp2; 
.................... BYTE first,second,third,forth, checksum; 
....................  
....................  
.................... lTmp = 0; 
0352:  CLR     ACC
.................... CO2SendStartBit(); 
0354:  CALL    236
.................... //lTmp=CO2WriteByte(0x7E);  //This Sensor address  that is 0x68  shifted left one with a zoer padded   0b01101000  -> 0b11010000 
.................... lTmp=CO2WriteByte(0xD0);  //This Sensor address  that is 0x68  shifted left one with a zoer padded   0b01101000  -> 0b11010000 
0358:  MOV.B   #D0,W0L
035A:  MOV.B   W0L,AD2
035C:  CALL    24E
0360:  MOV     W0,ACC
.................... if (lTmp == 1) 
0362:  MOV     ACC,W4
0364:  CP      W4,#1
0366:  BRA     NZ,3B2
.................... 	{ 
.................... 	lTmp = 0; 
0368:  CLR     ACC
.................... 	lTmp=CO2WriteByte(0x22);  
036A:  MOV.B   #22,W0L
036C:  MOV.B   W0L,AD2
036E:  CALL    24E
0372:  MOV     W0,ACC
.................... 	if (lTmp == 1) 
0374:  MOV     ACC,W4
0376:  CP      W4,#1
0378:  BRA     NZ,3B2
.................... 		{ 
.................... 		lTmp = 0; 
037A:  CLR     ACC
.................... 		lTmp=CO2WriteByte(0x00);  
037C:  CLR.B   AD2
037E:  CALL    24E
0382:  MOV     W0,ACC
.................... 		if (lTmp == 1) 
0384:  MOV     ACC,W4
0386:  CP      W4,#1
0388:  BRA     NZ,3B2
.................... 			{ 
.................... 			lTmp = 0; 
038A:  CLR     ACC
.................... 			lTmp=CO2WriteByte(0x08);  
038C:  MOV.B   #8,W0L
038E:  MOV.B   W0L,AD2
0390:  CALL    24E
0394:  MOV     W0,ACC
.................... 			if (lTmp == 1) 
0396:  MOV     ACC,W4
0398:  CP      W4,#1
039A:  BRA     NZ,3B2
.................... 			{	 
.................... 				lTmp = 0; 
039C:  CLR     ACC
.................... 				lTmp=CO2WriteByte(0x2A);  
039E:  MOV.B   #2A,W0L
03A0:  MOV.B   W0L,AD2
03A2:  CALL    24E
03A6:  MOV     W0,ACC
.................... 				if (lTmp == 1) 
03A8:  MOV     ACC,W4
03AA:  CP      W4,#1
03AC:  BRA     NZ,3B2
.................... 				{	 
.................... 					lTmp = 5;  
03AE:  MOV     #5,W4
03B0:  MOV     W4,ACC
.................... 					} 
.................... 				} 
.................... 			} 
.................... 		} 
.................... 	} 
....................    
.................... CO2SendStopBit(); 
03B2:  CALL    2CC
....................  
.................... if (lTmp == 5) 
03B6:  MOV     ACC,W4
03B8:  CP      W4,#5
03BA:  BRA     NZ,40A
.................... 	{ 
....................  
.................... delay_ms(10);  //Wait for sensor to come back with numbers and then send command. 
03BC:  MOV     #A,W0
03BE:  CALL    226
....................  
.................... //****************************************************************************** 
.................... //Added Feb 13, 2012 
.................... //This part waits for a start bit from the Slave. 
.................... //****************************************************************************** 
.................... //Slave Reply: 
.................... //*   <68> <04> <02> <03> <01> <24> <09>   This gives the nuimger of 0x301 ppm. 
.................... lTmp=0; 
03C2:  CLR     ACC
.................... CO2SendStartBit(); 
03C4:  CALL    236
.................... lTmp=CO2WriteByte(0xD1);  //This Sensor address  that is 0x68  shifted left one with a zoer padded   0b01101000  -> 0b11010000 
03C8:  MOV.B   #D1,W0L
03CA:  MOV.B   W0L,AD2
03CC:  CALL    24E
03D0:  MOV     W0,ACC
....................  
....................  
....................  	if (lTmp == 1) 
03D2:  MOV     ACC,W4
03D4:  CP      W4,#1
03D6:  BRA     NZ,3FC
.................... 		{ 
.................... 		first = CO2ReadByte(); 
03D8:  CALL    2EA
03DC:  MOV.B   W0L,AC6
.................... 		second = CO2ReadByte(); 
03DE:  CALL    2EA
03E2:  MOV.B   W0L,AC7
.................... 		third = CO2ReadByte(); 
03E4:  CALL    2EA
03E8:  MOV.B   W0L,AC8
.................... 		forth = CO2ReadByte(); 
03EA:  CALL    2EA
03EE:  MOV.B   W0L,AC9
.................... 		CO2SendStopBit(); 
03F0:  CALL    2CC
.................... 		lTmp = lTmp+1; 
03F4:  MOV     ACC,W4
03F6:  ADD     W4,#1,W0
03F8:  MOV     W0,ACC
.................... 		} 
03FA:  BRA     408
.................... 		else    //This is the else command for writing succesyy the first read command 
.................... 		{ 
.................... 		CO2SendStopBit(); 
03FC:  CALL    2CC
.................... 		lTmp = -1; 
0400:  SETM    ACC
.................... 		return(lTmp);  //If is does not work, then return failed. 
0402:  PUSH    ACC
0404:  POP     0
0406:  BRA     460
.................... 		} 
.................... 	} 
0408:  BRA     416
.................... 	else    //This is the else command for writing succesyy the first read command 
.................... 	{ 
.................... 	CO2SendStopBit(); 
040A:  CALL    2CC
.................... 	lTmp = -1; 
040E:  SETM    ACC
.................... 	return(lTmp);  //If is does not work, then return failed. 
0410:  PUSH    ACC
0412:  POP     0
0414:  BRA     460
.................... 	} 
.................... //****************************************************** 
.................... //Added Oct. 11, 2012 
.................... //This section does a checksum of the returned three values and tells the calling routine if the data 
.................... // is valid or returns the new CO2 measurement. 
.................... //****************************************************** 
....................  
.................... checksum = first + second + third; 
0416:  MOV.B   AC6,W0L
0418:  ADD.B   AC7,W0L
041A:  MOV     AC8,W4
041C:  ADD.B   W0L,W4L,W0L
041E:  MOV.B   W0L,ACA
.................... if ((checksum == forth) & (first == 0x21)) 
0420:  MOV.B   ACA,W0L
0422:  CP.B    AC9
0424:  BRA     Z,42A
0426:  CLR.B   W0
0428:  BRA     42C
042A:  MOV.B   #1,W0L
042C:  MOV.B   W0L,W5L
042E:  MOV     AC6,W4
0430:  XOR.B   #21,W4L
0432:  BRA     Z,438
0434:  CLR.B   W0
0436:  BRA     43A
0438:  MOV.B   #1,W0L
043A:  AND.B   W5L,W0L,W0L
043C:  CP0.B   W0L
043E:  BRA     Z,45A
.................... 	{ 
.................... //This sectoin agress that check sum is OK 
.................... //Added Oct 11, 2012 
.................... // Second is the upper part of the integer.  
....................     lTmp = second; 
0440:  MOV.B   AC7,W0L
0442:  MOV.B   W0L,ACC
0444:  CLR.B   ACD
.................... 	lTmp = lTmp * 256; 
0446:  MOV     ACC,W4
0448:  MOV     #100,W3
044A:  MUL.SS  W4,W3,W0
044C:  MOV     W0,ACC
.................... 	lTmp = lTmp + third; 
044E:  MOV     AC8,W4
0450:  CLR.B   9
0452:  MOV     ACC,W3
0454:  ADD     W3,W4,W0
0456:  MOV     W0,ACC
.................... 	} 
0458:  BRA     45C
.................... 	else 
.................... 	{ 
.................... 	lTmp = -1;  // This routines an error if the check sum does not come out. 
045A:  SETM    ACC
.................... 	} 
.................... return(lTmp); 
045C:  PUSH    ACC
045E:  POP     0
0460:  MOV     [--W15],W5
0462:  RETURN  
.................... } 
....................  
....................  
.................... void CalibrateCO2(void) 
.................... //****************************************************************************************** 
.................... // Added Jan 24, 2012 
.................... // This routines start the CO2 device to do a background CO2 calibration.  This routine is used once a month for 
.................... // now.  How to use this program is TBD. 
.................... //****************************************************************************************** 
.................... { 
....................  
....................  
....................  
....................  
.................... } 
....................  
....................  
.................... void InitCO2(void) 
.................... //****************************************************************************************** 
.................... // Added Jan 26, 2012 
.................... // This routine sets up the two control bits for output. 
.................... //****************************************************************************************** 
.................... { 
....................    output_high(DATACO2); 
*
0200:  BCLR.B  2C9.3
0202:  BSET.B  2CD.3
.................... 	output_high(SCKCO2); 
0204:  BCLR.B  2C9.2
0206:  BSET.B  2CD.2
0208:  RETURN  
....................  
.................... } 
....................  
....................  
....................  
.................... #include "ITwoSeeGeneralCommunicationSlave.c"     // this is included to connect to the master Osmobot. 
.................... //*************************************************************************************** 
.................... // Created October 16, 2016 
.................... // This file is included in project to make this unit a slave for the Osmobot. 
.................... // include this in the top of the project and update the data array with the data wanting to be returned. 
.................... //************************************************************************************** 
.................... //#define SDAPIN PIN_B2 
.................... //#define SCLPIN PIN_B3 
....................  
.................... //#use I2C(stream=SENSOR, SLAVE, sda=SDAPIN,scl=SCLPIN, FORCE_HW, address=0xa0, NO_STRETCH)   // this is I2C 1 
....................  
.................... char send_buffer[128];   // this is filled by this unit for sending data. 
.................... unsigned int8 rcv_buffer[128];   // this is the received data from the master  
.................... unsigned  int8 address, streamCntr=0;  
....................  
....................  
.................... //*************************************************************************** 
.................... // Created Oct 7, 2016 
.................... // Updated Oct 16, 2016  -- Added CO2 structure for sending data.  -- Changed the number of registers to 100 from 20. 
.................... // This routine sets the protocal for communicating to a remote custom I2c device. 
.................... // The frames and commands are as follows: 
.................... // Address 0x12  for this device. 
.................... // write a command to the command register before reading or writing to the device 
.................... // Command Register  :    01    // A one for R reads all data points from the unit   //  A one for W writes calibration numbers for all instruments 
.................... //      MSB                  LSB 
.................... //       7  6  5  4  3  2  1  0 
.................... //       X  X  X  X  X  X  R  W 
.................... // There are 20 registers (bytes) for reading data from the unit 
.................... // There are 40 registers (bytes) for writing data to the unit 
.................... // Reading frame definition     --  has to be done in sequence each time. 
.................... // 1: HN4  whole number portion of reading 
.................... // 2: NH4  fraction of the reading 
.................... // 3: DO  whole number portion of reading 
.................... // 4: DO  fraction of the reading 
.................... // 5: Water Temperature  whole number portion of reading 
.................... // 6: Water Temperature  fraction of the reading 
.................... // 7: CO2 High byte    Updated Oct 16, 2016 
.................... // 8: CO2 Low Byte   Updated Oct 16, 2016 
.................... // 9: Air Temperature whole number    Updated Oct 24, 2016 
.................... // 10: Air Temperature fractional part   Updated Oct 24, 2016 
.................... // 11: Air RH  whole number   Updated Oct 24, 2016 
.................... // 12: Air RH fractional part    Updated Oct 24, 2016 
.................... // 13: Water Temperature High Byte raw data   Updated Feb 15, 2017 
.................... // 14: Water Temperature Low Byte raw data   Updated Feb 15, 2017 
.................... // 15: DO  RawData High Byte 
.................... // 16: DO  RawData Low Byte 
.................... // 17: NH4 RawData High Byte 
.................... // 18: NH4 RawData Low Byte 
....................         // Added Fab 26, 2017 
....................         // these items are the raw numbers for NH4 
.................... // 19: NH4 Patch RED RawData High Byte 
.................... // 20: NH4 Patch RED RawData Low Byte 
.................... // 21: NH4 Patch GREEN RawData High Byte 
.................... // 22: NH4 Patch GREEN RawData Low Byte 
.................... // 23: NH4 Patch BLUE RawData High Byte 
.................... // 24: NH4 Patch blue RawData Low Byte 
.................... // 25: NH4 Patch WHITE RawData High Byte 
.................... // 26: NH4 Patch WHITE RawData Low Byte 
.................... // 27: DpH  Digital Red RawData High Byte 
.................... // 28: DpH  Digital Red RawData Low Byte 
.................... // 29:  DpH Reading  whole number  updated March 30, 2017 
.................... // 30:  DpH fractional part  updated March 30, 2017 
.................... // 31: DpH  Digital Green RawData High Byte   updated April 3, 2017 
.................... // 32: DpH  Digital Green RawData Low Byte   updated April 3, 2017 
.................... // 33: DpH  Digital Blue RawData High Byte   updated April 3, 2017 
.................... // 34: DpH  Digital Blue RawData Low Byte   updated April 3, 2017 
.................... // 35: DpH  Digital White RawData High Byte   updated April 3, 2017 
.................... // 36: DpH  Digital White RawData Low Byte   updated April 3, 2017 
.................... // XX:  TBD 
....................  
....................  
.................... /* 
....................  unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... float eccal1x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal1y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3y;    //  This the EC data point  Added July 18, 2016 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
....................  */ 
....................  
....................  
....................  
....................  
....................  
.................... // Writing frame definition  --  has to be done in sequence each time. 
.................... // 1: HN4  whole number portion of HN4 calibration for point 1 
.................... // 2: NH4  fraction of the reading of HN4 calibration for point 1 
.................... // 3: HN4  whole number portion of HN4 calibration for point 2 
.................... // 4: NH4  fraction of the reading of HN4 calibration for point 2 
.................... // 5: HN4  whole number returned value of HN4 calibration for point 1 
.................... // 6: NH4  fraction of the returned value of HN4 calibration for point 1 
.................... // 7: HN4  whole number returned value of HN4 calibration for point 2 
.................... // 8: NH4  fraction of the returned value of HN4 calibration for point 2 
.................... // 9: TBD   all zeros 
.................... // 10: TBD 
.................... // 11: TBD 
.................... // 12: TBD 
.................... // 13: TBD 
.................... // 14: TBD 
.................... // 15: TBD 
.................... // 16: TBD 
.................... // 17: TBD 
.................... // 18: TBD 
.................... // 19: TBD 
.................... // 20: TBD 
.................... //  ...... 
.................... // 99: checksum high byte 
.................... // 100: checksum low byte 
.................... // returns a 1 if the checksum is OK and it receives data 
.................... //****************************************************************************** 
....................  
....................  
.................... //******************************************************************************* 
.................... // Create November 2, 2016 
.................... // Save this float into eeprom 
.................... // returns nothing. 
.................... //  give the pointer to the number, the location in eeprom and length 
.................... //****************************************************************************** 
.................... void eeprom_write_block(int16 *ptr, unsigned int8 addr, unsigned char len) 
.................... { 
....................   unsigned int16 *data = ptr; 
....................     unsigned int16 bufferin[4]; 
....................     unsigned int8 stuffit = addr; 
....................     len=len>>1;    // Since we are using 16 bits, two bytes are used at a time because of defs. 
....................     addr=addr<<1;   //mult by two offset to the correct location. 
....................  
....................     //read back the data 
....................    while (len--) { 
....................         write_eeprom(addr, *data++); 
....................         addr=addr+2;  // need to skip two bytes since this is a 16 bit CPU   
....................     }  
.................... //    bufferin[0] = read_eeprom[0]; 
....................  //   bufferin[1] = read_eeprom[2];        
....................  stuffit= stuffit+1;     
.................... } 
....................  
....................  
....................  
....................  
.................... float READ_FLOAT_EEPROM(long int n)  
.................... {  
....................    int i;  
....................    float data; 
....................  
....................    for (i = 0; i < 2; i++)  
....................       *((int16*)&data + i) = read_eeprom(2*i + 2*n); 
....................  
....................    return(data);  
.................... } 
....................  
.................... //****************************************************************************** 
.................... // Documented Febuary 12, 2017 
.................... // This is the call for slave operation for a sensor board. 
.................... // It does the following functions: 
.................... // 1  Receives incoming data from the host 
.................... // 2  Sets the command register for sending back this modules ID 
.................... // 3 
.................... //****************************************************************************** 
.................... /* 
.................... #INT_SI2C2 
....................  
.................... void si2c2_interrupt() 
....................     { 
....................  
.................... unsigned int8  incoming, state; 
....................  
....................         state=i2c_isr_state(SENSOR); 
....................  
....................    if(state <= 0x80)                      //Master is sending data 
....................    { 
....................       incoming = i2c_read(SENSOR,1);  
....................       if(state == 1)                     //First received byte is address  
....................       {//First received byte is address 
....................          address = incoming; 
....................          streamCntr=0; 
....................       } 
....................       if(state == 2)                     //Second received byte is data  
....................           {   
....................           rcv_buffer[address] = incoming;  
....................           streamCntr=0; 
....................           } 
....................        
....................       if(state == 1)                      //First received byte is address 
....................          address = incoming; 
....................       else if(state >= 2 && state != 0x80)   //Received byte is data auto from the master 
....................            { 
....................             rcv_buffer[address++] = incoming; 
....................             streamCntr=0; 
....................             } 
....................    } 
....................  
....................    if((state >= 0x80) & (rcv_buffer[0x66] != 0x01))               //Master is requesting data 
....................    { 
....................       i2c_write(SENSOR,send_buffer[streamCntr++]); 
....................    } 
....................       if((state >= 0x80) & (rcv_buffer[0x66] == 0x01))               //Master is requesting data 
....................    { 
....................       i2c_write(SENSOR,SENSORNUMBER); 
....................       rcv_buffer[0x66]=0x00; 
....................    } 
.................... 	} 
....................  
....................   */   
....................      
.................... //****************************************************************************** 
.................... // Created October 17, 2016 
.................... // This is a check sum for the data sent through the I2C back to the master.  The numbers are split and put into the 
.................... // last two locations of the upload send_buffer[]. 
.................... //  Nothing is returned, but the data is updated in this function. 
.................... //****************************************************************************** 
.................... void CalculateCRC(void) 
.................... { 
....................     unsigned int16 checksum; 
....................     unsigned int8 checksumhigh, checksumlow, x; 
....................     for (x=0; x < 98; x++) 
....................     { 
....................     checksum = checksum + send_buffer[x]; 
....................     } 
....................     //seperate the numbers into high and low 
....................     checksumlow = 0x00FF & checksum; 
....................     //  place the numbers in the array 
....................     checksumhigh = (0xFF00 & checksum)>>8; 
....................     send_buffer[98]=checksumhigh; 
....................     send_buffer[99]=checksumlow; 
.................... }     
....................      
.................... //****************************************************************************** 
.................... // Created Oct. 16, 2016 
.................... // this routine clears the data in the return buffer to all 0xFF.  This means if the data is 0xFF, there is no sensor data avaible and is ignored by the 
.................... // master CPU.  That means the main CPU master needs to go through all of the returned data and check to see if it is not 0xFF for all sets of bytes. 
.................... //****************************************************************************** 
....................  
....................     void initTransMitBuffer(void) 
020A:  MOV     W5,[W15++]
....................     { 
....................         // there are 100 points in the transmit buffer. 
....................         int x; 
....................         for (x = 0; x < 100; x++)   // set all of the returned data to 0xFF.  If there is data to be returned, it will change it to non 0xFF 
020C:  CLR     AC6
020E:  MOV     AC6,W4
0210:  MOV     #64,W3
0212:  CP      W3,W4
0214:  BRA     LE,222
....................         { 
....................             send_buffer[x] = 0xFF; 
0216:  MOV     #9B6,W4
0218:  MOV     AC6,W3
021A:  ADD     W3,W4,W5
021C:  SETM.B  [W5]
021E:  INC     0AC6
0220:  BRA     20E
....................         } 
0222:  MOV     [--W15],W5
0224:  RETURN  
....................        
....................     } 
....................        
....................      
.................... //***************************************************************** 
.................... //Created November 2, 2016 
.................... //  This is the eeprom read function to load all of the calibration data from the eeprom 
.................... // This routine can be triggered from the program and from one of the commands from the I2C 
.................... // It returns all of the data read from the internal data eeprom 
.................... //****************************************************************** 
.................... int LoadConfiguration(void) 
.................... { 
....................     float checkvalue;   // this is used for returning the value and checking to see if it took. 
....................      
....................    /* 
....................     float Temp1DOOne = 9.5;            //These are the set points where we want to read these numbers at temperature 1 
.................... 	float Temp1DOTwo = 4.0;            //This is at 10 degrees 
.................... 	float Temp1DOThree = 0.0; 
.................... */  
....................     Temp1DOOne = READ_FLOAT_EEPROM(0); 
....................     Temp1DOTwo = READ_FLOAT_EEPROM(1); 
....................     Temp1DOThree = READ_FLOAT_EEPROM(2); 
....................     /* 
....................  
.................... 	float Temp2DOOne = 7.5;            //These are the set points where we want to read these numbers at temperature 2 
.................... 	float Temp2DOTwo = 4.0;				//This is at 20 degrees 
.................... 	float Temp2DOThree = 0.0; 
....................  
....................      */ 
....................     Temp2DOOne = READ_FLOAT_EEPROM(3); 
....................     Temp2DOTwo = READ_FLOAT_EEPROM(4); 
....................     Temp2DOThree = READ_FLOAT_EEPROM(5); 
....................     /* 
.................... 	float Temp3DOOne = 6.7;            //These are the set points where we want to read these numbers temperature 3 
.................... 	float Temp3DOTwo = 4.0;            //This is at 25 degrees 
.................... 	float Temp3DOThree = 0.0;   
....................  */ 
....................     Temp3DOOne = READ_FLOAT_EEPROM(6); 
....................     Temp3DOTwo = READ_FLOAT_EEPROM(7); 
....................     Temp3DOThree = READ_FLOAT_EEPROM(8); 
....................     /* 
....................       
....................     float Temp1ReadingOne = 10752.0;       //Readings for Temp3  10 degrees C 
.................... 	float Temp1ReadingTwo = 11000.0;      //Readings for Temp3 
.................... 	float Temp1ReadingThree = 12000.0;    //Readings for DOOne    this is no DO. 
....................       
....................      */ 
....................     Temp1ReadingOne = READ_FLOAT_EEPROM(9); 
....................     Temp1ReadingTwo = READ_FLOAT_EEPROM(10); 
....................     Temp1ReadingThree = READ_FLOAT_EEPROM(11); 
....................      /*  
....................       
.................... 	float Temp2ReadingOne = 11266.0;       //Readings for Temp3    20 degrees C 
.................... 	float Temp2ReadingTwo = 12000.0;      //Readings for Temp3 
.................... 	float Temp2ReadingThree = 13000.0;    //Readings for DOOne 
.................... */ 
....................     Temp2ReadingOne = READ_FLOAT_EEPROM(12); 
....................     Temp2ReadingTwo = READ_FLOAT_EEPROM(13); 
....................     Temp2ReadingThree = READ_FLOAT_EEPROM(14); 
....................     /* 
.................... 	float Temp3ReadingOne = 12425.0;       //Readings for Temp3   25 degrees C 
.................... 	float Temp3ReadingTwo = 13000.0;      //Readings for Temp3 
.................... 	float Temp3ReadingThree = 14000.0;    //Readings for DOOne 
.................... */ 
....................     Temp3ReadingOne = READ_FLOAT_EEPROM(15); 
....................     Temp3ReadingTwo = READ_FLOAT_EEPROM(16); 
....................     Temp3ReadingThree = READ_FLOAT_EEPROM(17); 
....................     /* 
....................     
.................... 	float TempOne = 10.0;       //Calibration temperatures for DO   Added April 7, 2015 
....................  	float TempTwo =  20.0;      //Calibration temperatures for DO  Added April 7, 2015 
.................... 	float TempThree =  25.0;     //Calibration temperatures for DO  Added April 7, 2015 
....................  
....................      */ 
....................     TempOne = READ_FLOAT_EEPROM(18); 
....................     TempTwo = READ_FLOAT_EEPROM(19); 
....................     TempThree = READ_FLOAT_EEPROM(20); 
....................      
....................     return(0);   // if it makes it to here, everything is ok. 
.................... } 
....................  
.................... //******************************************************************************* 
.................... // Create November 2, 2016 
.................... // Save this float into eeprom 
.................... // returns nothing. 
.................... //  give the pointer to the number, the location in eeprom and length 
.................... //****************************************************************************** 
.................... void eeprom_write_blocktest(int16 *ptr, unsigned int8 addr, unsigned char len) 
.................... { 
....................   unsigned int16 *data = ptr; 
....................     unsigned int16 bufferin[4]; 
....................     unsigned int8 stuff = addr; 
....................     len=len>>1;    // Since we are using 16 bits, two bytes are used at a time because of defs. 
....................     addr=addr<<1;   //mult by two offset to the correct location. 
....................  
....................     //read back the data 
....................    while (len--) { 
....................         write_eeprom(addr, *data++); 
....................         addr=addr+2;  // need to skip two bytes since this is a 16 bit CPU   
....................     }  
....................  //   bufferin[0] = read_eeprom[stuff]; 
....................  //   bufferin[1] = read_eeprom[stuff+2];        
....................  stuff= stuff+1;     
.................... } 
....................  
....................  
....................  
.................... //***************************************************************** 
.................... //Created Oct. 19, 2016 
.................... //  This is the eeprom write function to save all of the calibration data to the eeprom 
.................... // This routine can be triggered from the program and from one of the commands from the I2C 
.................... // It returns a 0 if everything is OK,  A 1 is returned when it failed. 
.................... //  It does a write and reads back the data to make it made it. 
.................... //****************************************************************** 
.................... int SaveConfiguration(void) 
.................... { 
....................     float checkvalue;   // this is used for returning the value and checking to see if it took. 
....................      
....................    /* 
....................     float Temp1DOOne = 9.5;            //These are the set points where we want to read these numbers at temperature 1 
.................... 	float Temp1DOTwo = 4.0;            //This is at 10 degrees 
.................... 	float Temp1DOThree = 0.0; 
.................... */  
....................     eeprom_write_blocktest(&Temp1DOOne, 0, sizeof Temp1DOOne); 
....................     checkvalue = READ_FLOAT_EEPROM(0); 
....................     if (Temp1DOOne != checkvalue) 
....................         return(1);    // return this error 
....................     eeprom_write_blocktest(&Temp1DOTwo, 1, sizeof Temp1DOTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(1); 
....................     if (Temp1DOTwo != checkvalue) 
....................         return(2);    // return this error 
....................      eeprom_write_blocktest(&Temp1DOThree, 2, sizeof Temp1DOThree); 
....................     checkvalue = READ_FLOAT_EEPROM(2); 
....................     if (Temp1DOThree != checkvalue) 
....................         return(3);    // return this error 
....................      
....................     // this routine saves the data for the NH4, EC, DO and temperature 
....................     /* 
....................  
.................... 	float Temp2DOOne = 7.5;            //These are the set points where we want to read these numbers at temperature 2 
.................... 	float Temp2DOTwo = 4.0;				//This is at 20 degrees 
.................... 	float Temp2DOThree = 0.0; 
....................  
....................      */ 
....................     eeprom_write_block(&Temp2DOOne, 3, sizeof Temp2DOOne); 
....................     checkvalue = READ_FLOAT_EEPROM(3); 
....................     if (Temp2DOOne != checkvalue) 
....................         return(4);    // return this error 
....................     eeprom_write_block(&Temp2DOTwo, 4, sizeof Temp2DOTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(4); 
....................     if (Temp2DOTwo != checkvalue) 
....................         return(5);    // return this error 
....................      eeprom_write_block(&Temp2DOThree, 5, sizeof Temp2DOThree); 
....................     checkvalue = READ_FLOAT_EEPROM(5); 
....................     if (Temp2DOThree != checkvalue) 
....................         return(6);    // return this error 
....................     
....................     /* 
.................... 	float Temp3DOOne = 6.7;            //These are the set points where we want to read these numbers temperature 3 
.................... 	float Temp3DOTwo = 4.0;            //This is at 25 degrees 
.................... 	float Temp3DOThree = 0.0;   
....................  */ 
....................      
....................     eeprom_write_block(&Temp3DOOne, 6, sizeof Temp3DOOne); 
....................     checkvalue = READ_FLOAT_EEPROM(6); 
....................     if (Temp3DOOne != checkvalue) 
....................         return(7);    // return this error 
....................     eeprom_write_block(&Temp3DOTwo, 7, sizeof Temp3DOTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(7); 
....................     if (Temp3DOTwo != checkvalue) 
....................         return(8);    // return this error 
....................      eeprom_write_block(&Temp3DOThree, 8, sizeof Temp3DOThree); 
....................     checkvalue = READ_FLOAT_EEPROM(8); 
....................     if (Temp3DOThree != checkvalue) 
....................         return(9);    // return this error   
....................     /* 
....................       
....................     float Temp1ReadingOne = 10752.0;       //Readings for Temp3  10 degrees C 
.................... 	float Temp1ReadingTwo = 11000.0;      //Readings for Temp3 
.................... 	float Temp1ReadingThree = 12000.0;    //Readings for DOOne    this is no DO. 
....................       
....................      */ 
....................      
....................     eeprom_write_block(&Temp1ReadingOne, 9, sizeof Temp1ReadingOne); 
....................     checkvalue = READ_FLOAT_EEPROM(9); 
....................     if (Temp1ReadingOne != checkvalue) 
....................         return(10);    // return this error 
....................     eeprom_write_block(&Temp1ReadingTwo, 10, sizeof Temp1ReadingTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(10); 
....................     if (Temp1ReadingTwo != checkvalue) 
....................         return(11);    // return this error 
....................      eeprom_write_block(&Temp1ReadingThree, 11, sizeof Temp1ReadingThree); 
....................     checkvalue = READ_FLOAT_EEPROM(11); 
....................     if (Temp1ReadingThree != checkvalue) 
....................         return(12);    // return this error 
....................      
....................      /*  
....................       
....................  
.................... 	float Temp2ReadingOne = 11266.0;       //Readings for Temp3    20 degrees C 
.................... 	float Temp2ReadingTwo = 12000.0;      //Readings for Temp3 
.................... 	float Temp2ReadingThree = 13000.0;    //Readings for DOOne 
.................... */ 
....................     eeprom_write_block(&Temp2ReadingOne, 12, sizeof Temp2ReadingOne); 
....................     checkvalue = READ_FLOAT_EEPROM(12); 
....................     if (Temp2ReadingOne != checkvalue) 
....................         return(13);    // return this error 
....................     eeprom_write_block(&Temp2ReadingTwo, 13, sizeof Temp2ReadingTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(13); 
....................     if (Temp2ReadingTwo != checkvalue) 
....................         return(14);    // return this error 
....................      eeprom_write_block(&Temp2ReadingThree, 14, sizeof Temp2ReadingThree); 
....................     checkvalue = READ_FLOAT_EEPROM(14); 
....................     if (Temp2ReadingThree != checkvalue) 
....................         return(15);    // return this error 
....................     /* 
.................... 	float Temp3ReadingOne = 12425.0;       //Readings for Temp3   25 degrees C 
.................... 	float Temp3ReadingTwo = 13000.0;      //Readings for Temp3 
.................... 	float Temp3ReadingThree = 14000.0;    //Readings for DOOne 
.................... */ 
....................     eeprom_write_block(&Temp3ReadingOne, 15, sizeof Temp3ReadingOne); 
....................     checkvalue = READ_FLOAT_EEPROM(15); 
....................     if (Temp3ReadingOne != checkvalue) 
....................         return(16);    // return this error 
....................     eeprom_write_block(&Temp3ReadingTwo, 16, sizeof Temp3ReadingTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(16); 
....................     if (Temp3ReadingTwo != checkvalue) 
....................         return(17);    // return this error 
....................      eeprom_write_block(&Temp3ReadingThree, 17, sizeof Temp3ReadingThree); 
....................     checkvalue = READ_FLOAT_EEPROM(17); 
....................     if (Temp3ReadingThree != checkvalue) 
....................         return(18);    // return this error 
....................     /* 
....................     
.................... 	float TempOne = 10.0;       //Calibration temperatures for DO   Added April 7, 2015 
....................  	float TempTwo =  20.0;      //Calibration temperatures for DO  Added April 7, 2015 
.................... 	float TempThree =  25.0;     //Calibration temperatures for DO  Added April 7, 2015 
....................  
....................       
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
....................      */ 
....................      
....................     eeprom_write_block(&sysInput.DOpt1returnednumber, 18, sizeof sysInput.DOpt1returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(18); 
....................     if (sysInput.DOpt1returnednumber != checkvalue) 
....................         return(19);    // return this error 
....................     eeprom_write_block(&sysInput.DOpt2returnednumber, 19, sizeof sysInput.DOpt2returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(19); 
....................     if (sysInput.DOpt2returnednumber != checkvalue) 
....................         return(20);    // return this error 
....................      eeprom_write_block(&sysInput.DOpt3returnednumber, 20, sizeof sysInput.DOpt3returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(20); 
....................     if (sysInput.DOpt3returnednumber != checkvalue) 
....................         return(21);    // return this error 
....................      /* 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
....................     */ 
....................      
....................      
....................     eeprom_write_block(&sysInput.Thermisterpt1cal1of3, 21, sizeof sysInput.Thermisterpt1cal1of3); 
....................     checkvalue = READ_FLOAT_EEPROM(21); 
....................     if (sysInput.Thermisterpt1cal1of3 != checkvalue) 
....................         return(22);    // return this error 
....................     eeprom_write_block(&sysInput.Thermisterpt1cal2of3, 22, sizeof sysInput.Thermisterpt1cal2of3); 
....................     checkvalue = READ_FLOAT_EEPROM(22); 
....................     if (sysInput.Thermisterpt1cal2of3 != checkvalue) 
....................         return(23);    // return this error 
....................      eeprom_write_block(&sysInput.Thermisterpt1cal3of3, 23, sizeof sysInput.Thermisterpt1cal3of3); 
....................     checkvalue = READ_FLOAT_EEPROM(23); 
....................     if (sysInput.Thermisterpt1cal3of3 != checkvalue) 
....................         return(24);    // return this error 
....................      
.................... /* 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
....................   */ 
....................      
....................    eeprom_write_block(&sysInput.Thermisterpt1returnednumber, 24, sizeof sysInput.Thermisterpt1returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(24); 
....................     if (sysInput.Thermisterpt1returnednumber!= checkvalue) 
....................         return(25);    // return this error 
....................     eeprom_write_block(&sysInput.Thermisterpt2returnednumber, 25, sizeof sysInput.Thermisterpt2returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(25); 
....................     if (sysInput.Thermisterpt2returnednumber != checkvalue) 
....................         return(26);    // return this error 
....................      eeprom_write_block(&sysInput.Thermisterpt3returnednumber, 26, sizeof sysInput.Thermisterpt3returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(26); 
....................     if (sysInput.Thermisterpt3returnednumber != checkvalue) 
....................         return(27);    // return this error 
....................       
....................      
....................     return(0);   // if it makes it to here, everything is ok. 
.................... } 
....................  
....................  
....................  
.................... //********************************************************************************************* 
.................... // Created November 28, 2016 
.................... // This moves the data from the recieve buffer into the configuation varaubles. 
.................... // Returns nothing.  This is called when rcv_buffer[2] == 0x01 
.................... //********************************************************************************************* 
.................... void movercvbuffertocolibration(void) 
.................... { 
....................        int x; 
....................     int8 lowbyte,highbyte; 
....................     unsigned int16 items; 
....................     int i;  
....................    float data; 
....................         
....................     //these are the two byte int16s 
....................     lowbyte = rcv_buffer[3]; 
....................     highbyte = rcv_buffer[4]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt1cal1of3 = (items<<8) +  lowbyte;   
....................   
....................     lowbyte = rcv_buffer[5]; 
....................     highbyte = rcv_buffer[6]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt1cal2of3 = (items<<8) +  lowbyte;   
....................      
....................     lowbyte = rcv_buffer[7]; 
....................     highbyte = rcv_buffer[8]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt1cal3of3 = (items<<8) +  lowbyte;   
....................      
....................          
....................     lowbyte = rcv_buffer[9]; 
....................     highbyte = rcv_buffer[10]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt2cal1of3 = (items<<8) +  lowbyte;   
....................   
....................     lowbyte = rcv_buffer[11]; 
....................     highbyte = rcv_buffer[12]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt2cal2of3 = (items<<8) +  lowbyte;   
....................      
....................     lowbyte = rcv_buffer[13]; 
....................     highbyte = rcv_buffer[14]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt2cal3of3 = (items<<8) +  lowbyte;   
....................              
....................     lowbyte = rcv_buffer[15]; 
....................     highbyte = rcv_buffer[16]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt3cal1of3 = (items<<8) +  lowbyte;   
....................   
....................     lowbyte = rcv_buffer[17]; 
....................     highbyte = rcv_buffer[18]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt3cal2of3 = (items<<8) +  lowbyte;   
....................      
....................     lowbyte = rcv_buffer[19]; 
....................     highbyte = rcv_buffer[20]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt3cal3of3 = (items<<8) +  lowbyte;   
....................      
....................     // these are the four byte floats 
....................      
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
....................       *((int8*)&data + i) = rcv_buffer[i + 21]; 
....................     sysInput.nh4pt1returnednumber = data; 
....................  
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
....................       *((int8*)&data + i) = rcv_buffer[i + 25]; 
....................     sysInput.nh4pt1returnednumber = data; 
....................  
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
....................       *((int8*)&data + i) = rcv_buffer[i + 29]; 
....................     sysInput.nh4pt1returnednumber = data;     
....................      
.................... } 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... // Documented Febuary 12, 2017 
.................... // This is the call for slave operation for a sensor board. 
.................... // It does the following functions: 
.................... // 1  Receives incoming data from the host 
.................... // 2  Sets the command register for sending back this modules ID 
.................... // 3 
.................... //****************************************************************************** 
.................... /* 
.................... #INT_SI2C2 
....................  
.................... void si2c2_interrupt() 
....................     { 
....................  
.................... unsigned int8  incoming, state; 
....................  
....................         state=i2c_isr_state(SENSOR); 
....................  
....................    if(state <= 0x80)                      //Master is sending data 
....................    { 
....................       incoming = i2c_read(SENSOR,1);  
....................       if(state == 1)                     //First received byte is address  
....................       {//First received byte is address 
....................          address = incoming; 
....................          streamCntr=0; 
....................       } 
....................       if(state == 2)                     //Second received byte is data  
....................           {   
....................           rcv_buffer[address] = incoming;  
....................           streamCntr=0; 
....................           } 
....................        
....................       if(state == 1)                      //First received byte is address 
....................          address = incoming; 
....................       else if(state >= 2 && state != 0x80)   //Received byte is data auto from the master 
....................            { 
....................             rcv_buffer[address++] = incoming; 
....................             streamCntr=0; 
....................             } 
....................    } 
....................  
....................    if((state >= 0x80) & (rcv_buffer[0x66] != 0x01))               //Master is requesting data 
....................    { 
....................       i2c_write(SENSOR,send_buffer[streamCntr++]); 
....................    } 
....................       if((state >= 0x80) & (rcv_buffer[0x66] == 0x01))               //Master is requesting data 
....................    { 
....................       i2c_write(SENSOR,SENSORNUMBER); 
....................       rcv_buffer[0x66]=0x00; 
....................    } 
.................... 	} 
....................  
.................... */ 
....................  
....................  
.................... /* 
.................... typedef struct outputDataStruct{ 
.................... char deviceID[16]; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int8 taosVersion; 
.................... float dOxy; 
.................... float wTemp; 
.................... float pH; 
.................... float pHLow; 
.................... float WhiteBalance; 
.................... float tdsLevel; 
.................... float wLevel; 
.................... float lLevelX; 
.................... float lLevelY; 
....................  
.................... int32 lLevelRed; 
.................... int32 lLevelGreen; 
.................... int32 lLevelBlue; 
.................... int32 lLevelClear; 
.................... int8 time; 
.................... int16 date; 
....................  
....................  
.................... float lLevelScale; 
.................... float rH,averagepH; 
.................... float aTemp; 
.................... int16 cO2; 
.................... float nh3; 
.................... float dPoint; 
.................... char DIEHARD[8]; 
.................... }outputData; 
....................  
....................  
.................... outputData sysOutput; 
.................... */ 
.................... //*********************************************************** 
....................  
....................  
....................  
.................... int main() { 
*
09EC:  MOV     #FA0,W15
09EE:  MOV     #FFF,W0
09F0:  MOV     W0,20
09F2:  NOP     
09F4:  BSET.B  81.7
09F6:  CLR     744
09F8:  BCLR.B  2CD.1
09FA:  BSET.B  207.7
09FC:  BSET.B  207.5
09FE:  BSET.B  206.6
0A00:  BCLR.B  207.3
0A02:  BSET.B  206.7
0A04:  BCLR.B  207.0
0A06:  BSET.B  207.1
0A08:  BCLR.B  207.2
0A0A:  CLR     20A
0A0C:  MOV     #9D,W4
0A0E:  MOV     W4,204
0A10:  CLR.B   860
0A12:  CLR.B   AB6
0A14:  CLR     4E0
0A16:  CLR     4E2
0A18:  CLR     85A
....................  
....................     int16 returneditem;  // this is the returned item 
....................     int8 highbyte, lowbyte; 
....................      
....................     float returnedresultit,titemp; 
....................     int returnedresult; 
....................     InitCO2(); 
0A1A:  CALL    200
....................  
....................   //  enable_interrupts(INT_SI2C2);    // this starts the slave communication. 
....................     initTransMitBuffer();   // Clear the buffer to send no data. 
0A1E:  CALL    20A
....................     while(1) 
....................     { 
....................         returneditem = ReadCOSensor();  // get the CO2 data 
0A22:  CALL    350
0A26:  MOV     W0,ABA
....................         // split it into two numbers.  High Byte and Low Byte. 
....................         lowbyte = 0x00FF & returneditem; 
0A28:  MOV     ABA,W0
0A2A:  AND     #FF,W0
0A2C:  MOV.B   W0L,AB9
....................         returneditem = 0xFF00 & returneditem; 
0A2E:  MOV     #FF00,W0
0A30:  AND     ABA
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
0A32:  CLR.B   1
0A34:  MOV.B   ABB,W0L
0A36:  MOV.B   W0L,AB8
....................         send_buffer[8] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
0A38:  MOV.B   AB9,W0L
0A3A:  MOV.B   W0L,9BE
....................         send_buffer[7] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
0A3C:  MOV.B   AB8,W0L
0A3E:  MOV.B   W0L,9BD
....................         // array, it will get the updated array.  
....................         
.................... // ********************************************************************************* 
.................... // Created No2. 3, 2014 
.................... // Find the RH and Temperature for the environment and send it to the server. 
.................... //  This routine talks with the cheap RH and Temperature sensor 
.................... // ******************************************************************************** 
.................... /* 
.................... if (!GetTempRH()) 
.................... 	{ 
.................... 	sysOutput.aTemp = Temperature;  //This is the float temperature 
....................      
....................     	if (sysOutput.aTemp < 0.0) 
....................         { 
.................... 		sysOutput.aTemp = 0.0; 
....................         Temperature = 0.0; 
....................         } 
....................      
....................     send_buffer[9] =  (int) Temperature;  // high whole number byte 
....................     send_buffer[10] =  (int) ((Temperature - (float) (int) Temperature)*100);  // high whole number byte 
....................      
....................  
.................... 		 
.................... 	sysOutput.rH = RHData;  //This is a float send into ta RH value. 
.................... 	if (sysOutput.rH < 0.0) 
.................... 		sysOutput.rH = 0.0; 
.................... 	} 
....................    send_buffer[11] =  (int) sysOutput.rH;  // high whole number byte 
....................    send_buffer[12] =  (int) ((sysOutput.rH - (float) (int) sysOutput.rH)*100);  // high whole number byte 
.................... */  
....................          
....................          
....................      
.................... //********************************************************************************* 
.................... // Created Jan 17, 2017 
.................... // This calls and saves the current air temp and rh 
.................... //********************************************************************************* 
.................... //   while(1)  
....................  //  { 
....................  //  returneditem = GetHDC1080Version(1);      
.................... //   } 
....................          
....................          
....................    returnedresultit = GetHDC1080RHTemp(8); 
0A40:  MOV     #8,W4
0A42:  MOV     W4,ACA
0A44:  CALL    4E4
0A48:  MOV     W0,ABC
0A4A:  MOV     W1,ABE
....................    returnedresult = th; 
0A4C:  PUSH    862
0A4E:  POP     AC4
....................    returnedresult = tl; 
0A50:  PUSH    864
0A52:  POP     AC4
....................    titemp = (float) (th << 8 | tl);     
0A54:  MOV.B   862,W0L
0A56:  MOV.B   W0L,B
0A58:  CLR.B   W5
0A5A:  MOV     W5,W0
0A5C:  IOR     864,W0
0A5E:  CALL    5D6
0A62:  MOV     W0,AC0
0A64:  MOV     W1,AC2
....................     titemp = titemp * 165.0 / 65536.0 - 40.0; 
0A66:  MOV     AC0,W0
0A68:  MOV     AC2,W1
0A6A:  MOV     #0,W2
0A6C:  MOV     #4325,W3
0A6E:  CALL    620
0A72:  MOV     W0,W5
0A74:  MOV     W1,W6
0A76:  MOV     W5,W0
0A78:  MOV     W6,W1
0A7A:  MOV     #0,W2
0A7C:  MOV     #4780,W3
0A7E:  CALL    6E4
0A82:  MOV     W0,W5
0A84:  MOV     W1,W6
0A86:  BSET.B  43.0
0A88:  MOV     W5,W0
0A8A:  MOV     W6,W1
0A8C:  MOV     #0,W2
0A8E:  MOV     #4220,W3
0A90:  CALL    7AE
0A94:  MOV     W0,AC0
0A96:  MOV     W1,AC2
....................     sysOutput.aTemp = titemp; 
0A98:  PUSH    AC0
0A9A:  POP     8C8
0A9C:  PUSH    AC2
0A9E:  POP     8CA
....................   	if (sysOutput.aTemp < 0.0) 
0AA0:  MOV     8C8,W0
0AA2:  MOV     8CA,W1
0AA4:  MOV     #0,W2
0AA6:  MOV     #0,W3
0AA8:  CALL    958
0AAC:  BRA     NC,AB2
.................... 		sysOutput.aTemp = 0.0; 
0AAE:  CLR     8C8
0AB0:  CLR     8CA
....................   
....................    returnedresult = hh; 
0AB2:  PUSH    866
0AB4:  POP     AC4
....................    returnedresult = hl; 
0AB6:  PUSH    868
0AB8:  POP     AC4
....................    titemp = (float) (th << 8 | tl);     
0ABA:  MOV.B   862,W0L
0ABC:  MOV.B   W0L,B
0ABE:  CLR.B   W5
0AC0:  MOV     W5,W0
0AC2:  IOR     864,W0
0AC4:  CALL    5D6
0AC8:  MOV     W0,AC0
0ACA:  MOV     W1,AC2
....................    titemp = titemp * 100.0 / 65536.0; 
0ACC:  MOV     AC0,W0
0ACE:  MOV     AC2,W1
0AD0:  MOV     #0,W2
0AD2:  MOV     #42C8,W3
0AD4:  CALL    620
0AD8:  MOV     W0,W5
0ADA:  MOV     W1,W6
0ADC:  MOV     W5,W0
0ADE:  MOV     W6,W1
0AE0:  MOV     #0,W2
0AE2:  MOV     #4780,W3
0AE4:  CALL    6E4
0AE8:  MOV     W0,AC0
0AEA:  MOV     W1,AC2
.................... 	sysOutput.rH = titemp;  //This is a float send into ta RH value. 
0AEC:  PUSH    AC0
0AEE:  POP     8C0
0AF0:  PUSH    AC2
0AF2:  POP     8C2
.................... 	if (sysOutput.rH < 0.0) 
0AF4:  MOV     8C0,W0
0AF6:  MOV     8C2,W1
0AF8:  MOV     #0,W2
0AFA:  MOV     #0,W3
0AFC:  CALL    958
0B00:  BRA     NC,B06
.................... 		sysOutput.rH = 0.0; 
0B02:  CLR     8C0
0B04:  CLR     8C2
....................  
....................      
....................     send_buffer[9] =  (int) sysOutput.aTemp;  // high whole number byte 
0B06:  MOV     8C8,W0
0B08:  MOV     8CA,W1
0B0A:  CALL    9C0
0B0E:  MOV.B   W0L,9BF
....................     send_buffer[10] =  (int) ((sysOutput.aTemp - (float) (int) sysOutput.aTemp)*100);  // high whole number byte 
0B10:  MOV     8C8,W0
0B12:  MOV     8CA,W1
0B14:  CALL    9C0
0B18:  CALL    5D6
0B1C:  BSET.B  43.0
0B1E:  MOV     W0,W2
0B20:  MOV     W1,W3
0B22:  MOV     8C8,W0
0B24:  MOV     8CA,W1
0B26:  CALL    7AE
0B2A:  MOV     W0,W5
0B2C:  MOV     W1,W6
0B2E:  MOV     W5,W0
0B30:  MOV     W6,W1
0B32:  MOV     #0,W2
0B34:  MOV     #42C8,W3
0B36:  CALL    620
0B3A:  CALL    9C0
0B3E:  MOV.B   W0L,9C0
....................      
....................      
....................     send_buffer[11] =  (int) sysOutput.rH;  // high whole number byte 
0B40:  MOV     8C0,W0
0B42:  MOV     8C2,W1
0B44:  CALL    9C0
0B48:  MOV.B   W0L,9C1
....................     send_buffer[12] =  (int) ((sysOutput.rH - (float) (int) sysOutput.rH)*100);  // high whole number byte 
0B4A:  MOV     8C0,W0
0B4C:  MOV     8C2,W1
0B4E:  CALL    9C0
0B52:  CALL    5D6
0B56:  BSET.B  43.0
0B58:  MOV     W0,W2
0B5A:  MOV     W1,W3
0B5C:  MOV     8C0,W0
0B5E:  MOV     8C2,W1
0B60:  CALL    7AE
0B64:  MOV     W0,W5
0B66:  MOV     W1,W6
0B68:  MOV     W5,W0
0B6A:  MOV     W6,W1
0B6C:  MOV     #0,W2
0B6E:  MOV     #42C8,W3
0B70:  CALL    620
0B74:  CALL    9C0
0B78:  MOV.B   W0L,9C2
0B7A:  BRA     A22
....................    
....................   
.................... // ******************************************************************************** 
.................... // Created Nov. 3, 2014 
.................... // This routines borrows the calcaulaton from the expensive SHt11 chip to calcaulate DP 
.................... // ******************************************************************************** 
....................  
.................... //sysOutput.dPoint=sht1x_calc_dewpoint(RHData,Temperature); 
....................  
....................  
....................   
....................   //      CalculateCRC();  // update the CRC for sending to the Master unit 
....................     } 
....................      
....................      
....................  
.................... } 
....................  
0B7C:  BRA     B7C

Configuration Fuses:
   Word  1L: 000F   NOWRTB NOBSS
          H: 0000  
   Word  2L: 0000  
          H: 0000  
   Word  3L: 0003   NOWRT NOPROTECT
          H: 0000  
   Word  4L: 00E3   PR_PLL SOSC_ANALOG LPRCHIGH IESO
          H: 0000  
   Word  5L: 00FA   HS OSCIO POSCFREQ_H SOSC_HIGH
          H: 0000  
   Word  6L: 005F   WPOSTS16 WDT128 WINDIS NOWDT
          H: 0000  
   Word  7L: 00F4   NOBROWNOUT NOLVR NOPUT NOALTI2C1 BORV_LOW MCLR
          H: 0000  
   Word  8L: 0003   ICSP1 DEBUG
          H: 0000  
   Word  9L: 00DF   DSWDTCK_LPRC DSBOR DSWDT
          H: 0000  

   Some fuses have been forced to be compatible with the ICD debugger.
