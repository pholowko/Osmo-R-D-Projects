CCS PCD C Compiler, Version 5.071, 35992               05-Apr-17 08:51

               Filename:   G:\OsomobotCarbonDioxideDigitalSensor\OsomobotCarbonDioxideDigitalSensor.X\build\default\debug\main.lst

               ROM used:   3268 bytes (15%)
                           Largest free fragment is 19260
               RAM used:   764 (39%) at main() level
                           900 (46%) worst case
               Stack used: 54 locations (14 in main + 40 for interrupts)
               Stack size: 144

*
0000:  GOTO    B16
*
0076:  DATA    38,02,00
.................... // CO2 Sensor RH temp Main.c file 
.................... #include <24FV32KA302.h> 
.................... //////////// Standard Header file for the PIC24FV32KA302 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FV32KA302 
*
0700:  MOV     W5,[W15++]
0702:  MOV     W6,[W15++]
0704:  MOV     #8E,W1
0706:  BCLR    W6.0
0708:  BTSS    W0.F
070A:  BRA     712
070C:  BSET    W6.0
070E:  NEG     W0,W0
0710:  BRA     712
0712:  CP0     W0
0714:  BRA     Z,73E
0716:  BTSC    W0.F
0718:  BRA     722
071A:  BCLR.B  42.0
071C:  RLC     W0,W0
071E:  DEC     W1,W1
0720:  BRA     716
0722:  SWAP    W1
0724:  BCLR.B  42.0
0726:  RRC     W1,W1
0728:  BCLR    W0.F
072A:  SWAP    W0
072C:  XOR.B   W0L,W1L,W1L
072E:  AND.B   #0,W0L
0730:  BTSC    W6.0
0732:  BSET    W1.F
0734:  BRA     744
0736:  MOV.B   W1L,W0L
0738:  BSET    W1.7
073A:  AND.B   #0,W1L
073C:  BRA     744
073E:  CLR     W0
0740:  CLR     W1
0742:  BRA     744
0744:  MOV     [--W15],W6
0746:  MOV     [--W15],W5
0748:  RETURN  
074A:  MOV     W5,[W15++]
074C:  MOV     #C,W5
074E:  REPEAT  #4
0750:  MOV     [W5++],[W15++]
0752:  MOV     W0,W4
0754:  MOV     W1,W5
0756:  MOV     W3,W7
0758:  MOV     W2,W6
075A:  BCLR.B  42.0
075C:  BCLR.B  42.1
075E:  RLC     W1,W1
0760:  SWAP    W1
0762:  AND     #FF,W1
0764:  CP0     W1
0766:  BRA     Z,7FE
0768:  BCLR.B  42.0
076A:  BCLR.B  42.1
076C:  RLC     W3,W3
076E:  SWAP    W3
0770:  AND     #FF,W3
0772:  CP0     W3
0774:  BRA     Z,7FE
0776:  ZE      W0,W0
0778:  ADD.B   W3L,W1L,W0L
077A:  BRA     C,784
077C:  SUB     #7F,W0
077E:  BRA     Z,7FE
0780:  BRA     NC,7FE
0782:  BRA     788
0784:  ADD.B   #81,W0L
0786:  BRA     C,7FE
0788:  XOR     W5,W7,W10
078A:  BCLR.B  42.0
078C:  BCLR.B  42.1
078E:  AND     #FF,W5
0790:  BSET    W5.7
0792:  BCLR.B  42.0
0794:  AND     #FF,W7
0796:  BSET    W7.7
0798:  MUL.UU  W4,W6,W2
079A:  MUL.UU  W5,W6,W8
079C:  ADDC    W8,W3,W3
079E:  MOV     W9,W1
07A0:  BTSC.B  42.0
07A2:  INC     W1,W1
07A4:  BCLR.B  42.0
07A6:  MUL.UU  W7,W4,W8
07A8:  ADDC    W8,W3,W3
07AA:  ADDC    W9,W1,W1
07AC:  MUL.UU  W5,W7,W8
07AE:  ADDC    W8,W1,W1
07B0:  INC     W0,W0
07B2:  CP0     W1
07B4:  BTSC.B  42.1
07B6:  BRA     7BA
07B8:  BRA     7C0
07BA:  CP0     W3
07BC:  BTSC.B  42.1
07BE:  BRA     7CA
07C0:  BTSC    W1.F
07C2:  BRA     7CA
07C4:  RLC     W3,W3
07C6:  RLC     W1,W1
07C8:  DEC     W0,W0
07CA:  MOV     W1,W2
07CC:  BCLR.B  42.0
07CE:  BTSS    W3.7
07D0:  BRA     7E4
07D2:  MOV     #FF00,W7
07D4:  AND     W3,W7,W3
07D6:  ADD     #100,W3
07D8:  ADDC    W2,#0,W2
07DA:  CP0     W2
07DC:  BRA     NZ,7E4
07DE:  CP0     W3
07E0:  BRA     NZ,7E4
07E2:  INC     W0,W0
07E4:  SWAP    W0
07E6:  BCLR.B  42.0
07E8:  BCLR.B  42.1
07EA:  RRC     W0,W1
07EC:  BTSC    W10.F
07EE:  BSET    W1.F
07F0:  BCLR    W2.F
07F2:  SWAP    W2
07F4:  XOR.B   W2L,W1L,W1L
07F6:  SWAP    W3
07F8:  MOV.B   W3L,W2L
07FA:  MOV     W2,W0
07FC:  BRA     804
07FE:  MOV     #0,W0
0800:  MOV     #0,W1
0802:  BRA     804
0804:  MOV     #14,W5
0806:  REPEAT  #4
0808:  MOV     [--W15],[W5--]
080A:  MOV     [--W15],W5
080C:  RETURN  
080E:  MOV     W5,[W15++]
0810:  MOV     #C,W5
0812:  REPEAT  #4
0814:  MOV     [W5++],[W15++]
0816:  CLR     W9
0818:  XOR     W1,W3,W9
081A:  MOV     W1,W6
081C:  MOV     W0,W5
081E:  MOV     W3,W8
0820:  MOV     W2,W7
0822:  RLC     W1,W1
0824:  SWAP    W1
0826:  ZE      W1,W1
0828:  CP0     W1
082A:  BRA     Z,8C8
082C:  RLC     W3,W3
082E:  SWAP    W3
0830:  ZE      W3,W3
0832:  CP0     W3
0834:  BRA     Z,8C8
0836:  CLR     W0
0838:  SUB.B   W1L,W3L,W0L
083A:  BRA     NC,842
083C:  ADD.B   #7F,W0L
083E:  BRA     C,8C8
0840:  BRA     848
0842:  SUB.B   #81,W0L
0844:  BRA     NC,8C8
0846:  BRA     Z,8C8
0848:  MOV     W5,W1
084A:  MOV     W6,W2
084C:  BSET    W2.7
084E:  AND     #FF,W2
0850:  AND     #FF,W8
0852:  BSET    W8.7
0854:  MOV     #19,W10
0856:  CLR     W3
0858:  CLR     W4
085A:  SUB     W1,W7,W1
085C:  SUBB    W2,W8,W2
085E:  BRA     N,864
0860:  BRA     C,86A
0862:  BRA     NZ,86C
0864:  ADD     W1,W7,W1
0866:  ADDC    W2,W8,W2
0868:  BRA     86C
086A:  BSET    W4.0
086C:  DEC     W10,W10
086E:  BRA     Z,87E
0870:  BCLR.B  42.0
0872:  RLC     W1,W1
0874:  RLC     W2,W2
0876:  BCLR.B  42.0
0878:  RLC     W4,W4
087A:  RLC     W3,W3
087C:  BRA     85A
087E:  CLR     W10
0880:  BTSC    W3.8
0882:  BRA     886
0884:  BRA     892
0886:  BCLR.B  42.0
0888:  RRC     W3,W3
088A:  BCLR    W3.7
088C:  RRC     W4,W4
088E:  RLC     W10,W10
0890:  BRA     896
0892:  DEC     W0,W0
0894:  BRA     Z,8C8
0896:  BTSC    W10.F
0898:  BRA     NC,8A4
089A:  RLC     W1,W1
089C:  RLC     W2,W2
089E:  SUB     W1,W7,W1
08A0:  SUBB    W2,W8,W2
08A2:  BRA     NC,8B6
08A4:  INC     W4,W4
08A6:  BRA     NZ,8B6
08A8:  INC     W3,W3
08AA:  BRA     NZ,8B6
08AC:  INC     W0,W0
08AE:  BRA     Z,8C8
08B0:  BRA     8B6
08B2:  DEC     W0,W0
08B4:  BRA     Z,8C8
08B6:  SWAP    W0
08B8:  RRC     W0,W1
08BA:  BSET    W1.F
08BC:  BTSS    W9.F
08BE:  BCLR    W1.F
08C0:  BCLR    W3.7
08C2:  XOR.B   W3L,W1L,W1L
08C4:  MOV     W4,W0
08C6:  BRA     8CE
08C8:  MOV     #0,W0
08CA:  MOV     #0,W1
08CC:  BRA     8CE
08CE:  MOV     #14,W5
08D0:  REPEAT  #4
08D2:  MOV     [--W15],[W5--]
08D4:  MOV     [--W15],W5
08D6:  RETURN  
08D8:  MOV     W5,[W15++]
08DA:  MOV     #C,W5
08DC:  REPEAT  #3
08DE:  MOV     [W5++],[W15++]
08E0:  CLR     W9
08E2:  MOV     #8000,W8
08E4:  BTSC.B  43.0
08E6:  XOR     W8,W3,W3
08E8:  CP0     W0
08EA:  BRA     NZ,8F2
08EC:  MOV     #7FFF,W10
08EE:  AND     W1,W10,W10
08F0:  BTSS.B  42.1
08F2:  MOV     W1,W10
08F4:  XOR     W3,W10,W11
08F6:  MOV     W1,W6
08F8:  MOV     W3,W7
08FA:  MOV     W3,W12
08FC:  BCLR.B  42.1
08FE:  BCLR.B  42.0
0900:  RLC     W6,W6
0902:  SWAP    W6
0904:  AND     #FF,W6
0906:  CP0     W6
0908:  BRA     Z,A4C
090A:  BCLR.B  42.1
090C:  BCLR.B  42.0
090E:  RLC     W7,W7
0910:  SWAP    W7
0912:  AND     #FF,W7
0914:  CP0     W7
0916:  BRA     Z,A56
0918:  BCLR.B  42.1
091A:  BCLR.B  42.0
091C:  CP      W7,W6
091E:  BRA     Z,A58
0920:  BRA     N,A68
0922:  BCLR    W9.0
0924:  BSET    W9.1
0926:  SUB     W7,W6,W8
0928:  MOV     W7,W6
092A:  AND     #FF,W1
092C:  BSET    W1.7
092E:  AND     #FF,W3
0930:  BSET    W3.7
0932:  MOV     #28,W7
0934:  CP      W7,W8
0936:  BRA     N,95A
0938:  BCLR.B  42.1
093A:  BCLR.B  42.0
093C:  RRC     W1,W1
093E:  RRC     W0,W0
0940:  DEC     W8,W8
0942:  BRA     NZ,938
0944:  BRA     960
0946:  MOV     #28,W7
0948:  CP      W7,W8
094A:  BRA     N,95E
094C:  BCLR.B  42.1
094E:  BCLR.B  42.0
0950:  RRC     W3,W3
0952:  RRC     W2,W2
0954:  DEC     W8,W8
0956:  BRA     NZ,94C
0958:  BRA     978
095A:  MOV     W2,W0
095C:  MOV     W3,W1
095E:  BRA     9E6
0960:  BTSS    W11.F
0962:  BRA     986
0964:  BTSC    W9.4
0966:  MOV     W12,W11
0968:  NEG     W0,W0
096A:  BRA     Z,970
096C:  COM.B   W1L,W1L
096E:  BRA     972
0970:  NEG     W1,W1
0972:  BTSC    W9.4
0974:  BRA     9CC
0976:  BRA     986
0978:  BTSS    W11.F
097A:  BRA     986
097C:  NEG     W2,W2
097E:  BRA     Z,984
0980:  COM.B   W3L,W3L
0982:  BRA     986
0984:  NEG     W3,W3
0986:  AND     #FF,W5
0988:  BCLR.B  42.1
098A:  BCLR.B  42.0
098C:  ADD     W0,W2,W0
098E:  ADDC.B  W1L,W3L,W1L
0990:  BTSC.B  42.0
0992:  BSET    W9.3
0994:  BTSC    W9.0
0996:  BRA     9AA
0998:  BTSC    W9.1
099A:  BRA     99E
099C:  BRA     9B4
099E:  BTSC    W11.F
09A0:  BRA     9CC
09A2:  BTSC    W9.3
09A4:  BRA     9F8
09A6:  BSET    W9.6
09A8:  BRA     9E6
09AA:  BTSC    W11.F
09AC:  BRA     9CC
09AE:  BTSC    W9.3
09B0:  BRA     9F8
09B2:  BRA     9E6
09B4:  BCLR    W9.2
09B6:  BTSC    W11.F
09B8:  BRA     9C2
09BA:  MOV     W10,W11
09BC:  BTSC    W9.3
09BE:  BRA     9F8
09C0:  BRA     A2E
09C2:  BSET    W9.4
09C4:  XOR.B   #80,W1L
09C6:  BTSC    W1.7
09C8:  BRA     964
09CA:  MOV     W10,W11
09CC:  AND     #FF,W1
09CE:  IOR      W0,  W1,W7
09D0:  BRA     Z,9E6
09D2:  BTSC    W1.7
09D4:  BRA     9E6
09D6:  BCLR.B  42.1
09D8:  BCLR.B  42.0
09DA:  RLC     W0,W0
09DC:  RLC     W1,W1
09DE:  DEC     W6,W6
09E0:  BTSC.B  42.1
09E2:  BRA     A46
09E4:  BRA     9D2
09E6:  BTSC    W9.0
09E8:  MOV     W10,W11
09EA:  BTSC    W9.1
09EC:  MOV     W12,W11
09EE:  BTSS    W9.5
09F0:  BRA     A26
09F2:  BTSC    W10.F
09F4:  BSET    W0.8
09F6:  BRA     A2E
09F8:  BSET.B  42.0
09FA:  RRC.B   W1L,W1L
09FC:  RRC     W0,W0
09FE:  BTSC.B  42.0
0A00:  BSET    W9.5
0A02:  INC     W6,W6
0A04:  BRA     Z,A46
0A06:  BTSS    W9.5
0A08:  BRA     A1A
0A0A:  INC     W0,W0
0A0C:  BRA     NZ,A1A
0A0E:  INC.B   W1L,W1L
0A10:  BRA     NZ,A1A
0A12:  RRC.B   W1L,W1L
0A14:  RRC     W0,W0
0A16:  INC     W6,W6
0A18:  BRA     Z,A46
0A1A:  BTSC    W9.0
0A1C:  MOV     W10,W11
0A1E:  BTSC    W9.1
0A20:  MOV     W12,W11
0A22:  BTSC.B  42.1
0A24:  BRA     A46
0A26:  BTSC    W9.6
0A28:  MOV     W10,W11
0A2A:  BTSC    W9.7
0A2C:  MOV     W12,W11
0A2E:  IOR      W0,  W1,W2
0A30:  BRA     Z,A78
0A32:  BCLR    W1.7
0A34:  SWAP    W6
0A36:  BCLR.B  42.1
0A38:  BCLR.B  42.0
0A3A:  RRC     W6,W6
0A3C:  XOR     W6,W1,W1
0A3E:  BSET    W1.F
0A40:  BTSS    W11.F
0A42:  BCLR    W1.F
0A44:  BRA     A78
0A46:  MOV     #0,W0
0A48:  MOV     #0,W1
0A4A:  BRA     A78
0A4C:  BTSC    W10.F
0A4E:  XOR     W8,W3,W3
0A50:  MOV     W2,W0
0A52:  MOV     W3,W1
0A54:  BRA     A78
0A56:  BRA     A78
0A58:  AND     #FF,W3
0A5A:  BSET    W3.7
0A5C:  AND     #FF,W1
0A5E:  BSET    W1.7
0A60:  BTSC    W11.F
0A62:  BCLR    W3.7
0A64:  BSET    W9.2
0A66:  BRA     978
0A68:  SUB     W6,W7,W8
0A6A:  AND     #FF,W1
0A6C:  BSET    W1.7
0A6E:  AND     #FF,W3
0A70:  BSET    W3.7
0A72:  BCLR    W9.1
0A74:  BSET    W9.0
0A76:  BRA     946
0A78:  MOV     #12,W5
0A7A:  REPEAT  #3
0A7C:  MOV     [--W15],[W5--]
0A7E:  MOV     [--W15],W5
0A80:  RETURN  
0A82:  MOV     W5,[W15++]
0A84:  MOV     W6,[W15++]
0A86:  MOV     W7,[W15++]
0A88:  XOR     W1,W3,W4
0A8A:  BTSS    W4.F
0A8C:  BRA     A9A
0A8E:  BCLR.B  42.0
0A90:  BCLR.B  42.1
0A92:  BTSS    W1.F
0A94:  BRA     AE2
0A96:  BSET.B  42.0
0A98:  BRA     AE2
0A9A:  MOV     W1,W4
0A9C:  MOV     W0,W5
0A9E:  MOV     W3,W6
0AA0:  MOV     W2,W7
0AA2:  RLC     W1,W1
0AA4:  SWAP    W1
0AA6:  RLC     W3,W3
0AA8:  SWAP    W3
0AAA:  SUB.B   W3L,W1L,W1L
0AAC:  BRA     Z,AB8
0AAE:  BTSS    W4.F
0AB0:  BRA     AE2
0AB2:  MOV     #1,W0
0AB4:  XOR.B   42
0AB6:  BRA     AE2
0AB8:  MOV.B   W4L,W1L
0ABA:  MOV.B   W6L,W3L
0ABC:  BCLR    W1.7
0ABE:  BCLR    W3.7
0AC0:  SUB.B   W3L,W1L,W1L
0AC2:  BRA     Z,ACE
0AC4:  BTSS    W4.F
0AC6:  BRA     AE2
0AC8:  MOV     #1,W0
0ACA:  XOR.B   42
0ACC:  BRA     AE2
0ACE:  SUB     W7,W5,W1
0AD0:  BRA     Z,ADC
0AD2:  BTSS    W4.F
0AD4:  BRA     AE2
0AD6:  MOV     #1,W0
0AD8:  XOR.B   42
0ADA:  BRA     AE2
0ADC:  BCLR.B  42.0
0ADE:  BRA     AE2
0AE0:  BRA     AE2
0AE2:  MOV     [--W15],W7
0AE4:  MOV     [--W15],W6
0AE6:  MOV     [--W15],W5
0AE8:  RETURN  
0AEA:  MOV     W0,W2
0AEC:  MOV     W1,W3
0AEE:  MOV.B   W1L,W0L
0AF0:  SWAP    W0
0AF2:  BSET    W0.F
0AF4:  RLC     W1,W1
0AF6:  SWAP    W1
0AF8:  ZE      W1,W1
0AFA:  MOV     #8E,W4
0AFC:  SUB.B   W4L,W1L,W1L
0AFE:  BRA     Z,B0C
0B00:  CP0     W0
0B02:  BRA     Z,B0C
0B04:  BCLR.B  42.0
0B06:  RRC     W0,W0
0B08:  DEC     W1,W1
0B0A:  BRA     NZ,B00
0B0C:  BTSS    W3.F
0B0E:  BRA     B14
0B10:  NEG     W0,W0
0B12:  BRA     B14
0B14:  RETURN  
....................  
.................... #list 
....................  
.................... #DEVICE ICD=TRUE 
.................... #device ADC=10 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #define SDAPIN PIN_B2 
.................... #define SCLPIN PIN_B3 
....................  
.................... #define SDATPIN PIN_B9 
.................... #define SCLTPIN PIN_B8 
....................  
.................... #fuses  NOWDT, NOBROWNOUT, NOPROTECT, PUT  
....................  
.................... #use delay( crystal=8mhz, clock=32mhz ) 
*
0360:  CP0     W0
0362:  BTSC.B  42.1
0364:  BRA     36E
0366:  REPEAT  #3E7B
0368:  NOP     
036A:  DEC     W0,W0
036C:  BRA     NZ,366
036E:  RETURN  
.................... //#use delay(crystal=25000000, clock=25000000)   // this is commented out for the new board.  It is the old 25MHz crystal. 
.................... #use I2C(stream=SENSOR, SLAVE, sda=SDAPIN,scl=SCLPIN, I2C2, address=0xa0)   // this is I2C 1 
*
0200:  MOV     #FFFF,W0
0202:  BTSS.B  218.3
0204:  BRA     202
0206:  BTSC.B  219.1
0208:  BRA     212
020A:  BTSS.B  217.2
020C:  BRA     212
020E:  BTSS.B  219.0
0210:  BRA     202
0212:  BTSS.B  218.1
0214:  BRA     212
0216:  MOV     210,W0
0218:  BTSC.B  218.6
021A:  BCLR.B  218.6
021C:  BSET.B  217.4
021E:  RETURN  
0220:  MOV     #FFFF,W0
0222:  BTSS.B  218.3
0224:  BRA     236
0226:  BTSS.B  218.2
0228:  BRA     236
022A:  BTSS.B  217.2
022C:  BRA     232
022E:  BTSS.B  219.0
0230:  BRA     236
0232:  MOV     W1,212
0234:  BSET.B  217.4
0236:  RETURN  
.................... #use I2C(stream=PH_LIGHT, MASTER, sda=SDATPIN, scl=SCLTPIN)    // this is the master I2c for talking with removote sensor boards.  There is only one I2c on this chip. 
*
059E:  MOV     #FFFF,W0
05A0:  BTSS.B  208.3
05A2:  BRA     5AE
05A4:  BTSC.B  209.6
05A6:  BRA     5A4
05A8:  MOV     W1,202
05AA:  BTSC.B  209.6
05AC:  BRA     5AA
05AE:  MOV     #0,W0
05B0:  BTSC.B  209.7
05B2:  INC     W0,W0
05B4:  RETURN  
*
05F4:  MOV     #FFFF,W0
05F6:  BTSS.B  208.3
05F8:  BRA     61C
05FA:  MOV     206,W2
05FC:  AND     W2,#1F,W2
05FE:  BRA     NZ,5FA
0600:  BSET.B  206.3
0602:  BTSC    W1.0
0604:  BCLR.B  206.5
0606:  BTSS    W1.0
0608:  BSET.B  206.5
060A:  MOV     206,W2
060C:  AND     W2,#1F,W2
060E:  BRA     NZ,60A
0610:  BSET.B  206.4
0612:  BTSS.B  208.1
0614:  BRA     612
0616:  MOV     200,W0
0618:  BTSC.B  208.6
061A:  BCLR.B  208.6
061C:  RETURN  
.................... #define RHTEMP PIN_B15      //  this is the pin used for talking to the RH and Temp sensor 
....................  
....................  
.................... #define TESTER 
.................... #define COTWOSENSOR 1 
.................... #define SLAVE 1 
.................... #define SENSORNUMBER 0xd9   // this means it is CO2 
....................  
.................... int8 startupdate = 0; // this is the flag to start an upload  
.................... int16 th,tl,hh,hl;  // variables for 1050 RH and temp sensor 
....................  
.................... typedef struct outputDataStruct{ 
.................... char deviceID[16]; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int8 taosVersion; 
.................... float dOxy; 
.................... float wTemp; 
.................... float pH; 
.................... float pHLow; 
.................... float WhiteBalance; 
.................... float tdsLevel; 
.................... float wLevel; 
.................... float lLevelX; 
.................... float lLevelY; 
....................  
.................... int32 lLevelRed; 
.................... int32 lLevelGreen; 
.................... int32 lLevelBlue; 
.................... int32 lLevelClear; 
.................... int8 time; 
.................... int16 date; 
....................  
....................  
.................... float lLevelScale; 
.................... float rH,averagepH; 
.................... float aTemp; 
.................... int16 cO2; 
.................... float nh3; 
.................... float dPoint; 
.................... char DIEHARD[8]; 
.................... }outputData; 
....................  
....................  
.................... outputData sysOutput; 
....................  
.................... //***************************************************************************** 
.................... // Created Febuary 20, 2017 
.................... // This is the selection routine where it picks which I2C to talk with.   
.................... //  It does not exist on the CO2 since there is only one I2C used for talking with the RH/Temp sensor 
.................... //****************************************************************************** 
....................  
.................... void selectsensor(int junk)  //This is added in this module to perform a dummy select.  It's used in the OSmobot only. 
.................... { 
....................     return; 
.................... } 
....................  
....................  
....................  
.................... #include "C:\Aquarium Software\Debug Monitor\CommonPassedDataFromMaterToSlave.h" 
.................... //********************************************************************************************** 
.................... // Created November 23, 2016 
.................... //these are the calibration varibles so far on the tester.   
.................... //********************************************************************************************** 
....................  
.................... typedef struct { 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
.................... float eccal1x; 
.................... float eccal2x; 
.................... float eccal3x; 
.................... float eccal1y; 
.................... float eccal2y; 
.................... float eccal3y; 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... }Calstuff; 
.................... Calstuff sysInput;  
.................... /* 
....................  
.................... typedef struct inputDataStruct{ 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... float eccal1x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal1y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3y;    //  This the EC data point  Added July 18, 2016 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... }inputData; 
.................... inputData sysInput; 
....................  
.................... */ 
....................  
.................... #ifdef SLAVE 
....................  
.................... float Temp1DOOne; 
.................... float Temp1DOTwo; 
.................... float Temp1DOThree; 
.................... float Temp2DOOne; 
.................... float Temp2DOTwo; 
.................... float Temp2DOThree; 
.................... float Temp3DOOne; 
.................... float Temp3DOTwo; 
.................... float Temp3DOThree; 
.................... float Temp1ReadingOne; 
.................... float Temp1ReadingTwo; 
.................... float Temp1ReadingThree; 
.................... float Temp2ReadingOne; 
.................... float Temp2ReadingTwo; 
.................... float Temp2ReadingThree; 
.................... float Temp3ReadingOne; 
.................... float Temp3ReadingTwo; 
.................... float Temp3ReadingThree; 
....................  
.................... unsigned int16 TempOne; 
.................... unsigned int16 TempTwo; 
.................... unsigned int16 TempThree; 
....................  
.................... #endif 
....................  
.................... #include <G:\Osmobot4PostProduction\Instrumentation\CheapRHAndTemp.c> 
.................... #ifdef TESTER 
.................... //****************************************************************************** 
.................... // Created Jan 12, 2017 
.................... // This routine gets the current model number and serial number of the HDC1080 RH/Temp chip.   
.................... // Returned values are valid if the function returns a zero. 
.................... // The RH and Temp is saved in the normal OUTPUT varaibles if the devices is attached to the usnit. 
.................... // The index is used to select the RJ45 port needed.   
.................... // For this set of boards, it's set to one port as a default.  It still needs to be called with the default value in place. 
.................... //****************************************************************************** 
.................... int16 GetHDC1080Version(int index) 
.................... { 
....................     int16 version, tempver; 
.................... #ifndef COTWOSENSOR 
.................... 	selectsensor(index);   // make the selection to talk with this sensor. 
.................... #endif 
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
....................  
.................... 	i2c_start(PH_LIGHT); 
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
.................... 	i2c_write(PH_LIGHT,0xFF);  //Send the command for reading the version 
.................... 	i2c_stop(PH_LIGHT); 
....................     i2c_start(PH_LIGHT); 
.................... 	i2c_write(PH_LIGHT,0x81);  //Move the address number left on and add a one to make is a read command. 
.................... 	tempver = i2c_read(PH_LIGHT); 
....................     version = i2c_read(PH_LIGHT); 
.................... 	i2c_stop(PH_LIGHT); 
....................      version = version + (tempver<<8); 
....................     return(version); 
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Jan 13, 2017 
.................... // This routine inits the HDC1080 RH/Temp chip.   
.................... // No returned value.  Sets all measurements to max resolution which is 14 bits 
.................... // The index is used to select the RJ45 port needed.   
.................... // For this set of boards, it's set to one port as a default.  It still needs to be called with the default value in place. 
.................... //****************************************************************************** 
.................... void GetHDC1080init(int index) 
.................... { 
....................     int version, tempver; 
....................  
.................... #ifndef COTWOSENSOR 
.................... 	selectsensor(index);   // make the selection to talk with this sensor. 
.................... #endif 
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
....................     // set the configuration register 
.................... 	i2c_start(PH_LIGHT); 
*
05B6:  BTSS.B  208.3
05B8:  BRA     5C2
05BA:  BSET.B  206.1
05BC:  BTSC.B  206.1
05BE:  BRA     5BC
05C0:  BRA     5C8
05C2:  BSET.B  206.0
05C4:  BTSC.B  206.0
05C6:  BRA     5C4
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
05C8:  MOV.B   #80,W1L
05CA:  CALL    59E
.................... 	i2c_write(PH_LIGHT,0x02);  //Point the next two  bytes to the command register. 
05CE:  MOV.B   #2,W1L
05D0:  CALL    59E
....................     i2c_write(PH_LIGHT,0x00);  // Send the MSB first.  In this case it is the default witch is 14 bits 
05D4:  CLR.B   W1
05D6:  CALL    59E
.................... 	i2c_write(PH_LIGHT,0x00);  //Send the configuration LSB 
05DA:  CLR.B   W1
05DC:  CALL    59E
.................... 	i2c_stop(PH_LIGHT); 
05E0:  MOV     #1F,W0
05E2:  AND     206,W0
05E4:  BRA     NZ,5E0
05E6:  BSET.B  206.2
05E8:  BTSC.B  206.2
05EA:  BRA     5E8
....................     delay_ms(45);  //This is the time it takes to get the first measurement 
05EC:  MOV     #2D,W0
05EE:  CALL    360
05F2:  RETURN  
....................       
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... // Created Jan 11, 2017 
.................... // This routine gets the current reading of the HDC1080 RH/Temp chip.   
.................... // Returned values are valid if the runction returns a zero. 
.................... // The RH and Temp is saved in the normal OUTPUT varaibles if the devices is attached to the usnit. 
.................... // The index is used to select the RJ45 port needed.   
.................... // For this set of boards, it's set to one port as a default.  It still needs to be called with the default value in place. 
.................... //****************************************************************************** 
.................... float GetHDC1080RHTemp(int index) 
.................... { 
....................     unsigned int8 temphigh,templow,rhhigh, rhlow; 
....................     float t,h; 
....................     //int th,tl,hh,hl; 
....................     GetHDC1080init(index); 
*
061E:  PUSH    ACA
0620:  POP     AD4
0622:  CALL    5B6
.................... #ifndef COTWOSENSOR 
.................... 	selectsensor(index);   // make the selection to talk with this sensor. 
.................... #endif 
.................... // then send the command down to the sensor.  All of the communcatiuon is done through the I2C on PH_LIGHT. 
....................  
.................... // trigger tempeerature  measurement 
.................... 	i2c_start(PH_LIGHT); 
0626:  BTSS.B  208.3
0628:  BRA     632
062A:  BSET.B  206.1
062C:  BTSC.B  206.1
062E:  BRA     62C
0630:  BRA     638
0632:  BSET.B  206.0
0634:  BTSC.B  206.0
0636:  BRA     634
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
0638:  MOV.B   #80,W1L
063A:  CALL    59E
.................... 	i2c_write(PH_LIGHT,0x00);  //Send the command for reading the version 
063E:  CLR.B   W1
0640:  CALL    59E
.................... //	i2c_stop(PH_LIGHT); 
....................     delay_ms(20);   // wait for measurement 
0644:  MOV     #14,W0
0646:  CALL    360
....................      
....................      
....................      
....................  //   Start over to read the measurement.  This kicks the chip out of low power mode. 
....................     i2c_start(PH_LIGHT); 
064A:  BTSS.B  208.3
064C:  BRA     656
064E:  BSET.B  206.1
0650:  BTSC.B  206.1
0652:  BRA     650
0654:  BRA     65C
0656:  BSET.B  206.0
0658:  BTSC.B  206.0
065A:  BRA     658
.................... 	i2c_write(PH_LIGHT,0x81);  //Move the address number left on and add a one to make is a read command. 
065C:  MOV.B   #81,W1L
065E:  CALL    59E
.................... 	temphigh = i2c_read(PH_LIGHT); 
0662:  MOV.B   200,W0L
0664:  MOV.B   W0L,AC6
....................     delay_ms(10);   // wait for measurement 
0666:  MOV     #A,W0
0668:  CALL    360
....................       
....................     templow = i2c_read(PH_LIGHT,0); 
066C:  MOV     #0,W1
066E:  MOV     W1,[W15++]
0670:  MOV     [--W15],W1
0672:  CALL    5F4
0676:  MOV.B   W0L,AC7
....................   	i2c_stop(PH_LIGHT);   
0678:  MOV     #1F,W0
067A:  AND     206,W0
067C:  BRA     NZ,678
067E:  BSET.B  206.2
0680:  BTSC.B  206.2
0682:  BRA     680
....................    
....................      
....................     // trigger rh  measurement 
.................... 	i2c_start(PH_LIGHT); 
0684:  BTSS.B  208.3
0686:  BRA     690
0688:  BSET.B  206.1
068A:  BTSC.B  206.1
068C:  BRA     68A
068E:  BRA     696
0690:  BSET.B  206.0
0692:  BTSC.B  206.0
0694:  BRA     692
.................... 	i2c_write(PH_LIGHT,0x80);  //Move the address number left on and add a zero. 
0696:  MOV.B   #80,W1L
0698:  CALL    59E
.................... 	i2c_write(PH_LIGHT,0x01);  //Send the command for reading the version 
069C:  MOV.B   #1,W1L
069E:  CALL    59E
.................... //	i2c_stop(PH_LIGHT); 
....................     delay_ms(20);   // wait for measurement 
06A2:  MOV     #14,W0
06A4:  CALL    360
....................      
....................   //   Start over to read the measurement.  This kicks the chip out of low power mode. 
....................     i2c_start(PH_LIGHT); 
06A8:  BTSS.B  208.3
06AA:  BRA     6B4
06AC:  BSET.B  206.1
06AE:  BTSC.B  206.1
06B0:  BRA     6AE
06B2:  BRA     6BA
06B4:  BSET.B  206.0
06B6:  BTSC.B  206.0
06B8:  BRA     6B6
.................... 	i2c_write(PH_LIGHT,0x81);  //Move the address number left on and add a one to make is a read command.    
06BA:  MOV.B   #81,W1L
06BC:  CALL    59E
....................     rhhigh = i2c_read(PH_LIGHT); 
06C0:  MOV.B   200,W0L
06C2:  MOV.B   W0L,AC8
....................        delay_ms(10);   // wait for measurement 
06C4:  MOV     #A,W0
06C6:  CALL    360
....................     rhlow = i2c_read(PH_LIGHT,0); 
06CA:  MOV     #0,W1
06CC:  MOV     W1,[W15++]
06CE:  MOV     [--W15],W1
06D0:  CALL    5F4
06D4:  MOV.B   W0L,AC9
.................... 	i2c_stop(PH_LIGHT); 
06D6:  MOV     #1F,W0
06D8:  AND     206,W0
06DA:  BRA     NZ,6D6
06DC:  BSET.B  206.2
06DE:  BTSC.B  206.2
06E0:  BRA     6DE
....................      
....................     th = (int) temphigh; 
06E2:  MOV.B   AC6,W0L
06E4:  MOV.B   W0L,862
06E6:  CLR.B   863
....................     tl = (int) templow; 
06E8:  MOV.B   AC7,W0L
06EA:  MOV.B   W0L,864
06EC:  CLR.B   865
....................     hh = (int) rhhigh; 
06EE:  MOV.B   AC8,W0L
06F0:  MOV.B   W0L,866
06F2:  CLR.B   867
....................     hl = (int) rhlow; 
06F4:  MOV.B   AC9,W0L
06F6:  MOV.B   W0L,868
06F8:  CLR.B   869
....................      
....................  //   t = (float) (th << 8 | tl); 
....................  //   h = (float) (hh << 8 | hl); 
....................  //   t = t * 165.0 / 65536.0 - 40.0; 
.................... //	h = h * 100.0 / 65536.0;	 
....................  
....................      
....................      
....................     return(t); 
06FA:  MOV     ACC,W0
06FC:  MOV     ACE,W1
06FE:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
.................... #ifndef TIRHTEMP 
....................  
.................... float RHData, Temperature;   // These are the values for the coefenents for decay solutions. 
....................  
.................... //**************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // Init all of the I/O bits to make the RH/Temp sensor work 
.................... // Returns nothing 
.................... //**************************************************************************** 
.................... void initRHTemp(void) 
.................... 	{ 
.................... 	output_high(RHTEMP);   //This sets the output high. 
.................... 	} 
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // Find the check sum number 
.................... //  0 - all is good, 1 - all is bad 
.................... //**************************************************************************** 
.................... int16 CheckSumRHTemp(long RawRH, long RawTemp) 
.................... 	{ 
.................... 	int16 checksum2,checksum3; 
....................  
.................... 	checksum2 = (int16) 0xFF00 & RawRH; 
....................     checksum2 = checksum2>>8; 
.................... 	checksum2 = checksum2 + (int16) (0x00FF & RawRH); 
....................  
.................... 	checksum3 = (int16) (0xFF00 & RawTemp); 
....................     checksum3 = checksum3>>8; 
.................... 	checksum2 = checksum3 + checksum2 + (int16) (0x00FF & RawTemp); 
....................  
.................... 	return(0x00FF & checksum2); 
.................... 	} 
....................  
....................  
.................... //*************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // This routine returns the RH and Temps as float through global variables 
.................... // Returns 1 if there is an error.  a zero if there none 
.................... // All calculations for converion and reading the sensor is done here. 
.................... //*************************************************************************** 
.................... int GetTempRH(void) 
.................... 	{ 
.................... 	int x,y,w,counter; 
....................     long  RawRH, RawTemp, CheckSum;//These are the global varaibles for RH and Temperature 
....................  
....................  
.................... //  Send command out to the I/O pin 
.................... 	output_high(RHTEMP);   //This sets the output high. 
.................... 	output_low(RHTEMP);   //This sets the output high. 
.................... 	delay_ms(5); 
.................... 	output_high(RHTEMP);   //This sets the output high. 
.................... 	delay_us(40); 
.................... 	output_float(RHTEMP); 
.................... 	delay_us(20); 
....................  
.................... 	for (x=0; x < 5; x++) ///This waits to get out of the MCU command 
.................... 		{ 
.................... 		y=input_state(RHTEMP); 
.................... 		if (!y) break; 
.................... 		delay_us(10); 
.................... 		} 
.................... 	for (x=0; x < 20; x++)   //This waits through the zero and finds a 1 
.................... 		{ 
.................... 		y=input_state(RHTEMP); 
.................... 		if (y) break; 
.................... 		delay_us(10); 
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(10); 
.................... 		} 
.................... 	 
.................... //beginning of first bit zero 
.................... //Setup the for loop 
.................... RawRH = 0; /// Clear out the variable 
.................... for (counter=0; counter < 16; counter++) 
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the bit to time out the zero for the next bit 
.................... 		if (y) break; 
.................... 		delay_us(5); 
.................... 		} 
.................... 		w=y; 
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(5); 
.................... 		} 
....................  
.................... 	RawRH=RawRH<<1;	// Shift the whole word one bit left. 
.................... 	if (x > 6) 
.................... 		{ 
.................... 		RawRH = RawRH + 0x0001; 
.................... 		} 
.................... 	} 
.................... 	 
....................  
....................  
.................... RawTemp = 0; /// Clear out the variable 
.................... for (counter=0; counter < 16; counter++) 
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the bit to time out the zero for the next bit 
.................... 		if (y) break; 
.................... 		delay_us(5); 
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(5); 
.................... 		} 
.................... 	 
....................  
.................... 	RawTemp=RawTemp<<1;	// Shift the whole word one bit left. 
.................... 	if (x > 6) 
.................... 		{ 
.................... 		RawTemp = RawTemp + 0x0001; 
.................... 		} 
.................... 	} 
....................  
....................  
....................  
.................... CheckSum = 0; /// Clear out the variable 
.................... for (counter=0; counter < 8; counter++) 
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the bit to time out the zero for the next bit 
.................... 		if (y) break; 
.................... 		delay_us(5); 
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
.................... 		{ 
.................... 		y=input_state(RHTEMP);   //wait for the first bit to pop up  Assuming is less than 200 us 
.................... 		if (!y) break; 
.................... 		delay_us(5); 
.................... 		} 
.................... 	 
....................  
.................... 	CheckSum=CheckSum<<1;	// Shift the whole word one bit left. 
.................... 	if (x > 6) 
.................... 		{ 
.................... 		CheckSum = CheckSum + 0x0001; 
.................... 		} 
.................... 	} 
....................  
.................... 	RHData = (float)RawRH; 
....................  
.................... if (CheckSum == CheckSumRHTemp(RawRH,RawTemp)) 
.................... 	{ 
.................... 	RHData = (float)RawRH/10.0; 
....................     Temperature = ((float)RawTemp)/10.0; 
.................... 	return(0); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 	return(1); 
.................... 	} 
.................... 	} 
....................  
.................... #endif 
....................  
.................... #ifdef CHEAPEC  
.................... //************************************************************************************* 
.................... // Created September 2, 2015 
.................... // This routines calculated all of the values for a given set of decay equation. 
.................... //  The equation is y = AA + BBexp^-CCx.  This is an electrcial decay equation that has to be run several times to get the values for AA, BB and CC. 
.................... // It's assumed the first value is the highest ppm  with the lowst value for x as in imput. 
.................... // The result are gloabe variables for AA, BB and BC. 
.................... // AA is calculated by knowing the first assmetopt. 
....................  
.................... float solvefordecay(int32 measurement)	 
.................... 	{ 
....................  
.................... 	float eccheck;    //These are used for holding the caluclated values for the current returned iteration.  The x input is not needed because it's already defined. 
.................... 	int x; 
....................  
....................  
.................... //********************************************************************** 
.................... // Added Sept 3, 2015 
.................... // Updated with regression equations May 31, 2016 
.................... // The attempt to solve for a decaying curve is stopped for now.   
.................... // Currently a liner approach is used for three points. 
.................... //********************************************************************** 
.................... // Form the calibration data proved on the EEPROM, find all of the coef for the lineized LOG function. 
.................... //  Y = B + m(ln(x)) 
.................... // B =  
.................... // Find Y     
....................      
....................      
....................      
....................      
....................      
....................      
.................... eccheck = (float) measurement;   /// Change over the data type to a float for correct operations in the range testing. 
....................  
....................  
.................... if (eccheck > eccalibrationx[0])    
.................... 	{ 
.................... 	y = 0.0; 
.................... 	return(y);   //Send out the result if it's to a limit. 
.................... 	} 
....................  
.................... if (eccheck <= eccalibrationx[2]) 
.................... 	{ 
.................... 	y = 2000.0; 
.................... 	return(y);  //Send out the result if it's to a limit. 
.................... 	} 
....................  
.................... } 
....................  
....................  
....................  
.................... //************************************************************************************ 
.................... // Created Augest 24, 2015 
.................... // This routine measures the time delay for EC  or TDS.  It does this by cycling through a decay of an RC circute. 
.................... // The pinouts are as follwos: 
.................... // PICCPU    Function 
.................... // RC14     - C+ 
.................... // RC13     - C- 
.................... // RD0      - EC+ 
.................... // RD11     - EC- 
.................... // This is the firing order for measurement: 
.................... // EC1     input   low       low               input        measuere decay    high 
.................... // C+      high    input     measuere decay    high         low               input 
.................... // C-      low     low       low               high         high              high 
.................... // The returned results is an average of 16 measurements of plus and mnues measurentents at 1Khz 
.................... // returns a float with the current EC value. 
.................... //************************************************************************************* 
.................... float measureTDS(void) 
.................... 	{ 
....................  
.................... 	int statecounter,x; 
.................... 	int32 currentreadingunder=0,y,z;  // This is used as the state counter for the measurmeents.  It goes between 1 to seven. 
.................... 	int32 measurement=0, currentreading;   //This is the measurement accumlator and then it's averaged. 
.................... 	float result; 
....................  
.................... //  Set up the output and input for the EC meter. 
.................... /* 
.................... while(1) 
.................... 	{ 
.................... 	output_high(PIN_D10);    //  Define as EC1 
.................... 	output_low(PIN_D10);    //  Define as EC1 
.................... 	} 
.................... */ 
.................... output_high(PIN_D10);    //  Define as EC1- 
....................  
.................... //************************************************* 
.................... // Changed from the old board to the last version on March 28, 2016 
.................... // The two C+ and C- are changed from D0  & C13 to D8 and RD9 for C+ and RD8 for C- 
.................... // Old settings are below. 
.................... //output_high(PIN_D0);     // Define as C+   // Added September 6, 2015  Needs to be changed to RD9 for the new board 
.................... //output_float(PIN_C13);           // Define as C-   // Added September 6, 2015  Needs to be changed to RD8 for the new board 
.................... //************************************************************** 
....................  
.................... output_high(PIN_D9);     // Define as C+   // Added September 6, 2015  Needs to be changed to RD9 for the new board 
.................... output_float(PIN_D8);           // Define as C-   // Added September 6, 2015  Needs to be changed to RD8 for the new board 
....................  
.................... output_high(PIN_D11);    //  Define as EC2+   This is the negative direction charge compared to ground.  
.................... // input_state(); 
.................... //while(1) 
.................... //	{ 
.................... restart_wdt();   // restart the WD timer.  It set for 65 seconds 
.................... for (x = 1; x <=16; x++) 
.................... 	{ 
....................  
.................... 	for (statecounter = 1; statecounter < 7; statecounter++) 
.................... 		{ 
.................... 		switch(statecounter) 
.................... 			{ 
.................... 			case 1:     //  Charge Cap to max in + direction. 
.................... 				output_float(PIN_D10);    //  Define as EC- 
.................... 				input(PIN_D11);    //  Define as EC+    keep floarting to no interferiw with measurement.				 
.................... 				//output_high(PIN_D0);     // Define as C+ 
....................                 output_high(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				//output_low(PIN_C13);           // Define as C- 
....................                 output_low(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 				delay_us(100);   // Wait for the CAP to charge to Vcc.  Check on scope. 
.................... 				break; 
.................... 			case 2: 
.................... 				output_low(PIN_D11);    //  Define as EC+ 
.................... 				output_float(PIN_D10);    //  Define as EC-    keep floarting to no interferiw with measurement.				 
.................... //				input(PIN_D0);     // Define as C+ 
....................  
.................... 		//		output_low(PIN_D0);     // Define as C+ 
.................... 				//output_low(PIN_C13);           // Define as C- 
....................                 output_low(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 			//	currentreading = input(PIN_D11);   // update the output for the first one. 
.................... 				for (currentreading = 0; currentreading < 20000; currentreading++) 
.................... 					{ 
.................... 				//	fprintf(BT,"Current EC currentreading %i\n\r",currentreading); 
.................... 				/*	if (!input(PIN_D0)) 
.................... 							{ 
.................... 							 y = currentreading;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							}  */ 
....................  					if (!input(PIN_D9))   //New Board I/O pin  March 28, 2016 
.................... 							{ 
.................... 							 y = currentreading;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							}                    
.................... 					} 
.................... 				break; 
.................... 			case 3: 
.................... 			    input(PIN_D10);    //  Define as EC- 
.................... 				output_float(PIN_D11);    //  Define as EC+    keep floarting to no interferiw with measurement.				 
....................  
.................... 				//output_high(PIN_D0);     // Define as C+   //Discharge the CAP in the other direction. 
....................                 output_high(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				//output_high(PIN_C13);           // Define as C- 
....................                 output_high(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 				delay_us(100);   // Wait for the CAP to charge to Vcc.  Check on scope. 
....................  
.................... 				break; 
.................... 			case 4: 
.................... 				//output_high(PIN_C13);     // Define as C+ 
....................                 output_high(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
.................... 				//output_low(PIN_D0);           // Define as C- 
....................                 output_low(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				delay_us(100);   // Wait for the CAP to charge to Vcc.  Check on scope. 
.................... 				break; 
.................... 			case 5: 
.................... 				output_high(PIN_D10);    //  Define as EC- 
.................... 				output_float(PIN_D11);    //  Define as EC+    keep floarting to no interferiw with measurement.				 
.................... //				input(PIN_D0);     // Define as C+ 
....................  
.................... 		//		output_low(PIN_D0);     // Define as C+ 
.................... 			//	output_high(PIN_D0);           // Define as C+ 
.................... 			//	currentreading = input(PIN_D11);   // update the output for the first one. 
.................... 				for (currentreadingunder = 0; currentreadingunder < 20000; currentreadingunder++) 
.................... 					{ 
.................... 				//	fprintf(BT,"Current EC currentreading %i\n\r",currentreading); 
.................... 				/*	if (input(PIN_D0))    //  measure using C- 
.................... 							{ 
.................... 							 z = currentreadingunder;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							}  */ 
....................                     if (input(PIN_D9))    //  measure using C-  New Board I/O pin  March 28, 2016 
.................... 							{ 
.................... 							 z = currentreadingunder;   //this is the count for the 1/3 of the trigger. 
.................... 							break; 
.................... 							} 
.................... 					} 
.................... 				break; 
....................  
.................... 			case 6: 
....................  
.................... 				//output_low(PIN_D0);     // Define as C+   //Discharge the CAP in the other direction. 
....................                 output_low(PIN_D9);     // Define as C+  New Board I/O pin  March 28, 2016 
.................... 				//output_low(PIN_C13);           // Define as C- 
....................                 output_low(PIN_D8);           // Define as C-  New Board I/O pin  March 28, 2016 
....................  
....................  
....................  
.................... 				break; 
.................... 			default: 
....................  
....................  
.................... 				break; 
.................... 			} 
....................  
.................... 	 measurement =  measurement + y;   // Add together all of the 16 numbers. 
.................... currentreadingunder = currentreadingunder + z; 
.................... restart_wdt();   // restart the WD timer.  It set for 65 seconds 
.................... 		} 
....................  
....................  
.................... 	} 
.................... currentreadingunder = currentreadingunder/16; 
.................... 	measurement = measurement/16;   // Do the average 
....................  
....................  
.................... //********************************************************************************* 
.................... // Created Aug 10, 2016 
.................... // Set all EC probe levels to zero when leaving the routine. 
.................... //******************************************************************************** 
....................   output_low(PIN_D8);     //Set to low to prevent interference with pH bulb. 
....................   output_low(PIN_D9); 
....................   output_low(PIN_D10); 
....................   output_low(PIN_D11); 
....................  
.................... //************************************************************************************************ 
.................... // Created Sept 1, 2015 
.................... // Below takes the decay value from the C+ side and converts it into ppm.   
.................... // At this time there is no temperature compensation. 
.................... // At this time the calibration values are not saved in SD Card. 
.................... //************************************************************************************************ 
....................  
.................... //  Current measured data 
.................... //  Reading            ppm 
.................... //  36                 1553 
.................... //  51                 468 
.................... //  700                24 
....................  
.................... eccalibrationx[0] = 447.0; 
.................... eccalibrationx[1] = 44.0; 
.................... eccalibrationx[2] = 19.0; 
....................  
....................  
.................... eccalibrationy[0]  = 33.0; 
.................... eccalibrationy[1]  = 481.0; 
.................... eccalibrationy[2]  = 1718.0; 
....................  
....................  
.................... result = solvefordecay(measurement); // Solve for the current value for calibration for this EC meter 
.................... fprintf(BT,"Current EC reading top %Lu under %Lu  ppm %f\n\r",measurement,currentreadingunder,result); 
.................... result =  (float) measurement; 
.................... //measurement=0; 
.................... //} 
.................... //return(result);   // this is the old return  Changed April 14, 2016 
.................... return(result);	 
.................... 	}   // end of function. 
....................  
.................... #endif 
....................  
.................... #include "I2cCO2.c" 
....................  
....................  
.................... //**************************************************************************************** 
.................... // Added Jan 24, 2012 
.................... // This is a file for all the routines to connect with a CO2 K-30 sensor. 
.................... //The changes below are for the internal sensor inside the CELSS system. 
.................... //**************************************************************************************** 
....................  
.................... //#define DATACO2  PIN_A2    /*set DATACO2 to PortA1 and SCKCO2 to portA2*/ //Old ones 
.................... //#define SCKCO2   PIN_A1     // Old ones 
....................  
.................... //#define DATACO2  PIN_B2    /*set DATACO2 to PortB3 and SCKCO2 to portB2*/  
.................... //#define SCKCO2   PIN_B3    //This is set up for BioSphere2  Added June 20, 2013 
....................  
.................... #define DATACO2  PIN_B11    /*set DATACO2 to PortB3 and SCKCO2 to portB2*/  
.................... #define SCKCO2   PIN_B10    //This is set up for BioSphere2  Added June 20, 2013 
....................  
.................... //**************************************************************************************** 
.................... // Added Jan 28, 2012 
.................... // This routine is used to send the timing for reading one Byte of data from the I2c. 
.................... //**************************************************************************************** 
.................... BYTE CO2ReadByte(void) 
.................... { 
....................  
....................   int i; 
.................... 	BYTE lVal1;   //Add September 3, 2012.  This def needed to be added. 
....................    long lTmp,lValue; 
.................... 	lVal1=0; 
*
0424:  CLR.B   AD2
....................    output_low(SCKCO2); 
0426:  BCLR.B  2C9.2
0428:  BCLR.B  2CD.2
....................    delay_us(5); 
042A:  REPEAT  #4E
042C:  NOP     
.................... 	output_float(DATACO2); 
042E:  BSET.B  2C9.3
....................    for (i=0; i<8; i++)         //Read CO2 sensor without ACK. 
0430:  CLR     AD4
0432:  MOV     AD4,W4
0434:  CP      W4,#8
0436:  BRA     GE,466
.................... 	   { 
.................... 		lVal1<<=1; 
0438:  SL.B    AD2
....................     	output_high(SCKCO2);  //Clock High is when the data is legal. 
043A:  BCLR.B  2C9.2
043C:  BSET.B  2CD.2
....................     	delay_us(10); 
043E:  REPEAT  #9E
0440:  NOP     
....................     	lTmp = input(DATACO2); 
0442:  BSET.B  2C9.3
0444:  CLR     AD6
0446:  BTSC.B  2CB.3
0448:  INC     0AD6
044A:  CLR     AD8
....................    	    delay_us(10); 
044C:  REPEAT  #9E
044E:  NOP     
....................     	output_low(SCKCO2); 
0450:  BCLR.B  2C9.2
0452:  BCLR.B  2CD.2
....................     	delay_us(10); 
0454:  REPEAT  #9E
0456:  NOP     
....................     	if (lTmp) lVal1|=1;  
0458:  CP0     AD6
045A:  BRA     NZ,460
045C:  CP0     AD8
045E:  BRA     Z,462
0460:  BSET.B  AD2.0
0462:  INC     0AD4
0464:  BRA     432
....................    		}  
.................... 		output_low(DATACO2); 
0466:  BCLR.B  2C9.3
0468:  BCLR.B  2CD.3
....................  		delay_us(5); 
046A:  REPEAT  #4E
046C:  NOP     
....................     	output_high(SCKCO2);  //Clock High is when the data is legal. 
046E:  BCLR.B  2C9.2
0470:  BSET.B  2CD.2
....................  		delay_us(5); 
0472:  REPEAT  #4E
0474:  NOP     
....................     	output_low(SCKCO2); 
0476:  BCLR.B  2C9.2
0478:  BCLR.B  2CD.2
.................... 		delay_us(5); 
047A:  REPEAT  #4E
047C:  NOP     
.................... 	    output_float(DATACO2); 
047E:  BSET.B  2C9.3
.................... 		delay_us(5); 
0480:  REPEAT  #4E
0482:  NOP     
....................  
.................... return(lVal1); 
0484:  MOV.B   AD2,W0L
0486:  MOV.B   W0L,0
0488:  RETURN  
.................... } 
....................  
....................  
.................... void CO2SendStopBit(void) 
.................... //**************************************************************************************** 
.................... // Added Jan 28, 2012 
.................... // This routine sends a start bit only. 
.................... //Starting with the clock and data lines low for data SDA change.   
.................... //Leaving Data lines  high. 
.................... //**************************************************************************************** 
.................... { 
....................  
.................... 	output_high(DATACO2); 
*
0406:  BCLR.B  2C9.3
0408:  BSET.B  2CD.3
....................     delay_us(6); 
040A:  REPEAT  #5E
040C:  NOP     
....................     output_high(SCKCO2); 
040E:  BCLR.B  2C9.2
0410:  BSET.B  2CD.2
....................     delay_us(6); 
0412:  REPEAT  #5E
0414:  NOP     
.................... 	output_low(DATACO2); 
0416:  BCLR.B  2C9.3
0418:  BCLR.B  2CD.3
....................     delay_us(10); 
041A:  REPEAT  #9E
041C:  NOP     
.................... 	output_high(DATACO2); 
041E:  BCLR.B  2C9.3
0420:  BSET.B  2CD.3
0422:  RETURN  
.................... 	 
.................... } 
....................  
....................  
.................... //**************************************************************************************** 
.................... // Added Jan 28, 2012 
.................... // This routine is used to send the timing to send one Byte of data to the CO2 sensor. 
.................... //This routines makes about 10 attempts of writing one byte of data with ACK.  If the ACk is not present, then it tries again until 10 times are up. 
.................... //The routine returns a 0 ieverything is OK, it returns a 1 if it failed. 
.................... //This routines assumes a startbit has occured. 
.................... //**************************************************************************************** 
.................... int CO2WriteByte(BYTE command) 
.................... { 
....................  
.................... int i,ii; 
.................... int lTmp; 
.................... int state; 
.................... //Make sure the start bit is active. 
.................... // All data lines are coming in Low 
....................  
.................... 	//Setup first bit of data to write. 
....................  
.................... //for (ii=0; ii<10; ii++)  //loop through 10 tries 
.................... //**************************************************************** 
.................... //Added 2/13/2012 
.................... //*  data is sent to the CO2 sensor in a backwards way.  For instance the command address 0x68 is b01101000.  The LSB is send firt and the last bit is the MSB.   
.................... //*  The wave form looks like   b00010110.  All numbers are like that for the CO2 sensor. 
.................... //*  To receive data from the CO2 sensor. 
.................... //*   Master Transmit: 
.................... //*   <68> <04> <00> <03> <00> <01> <C8> <F3>       
.................... //*  This means  
.................... //*  0x68 is the command.  In the I2C world this needs to be shifted to 0xD0  or  0x68 = b01101000 to 11010000  padded 0 shift left.  
.................... //*  0x04 is the register 
.................... //*  0x00 and 0x03 is the register.  It is sent in this order. 
.................... //*  0x00 and 0x01 is the number of bytes read back in this case 2. 
.................... //*  The last two are the check Sum where the LSByte is send first and the high one last. 
.................... //*  All data is reversted. 
....................  
....................  
.................... //*   Slave Reply: 
.................... //*   <68> <04> <02> <03> <01> <24> <09>   This gives the nuimger of 0x301 ppm. 
....................  
.................... //{ 
....................    output_low(SCKCO2); 
*
0388:  BCLR.B  2C9.2
038A:  BCLR.B  2CD.2
....................    delay_us(5); 
038C:  REPEAT  #4E
038E:  NOP     
.................... 	ii = 0x80; 
0390:  MOV     #80,W4
0392:  MOV     W4,AD6
....................    for (i=1; i<=8; i++) 
0394:  MOV     #1,W4
0396:  MOV     W4,AD4
0398:  MOV     AD4,W4
039A:  CP      W4,#8
039C:  BRA     GT,3D0
....................    {if (ii & command)  
039E:  MOV.B   AD2,W0L
03A0:  CLR.B   1
03A2:  AND     AD6,W0
03A4:  CP0     W0
03A6:  BRA     Z,3AE
.................... 		{ 
.................... 		output_high(DATACO2); 
03A8:  BCLR.B  2C9.3
03AA:  BSET.B  2CD.3
.................... 		} 
03AC:  BRA     3B2
....................     else  
.................... 		{  
.................... 		output_low(DATACO2); 
03AE:  BCLR.B  2C9.3
03B0:  BCLR.B  2CD.3
.................... 		}	 
.................... 		ii/=2;   
03B2:  MOV     AD6,W4
03B4:  MOV     #2,W3
03B6:  REPEAT  #11
03B8:  DIV.S   W4,W3
03BA:  MOV     W0,AD6
.................... 		  delay_us(10);  
03BC:  REPEAT  #9E
03BE:  NOP     
....................           output_high(SCKCO2); 
03C0:  BCLR.B  2C9.2
03C2:  BSET.B  2CD.2
....................           delay_us(10); 
03C4:  REPEAT  #9E
03C6:  NOP     
....................           output_low(SCKCO2); 
03C8:  BCLR.B  2C9.2
03CA:  BCLR.B  2CD.2
03CC:  INC     0AD4
03CE:  BRA     398
....................       }   
....................  delay_us(7); 
03D0:  REPEAT  #6E
03D2:  NOP     
....................   output_float(DATACO2); 
03D4:  BSET.B  2C9.3
....................    delay_us(7); 
03D6:  REPEAT  #6E
03D8:  NOP     
....................           output_high(SCKCO2); 
03DA:  BCLR.B  2C9.2
03DC:  BSET.B  2CD.2
....................           delay_us(10); 
03DE:  REPEAT  #9E
03E0:  NOP     
....................   
....................         //  output_low(SCKCO2); 
.................... 	//	  delay_us(10); 
....................  
....................  //  output_high(SCKCO2); 
....................  
....................  state = 0; 
03E2:  CLR     ADA
.................... 	lTmp=input(DATACO2);   //Check to see if the Data line is high.  Low means sensor can take a command.  A Low means sensor is not ready. 
03E4:  BSET.B  2C9.3
03E6:  CLR     AD8
03E8:  BTSC.B  2CB.3
03EA:  INC     0AD8
.................... if(lTmp != 0) 
03EC:  CP0     AD8
03EE:  BRA     Z,3F4
.................... 		{ 
.................... 		state = 0;  //This means the device is not ready. 
03F0:  CLR     ADA
.................... //		CO2SendStopBit(); 
.................... 		} 
03F2:  BRA     3F8
.................... 		else 
.................... 		{ 
.................... 		state = 1;  //This means the device is ready or ACK worked 
03F4:  MOV     #1,W4
03F6:  MOV     W4,ADA
.................... 		//break; 
.................... 		}  
.................... output_low(SCKCO2); 
03F8:  BCLR.B  2C9.2
03FA:  BCLR.B  2CD.2
....................  
.................... output_high(DATACO2); 
03FC:  BCLR.B  2C9.3
03FE:  BSET.B  2CD.3
....................  
.................... //start to setup stop bit if needed or loop back and do it again. 
.................... //	output_low(DATACO2); 
.................... 	 
....................  //   delay_us(10); 
.................... //} 
....................  
....................  
.................... return(state);   //If it returns a 0, then is failed.  If it reutrns a 1, it worked. 
0400:  PUSH    ADA
0402:  POP     0
0404:  RETURN  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... void CO2SendStartBit(void) 
.................... //**************************************************************************************** 
.................... // Added Jan 24, 2012 
.................... // This routine sends a start bit only. 
.................... //Leaving the clock low for data SDA change.   
.................... //Leaving Data high. 
.................... //This routine assumes all lines are high for a while. 
.................... //**************************************************************************************** 
.................... { 
....................   output_high(SCKCO2); 
*
0370:  BCLR.B  2C9.2
0372:  BSET.B  2CD.2
....................    output_high(DATACO2); 
0374:  BCLR.B  2C9.3
0376:  BSET.B  2CD.3
.................... 	delay_ms(20); 
0378:  MOV     #14,W0
037A:  CALL    360
....................   output_low(DATACO2);   //High to low on the data line  Start Condition 
037E:  BCLR.B  2C9.3
0380:  BCLR.B  2CD.3
.................... 	delay_us(10); 
0382:  REPEAT  #9E
0384:  NOP     
0386:  RETURN  
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... int WakeUpCO2Sensor(void) 
.................... //**************************************************************************************** 
.................... //  Added Jan 24, 2012 
.................... //This wakes up the CO2 scensor and then keeps the clock going until the first command 
.................... // can be set to the CO2 Sensor. 
.................... //**************************************************************************************** 
....................  
.................... { 
....................  
....................  
.................... int lTmp; 
.................... int state; 
....................  
....................  
.................... CO2SendStartBit(); 
.................... lTmp=CO2WriteByte(0xFE);  //This is a test wakeup. 
....................  
.................... CO2SendStopBit(); 
....................  
.................... 	 
.................... 	return(lTmp); 
.................... }	 
.................... 	 
.................... //int ReadCOSensor(BYTE &ReturnedReadSuccess, BYTE &data1, BYTE &data2, BYTE &CheckSum) 
.................... int16 ReadCOSensor(void) 
*
048A:  MOV     W5,[W15++]
.................... //****************************************************************************************** 
.................... // Added Jan 24, 2012 
.................... // This routine sends the sequence of bytes to the CO2 device and then waits for the return data line to go low. 
.................... //  At the time, the program starts to read the data coming back from the CO2. 
.................... //****************************************************************************************** 
....................  
.................... 	{ 
.................... int16 lTmp;	 
.................... int i,lTmp2; 
.................... BYTE first,second,third,forth, checksum; 
....................  
....................  
.................... lTmp = 0; 
048C:  CLR     ACC
.................... CO2SendStartBit(); 
048E:  CALL    370
.................... //lTmp=CO2WriteByte(0x7E);  //This Sensor address  that is 0x68  shifted left one with a zoer padded   0b01101000  -> 0b11010000 
.................... lTmp=CO2WriteByte(0xD0);  //This Sensor address  that is 0x68  shifted left one with a zoer padded   0b01101000  -> 0b11010000 
0492:  MOV.B   #D0,W0L
0494:  MOV.B   W0L,AD2
0496:  CALL    388
049A:  MOV     W0,ACC
.................... if (lTmp == 1) 
049C:  MOV     ACC,W4
049E:  CP      W4,#1
04A0:  BRA     NZ,4EC
.................... 	{ 
.................... 	lTmp = 0; 
04A2:  CLR     ACC
.................... 	lTmp=CO2WriteByte(0x22);  
04A4:  MOV.B   #22,W0L
04A6:  MOV.B   W0L,AD2
04A8:  CALL    388
04AC:  MOV     W0,ACC
.................... 	if (lTmp == 1) 
04AE:  MOV     ACC,W4
04B0:  CP      W4,#1
04B2:  BRA     NZ,4EC
.................... 		{ 
.................... 		lTmp = 0; 
04B4:  CLR     ACC
.................... 		lTmp=CO2WriteByte(0x00);  
04B6:  CLR.B   AD2
04B8:  CALL    388
04BC:  MOV     W0,ACC
.................... 		if (lTmp == 1) 
04BE:  MOV     ACC,W4
04C0:  CP      W4,#1
04C2:  BRA     NZ,4EC
.................... 			{ 
.................... 			lTmp = 0; 
04C4:  CLR     ACC
.................... 			lTmp=CO2WriteByte(0x08);  
04C6:  MOV.B   #8,W0L
04C8:  MOV.B   W0L,AD2
04CA:  CALL    388
04CE:  MOV     W0,ACC
.................... 			if (lTmp == 1) 
04D0:  MOV     ACC,W4
04D2:  CP      W4,#1
04D4:  BRA     NZ,4EC
.................... 			{	 
.................... 				lTmp = 0; 
04D6:  CLR     ACC
.................... 				lTmp=CO2WriteByte(0x2A);  
04D8:  MOV.B   #2A,W0L
04DA:  MOV.B   W0L,AD2
04DC:  CALL    388
04E0:  MOV     W0,ACC
.................... 				if (lTmp == 1) 
04E2:  MOV     ACC,W4
04E4:  CP      W4,#1
04E6:  BRA     NZ,4EC
.................... 				{	 
.................... 					lTmp = 5;  
04E8:  MOV     #5,W4
04EA:  MOV     W4,ACC
.................... 					} 
.................... 				} 
.................... 			} 
.................... 		} 
.................... 	} 
....................    
.................... CO2SendStopBit(); 
04EC:  CALL    406
....................  
.................... if (lTmp == 5) 
04F0:  MOV     ACC,W4
04F2:  CP      W4,#5
04F4:  BRA     NZ,544
.................... 	{ 
....................  
.................... delay_ms(10);  //Wait for sensor to come back with numbers and then send command. 
04F6:  MOV     #A,W0
04F8:  CALL    360
....................  
.................... //****************************************************************************** 
.................... //Added Feb 13, 2012 
.................... //This part waits for a start bit from the Slave. 
.................... //****************************************************************************** 
.................... //Slave Reply: 
.................... //*   <68> <04> <02> <03> <01> <24> <09>   This gives the nuimger of 0x301 ppm. 
.................... lTmp=0; 
04FC:  CLR     ACC
.................... CO2SendStartBit(); 
04FE:  CALL    370
.................... lTmp=CO2WriteByte(0xD1);  //This Sensor address  that is 0x68  shifted left one with a zoer padded   0b01101000  -> 0b11010000 
0502:  MOV.B   #D1,W0L
0504:  MOV.B   W0L,AD2
0506:  CALL    388
050A:  MOV     W0,ACC
....................  
....................  
....................  	if (lTmp == 1) 
050C:  MOV     ACC,W4
050E:  CP      W4,#1
0510:  BRA     NZ,536
.................... 		{ 
.................... 		first = CO2ReadByte(); 
0512:  CALL    424
0516:  MOV.B   W0L,AC6
.................... 		second = CO2ReadByte(); 
0518:  CALL    424
051C:  MOV.B   W0L,AC7
.................... 		third = CO2ReadByte(); 
051E:  CALL    424
0522:  MOV.B   W0L,AC8
.................... 		forth = CO2ReadByte(); 
0524:  CALL    424
0528:  MOV.B   W0L,AC9
.................... 		CO2SendStopBit(); 
052A:  CALL    406
.................... 		lTmp = lTmp+1; 
052E:  MOV     ACC,W4
0530:  ADD     W4,#1,W0
0532:  MOV     W0,ACC
.................... 		} 
0534:  BRA     542
.................... 		else    //This is the else command for writing succesyy the first read command 
.................... 		{ 
.................... 		CO2SendStopBit(); 
0536:  CALL    406
.................... 		lTmp = -1; 
053A:  SETM    ACC
.................... 		return(lTmp);  //If is does not work, then return failed. 
053C:  PUSH    ACC
053E:  POP     0
0540:  BRA     59A
.................... 		} 
.................... 	} 
0542:  BRA     550
.................... 	else    //This is the else command for writing succesyy the first read command 
.................... 	{ 
.................... 	CO2SendStopBit(); 
0544:  CALL    406
.................... 	lTmp = -1; 
0548:  SETM    ACC
.................... 	return(lTmp);  //If is does not work, then return failed. 
054A:  PUSH    ACC
054C:  POP     0
054E:  BRA     59A
.................... 	} 
.................... //****************************************************** 
.................... //Added Oct. 11, 2012 
.................... //This section does a checksum of the returned three values and tells the calling routine if the data 
.................... // is valid or returns the new CO2 measurement. 
.................... //****************************************************** 
....................  
.................... checksum = first + second + third; 
0550:  MOV.B   AC6,W0L
0552:  ADD.B   AC7,W0L
0554:  MOV     AC8,W4
0556:  ADD.B   W0L,W4L,W0L
0558:  MOV.B   W0L,ACA
.................... if ((checksum == forth) & (first == 0x21)) 
055A:  MOV.B   ACA,W0L
055C:  CP.B    AC9
055E:  BRA     Z,564
0560:  CLR.B   W0
0562:  BRA     566
0564:  MOV.B   #1,W0L
0566:  MOV.B   W0L,W5L
0568:  MOV     AC6,W4
056A:  XOR.B   #21,W4L
056C:  BRA     Z,572
056E:  CLR.B   W0
0570:  BRA     574
0572:  MOV.B   #1,W0L
0574:  AND.B   W5L,W0L,W0L
0576:  CP0.B   W0L
0578:  BRA     Z,594
.................... 	{ 
.................... //This sectoin agress that check sum is OK 
.................... //Added Oct 11, 2012 
.................... // Second is the upper part of the integer.  
....................     lTmp = second; 
057A:  MOV.B   AC7,W0L
057C:  MOV.B   W0L,ACC
057E:  CLR.B   ACD
.................... 	lTmp = lTmp * 256; 
0580:  MOV     ACC,W4
0582:  MOV     #100,W3
0584:  MUL.SS  W4,W3,W0
0586:  MOV     W0,ACC
.................... 	lTmp = lTmp + third; 
0588:  MOV     AC8,W4
058A:  CLR.B   9
058C:  MOV     ACC,W3
058E:  ADD     W3,W4,W0
0590:  MOV     W0,ACC
.................... 	} 
0592:  BRA     596
.................... 	else 
.................... 	{ 
.................... 	lTmp = -1;  // This routines an error if the check sum does not come out. 
0594:  SETM    ACC
.................... 	} 
.................... return(lTmp); 
0596:  PUSH    ACC
0598:  POP     0
059A:  MOV     [--W15],W5
059C:  RETURN  
.................... } 
....................  
....................  
.................... void CalibrateCO2(void) 
.................... //****************************************************************************************** 
.................... // Added Jan 24, 2012 
.................... // This routines start the CO2 device to do a background CO2 calibration.  This routine is used once a month for 
.................... // now.  How to use this program is TBD. 
.................... //****************************************************************************************** 
.................... { 
....................  
....................  
....................  
....................  
.................... } 
....................  
....................  
.................... void InitCO2(void) 
.................... //****************************************************************************************** 
.................... // Added Jan 26, 2012 
.................... // This routine sets up the two control bits for output. 
.................... //****************************************************************************************** 
.................... { 
....................    output_high(DATACO2); 
*
033A:  BCLR.B  2C9.3
033C:  BSET.B  2CD.3
.................... 	output_high(SCKCO2); 
033E:  BCLR.B  2C9.2
0340:  BSET.B  2CD.2
0342:  RETURN  
....................  
.................... } 
....................  
....................  
....................  
.................... #include "ITwoSeeGeneralCommunicationSlave.c"     // this is included to connect to the master Osmobot. 
.................... //*************************************************************************************** 
.................... // Created October 16, 2016 
.................... // This file is included in project to make this unit a slave for the Osmobot. 
.................... // include this in the top of the project and update the data array with the data wanting to be returned. 
.................... //************************************************************************************** 
.................... //#define SDAPIN PIN_B2 
.................... //#define SCLPIN PIN_B3 
....................  
.................... //#use I2C(stream=SENSOR, SLAVE, sda=SDAPIN,scl=SCLPIN, FORCE_HW, address=0xa0, NO_STRETCH)   // this is I2C 1 
....................  
.................... char send_buffer[128];   // this is filled by this unit for sending data. 
.................... unsigned int8 rcv_buffer[128];   // this is the received data from the master  
.................... unsigned  int8 address, streamCntr=0;  
....................  
....................  
.................... //*************************************************************************** 
.................... // Created Oct 7, 2016 
.................... // Updated Oct 16, 2016  -- Added CO2 structure for sending data.  -- Changed the number of registers to 100 from 20. 
.................... // This routine sets the protocal for communicating to a remote custom I2c device. 
.................... // The frames and commands are as follows: 
.................... // Address 0x12  for this device. 
.................... // write a command to the command register before reading or writing to the device 
.................... // Command Register  :    01    // A one for R reads all data points from the unit   //  A one for W writes calibration numbers for all instruments 
.................... //      MSB                  LSB 
.................... //       7  6  5  4  3  2  1  0 
.................... //       X  X  X  X  X  X  R  W 
.................... // There are 20 registers (bytes) for reading data from the unit 
.................... // There are 40 registers (bytes) for writing data to the unit 
.................... // Reading frame definition     --  has to be done in sequence each time. 
.................... // 1: HN4  whole number portion of reading 
.................... // 2: NH4  fraction of the reading 
.................... // 3: DO  whole number portion of reading 
.................... // 4: DO  fraction of the reading 
.................... // 5: Water Temperature  whole number portion of reading 
.................... // 6: Water Temperature  fraction of the reading 
.................... // 7: CO2 High byte    Updated Oct 16, 2016 
.................... // 8: CO2 Low Byte   Updated Oct 16, 2016 
.................... // 9: Air Temperature whole number    Updated Oct 24, 2016 
.................... // 10: Air Temperature fractional part   Updated Oct 24, 2016 
.................... // 11: Air RH  whole number   Updated Oct 24, 2016 
.................... // 12: Air RH fractional part    Updated Oct 24, 2016 
.................... // 13: Water Temperature High Byte raw data   Updated Feb 15, 2017 
.................... // 14: Water Temperature Low Byte raw data   Updated Feb 15, 2017 
.................... // 15: DO  RawData High Byte 
.................... // 16: DO  RawData Low Byte 
.................... // 17: NH4 RawData High Byte 
.................... // 18: NH4 RawData Low Byte 
....................         // Added Fab 26, 2017 
....................         // these items are the raw numbers for NH4 
.................... // 19: NH4 Patch RED RawData High Byte 
.................... // 20: NH4 Patch RED RawData Low Byte 
.................... // 21: NH4 Patch GREEN RawData High Byte 
.................... // 22: NH4 Patch GREEN RawData Low Byte 
.................... // 23: NH4 Patch BLUE RawData High Byte 
.................... // 24: NH4 Patch blue RawData Low Byte 
.................... // 25: NH4 Patch WHITE RawData High Byte 
.................... // 26: NH4 Patch WHITE RawData Low Byte 
.................... // 27: DpH  Digital Red RawData High Byte 
.................... // 28: DpH  Digital Red RawData Low Byte 
.................... // 29:  DpH Reading  whole number  updated March 30, 2017 
.................... // 30:  DpH fractional part  updated March 30, 2017 
.................... // 31: DpH  Digital Green RawData High Byte   updated April 3, 2017 
.................... // 32: DpH  Digital Green RawData Low Byte   updated April 3, 2017 
.................... // 33: DpH  Digital Blue RawData High Byte   updated April 3, 2017 
.................... // 34: DpH  Digital Blue RawData Low Byte   updated April 3, 2017 
.................... // 35: DpH  Digital White RawData High Byte   updated April 3, 2017 
.................... // 36: DpH  Digital White RawData Low Byte   updated April 3, 2017 
.................... // XX:  TBD 
....................  
....................  
.................... /* 
....................  unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... float eccal1x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3x;    //  This the EC data point  Added July 18, 2016 
.................... float eccal1y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal2y;    //  This the EC data point  Added July 18, 2016 
.................... float eccal3y;    //  This the EC data point  Added July 18, 2016 
.................... char unittype[5];  // This is a string of no more than 5 characters to describe the unit type.  Needs to end with a null. 
.................... float phcallow;       //  This is the lower ADC value count.  It is assocatred always with a pH of 4.  The default is 275. 
.................... float phcalhigh;       //  This is the ADC value used to associate with the phnumberupper.  The default is 500, but it can change. 
.................... float phnumberupper;    // this is the upper variable pH number.  the default is 10, but it can change 
.................... unsigned int16 nh4pt1cal1of3; 
.................... unsigned int16 nh4pt1cal2of3; 
.................... unsigned int16 nh4pt1cal3of3; 
.................... unsigned int16 nh4pt2cal1of3; 
.................... unsigned int16 nh4pt2cal2of3; 
.................... unsigned int16 nh4pt2cal3of3; 
.................... unsigned int16 nh4pt3cal1of3; 
.................... unsigned int16 nh4pt3cal2of3; 
.................... unsigned int16 nh4pt3cal3of3; 
.................... float nh4pt1returnednumber; 
.................... float nh4pt2returnednumber; 
.................... float nh4pt3returnednumber; 
.................... unsigned int16 DOpt1cal1of3; 
.................... unsigned int16 DOpt1cal2of3; 
.................... unsigned int16 DOpt1cal3of3; 
.................... unsigned int16 DOpt2cal1of3; 
.................... unsigned int16 DOpt2cal2of3; 
.................... unsigned int16 DOpt2cal3of3; 
.................... unsigned int16 DOpt3cal1of3; 
.................... unsigned int16 DOpt3cal2of3; 
.................... unsigned int16 DOpt3cal3of3; 
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
....................  */ 
....................  
....................  
....................  
....................  
....................  
.................... // Writing frame definition  --  has to be done in sequence each time. 
.................... // 1: HN4  whole number portion of HN4 calibration for point 1 
.................... // 2: NH4  fraction of the reading of HN4 calibration for point 1 
.................... // 3: HN4  whole number portion of HN4 calibration for point 2 
.................... // 4: NH4  fraction of the reading of HN4 calibration for point 2 
.................... // 5: HN4  whole number returned value of HN4 calibration for point 1 
.................... // 6: NH4  fraction of the returned value of HN4 calibration for point 1 
.................... // 7: HN4  whole number returned value of HN4 calibration for point 2 
.................... // 8: NH4  fraction of the returned value of HN4 calibration for point 2 
.................... // 9: TBD   all zeros 
.................... // 10: TBD 
.................... // 11: TBD 
.................... // 12: TBD 
.................... // 13: TBD 
.................... // 14: TBD 
.................... // 15: TBD 
.................... // 16: TBD 
.................... // 17: TBD 
.................... // 18: TBD 
.................... // 19: TBD 
.................... // 20: TBD 
.................... //  ...... 
.................... // 99: checksum high byte 
.................... // 100: checksum low byte 
.................... // returns a 1 if the checksum is OK and it receives data 
.................... //****************************************************************************** 
....................  
....................  
.................... //******************************************************************************* 
.................... // Create November 2, 2016 
.................... // Save this float into eeprom 
.................... // returns nothing. 
.................... //  give the pointer to the number, the location in eeprom and length 
.................... //****************************************************************************** 
.................... void eeprom_write_block(int16 *ptr, unsigned int8 addr, unsigned char len) 
.................... { 
....................   unsigned int16 *data = ptr; 
....................     unsigned int16 bufferin[4]; 
....................     unsigned int8 stuffit = addr; 
....................     len=len>>1;    // Since we are using 16 bits, two bytes are used at a time because of defs. 
....................     addr=addr<<1;   //mult by two offset to the correct location. 
....................  
....................     //read back the data 
....................    while (len--) { 
....................         write_eeprom(addr, *data++); 
....................         addr=addr+2;  // need to skip two bytes since this is a 16 bit CPU   
....................     }  
.................... //    bufferin[0] = read_eeprom[0]; 
....................  //   bufferin[1] = read_eeprom[2];        
....................  stuffit= stuffit+1;     
.................... } 
....................  
....................  
....................  
....................  
.................... float READ_FLOAT_EEPROM(long int n)  
.................... {  
....................    int i;  
....................    float data; 
....................  
....................    for (i = 0; i < 2; i++)  
....................       *((int16*)&data + i) = read_eeprom(2*i + 2*n); 
....................  
....................    return(data);  
.................... } 
....................  
.................... //****************************************************************************** 
.................... // Documented Febuary 12, 2017 
.................... // This is the call for slave operation for a sensor board. 
.................... // It does the following functions: 
.................... // 1  Receives incoming data from the host 
.................... // 2  Sets the command register for sending back this modules ID 
.................... // 3 
.................... //****************************************************************************** 
.................... /* 
.................... #INT_SI2C2 
....................  
.................... void si2c2_interrupt() 
....................     { 
....................  
.................... unsigned int8  incoming, state; 
....................  
....................         state=i2c_isr_state(SENSOR); 
....................  
....................    if(state <= 0x80)                      //Master is sending data 
....................    { 
....................       incoming = i2c_read(SENSOR,1);  
....................       if(state == 1)                     //First received byte is address  
....................       {//First received byte is address 
....................          address = incoming; 
....................          streamCntr=0; 
....................       } 
....................       if(state == 2)                     //Second received byte is data  
....................           {   
....................           rcv_buffer[address] = incoming;  
....................           streamCntr=0; 
....................           } 
....................        
....................       if(state == 1)                      //First received byte is address 
....................          address = incoming; 
....................       else if(state >= 2 && state != 0x80)   //Received byte is data auto from the master 
....................            { 
....................             rcv_buffer[address++] = incoming; 
....................             streamCntr=0; 
....................             } 
....................    } 
....................  
....................    if((state >= 0x80) & (rcv_buffer[0x66] != 0x01))               //Master is requesting data 
....................    { 
....................       i2c_write(SENSOR,send_buffer[streamCntr++]); 
....................    } 
....................       if((state >= 0x80) & (rcv_buffer[0x66] == 0x01))               //Master is requesting data 
....................    { 
....................       i2c_write(SENSOR,SENSORNUMBER); 
....................       rcv_buffer[0x66]=0x00; 
....................    } 
.................... 	} 
....................  
....................   */   
....................      
.................... //****************************************************************************** 
.................... // Created October 17, 2016 
.................... // This is a check sum for the data sent through the I2C back to the master.  The numbers are split and put into the 
.................... // last two locations of the upload send_buffer[]. 
.................... //  Nothing is returned, but the data is updated in this function. 
.................... //****************************************************************************** 
.................... void CalculateCRC(void) 
.................... { 
....................     unsigned int16 checksum; 
....................     unsigned int8 checksumhigh, checksumlow, x; 
....................     for (x=0; x < 98; x++) 
....................     { 
....................     checksum = checksum + send_buffer[x]; 
....................     } 
....................     //seperate the numbers into high and low 
....................     checksumlow = 0x00FF & checksum; 
....................     //  place the numbers in the array 
....................     checksumhigh = (0xFF00 & checksum)>>8; 
....................     send_buffer[98]=checksumhigh; 
....................     send_buffer[99]=checksumlow; 
.................... }     
....................      
.................... //****************************************************************************** 
.................... // Created Oct. 16, 2016 
.................... // this routine clears the data in the return buffer to all 0xFF.  This means if the data is 0xFF, there is no sensor data avaible and is ignored by the 
.................... // master CPU.  That means the main CPU master needs to go through all of the returned data and check to see if it is not 0xFF for all sets of bytes. 
.................... //****************************************************************************** 
....................  
....................     void initTransMitBuffer(void) 
0344:  MOV     W5,[W15++]
....................     { 
....................         // there are 100 points in the transmit buffer. 
....................         int x; 
....................         for (x = 0; x < 100; x++)   // set all of the returned data to 0xFF.  If there is data to be returned, it will change it to non 0xFF 
0346:  CLR     AC6
0348:  MOV     AC6,W4
034A:  MOV     #64,W3
034C:  CP      W3,W4
034E:  BRA     LE,35C
....................         { 
....................             send_buffer[x] = 0xFF; 
0350:  MOV     #9B6,W4
0352:  MOV     AC6,W3
0354:  ADD     W3,W4,W5
0356:  SETM.B  [W5]
0358:  INC     0AC6
035A:  BRA     348
....................         } 
035C:  MOV     [--W15],W5
035E:  RETURN  
....................        
....................     } 
....................        
....................      
.................... //***************************************************************** 
.................... //Created November 2, 2016 
.................... //  This is the eeprom read function to load all of the calibration data from the eeprom 
.................... // This routine can be triggered from the program and from one of the commands from the I2C 
.................... // It returns all of the data read from the internal data eeprom 
.................... //****************************************************************** 
.................... int LoadConfiguration(void) 
.................... { 
....................     float checkvalue;   // this is used for returning the value and checking to see if it took. 
....................      
....................    /* 
....................     float Temp1DOOne = 9.5;            //These are the set points where we want to read these numbers at temperature 1 
.................... 	float Temp1DOTwo = 4.0;            //This is at 10 degrees 
.................... 	float Temp1DOThree = 0.0; 
.................... */  
....................     Temp1DOOne = READ_FLOAT_EEPROM(0); 
....................     Temp1DOTwo = READ_FLOAT_EEPROM(1); 
....................     Temp1DOThree = READ_FLOAT_EEPROM(2); 
....................     /* 
....................  
.................... 	float Temp2DOOne = 7.5;            //These are the set points where we want to read these numbers at temperature 2 
.................... 	float Temp2DOTwo = 4.0;				//This is at 20 degrees 
.................... 	float Temp2DOThree = 0.0; 
....................  
....................      */ 
....................     Temp2DOOne = READ_FLOAT_EEPROM(3); 
....................     Temp2DOTwo = READ_FLOAT_EEPROM(4); 
....................     Temp2DOThree = READ_FLOAT_EEPROM(5); 
....................     /* 
.................... 	float Temp3DOOne = 6.7;            //These are the set points where we want to read these numbers temperature 3 
.................... 	float Temp3DOTwo = 4.0;            //This is at 25 degrees 
.................... 	float Temp3DOThree = 0.0;   
....................  */ 
....................     Temp3DOOne = READ_FLOAT_EEPROM(6); 
....................     Temp3DOTwo = READ_FLOAT_EEPROM(7); 
....................     Temp3DOThree = READ_FLOAT_EEPROM(8); 
....................     /* 
....................       
....................     float Temp1ReadingOne = 10752.0;       //Readings for Temp3  10 degrees C 
.................... 	float Temp1ReadingTwo = 11000.0;      //Readings for Temp3 
.................... 	float Temp1ReadingThree = 12000.0;    //Readings for DOOne    this is no DO. 
....................       
....................      */ 
....................     Temp1ReadingOne = READ_FLOAT_EEPROM(9); 
....................     Temp1ReadingTwo = READ_FLOAT_EEPROM(10); 
....................     Temp1ReadingThree = READ_FLOAT_EEPROM(11); 
....................      /*  
....................       
.................... 	float Temp2ReadingOne = 11266.0;       //Readings for Temp3    20 degrees C 
.................... 	float Temp2ReadingTwo = 12000.0;      //Readings for Temp3 
.................... 	float Temp2ReadingThree = 13000.0;    //Readings for DOOne 
.................... */ 
....................     Temp2ReadingOne = READ_FLOAT_EEPROM(12); 
....................     Temp2ReadingTwo = READ_FLOAT_EEPROM(13); 
....................     Temp2ReadingThree = READ_FLOAT_EEPROM(14); 
....................     /* 
.................... 	float Temp3ReadingOne = 12425.0;       //Readings for Temp3   25 degrees C 
.................... 	float Temp3ReadingTwo = 13000.0;      //Readings for Temp3 
.................... 	float Temp3ReadingThree = 14000.0;    //Readings for DOOne 
.................... */ 
....................     Temp3ReadingOne = READ_FLOAT_EEPROM(15); 
....................     Temp3ReadingTwo = READ_FLOAT_EEPROM(16); 
....................     Temp3ReadingThree = READ_FLOAT_EEPROM(17); 
....................     /* 
....................     
.................... 	float TempOne = 10.0;       //Calibration temperatures for DO   Added April 7, 2015 
....................  	float TempTwo =  20.0;      //Calibration temperatures for DO  Added April 7, 2015 
.................... 	float TempThree =  25.0;     //Calibration temperatures for DO  Added April 7, 2015 
....................  
....................      */ 
....................     TempOne = READ_FLOAT_EEPROM(18); 
....................     TempTwo = READ_FLOAT_EEPROM(19); 
....................     TempThree = READ_FLOAT_EEPROM(20); 
....................      
....................     return(0);   // if it makes it to here, everything is ok. 
.................... } 
....................  
.................... //******************************************************************************* 
.................... // Create November 2, 2016 
.................... // Save this float into eeprom 
.................... // returns nothing. 
.................... //  give the pointer to the number, the location in eeprom and length 
.................... //****************************************************************************** 
.................... void eeprom_write_blocktest(int16 *ptr, unsigned int8 addr, unsigned char len) 
.................... { 
....................   unsigned int16 *data = ptr; 
....................     unsigned int16 bufferin[4]; 
....................     unsigned int8 stuff = addr; 
....................     len=len>>1;    // Since we are using 16 bits, two bytes are used at a time because of defs. 
....................     addr=addr<<1;   //mult by two offset to the correct location. 
....................  
....................     //read back the data 
....................    while (len--) { 
....................         write_eeprom(addr, *data++); 
....................         addr=addr+2;  // need to skip two bytes since this is a 16 bit CPU   
....................     }  
....................  //   bufferin[0] = read_eeprom[stuff]; 
....................  //   bufferin[1] = read_eeprom[stuff+2];        
....................  stuff= stuff+1;     
.................... } 
....................  
....................  
....................  
.................... //***************************************************************** 
.................... //Created Oct. 19, 2016 
.................... //  This is the eeprom write function to save all of the calibration data to the eeprom 
.................... // This routine can be triggered from the program and from one of the commands from the I2C 
.................... // It returns a 0 if everything is OK,  A 1 is returned when it failed. 
.................... //  It does a write and reads back the data to make it made it. 
.................... //****************************************************************** 
.................... int SaveConfiguration(void) 
.................... { 
....................     float checkvalue;   // this is used for returning the value and checking to see if it took. 
....................      
....................    /* 
....................     float Temp1DOOne = 9.5;            //These are the set points where we want to read these numbers at temperature 1 
.................... 	float Temp1DOTwo = 4.0;            //This is at 10 degrees 
.................... 	float Temp1DOThree = 0.0; 
.................... */  
....................     eeprom_write_blocktest(&Temp1DOOne, 0, sizeof Temp1DOOne); 
....................     checkvalue = READ_FLOAT_EEPROM(0); 
....................     if (Temp1DOOne != checkvalue) 
....................         return(1);    // return this error 
....................     eeprom_write_blocktest(&Temp1DOTwo, 1, sizeof Temp1DOTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(1); 
....................     if (Temp1DOTwo != checkvalue) 
....................         return(2);    // return this error 
....................      eeprom_write_blocktest(&Temp1DOThree, 2, sizeof Temp1DOThree); 
....................     checkvalue = READ_FLOAT_EEPROM(2); 
....................     if (Temp1DOThree != checkvalue) 
....................         return(3);    // return this error 
....................      
....................     // this routine saves the data for the NH4, EC, DO and temperature 
....................     /* 
....................  
.................... 	float Temp2DOOne = 7.5;            //These are the set points where we want to read these numbers at temperature 2 
.................... 	float Temp2DOTwo = 4.0;				//This is at 20 degrees 
.................... 	float Temp2DOThree = 0.0; 
....................  
....................      */ 
....................     eeprom_write_block(&Temp2DOOne, 3, sizeof Temp2DOOne); 
....................     checkvalue = READ_FLOAT_EEPROM(3); 
....................     if (Temp2DOOne != checkvalue) 
....................         return(4);    // return this error 
....................     eeprom_write_block(&Temp2DOTwo, 4, sizeof Temp2DOTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(4); 
....................     if (Temp2DOTwo != checkvalue) 
....................         return(5);    // return this error 
....................      eeprom_write_block(&Temp2DOThree, 5, sizeof Temp2DOThree); 
....................     checkvalue = READ_FLOAT_EEPROM(5); 
....................     if (Temp2DOThree != checkvalue) 
....................         return(6);    // return this error 
....................     
....................     /* 
.................... 	float Temp3DOOne = 6.7;            //These are the set points where we want to read these numbers temperature 3 
.................... 	float Temp3DOTwo = 4.0;            //This is at 25 degrees 
.................... 	float Temp3DOThree = 0.0;   
....................  */ 
....................      
....................     eeprom_write_block(&Temp3DOOne, 6, sizeof Temp3DOOne); 
....................     checkvalue = READ_FLOAT_EEPROM(6); 
....................     if (Temp3DOOne != checkvalue) 
....................         return(7);    // return this error 
....................     eeprom_write_block(&Temp3DOTwo, 7, sizeof Temp3DOTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(7); 
....................     if (Temp3DOTwo != checkvalue) 
....................         return(8);    // return this error 
....................      eeprom_write_block(&Temp3DOThree, 8, sizeof Temp3DOThree); 
....................     checkvalue = READ_FLOAT_EEPROM(8); 
....................     if (Temp3DOThree != checkvalue) 
....................         return(9);    // return this error   
....................     /* 
....................       
....................     float Temp1ReadingOne = 10752.0;       //Readings for Temp3  10 degrees C 
.................... 	float Temp1ReadingTwo = 11000.0;      //Readings for Temp3 
.................... 	float Temp1ReadingThree = 12000.0;    //Readings for DOOne    this is no DO. 
....................       
....................      */ 
....................      
....................     eeprom_write_block(&Temp1ReadingOne, 9, sizeof Temp1ReadingOne); 
....................     checkvalue = READ_FLOAT_EEPROM(9); 
....................     if (Temp1ReadingOne != checkvalue) 
....................         return(10);    // return this error 
....................     eeprom_write_block(&Temp1ReadingTwo, 10, sizeof Temp1ReadingTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(10); 
....................     if (Temp1ReadingTwo != checkvalue) 
....................         return(11);    // return this error 
....................      eeprom_write_block(&Temp1ReadingThree, 11, sizeof Temp1ReadingThree); 
....................     checkvalue = READ_FLOAT_EEPROM(11); 
....................     if (Temp1ReadingThree != checkvalue) 
....................         return(12);    // return this error 
....................      
....................      /*  
....................       
....................  
.................... 	float Temp2ReadingOne = 11266.0;       //Readings for Temp3    20 degrees C 
.................... 	float Temp2ReadingTwo = 12000.0;      //Readings for Temp3 
.................... 	float Temp2ReadingThree = 13000.0;    //Readings for DOOne 
.................... */ 
....................     eeprom_write_block(&Temp2ReadingOne, 12, sizeof Temp2ReadingOne); 
....................     checkvalue = READ_FLOAT_EEPROM(12); 
....................     if (Temp2ReadingOne != checkvalue) 
....................         return(13);    // return this error 
....................     eeprom_write_block(&Temp2ReadingTwo, 13, sizeof Temp2ReadingTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(13); 
....................     if (Temp2ReadingTwo != checkvalue) 
....................         return(14);    // return this error 
....................      eeprom_write_block(&Temp2ReadingThree, 14, sizeof Temp2ReadingThree); 
....................     checkvalue = READ_FLOAT_EEPROM(14); 
....................     if (Temp2ReadingThree != checkvalue) 
....................         return(15);    // return this error 
....................     /* 
.................... 	float Temp3ReadingOne = 12425.0;       //Readings for Temp3   25 degrees C 
.................... 	float Temp3ReadingTwo = 13000.0;      //Readings for Temp3 
.................... 	float Temp3ReadingThree = 14000.0;    //Readings for DOOne 
.................... */ 
....................     eeprom_write_block(&Temp3ReadingOne, 15, sizeof Temp3ReadingOne); 
....................     checkvalue = READ_FLOAT_EEPROM(15); 
....................     if (Temp3ReadingOne != checkvalue) 
....................         return(16);    // return this error 
....................     eeprom_write_block(&Temp3ReadingTwo, 16, sizeof Temp3ReadingTwo); 
....................     checkvalue = READ_FLOAT_EEPROM(16); 
....................     if (Temp3ReadingTwo != checkvalue) 
....................         return(17);    // return this error 
....................      eeprom_write_block(&Temp3ReadingThree, 17, sizeof Temp3ReadingThree); 
....................     checkvalue = READ_FLOAT_EEPROM(17); 
....................     if (Temp3ReadingThree != checkvalue) 
....................         return(18);    // return this error 
....................     /* 
....................     
.................... 	float TempOne = 10.0;       //Calibration temperatures for DO   Added April 7, 2015 
....................  	float TempTwo =  20.0;      //Calibration temperatures for DO  Added April 7, 2015 
.................... 	float TempThree =  25.0;     //Calibration temperatures for DO  Added April 7, 2015 
....................  
....................       
.................... float DOpt1returnednumber;   // this is the returned DO number used for solving the equations at different temperatures 
.................... float DOpt2returnednumber; 
.................... float DOpt3returnednumber; 
....................      */ 
....................      
....................     eeprom_write_block(&sysInput.DOpt1returnednumber, 18, sizeof sysInput.DOpt1returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(18); 
....................     if (sysInput.DOpt1returnednumber != checkvalue) 
....................         return(19);    // return this error 
....................     eeprom_write_block(&sysInput.DOpt2returnednumber, 19, sizeof sysInput.DOpt2returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(19); 
....................     if (sysInput.DOpt2returnednumber != checkvalue) 
....................         return(20);    // return this error 
....................      eeprom_write_block(&sysInput.DOpt3returnednumber, 20, sizeof sysInput.DOpt3returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(20); 
....................     if (sysInput.DOpt3returnednumber != checkvalue) 
....................         return(21);    // return this error 
....................      /* 
.................... unsigned int16 Thermisterpt1cal1of3; 
.................... unsigned int16 Thermisterpt1cal2of3; 
.................... unsigned int16 Thermisterpt1cal3of3; 
....................     */ 
....................      
....................      
....................     eeprom_write_block(&sysInput.Thermisterpt1cal1of3, 21, sizeof sysInput.Thermisterpt1cal1of3); 
....................     checkvalue = READ_FLOAT_EEPROM(21); 
....................     if (sysInput.Thermisterpt1cal1of3 != checkvalue) 
....................         return(22);    // return this error 
....................     eeprom_write_block(&sysInput.Thermisterpt1cal2of3, 22, sizeof sysInput.Thermisterpt1cal2of3); 
....................     checkvalue = READ_FLOAT_EEPROM(22); 
....................     if (sysInput.Thermisterpt1cal2of3 != checkvalue) 
....................         return(23);    // return this error 
....................      eeprom_write_block(&sysInput.Thermisterpt1cal3of3, 23, sizeof sysInput.Thermisterpt1cal3of3); 
....................     checkvalue = READ_FLOAT_EEPROM(23); 
....................     if (sysInput.Thermisterpt1cal3of3 != checkvalue) 
....................         return(24);    // return this error 
....................      
.................... /* 
.................... float Thermisterpt1returnednumber; 
.................... float Thermisterpt2returnednumber; 
.................... float Thermisterpt3returnednumber; 
....................   */ 
....................      
....................    eeprom_write_block(&sysInput.Thermisterpt1returnednumber, 24, sizeof sysInput.Thermisterpt1returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(24); 
....................     if (sysInput.Thermisterpt1returnednumber!= checkvalue) 
....................         return(25);    // return this error 
....................     eeprom_write_block(&sysInput.Thermisterpt2returnednumber, 25, sizeof sysInput.Thermisterpt2returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(25); 
....................     if (sysInput.Thermisterpt2returnednumber != checkvalue) 
....................         return(26);    // return this error 
....................      eeprom_write_block(&sysInput.Thermisterpt3returnednumber, 26, sizeof sysInput.Thermisterpt3returnednumber); 
....................     checkvalue = READ_FLOAT_EEPROM(26); 
....................     if (sysInput.Thermisterpt3returnednumber != checkvalue) 
....................         return(27);    // return this error 
....................       
....................      
....................     return(0);   // if it makes it to here, everything is ok. 
.................... } 
....................  
....................  
....................  
.................... //********************************************************************************************* 
.................... // Created November 28, 2016 
.................... // This moves the data from the recieve buffer into the configuation varaubles. 
.................... // Returns nothing.  This is called when rcv_buffer[2] == 0x01 
.................... //********************************************************************************************* 
.................... void movercvbuffertocolibration(void) 
.................... { 
....................        int x; 
....................     int8 lowbyte,highbyte; 
....................     unsigned int16 items; 
....................     int i;  
....................    float data; 
....................         
....................     //these are the two byte int16s 
....................     lowbyte = rcv_buffer[3]; 
....................     highbyte = rcv_buffer[4]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt1cal1of3 = (items<<8) +  lowbyte;   
....................   
....................     lowbyte = rcv_buffer[5]; 
....................     highbyte = rcv_buffer[6]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt1cal2of3 = (items<<8) +  lowbyte;   
....................      
....................     lowbyte = rcv_buffer[7]; 
....................     highbyte = rcv_buffer[8]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt1cal3of3 = (items<<8) +  lowbyte;   
....................      
....................          
....................     lowbyte = rcv_buffer[9]; 
....................     highbyte = rcv_buffer[10]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt2cal1of3 = (items<<8) +  lowbyte;   
....................   
....................     lowbyte = rcv_buffer[11]; 
....................     highbyte = rcv_buffer[12]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt2cal2of3 = (items<<8) +  lowbyte;   
....................      
....................     lowbyte = rcv_buffer[13]; 
....................     highbyte = rcv_buffer[14]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt2cal3of3 = (items<<8) +  lowbyte;   
....................              
....................     lowbyte = rcv_buffer[15]; 
....................     highbyte = rcv_buffer[16]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt3cal1of3 = (items<<8) +  lowbyte;   
....................   
....................     lowbyte = rcv_buffer[17]; 
....................     highbyte = rcv_buffer[18]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt3cal2of3 = (items<<8) +  lowbyte;   
....................      
....................     lowbyte = rcv_buffer[19]; 
....................     highbyte = rcv_buffer[20]; 
....................     items = (int16) highbyte; 
....................     sysInput.nh4pt3cal3of3 = (items<<8) +  lowbyte;   
....................      
....................     // these are the four byte floats 
....................      
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
....................       *((int8*)&data + i) = rcv_buffer[i + 21]; 
....................     sysInput.nh4pt1returnednumber = data; 
....................  
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
....................       *((int8*)&data + i) = rcv_buffer[i + 25]; 
....................     sysInput.nh4pt1returnednumber = data; 
....................  
....................    for (i = 0; i < 4; i++)    // this needs to read in four bytes 
....................       *((int8*)&data + i) = rcv_buffer[i + 29]; 
....................     sysInput.nh4pt1returnednumber = data;     
....................      
.................... } 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... // Documented Febuary 12, 2017 
.................... // This is the call for slave operation for a sensor board. 
.................... // It does the following functions: 
.................... // 1  Receives incoming data from the host 
.................... // 2  Sets the command register for sending back this modules ID 
.................... // 3 
.................... //****************************************************************************** 
....................  
.................... #INT_SI2C2 
....................  
.................... void si2c2_interrupt() 
*
0238:  PUSH    42
023A:  PUSH    36
023C:  PUSH    32
023E:  MOV     W0,[W15++]
0240:  MOV     #2,W0
0242:  REPEAT  #C
0244:  MOV     [W0++],[W15++]
....................     { 
....................  
.................... unsigned int8  incoming, state; 
....................  
....................         state=i2c_isr_state(SENSOR); 
0246:  BTSC.B  218.5
0248:  BRA     252
024A:  CLR.B   AB7
024C:  BTSS.B  218.2
024E:  BRA     252
0250:  BSET.B  AB7.7
0252:  MOV.B   AB7,W0L
0254:  CLR.B   1
0256:  INC.B   0AB7
0258:  MOV.B   W0L,B4B
....................  
....................    if(state <= 0x80)                      //Master is sending data 
025A:  MOV     B4A,W4
025C:  LSR     W4,#8,W4
025E:  MOV     #80,W3
0260:  CP.B    W3L,W4L
0262:  BRA     NC,2C2
....................    { 
....................       incoming = i2c_read(SENSOR,1);  
0264:  MOV     #1,W1
0266:  MOV     W1,[W15++]
0268:  MOV     [--W15],W1
026A:  CALL    200
026E:  MOV.B   W0L,B4A
....................       if(state == 1)                     //First received byte is address  
0270:  MOV     B4A,W4
0272:  LSR     W4,#8,W4
0274:  CP.B    W4L,#1
0276:  BRA     NZ,27E
....................       {//First received byte is address 
....................          address = incoming; 
0278:  MOV.B   B4A,W0L
027A:  MOV.B   W0L,861
....................          streamCntr=0; 
027C:  CLR.B   AB6
....................       } 
....................       if(state == 2)                     //Second received byte is data  
027E:  MOV     B4A,W4
0280:  LSR     W4,#8,W4
0282:  CP.B    W4L,#2
0284:  BRA     NZ,294
....................           {   
....................           rcv_buffer[address] = incoming;  
0286:  MOV     860,W4
0288:  LSR     W4,#8,W4
028A:  MOV     #A36,W3
028C:  ADD     W4,W3,W5
028E:  MOV     B4A,W0
0290:  MOV.B   W0L,[W5+#0]
....................           streamCntr=0; 
0292:  CLR.B   AB6
....................           } 
....................        
....................       if(state == 1)                      //First received byte is address 
0294:  MOV     B4A,W4
0296:  LSR     W4,#8,W4
0298:  CP.B    W4L,#1
029A:  BRA     NZ,2A2
....................          address = incoming; 
029C:  MOV.B   B4A,W0L
029E:  MOV.B   W0L,861
02A0:  BRA     2C2
....................       else if(state >= 2 && state != 0x80)   //Received byte is data auto from the master 
02A2:  MOV     B4A,W4
02A4:  LSR     W4,#8,W4
02A6:  CP.B    W4L,#2
02A8:  BRA     NC,2C2
02AA:  MOV     B4A,W4
02AC:  LSR     W4,#8,W4
02AE:  XOR.B   #80,W4L
02B0:  BRA     Z,2C2
....................            { 
....................             rcv_buffer[address++] = incoming; 
02B2:  MOV.B   861,W0L
02B4:  INC.B   0861
02B6:  ZE      W0,W0
02B8:  MOV     #A36,W4
02BA:  ADD     W0,W4,W5
02BC:  MOV     B4A,W0
02BE:  MOV.B   W0L,[W5+#0]
....................             streamCntr=0; 
02C0:  CLR.B   AB6
....................             } 
....................    } 
....................  
....................    if((state >= 0x80) & (rcv_buffer[0x66] != 0x01))               //Master is requesting data 
02C2:  MOV     B4A,W4
02C4:  LSR     W4,#8,W4
02C6:  MOV     #80,W3
02C8:  CP.B    W3L,W4L
02CA:  BRA     GTU,2CE
02CC:  BRA     2D2
02CE:  CLR.B   W0
02D0:  BRA     2D4
02D2:  MOV.B   #1,W0L
02D4:  MOV.B   W0L,W5L
02D6:  MOV     A9C,W4
02D8:  CP.B    W4L,#1
02DA:  BRA     NZ,2E0
02DC:  CLR.B   W0
02DE:  BRA     2E2
02E0:  MOV.B   #1,W0L
02E2:  AND.B   W5L,W0L,W0L
02E4:  CP0.B   W0L
02E6:  BRA     Z,2FA
....................    { 
....................       i2c_write(SENSOR,send_buffer[streamCntr++]); 
02E8:  MOV.B   AB6,W0L
02EA:  INC.B   0AB6
02EC:  ZE      W0,W0
02EE:  MOV     #9B6,W4
02F0:  ADD     W0,W4,W0
02F2:  MOV.B   [W0],W5L
02F4:  MOV.B   W5L,W1L
02F6:  CALL    220
....................    } 
....................       if((state >= 0x80) & (rcv_buffer[0x66] == 0x01))               //Master is requesting data 
02FA:  MOV     B4A,W4
02FC:  LSR     W4,#8,W4
02FE:  MOV     #80,W3
0300:  CP.B    W3L,W4L
0302:  BRA     GTU,306
0304:  BRA     30A
0306:  CLR.B   W0
0308:  BRA     30C
030A:  MOV.B   #1,W0L
030C:  MOV.B   W0L,W5L
030E:  MOV     A9C,W4
0310:  CP.B    W4L,#1
0312:  BRA     Z,318
0314:  CLR.B   W0
0316:  BRA     31A
0318:  MOV.B   #1,W0L
031A:  AND.B   W5L,W0L,W0L
031C:  CP0.B   W0L
031E:  BRA     Z,328
....................    { 
....................       i2c_write(SENSOR,SENSORNUMBER); 
0320:  MOV.B   #D9,W1L
0322:  CALL    220
....................       rcv_buffer[0x66]=0x00; 
0326:  CLR.B   A9C
....................    } 
0328:  BCLR.B  8A.1
032A:  MOV     #1A,W0
032C:  REPEAT  #C
032E:  MOV     [--W15],[W0--]
0330:  MOV     [--W15],W0
0332:  POP     32
0334:  POP     36
0336:  POP     42
0338:  RETFIE  
.................... 	} 
....................  
....................  
....................  
....................  
.................... /* 
.................... typedef struct outputDataStruct{ 
.................... char deviceID[16]; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int8 taosVersion; 
.................... float dOxy; 
.................... float wTemp; 
.................... float pH; 
.................... float pHLow; 
.................... float WhiteBalance; 
.................... float tdsLevel; 
.................... float wLevel; 
.................... float lLevelX; 
.................... float lLevelY; 
....................  
.................... int32 lLevelRed; 
.................... int32 lLevelGreen; 
.................... int32 lLevelBlue; 
.................... int32 lLevelClear; 
.................... int8 time; 
.................... int16 date; 
....................  
....................  
.................... float lLevelScale; 
.................... float rH,averagepH; 
.................... float aTemp; 
.................... int16 cO2; 
.................... float nh3; 
.................... float dPoint; 
.................... char DIEHARD[8]; 
.................... }outputData; 
....................  
....................  
.................... outputData sysOutput; 
.................... */ 
.................... //*********************************************************** 
....................  
....................  
....................  
.................... int main() { 
*
0B16:  MOV     #F70,W15
0B18:  MOV     #FFF,W0
0B1A:  MOV     W0,20
0B1C:  NOP     
0B1E:  BSET.B  81.7
0B20:  CLR     744
0B22:  BCLR.B  2CC.2
0B24:  BSET.B  217.7
0B26:  BSET.B  217.5
0B28:  BSET.B  216.6
0B2A:  BCLR.B  217.3
0B2C:  BSET.B  216.7
0B2E:  BCLR.B  217.0
0B30:  BSET.B  217.1
0B32:  BCLR.B  217.2
0B34:  MOV     #50,W4
0B36:  MOV     W4,21A
0B38:  BCLR.B  2CD.1
0B3A:  BSET.B  207.7
0B3C:  BSET.B  207.5
0B3E:  BSET.B  206.6
0B40:  BCLR.B  207.3
0B42:  BSET.B  206.7
0B44:  BCLR.B  207.0
0B46:  BSET.B  207.1
0B48:  BCLR.B  207.2
0B4A:  CLR     20A
0B4C:  MOV     #9D,W4
0B4E:  MOV     W4,204
0B50:  CLR.B   860
0B52:  CLR.B   AB6
0B54:  MOV.B   #3,W0L
0B56:  MOV.B   W0L,AB7
0B58:  CLR     4E0
0B5A:  CLR     4E2
0B5C:  CLR     85A
....................  
....................     int16 returneditem;  // this is the returned item 
....................     int8 highbyte, lowbyte; 
....................      
....................     float returnedresultit,titemp; 
....................     int returnedresult; 
....................     InitCO2(); 
0B5E:  CALL    33A
....................  
....................     enable_interrupts(INT_SI2C2);    // this starts the slave communication. 
0B62:  BSET.B  9A.1
....................     initTransMitBuffer();   // Clear the buffer to send no data. 
0B64:  CALL    344
....................     while(1) 
....................     { 
....................         returneditem = ReadCOSensor();  // get the CO2 data 
0B68:  CALL    48A
0B6C:  MOV     W0,ABA
....................         // split it into two numbers.  High Byte and Low Byte. 
....................         lowbyte = 0x00FF & returneditem; 
0B6E:  MOV     ABA,W0
0B70:  AND     #FF,W0
0B72:  MOV.B   W0L,AB9
....................         returneditem = 0xFF00 & returneditem; 
0B74:  MOV     #FF00,W0
0B76:  AND     ABA
....................         highbyte = returneditem>>8;  // this moves it over to the low part 
0B78:  CLR.B   1
0B7A:  MOV.B   ABB,W0L
0B7C:  MOV.B   W0L,AB8
....................         send_buffer[8] = lowbyte;   // update this on the send buffer  Added Oct 16, 2016 
0B7E:  MOV.B   AB9,W0L
0B80:  MOV.B   W0L,9BE
....................         send_buffer[7] = highbyte;   // update this on the send buffer  Added Oct 16, 2016    this is all that is needed to send the data.  When the master asks for the  
0B82:  MOV.B   AB8,W0L
0B84:  MOV.B   W0L,9BD
....................         // array, it will get the updated array.  
....................         
.................... // ********************************************************************************* 
.................... // Created No2. 3, 2014 
.................... // Find the RH and Temperature for the environment and send it to the server. 
.................... //  This routine talks with the cheap RH and Temperature sensor 
.................... // ******************************************************************************** 
.................... /* 
.................... if (!GetTempRH()) 
.................... 	{ 
.................... 	sysOutput.aTemp = Temperature;  //This is the float temperature 
....................      
....................     	if (sysOutput.aTemp < 0.0) 
....................         { 
.................... 		sysOutput.aTemp = 0.0; 
....................         Temperature = 0.0; 
....................         } 
....................      
....................     send_buffer[9] =  (int) Temperature;  // high whole number byte 
....................     send_buffer[10] =  (int) ((Temperature - (float) (int) Temperature)*100);  // high whole number byte 
....................      
....................  
.................... 		 
.................... 	sysOutput.rH = RHData;  //This is a float send into ta RH value. 
.................... 	if (sysOutput.rH < 0.0) 
.................... 		sysOutput.rH = 0.0; 
.................... 	} 
....................    send_buffer[11] =  (int) sysOutput.rH;  // high whole number byte 
....................    send_buffer[12] =  (int) ((sysOutput.rH - (float) (int) sysOutput.rH)*100);  // high whole number byte 
.................... */  
....................          
....................          
....................      
.................... //********************************************************************************* 
.................... // Created Jan 17, 2017 
.................... // This calls and saves the current air temp and rh 
.................... //********************************************************************************* 
.................... //   while(1)  
....................  //  { 
....................  //  returneditem = GetHDC1080Version(1);      
.................... //   } 
....................          
....................          
....................    returnedresultit = GetHDC1080RHTemp(8); 
0B86:  MOV     #8,W4
0B88:  MOV     W4,ACA
0B8A:  CALL    61E
0B8E:  MOV     W0,ABC
0B90:  MOV     W1,ABE
....................    returnedresult = th; 
0B92:  PUSH    862
0B94:  POP     AC4
....................    returnedresult = tl; 
0B96:  PUSH    864
0B98:  POP     AC4
....................    titemp = (float) (th << 8 | tl);     
0B9A:  MOV.B   862,W0L
0B9C:  MOV.B   W0L,B
0B9E:  CLR.B   W5
0BA0:  MOV     W5,W0
0BA2:  IOR     864,W0
0BA4:  CALL    700
0BA8:  MOV     W0,AC0
0BAA:  MOV     W1,AC2
....................     titemp = titemp * 165.0 / 65536.0 - 40.0; 
0BAC:  MOV     AC0,W0
0BAE:  MOV     AC2,W1
0BB0:  MOV     #0,W2
0BB2:  MOV     #4325,W3
0BB4:  CALL    74A
0BB8:  MOV     W0,W5
0BBA:  MOV     W1,W6
0BBC:  MOV     W5,W0
0BBE:  MOV     W6,W1
0BC0:  MOV     #0,W2
0BC2:  MOV     #4780,W3
0BC4:  CALL    80E
0BC8:  MOV     W0,W5
0BCA:  MOV     W1,W6
0BCC:  BSET.B  43.0
0BCE:  MOV     W5,W0
0BD0:  MOV     W6,W1
0BD2:  MOV     #0,W2
0BD4:  MOV     #4220,W3
0BD6:  CALL    8D8
0BDA:  MOV     W0,AC0
0BDC:  MOV     W1,AC2
....................     sysOutput.aTemp = titemp; 
0BDE:  PUSH    AC0
0BE0:  POP     8C8
0BE2:  PUSH    AC2
0BE4:  POP     8CA
....................   	if (sysOutput.aTemp < 0.0) 
0BE6:  MOV     8C8,W0
0BE8:  MOV     8CA,W1
0BEA:  MOV     #0,W2
0BEC:  MOV     #0,W3
0BEE:  CALL    A82
0BF2:  BRA     NC,BF8
.................... 		sysOutput.aTemp = 0.0; 
0BF4:  CLR     8C8
0BF6:  CLR     8CA
....................   
....................    returnedresult = hh; 
0BF8:  PUSH    866
0BFA:  POP     AC4
....................    returnedresult = hl; 
0BFC:  PUSH    868
0BFE:  POP     AC4
....................    titemp = (float) (th << 8 | tl);     
0C00:  MOV.B   862,W0L
0C02:  MOV.B   W0L,B
0C04:  CLR.B   W5
0C06:  MOV     W5,W0
0C08:  IOR     864,W0
0C0A:  CALL    700
0C0E:  MOV     W0,AC0
0C10:  MOV     W1,AC2
....................    titemp = titemp * 100.0 / 65536.0; 
0C12:  MOV     AC0,W0
0C14:  MOV     AC2,W1
0C16:  MOV     #0,W2
0C18:  MOV     #42C8,W3
0C1A:  CALL    74A
0C1E:  MOV     W0,W5
0C20:  MOV     W1,W6
0C22:  MOV     W5,W0
0C24:  MOV     W6,W1
0C26:  MOV     #0,W2
0C28:  MOV     #4780,W3
0C2A:  CALL    80E
0C2E:  MOV     W0,AC0
0C30:  MOV     W1,AC2
.................... 	sysOutput.rH = titemp;  //This is a float send into ta RH value. 
0C32:  PUSH    AC0
0C34:  POP     8C0
0C36:  PUSH    AC2
0C38:  POP     8C2
.................... 	if (sysOutput.rH < 0.0) 
0C3A:  MOV     8C0,W0
0C3C:  MOV     8C2,W1
0C3E:  MOV     #0,W2
0C40:  MOV     #0,W3
0C42:  CALL    A82
0C46:  BRA     NC,C4C
.................... 		sysOutput.rH = 0.0; 
0C48:  CLR     8C0
0C4A:  CLR     8C2
....................  
....................      
....................     send_buffer[9] =  (int) sysOutput.aTemp;  // high whole number byte 
0C4C:  MOV     8C8,W0
0C4E:  MOV     8CA,W1
0C50:  CALL    AEA
0C54:  MOV.B   W0L,9BF
....................     send_buffer[10] =  (int) ((sysOutput.aTemp - (float) (int) sysOutput.aTemp)*100);  // high whole number byte 
0C56:  MOV     8C8,W0
0C58:  MOV     8CA,W1
0C5A:  CALL    AEA
0C5E:  CALL    700
0C62:  BSET.B  43.0
0C64:  MOV     W0,W2
0C66:  MOV     W1,W3
0C68:  MOV     8C8,W0
0C6A:  MOV     8CA,W1
0C6C:  CALL    8D8
0C70:  MOV     W0,W5
0C72:  MOV     W1,W6
0C74:  MOV     W5,W0
0C76:  MOV     W6,W1
0C78:  MOV     #0,W2
0C7A:  MOV     #42C8,W3
0C7C:  CALL    74A
0C80:  CALL    AEA
0C84:  MOV.B   W0L,9C0
....................      
....................      
....................     send_buffer[11] =  (int) sysOutput.rH;  // high whole number byte 
0C86:  MOV     8C0,W0
0C88:  MOV     8C2,W1
0C8A:  CALL    AEA
0C8E:  MOV.B   W0L,9C1
....................     send_buffer[12] =  (int) ((sysOutput.rH - (float) (int) sysOutput.rH)*100);  // high whole number byte 
0C90:  MOV     8C0,W0
0C92:  MOV     8C2,W1
0C94:  CALL    AEA
0C98:  CALL    700
0C9C:  BSET.B  43.0
0C9E:  MOV     W0,W2
0CA0:  MOV     W1,W3
0CA2:  MOV     8C0,W0
0CA4:  MOV     8C2,W1
0CA6:  CALL    8D8
0CAA:  MOV     W0,W5
0CAC:  MOV     W1,W6
0CAE:  MOV     W5,W0
0CB0:  MOV     W6,W1
0CB2:  MOV     #0,W2
0CB4:  MOV     #42C8,W3
0CB6:  CALL    74A
0CBA:  CALL    AEA
0CBE:  MOV.B   W0L,9C2
0CC0:  BRA     B68
....................    
....................   
.................... // ******************************************************************************** 
.................... // Created Nov. 3, 2014 
.................... // This routines borrows the calcaulaton from the expensive SHt11 chip to calcaulate DP 
.................... // ******************************************************************************** 
....................  
.................... //sysOutput.dPoint=sht1x_calc_dewpoint(RHData,Temperature); 
....................  
....................  
....................   
....................   //      CalculateCRC();  // update the CRC for sending to the Master unit 
....................     } 
....................      
....................      
....................  
.................... } 
....................  
0CC2:  BRA     CC2

Configuration Fuses:
   Word  1L: 000F   NOWRTB NOBSS
          H: 0000  
   Word  2L: 0000  
          H: 0000  
   Word  3L: 0003   NOWRT NOPROTECT
          H: 0000  
   Word  4L: 00E3   PR_PLL SOSC_ANALOG LPRCHIGH IESO
          H: 0000  
   Word  5L: 00FA   HS OSCIO POSCFREQ_H SOSC_HIGH
          H: 0000  
   Word  6L: 005F   WPOSTS16 WDT128 WINDIS NOWDT
          H: 0000  
   Word  7L: 00F4   NOBROWNOUT NOLVR NOPUT NOALTI2C1 BORV_LOW MCLR
          H: 0000  
   Word  8L: 0003   ICSP1 DEBUG
          H: 0000  
   Word  9L: 00DF   DSWDTCK_LPRC DSBOR DSWDT
          H: 0000  

   Some fuses have been forced to be compatible with the ICD debugger.
